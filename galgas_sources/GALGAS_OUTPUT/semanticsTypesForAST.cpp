//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'semanticsTypesForAST.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       june 7th, 2010, at 19h55'35"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsTypesForAST.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsTypesForAST.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_semanticExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticExpressionAST::
cPtr_semanticExpressionAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticExpressionAST * GGS_semanticExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticExpressionAST) ;
    return (cPtr_semanticExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticExpressionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticExpressionAST (& typeid (cPtr_semanticExpressionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__semanticExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_semanticExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionAST ("semanticExpressionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST::
GGS_semanticExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST::
GGS_semanticExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticExpressionAST GGS_semanticExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_semanticExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticExpressionAST::actualTypeName (void) const {
  return "semanticExpressionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticExpressionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticExpressionAST ("semanticExpressionAST", & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionAST * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST GGS_semanticExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionAST * p = dynamic_cast <const GGS_semanticExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@semanticExpressionListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticExpressionListAST::
elementOf_GGS_semanticExpressionListAST (const GGS_semanticExpressionAST & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mExpression (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticExpressionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticExpressionListAST * ptr = dynamic_cast <const elementOf_GGS_semanticExpressionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mEndOfExpressionLocation.operator_isEqual (ptr->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticExpressionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpressionLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@semanticExpressionListAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionListAST ("semanticExpressionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
internalAppendValues (const GGS_semanticExpressionAST & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
internalPrependValues (const GGS_semanticExpressionAST & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
addAssign_operation (const GGS_semanticExpressionAST & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST GGS_semanticExpressionListAST::
operator_concat (const GGS_semanticExpressionListAST & inOperand) const {
  GGS_semanticExpressionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
dotAssign_operation (const GGS_semanticExpressionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticExpressionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionAST  p_0 = p->mExpression ;
          GGS_location  p_1 = p->mEndOfExpressionLocation ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpressionAST & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression,
                                ptr->mEndOfExpressionLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_semanticExpressionListAST::
constructor_emptyList (void) {
  GGS_semanticExpressionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_semanticExpressionListAST::
constructor_listWithValue (const GGS_semanticExpressionAST & argument_0,
                                const GGS_location & argument_1) {
  GGS_semanticExpressionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
internalSubListWithRange (GGS_semanticExpressionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression, ptr->mEndOfExpressionLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST GGS_semanticExpressionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST GGS_semanticExpressionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticExpressionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticExpressionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
method_first (C_Compiler & inLexique,
              GGS_semanticExpressionAST & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mEndOfExpressionLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
method_last (C_Compiler & inLexique,
             GGS_semanticExpressionAST & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mEndOfExpressionLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticExpressionAST & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mEndOfExpressionLocation ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticExpressionAST & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mEndOfExpressionLocation ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_semanticExpressionListAST::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_semanticExpressionListAST::
reader_mEndOfExpressionLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfExpressionLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_setMEndOfExpressionLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfExpressionLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionAST  & GGS_semanticExpressionListAST::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_semanticExpressionListAST::cEnumerator::_mEndOfExpressionLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfExpressionLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionListAST * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST GGS_semanticExpressionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionListAST * p = dynamic_cast <const GGS_semanticExpressionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_selfInExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selfInExpressionAST::
cPtr_selfInExpressionAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mSelfLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selfInExpressionAST * GGS_selfInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_selfInExpressionAST) ;
    return (cPtr_selfInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_selfInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_selfInExpressionAST * ptr = dynamic_cast <const cPtr_selfInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSelfLocation.operator_isEqual (ptr->mSelfLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_selfInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@selfInExpressionAST:"
           << mSelfLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_selfInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_selfInExpressionAST (& typeid (cPtr_selfInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_selfInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__selfInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_selfInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_selfInExpressionAST (mSelfLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_selfInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_selfInExpressionAST ("selfInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_selfInExpressionAST::
GGS_selfInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionAST::
GGS_selfInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_selfInExpressionAST GGS_selfInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_selfInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_selfInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_selfInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_selfInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionAST GGS_selfInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_selfInExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_selfInExpressionAST::
reader_mSelfLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_selfInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_selfInExpressionAST *) mPointer)->mSelfLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selfInExpressionAST::actualTypeName (void) const {
  return "selfInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__selfInExpressionAST ("selfInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_selfInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_selfInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_selfInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_selfInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionAST GGS_selfInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_selfInExpressionAST * p = dynamic_cast <const GGS_selfInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_selfInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_selfInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_selfInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_hereExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_hereExpressionAST::
cPtr_hereExpressionAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_hereExpressionAST * GGS_hereExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_hereExpressionAST) ;
    return (cPtr_hereExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_hereExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_hereExpressionAST * ptr = dynamic_cast <const cPtr_hereExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_hereExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@hereExpressionAST:"
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_hereExpressionAST (& typeid (cPtr_hereExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_hereExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__hereExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_hereExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_hereExpressionAST (mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_hereExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_hereExpressionAST ("hereExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_hereExpressionAST::
GGS_hereExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionAST::
GGS_hereExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_hereExpressionAST GGS_hereExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_hereExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_hereExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_hereExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_hereExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_hereExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionAST GGS_hereExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_hereExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_hereExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_hereExpressionAST::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_hereExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_hereExpressionAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_hereExpressionAST::actualTypeName (void) const {
  return "hereExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__hereExpressionAST ("hereExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_hereExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_hereExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_hereExpressionAST * p = NULL ;
    macroMyNew (p, GGS_hereExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionAST GGS_hereExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_hereExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_hereExpressionAST * p = dynamic_cast <const GGS_hereExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_hereExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_hereExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_hereExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_trueExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trueExpressionAST::
cPtr_trueExpressionAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trueExpressionAST * GGS_trueExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trueExpressionAST) ;
    return (cPtr_trueExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trueExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_trueExpressionAST * ptr = dynamic_cast <const cPtr_trueExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_trueExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@trueExpressionAST:"
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trueExpressionAST (& typeid (cPtr_trueExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trueExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__trueExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_trueExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_trueExpressionAST (mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_trueExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trueExpressionAST ("trueExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_trueExpressionAST::
GGS_trueExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionAST::
GGS_trueExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trueExpressionAST GGS_trueExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trueExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trueExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_trueExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trueExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trueExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionAST GGS_trueExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_trueExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_trueExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_trueExpressionAST::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_trueExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_trueExpressionAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trueExpressionAST::actualTypeName (void) const {
  return "trueExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trueExpressionAST ("trueExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_trueExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trueExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trueExpressionAST * p = NULL ;
    macroMyNew (p, GGS_trueExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionAST GGS_trueExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trueExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trueExpressionAST * p = dynamic_cast <const GGS_trueExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trueExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trueExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trueExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_falseExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_falseExpressionAST::
cPtr_falseExpressionAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_falseExpressionAST * GGS_falseExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_falseExpressionAST) ;
    return (cPtr_falseExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_falseExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_falseExpressionAST * ptr = dynamic_cast <const cPtr_falseExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_falseExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@falseExpressionAST:"
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_falseExpressionAST (& typeid (cPtr_falseExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_falseExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__falseExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_falseExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_falseExpressionAST (mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_falseExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_falseExpressionAST ("falseExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_falseExpressionAST::
GGS_falseExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionAST::
GGS_falseExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_falseExpressionAST GGS_falseExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_falseExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_falseExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_falseExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_falseExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_falseExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionAST GGS_falseExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_falseExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_falseExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_falseExpressionAST::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_falseExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_falseExpressionAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_falseExpressionAST::actualTypeName (void) const {
  return "falseExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__falseExpressionAST ("falseExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_falseExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_falseExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_falseExpressionAST * p = NULL ;
    macroMyNew (p, GGS_falseExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionAST GGS_falseExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_falseExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_falseExpressionAST * p = dynamic_cast <const GGS_falseExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_falseExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_falseExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_falseExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_literalCharExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalCharExpressionAST::
cPtr_literalCharExpressionAST (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalCharExpressionAST * GGS_literalCharExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalCharExpressionAST) ;
    return (cPtr_literalCharExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalCharExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalCharExpressionAST * ptr = dynamic_cast <const cPtr_literalCharExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalCharExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalCharExpressionAST:"
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalCharExpressionAST (& typeid (cPtr_literalCharExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalCharExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalCharExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalCharExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalCharExpressionAST (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_literalCharExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalCharExpressionAST ("literalCharExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalCharExpressionAST::
GGS_literalCharExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionAST::
GGS_literalCharExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalCharExpressionAST GGS_literalCharExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalCharExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalCharExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalCharExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalCharExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionAST GGS_literalCharExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalCharExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_literalCharExpressionAST::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalCharExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalCharExpressionAST *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalCharExpressionAST::actualTypeName (void) const {
  return "literalCharExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalCharExpressionAST ("literalCharExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalCharExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalCharExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalCharExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalCharExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionAST GGS_literalCharExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalCharExpressionAST * p = dynamic_cast <const GGS_literalCharExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalCharExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalCharExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalCharExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalStringExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalStringExpressionAST::
cPtr_literalStringExpressionAST (const GGS_location & argument_0,
                                const GGS_stringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mLocation (argument_0),
mStringSequence (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalStringExpressionAST * GGS_literalStringExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalStringExpressionAST) ;
    return (cPtr_literalStringExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalStringExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalStringExpressionAST * ptr = dynamic_cast <const cPtr_literalStringExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mStringSequence.operator_isEqual (ptr->mStringSequence).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalStringExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalStringExpressionAST:"
           << mLocation.reader_description (inIndentation + 1)
           << mStringSequence.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalStringExpressionAST (& typeid (cPtr_literalStringExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalStringExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalStringExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalStringExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalStringExpressionAST (mLocation, mStringSequence COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalStringExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalStringExpressionAST ("literalStringExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalStringExpressionAST::
GGS_literalStringExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionAST::
GGS_literalStringExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalStringExpressionAST GGS_literalStringExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalStringExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalStringExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalStringExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalStringExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionAST GGS_literalStringExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_stringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalStringExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_literalStringExpressionAST::
reader_mLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalStringExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalStringExpressionAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_literalStringExpressionAST::
reader_mStringSequence (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalStringExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalStringExpressionAST *) mPointer)->mStringSequence ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalStringExpressionAST::actualTypeName (void) const {
  return "literalStringExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalStringExpressionAST ("literalStringExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalStringExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalStringExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalStringExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalStringExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionAST GGS_literalStringExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalStringExpressionAST * p = dynamic_cast <const GGS_literalStringExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalStringExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalStringExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalStringExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalDoubleExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalDoubleExpressionAST::
cPtr_literalDoubleExpressionAST (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalDoubleExpressionAST * GGS_literalDoubleExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalDoubleExpressionAST) ;
    return (cPtr_literalDoubleExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalDoubleExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalDoubleExpressionAST * ptr = dynamic_cast <const cPtr_literalDoubleExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalDoubleExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalDoubleExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalDoubleExpressionAST (& typeid (cPtr_literalDoubleExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalDoubleExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalDoubleExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalDoubleExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalDoubleExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalDoubleExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalDoubleExpressionAST ("literalDoubleExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionAST::
GGS_literalDoubleExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionAST::
GGS_literalDoubleExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalDoubleExpressionAST GGS_literalDoubleExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalDoubleExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalDoubleExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalDoubleExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalDoubleExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionAST GGS_literalDoubleExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalDoubleExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_literalDoubleExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalDoubleExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalDoubleExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalDoubleExpressionAST::actualTypeName (void) const {
  return "literalDoubleExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalDoubleExpressionAST ("literalDoubleExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalDoubleExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalDoubleExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalDoubleExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalDoubleExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionAST GGS_literalDoubleExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalDoubleExpressionAST * p = dynamic_cast <const GGS_literalDoubleExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalDoubleExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalDoubleExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalDoubleExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_literalUIntExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUIntExpressionAST::
cPtr_literalUIntExpressionAST (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUIntExpressionAST * GGS_literalUIntExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUIntExpressionAST) ;
    return (cPtr_literalUIntExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUIntExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUIntExpressionAST * ptr = dynamic_cast <const cPtr_literalUIntExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUIntExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUIntExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUIntExpressionAST (& typeid (cPtr_literalUIntExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUIntExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalUIntExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUIntExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUIntExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_literalUIntExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUIntExpressionAST ("literalUIntExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionAST::
GGS_literalUIntExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionAST::
GGS_literalUIntExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUIntExpressionAST GGS_literalUIntExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUIntExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalUIntExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUIntExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUIntExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionAST GGS_literalUIntExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalUIntExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_literalUIntExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUIntExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUIntExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUIntExpressionAST::actualTypeName (void) const {
  return "literalUIntExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUIntExpressionAST ("literalUIntExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalUIntExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUIntExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUIntExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalUIntExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionAST GGS_literalUIntExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUIntExpressionAST * p = dynamic_cast <const GGS_literalUIntExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUIntExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUIntExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUIntExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalUInt64ExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUInt64ExpressionAST::
cPtr_literalUInt64ExpressionAST (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUInt64ExpressionAST * GGS_literalUInt64ExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUInt64ExpressionAST) ;
    return (cPtr_literalUInt64ExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUInt64ExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUInt64ExpressionAST * ptr = dynamic_cast <const cPtr_literalUInt64ExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUInt64ExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUInt64ExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUInt64ExpressionAST (& typeid (cPtr_literalUInt64ExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUInt64ExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalUInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUInt64ExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUInt64ExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalUInt64ExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUInt64ExpressionAST ("literalUInt64ExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionAST::
GGS_literalUInt64ExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionAST::
GGS_literalUInt64ExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUInt64ExpressionAST GGS_literalUInt64ExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUInt64ExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalUInt64ExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUInt64ExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUInt64ExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionAST GGS_literalUInt64ExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalUInt64ExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_literalUInt64ExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUInt64ExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUInt64ExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUInt64ExpressionAST::actualTypeName (void) const {
  return "literalUInt64ExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUInt64ExpressionAST ("literalUInt64ExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalUInt64ExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUInt64ExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUInt64ExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalUInt64ExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionAST GGS_literalUInt64ExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUInt64ExpressionAST * p = dynamic_cast <const GGS_literalUInt64ExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUInt64ExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUInt64ExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_literalSIntExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSIntExpressionAST::
cPtr_literalSIntExpressionAST (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSIntExpressionAST * GGS_literalSIntExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSIntExpressionAST) ;
    return (cPtr_literalSIntExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSIntExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSIntExpressionAST * ptr = dynamic_cast <const cPtr_literalSIntExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSIntExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSIntExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSIntExpressionAST (& typeid (cPtr_literalSIntExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSIntExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalSIntExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSIntExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSIntExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_literalSIntExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSIntExpressionAST ("literalSIntExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionAST::
GGS_literalSIntExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionAST::
GGS_literalSIntExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSIntExpressionAST GGS_literalSIntExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSIntExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalSIntExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSIntExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSIntExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionAST GGS_literalSIntExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalSIntExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_literalSIntExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSIntExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSIntExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSIntExpressionAST::actualTypeName (void) const {
  return "literalSIntExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSIntExpressionAST ("literalSIntExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalSIntExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSIntExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSIntExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalSIntExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionAST GGS_literalSIntExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSIntExpressionAST * p = dynamic_cast <const GGS_literalSIntExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSIntExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSIntExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSIntExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalSInt64ExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSInt64ExpressionAST::
cPtr_literalSInt64ExpressionAST (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSInt64ExpressionAST * GGS_literalSInt64ExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSInt64ExpressionAST) ;
    return (cPtr_literalSInt64ExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSInt64ExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSInt64ExpressionAST * ptr = dynamic_cast <const cPtr_literalSInt64ExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSInt64ExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSInt64ExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSInt64ExpressionAST (& typeid (cPtr_literalSInt64ExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSInt64ExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalSInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSInt64ExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSInt64ExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalSInt64ExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSInt64ExpressionAST ("literalSInt64ExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionAST::
GGS_literalSInt64ExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionAST::
GGS_literalSInt64ExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSInt64ExpressionAST GGS_literalSInt64ExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSInt64ExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalSInt64ExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSInt64ExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSInt64ExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionAST GGS_literalSInt64ExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalSInt64ExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_literalSInt64ExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSInt64ExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSInt64ExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSInt64ExpressionAST::actualTypeName (void) const {
  return "literalSInt64ExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSInt64ExpressionAST ("literalSInt64ExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalSInt64ExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSInt64ExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSInt64ExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalSInt64ExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionAST GGS_literalSInt64ExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSInt64ExpressionAST * p = dynamic_cast <const GGS_literalSInt64ExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSInt64ExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSInt64ExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_constructorExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constructorExpressionAST::
cPtr_constructorExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mTypeName (argument_0),
mConstructorName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constructorExpressionAST * GGS_constructorExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_constructorExpressionAST) ;
    return (cPtr_constructorExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constructorExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constructorExpressionAST * ptr = dynamic_cast <const cPtr_constructorExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constructorExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@constructorExpressionAST:"
           << mTypeName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constructorExpressionAST (& typeid (cPtr_constructorExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_constructorExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__constructorExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_constructorExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_constructorExpressionAST (mTypeName, mConstructorName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_constructorExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constructorExpressionAST ("constructorExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_constructorExpressionAST::
GGS_constructorExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionAST::
GGS_constructorExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_constructorExpressionAST GGS_constructorExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constructorExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_constructorExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_constructorExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constructorExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionAST GGS_constructorExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_constructorExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpressionAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpressionAST::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionAST *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_constructorExpressionAST::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionAST *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constructorExpressionAST::actualTypeName (void) const {
  return "constructorExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__constructorExpressionAST ("constructorExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_constructorExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_constructorExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constructorExpressionAST * p = NULL ;
    macroMyNew (p, GGS_constructorExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionAST GGS_constructorExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constructorExpressionAST * p = dynamic_cast <const GGS_constructorExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constructorExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constructorExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constructorExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_readerCallExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readerCallExpressionAST::
cPtr_readerCallExpressionAST (const GGS_semanticExpressionAST & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mReceiver (argument_0),
mReaderName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readerCallExpressionAST * GGS_readerCallExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readerCallExpressionAST) ;
    return (cPtr_readerCallExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readerCallExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readerCallExpressionAST * ptr = dynamic_cast <const cPtr_readerCallExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiver.operator_isEqual (ptr->mReceiver).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readerCallExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readerCallExpressionAST:"
           << mReceiver.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readerCallExpressionAST (& typeid (cPtr_readerCallExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readerCallExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__readerCallExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readerCallExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readerCallExpressionAST (mReceiver, mReaderName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_readerCallExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerCallExpressionAST ("readerCallExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_readerCallExpressionAST::
GGS_readerCallExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionAST::
GGS_readerCallExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readerCallExpressionAST GGS_readerCallExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readerCallExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_readerCallExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readerCallExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readerCallExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionAST GGS_readerCallExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionAST & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_readerCallExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_readerCallExpressionAST::
reader_mReceiver (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionAST *) mPointer)->mReceiver ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readerCallExpressionAST::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionAST *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_readerCallExpressionAST::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionAST *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readerCallExpressionAST::actualTypeName (void) const {
  return "readerCallExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readerCallExpressionAST ("readerCallExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_readerCallExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readerCallExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerCallExpressionAST * p = NULL ;
    macroMyNew (p, GGS_readerCallExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionAST GGS_readerCallExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerCallExpressionAST * p = dynamic_cast <const GGS_readerCallExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerCallExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerCallExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerCallExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_optionExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionExpressionAST::
cPtr_optionExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOptionComponentName (argument_0),
mOptionEntryName (argument_1),
mOptionReaderName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionExpressionAST * GGS_optionExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionExpressionAST) ;
    return (cPtr_optionExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionExpressionAST * ptr = dynamic_cast <const cPtr_optionExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue ()
         && mOptionReaderName.operator_isEqual (ptr->mOptionReaderName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionExpressionAST:"
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1)
           << mOptionReaderName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionExpressionAST (& typeid (cPtr_optionExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__optionExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionExpressionAST (mOptionComponentName, mOptionEntryName, mOptionReaderName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_optionExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionExpressionAST ("optionExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_optionExpressionAST::
GGS_optionExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionAST::
GGS_optionExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionExpressionAST GGS_optionExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_optionExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionAST GGS_optionExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_optionExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_optionExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionAST::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionAST *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionAST::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionAST *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionAST::
reader_mOptionReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionAST *) mPointer)->mOptionReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionExpressionAST::actualTypeName (void) const {
  return "optionExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionExpressionAST ("optionExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_optionExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionExpressionAST * p = NULL ;
    macroMyNew (p, GGS_optionExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionAST GGS_optionExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionExpressionAST * p = dynamic_cast <const GGS_optionExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_concatExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_concatExpressionAST::
cPtr_concatExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_concatExpressionAST * GGS_concatExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_concatExpressionAST) ;
    return (cPtr_concatExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_concatExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_concatExpressionAST * ptr = dynamic_cast <const cPtr_concatExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_concatExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@concatExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_concatExpressionAST (& typeid (cPtr_concatExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_concatExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__concatExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_concatExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_concatExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_concatExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_concatExpressionAST ("concatExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_concatExpressionAST::
GGS_concatExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionAST::
GGS_concatExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_concatExpressionAST GGS_concatExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_concatExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_concatExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_concatExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_concatExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_concatExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionAST GGS_concatExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_concatExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_concatExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_concatExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_concatExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_concatExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_concatExpressionAST::actualTypeName (void) const {
  return "concatExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__concatExpressionAST ("concatExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_concatExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_concatExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_concatExpressionAST * p = NULL ;
    macroMyNew (p, GGS_concatExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionAST GGS_concatExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_concatExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_concatExpressionAST * p = dynamic_cast <const GGS_concatExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_concatExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_concatExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_concatExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_orExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_orExpressionAST::
cPtr_orExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_orExpressionAST * GGS_orExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_orExpressionAST) ;
    return (cPtr_orExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_orExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_orExpressionAST * ptr = dynamic_cast <const cPtr_orExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_orExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@orExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_orExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_orExpressionAST (& typeid (cPtr_orExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_orExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__orExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_orExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_orExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_orExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_orExpressionAST ("orExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_orExpressionAST::
GGS_orExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionAST::
GGS_orExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_orExpressionAST GGS_orExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_orExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_orExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_orExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_orExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_orExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionAST GGS_orExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_orExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_orExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_orExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_orExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_orExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_orExpressionAST::actualTypeName (void) const {
  return "orExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__orExpressionAST ("orExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_orExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_orExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_orExpressionAST * p = NULL ;
    macroMyNew (p, GGS_orExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionAST GGS_orExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_orExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_orExpressionAST * p = dynamic_cast <const GGS_orExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_orExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_orExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_orExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_xorExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_xorExpressionAST::
cPtr_xorExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_xorExpressionAST * GGS_xorExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_xorExpressionAST) ;
    return (cPtr_xorExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_xorExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_xorExpressionAST * ptr = dynamic_cast <const cPtr_xorExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_xorExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@xorExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_xorExpressionAST (& typeid (cPtr_xorExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_xorExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__xorExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_xorExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_xorExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_xorExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_xorExpressionAST ("xorExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_xorExpressionAST::
GGS_xorExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionAST::
GGS_xorExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_xorExpressionAST GGS_xorExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_xorExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_xorExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_xorExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_xorExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_xorExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionAST GGS_xorExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_xorExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_xorExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_xorExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_xorExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_xorExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_xorExpressionAST::actualTypeName (void) const {
  return "xorExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__xorExpressionAST ("xorExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_xorExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_xorExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_xorExpressionAST * p = NULL ;
    macroMyNew (p, GGS_xorExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionAST GGS_xorExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_xorExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_xorExpressionAST * p = dynamic_cast <const GGS_xorExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_xorExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_xorExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_xorExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_andExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_andExpressionAST::
cPtr_andExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_andExpressionAST * GGS_andExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_andExpressionAST) ;
    return (cPtr_andExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_andExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_andExpressionAST * ptr = dynamic_cast <const cPtr_andExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_andExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@andExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_andExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_andExpressionAST (& typeid (cPtr_andExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_andExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__andExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_andExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_andExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_andExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_andExpressionAST ("andExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_andExpressionAST::
GGS_andExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionAST::
GGS_andExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_andExpressionAST GGS_andExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_andExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_andExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_andExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_andExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_andExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionAST GGS_andExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_andExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_andExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_andExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_andExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_andExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_andExpressionAST::actualTypeName (void) const {
  return "andExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__andExpressionAST ("andExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_andExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_andExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_andExpressionAST * p = NULL ;
    macroMyNew (p, GGS_andExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionAST GGS_andExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_andExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_andExpressionAST * p = dynamic_cast <const GGS_andExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_andExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_andExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_andExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_equalExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_equalExpressionAST::
cPtr_equalExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_equalExpressionAST * GGS_equalExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_equalExpressionAST) ;
    return (cPtr_equalExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_equalExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_equalExpressionAST * ptr = dynamic_cast <const cPtr_equalExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_equalExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@equalExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_equalExpressionAST (& typeid (cPtr_equalExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_equalExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__equalExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_equalExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_equalExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_equalExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_equalExpressionAST ("equalExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_equalExpressionAST::
GGS_equalExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionAST::
GGS_equalExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_equalExpressionAST GGS_equalExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_equalExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_equalExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_equalExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_equalExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_equalExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionAST GGS_equalExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_equalExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_equalExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_equalExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_equalExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_equalExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_equalExpressionAST::actualTypeName (void) const {
  return "equalExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__equalExpressionAST ("equalExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_equalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_equalExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_equalExpressionAST * p = NULL ;
    macroMyNew (p, GGS_equalExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionAST GGS_equalExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_equalExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_equalExpressionAST * p = dynamic_cast <const GGS_equalExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_equalExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_equalExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_equalExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_notEqualExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notEqualExpressionAST::
cPtr_notEqualExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notEqualExpressionAST * GGS_notEqualExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notEqualExpressionAST) ;
    return (cPtr_notEqualExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notEqualExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notEqualExpressionAST * ptr = dynamic_cast <const cPtr_notEqualExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notEqualExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notEqualExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notEqualExpressionAST (& typeid (cPtr_notEqualExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notEqualExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__notEqualExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notEqualExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notEqualExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_notEqualExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notEqualExpressionAST ("notEqualExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_notEqualExpressionAST::
GGS_notEqualExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionAST::
GGS_notEqualExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notEqualExpressionAST GGS_notEqualExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notEqualExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_notEqualExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notEqualExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notEqualExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionAST GGS_notEqualExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_notEqualExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notEqualExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_notEqualExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_notEqualExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notEqualExpressionAST::actualTypeName (void) const {
  return "notEqualExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notEqualExpressionAST ("notEqualExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_notEqualExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notEqualExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notEqualExpressionAST * p = NULL ;
    macroMyNew (p, GGS_notEqualExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionAST GGS_notEqualExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notEqualExpressionAST * p = dynamic_cast <const GGS_notEqualExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notEqualExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notEqualExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notEqualExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lowerOrEqualExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lowerOrEqualExpressionAST::
cPtr_lowerOrEqualExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lowerOrEqualExpressionAST * GGS_lowerOrEqualExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lowerOrEqualExpressionAST) ;
    return (cPtr_lowerOrEqualExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lowerOrEqualExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lowerOrEqualExpressionAST * ptr = dynamic_cast <const cPtr_lowerOrEqualExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lowerOrEqualExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lowerOrEqualExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lowerOrEqualExpressionAST (& typeid (cPtr_lowerOrEqualExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lowerOrEqualExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lowerOrEqualExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lowerOrEqualExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lowerOrEqualExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lowerOrEqualExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lowerOrEqualExpressionAST ("lowerOrEqualExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionAST::
GGS_lowerOrEqualExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionAST::
GGS_lowerOrEqualExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lowerOrEqualExpressionAST GGS_lowerOrEqualExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lowerOrEqualExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lowerOrEqualExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lowerOrEqualExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lowerOrEqualExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionAST GGS_lowerOrEqualExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_lowerOrEqualExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lowerOrEqualExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_lowerOrEqualExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_lowerOrEqualExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lowerOrEqualExpressionAST::actualTypeName (void) const {
  return "lowerOrEqualExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lowerOrEqualExpressionAST ("lowerOrEqualExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_lowerOrEqualExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lowerOrEqualExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lowerOrEqualExpressionAST * p = NULL ;
    macroMyNew (p, GGS_lowerOrEqualExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionAST GGS_lowerOrEqualExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lowerOrEqualExpressionAST * p = dynamic_cast <const GGS_lowerOrEqualExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lowerOrEqualExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lowerOrEqualExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lowerOrEqualExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_greaterOrEqualExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_greaterOrEqualExpressionAST::
cPtr_greaterOrEqualExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_greaterOrEqualExpressionAST * GGS_greaterOrEqualExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_greaterOrEqualExpressionAST) ;
    return (cPtr_greaterOrEqualExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_greaterOrEqualExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_greaterOrEqualExpressionAST * ptr = dynamic_cast <const cPtr_greaterOrEqualExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_greaterOrEqualExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@greaterOrEqualExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_greaterOrEqualExpressionAST (& typeid (cPtr_greaterOrEqualExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_greaterOrEqualExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__greaterOrEqualExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_greaterOrEqualExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_greaterOrEqualExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_greaterOrEqualExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_greaterOrEqualExpressionAST ("greaterOrEqualExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionAST::
GGS_greaterOrEqualExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionAST::
GGS_greaterOrEqualExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_greaterOrEqualExpressionAST GGS_greaterOrEqualExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_greaterOrEqualExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_greaterOrEqualExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_greaterOrEqualExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_greaterOrEqualExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionAST GGS_greaterOrEqualExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_greaterOrEqualExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_greaterOrEqualExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_greaterOrEqualExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_greaterOrEqualExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_greaterOrEqualExpressionAST::actualTypeName (void) const {
  return "greaterOrEqualExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__greaterOrEqualExpressionAST ("greaterOrEqualExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_greaterOrEqualExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_greaterOrEqualExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_greaterOrEqualExpressionAST * p = NULL ;
    macroMyNew (p, GGS_greaterOrEqualExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionAST GGS_greaterOrEqualExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_greaterOrEqualExpressionAST * p = dynamic_cast <const GGS_greaterOrEqualExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_greaterOrEqualExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_greaterOrEqualExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_greaterOrEqualExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_strictGreaterExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictGreaterExpressionAST::
cPtr_strictGreaterExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictGreaterExpressionAST * GGS_strictGreaterExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictGreaterExpressionAST) ;
    return (cPtr_strictGreaterExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictGreaterExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictGreaterExpressionAST * ptr = dynamic_cast <const cPtr_strictGreaterExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictGreaterExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictGreaterExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictGreaterExpressionAST (& typeid (cPtr_strictGreaterExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictGreaterExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__strictGreaterExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictGreaterExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictGreaterExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_strictGreaterExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictGreaterExpressionAST ("strictGreaterExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionAST::
GGS_strictGreaterExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionAST::
GGS_strictGreaterExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictGreaterExpressionAST GGS_strictGreaterExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictGreaterExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_strictGreaterExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictGreaterExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictGreaterExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionAST GGS_strictGreaterExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_strictGreaterExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictGreaterExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_strictGreaterExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_strictGreaterExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictGreaterExpressionAST::actualTypeName (void) const {
  return "strictGreaterExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictGreaterExpressionAST ("strictGreaterExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_strictGreaterExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictGreaterExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictGreaterExpressionAST * p = NULL ;
    macroMyNew (p, GGS_strictGreaterExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionAST GGS_strictGreaterExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictGreaterExpressionAST * p = dynamic_cast <const GGS_strictGreaterExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictGreaterExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictGreaterExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictGreaterExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_strictLowerExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictLowerExpressionAST::
cPtr_strictLowerExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictLowerExpressionAST * GGS_strictLowerExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictLowerExpressionAST) ;
    return (cPtr_strictLowerExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictLowerExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictLowerExpressionAST * ptr = dynamic_cast <const cPtr_strictLowerExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictLowerExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictLowerExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictLowerExpressionAST (& typeid (cPtr_strictLowerExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictLowerExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__strictLowerExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictLowerExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictLowerExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_strictLowerExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictLowerExpressionAST ("strictLowerExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionAST::
GGS_strictLowerExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionAST::
GGS_strictLowerExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictLowerExpressionAST GGS_strictLowerExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictLowerExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_strictLowerExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictLowerExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictLowerExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionAST GGS_strictLowerExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_strictLowerExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictLowerExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_strictLowerExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_strictLowerExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictLowerExpressionAST::actualTypeName (void) const {
  return "strictLowerExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictLowerExpressionAST ("strictLowerExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_strictLowerExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictLowerExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictLowerExpressionAST * p = NULL ;
    macroMyNew (p, GGS_strictLowerExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionAST GGS_strictLowerExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictLowerExpressionAST * p = dynamic_cast <const GGS_strictLowerExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictLowerExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictLowerExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictLowerExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_rightShiftExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rightShiftExpressionAST::
cPtr_rightShiftExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rightShiftExpressionAST * GGS_rightShiftExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rightShiftExpressionAST) ;
    return (cPtr_rightShiftExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rightShiftExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rightShiftExpressionAST * ptr = dynamic_cast <const cPtr_rightShiftExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rightShiftExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rightShiftExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rightShiftExpressionAST (& typeid (cPtr_rightShiftExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rightShiftExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__rightShiftExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rightShiftExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rightShiftExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_rightShiftExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rightShiftExpressionAST ("rightShiftExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionAST::
GGS_rightShiftExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionAST::
GGS_rightShiftExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rightShiftExpressionAST GGS_rightShiftExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rightShiftExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_rightShiftExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rightShiftExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rightShiftExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionAST GGS_rightShiftExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_rightShiftExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_rightShiftExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_rightShiftExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_rightShiftExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rightShiftExpressionAST::actualTypeName (void) const {
  return "rightShiftExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rightShiftExpressionAST ("rightShiftExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_rightShiftExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rightShiftExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rightShiftExpressionAST * p = NULL ;
    macroMyNew (p, GGS_rightShiftExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionAST GGS_rightShiftExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rightShiftExpressionAST * p = dynamic_cast <const GGS_rightShiftExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rightShiftExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rightShiftExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rightShiftExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_leftShiftExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_leftShiftExpressionAST::
cPtr_leftShiftExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_leftShiftExpressionAST * GGS_leftShiftExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_leftShiftExpressionAST) ;
    return (cPtr_leftShiftExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_leftShiftExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_leftShiftExpressionAST * ptr = dynamic_cast <const cPtr_leftShiftExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_leftShiftExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@leftShiftExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_leftShiftExpressionAST (& typeid (cPtr_leftShiftExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_leftShiftExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__leftShiftExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_leftShiftExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_leftShiftExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_leftShiftExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_leftShiftExpressionAST ("leftShiftExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionAST::
GGS_leftShiftExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionAST::
GGS_leftShiftExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_leftShiftExpressionAST GGS_leftShiftExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_leftShiftExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_leftShiftExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_leftShiftExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_leftShiftExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionAST GGS_leftShiftExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_leftShiftExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_leftShiftExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_leftShiftExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_leftShiftExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_leftShiftExpressionAST::actualTypeName (void) const {
  return "leftShiftExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__leftShiftExpressionAST ("leftShiftExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_leftShiftExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_leftShiftExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_leftShiftExpressionAST * p = NULL ;
    macroMyNew (p, GGS_leftShiftExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionAST GGS_leftShiftExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_leftShiftExpressionAST * p = dynamic_cast <const GGS_leftShiftExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_leftShiftExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_leftShiftExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_leftShiftExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_addExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addExpressionAST::
cPtr_addExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addExpressionAST * GGS_addExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addExpressionAST) ;
    return (cPtr_addExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addExpressionAST * ptr = dynamic_cast <const cPtr_addExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addExpressionAST (& typeid (cPtr_addExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__addExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_addExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addExpressionAST ("addExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_addExpressionAST::
GGS_addExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionAST::
GGS_addExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addExpressionAST GGS_addExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_addExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionAST GGS_addExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_addExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_addExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_addExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_addExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_addExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addExpressionAST::actualTypeName (void) const {
  return "addExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addExpressionAST ("addExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_addExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addExpressionAST * p = NULL ;
    macroMyNew (p, GGS_addExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionAST GGS_addExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addExpressionAST * p = dynamic_cast <const GGS_addExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_subExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_subExpressionAST::
cPtr_subExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_subExpressionAST * GGS_subExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_subExpressionAST) ;
    return (cPtr_subExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_subExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_subExpressionAST * ptr = dynamic_cast <const cPtr_subExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_subExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@subExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_subExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_subExpressionAST (& typeid (cPtr_subExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_subExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__subExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_subExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_subExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_subExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_subExpressionAST ("subExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_subExpressionAST::
GGS_subExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionAST::
GGS_subExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_subExpressionAST GGS_subExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_subExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_subExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_subExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_subExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_subExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionAST GGS_subExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_subExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_subExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_subExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_subExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_subExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_subExpressionAST::actualTypeName (void) const {
  return "subExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__subExpressionAST ("subExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_subExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_subExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_subExpressionAST * p = NULL ;
    macroMyNew (p, GGS_subExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionAST GGS_subExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_subExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_subExpressionAST * p = dynamic_cast <const GGS_subExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_subExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_subExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_subExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_multiplicationExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_multiplicationExpressionAST::
cPtr_multiplicationExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_multiplicationExpressionAST * GGS_multiplicationExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_multiplicationExpressionAST) ;
    return (cPtr_multiplicationExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_multiplicationExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_multiplicationExpressionAST * ptr = dynamic_cast <const cPtr_multiplicationExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_multiplicationExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@multiplicationExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_multiplicationExpressionAST (& typeid (cPtr_multiplicationExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_multiplicationExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__multiplicationExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_multiplicationExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_multiplicationExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_multiplicationExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiplicationExpressionAST ("multiplicationExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionAST::
GGS_multiplicationExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionAST::
GGS_multiplicationExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_multiplicationExpressionAST GGS_multiplicationExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_multiplicationExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_multiplicationExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_multiplicationExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_multiplicationExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionAST GGS_multiplicationExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_multiplicationExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_multiplicationExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_multiplicationExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_multiplicationExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiplicationExpressionAST::actualTypeName (void) const {
  return "multiplicationExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__multiplicationExpressionAST ("multiplicationExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_multiplicationExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_multiplicationExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiplicationExpressionAST * p = NULL ;
    macroMyNew (p, GGS_multiplicationExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionAST GGS_multiplicationExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiplicationExpressionAST * p = dynamic_cast <const GGS_multiplicationExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiplicationExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiplicationExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiplicationExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_divisionExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_divisionExpressionAST::
cPtr_divisionExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_divisionExpressionAST * GGS_divisionExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_divisionExpressionAST) ;
    return (cPtr_divisionExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_divisionExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_divisionExpressionAST * ptr = dynamic_cast <const cPtr_divisionExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_divisionExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@divisionExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_divisionExpressionAST (& typeid (cPtr_divisionExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_divisionExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__divisionExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_divisionExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_divisionExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_divisionExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_divisionExpressionAST ("divisionExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_divisionExpressionAST::
GGS_divisionExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionAST::
GGS_divisionExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_divisionExpressionAST GGS_divisionExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_divisionExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_divisionExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_divisionExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_divisionExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionAST GGS_divisionExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_divisionExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_divisionExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_divisionExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_divisionExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_divisionExpressionAST::actualTypeName (void) const {
  return "divisionExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__divisionExpressionAST ("divisionExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_divisionExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_divisionExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_divisionExpressionAST * p = NULL ;
    macroMyNew (p, GGS_divisionExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionAST GGS_divisionExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_divisionExpressionAST * p = dynamic_cast <const GGS_divisionExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_divisionExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_divisionExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_divisionExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_moduloExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_moduloExpressionAST::
cPtr_moduloExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_moduloExpressionAST * GGS_moduloExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_moduloExpressionAST) ;
    return (cPtr_moduloExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_moduloExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_moduloExpressionAST * ptr = dynamic_cast <const cPtr_moduloExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_moduloExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@moduloExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_moduloExpressionAST (& typeid (cPtr_moduloExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_moduloExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__moduloExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_moduloExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_moduloExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_moduloExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_moduloExpressionAST ("moduloExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_moduloExpressionAST::
GGS_moduloExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionAST::
GGS_moduloExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_moduloExpressionAST GGS_moduloExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_moduloExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_moduloExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_moduloExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_moduloExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionAST GGS_moduloExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_moduloExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_moduloExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_moduloExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_moduloExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_moduloExpressionAST::actualTypeName (void) const {
  return "moduloExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__moduloExpressionAST ("moduloExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_moduloExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_moduloExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_moduloExpressionAST * p = NULL ;
    macroMyNew (p, GGS_moduloExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionAST GGS_moduloExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_moduloExpressionAST * p = dynamic_cast <const GGS_moduloExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_moduloExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_moduloExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_moduloExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_unaryMinusExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_unaryMinusExpressionAST::
cPtr_unaryMinusExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_unaryMinusExpressionAST * GGS_unaryMinusExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_unaryMinusExpressionAST) ;
    return (cPtr_unaryMinusExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_unaryMinusExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_unaryMinusExpressionAST * ptr = dynamic_cast <const cPtr_unaryMinusExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_unaryMinusExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@unaryMinusExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_unaryMinusExpressionAST (& typeid (cPtr_unaryMinusExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_unaryMinusExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__unaryMinusExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_unaryMinusExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_unaryMinusExpressionAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_unaryMinusExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unaryMinusExpressionAST ("unaryMinusExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionAST::
GGS_unaryMinusExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionAST::
GGS_unaryMinusExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_unaryMinusExpressionAST GGS_unaryMinusExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_unaryMinusExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_unaryMinusExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_unaryMinusExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_unaryMinusExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionAST GGS_unaryMinusExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_unaryMinusExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_unaryMinusExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_unaryMinusExpressionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpressionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_unaryMinusExpressionAST::actualTypeName (void) const {
  return "unaryMinusExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__unaryMinusExpressionAST ("unaryMinusExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_unaryMinusExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_unaryMinusExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unaryMinusExpressionAST * p = NULL ;
    macroMyNew (p, GGS_unaryMinusExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionAST GGS_unaryMinusExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unaryMinusExpressionAST * p = dynamic_cast <const GGS_unaryMinusExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unaryMinusExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unaryMinusExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unaryMinusExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_notExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notExpressionAST::
cPtr_notExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notExpressionAST * GGS_notExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notExpressionAST) ;
    return (cPtr_notExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notExpressionAST * ptr = dynamic_cast <const cPtr_notExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notExpressionAST (& typeid (cPtr_notExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__notExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notExpressionAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_notExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notExpressionAST ("notExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_notExpressionAST::
GGS_notExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionAST::
GGS_notExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notExpressionAST GGS_notExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_notExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionAST GGS_notExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_notExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_notExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_notExpressionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpressionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notExpressionAST::actualTypeName (void) const {
  return "notExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notExpressionAST ("notExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_notExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notExpressionAST * p = NULL ;
    macroMyNew (p, GGS_notExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionAST GGS_notExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notExpressionAST * p = dynamic_cast <const GGS_notExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_complementExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_complementExpressionAST::
cPtr_complementExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_complementExpressionAST * GGS_complementExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_complementExpressionAST) ;
    return (cPtr_complementExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_complementExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_complementExpressionAST * ptr = dynamic_cast <const cPtr_complementExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_complementExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@complementExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_complementExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_complementExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_complementExpressionAST (& typeid (cPtr_complementExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_complementExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__complementExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_complementExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_complementExpressionAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_complementExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_complementExpressionAST ("complementExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_complementExpressionAST::
GGS_complementExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_complementExpressionAST::
GGS_complementExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_complementExpressionAST GGS_complementExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_complementExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_complementExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_complementExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_complementExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_complementExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_complementExpressionAST GGS_complementExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_complementExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_complementExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_complementExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_complementExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_complementExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_complementExpressionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_complementExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_complementExpressionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_complementExpressionAST::actualTypeName (void) const {
  return "complementExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__complementExpressionAST ("complementExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_complementExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_complementExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_complementExpressionAST * p = NULL ;
    macroMyNew (p, GGS_complementExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_complementExpressionAST GGS_complementExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_complementExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_complementExpressionAST * p = dynamic_cast <const GGS_complementExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_complementExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_complementExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_complementExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_ifExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifExpressionAST::
cPtr_ifExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mIfExpression (argument_1),
mThenExpression (argument_2),
mElseExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifExpressionAST * GGS_ifExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifExpressionAST) ;
    return (cPtr_ifExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifExpressionAST * ptr = dynamic_cast <const cPtr_ifExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mIfExpression.operator_isEqual (ptr->mIfExpression).boolValue ()
         && mThenExpression.operator_isEqual (ptr->mThenExpression).boolValue ()
         && mElseExpression.operator_isEqual (ptr->mElseExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mIfExpression.reader_description (inIndentation + 1)
           << mThenExpression.reader_description (inIndentation + 1)
           << mElseExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifExpressionAST (& typeid (cPtr_ifExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__ifExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifExpressionAST (mOperatorLocation, mIfExpression, mThenExpression, mElseExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ifExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifExpressionAST ("ifExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_ifExpressionAST::
GGS_ifExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionAST::
GGS_ifExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifExpressionAST GGS_ifExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_ifExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionAST GGS_ifExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_ifExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_ifExpressionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_ifExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_ifExpressionAST::
reader_mIfExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionAST *) mPointer)->mIfExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_ifExpressionAST::
reader_mThenExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionAST *) mPointer)->mThenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_ifExpressionAST::
reader_mElseExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionAST *) mPointer)->mElseExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifExpressionAST::actualTypeName (void) const {
  return "ifExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifExpressionAST ("ifExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_ifExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifExpressionAST * p = NULL ;
    macroMyNew (p, GGS_ifExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionAST GGS_ifExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifExpressionAST * p = dynamic_cast <const GGS_ifExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_functionCallExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionCallExpressionAST::
cPtr_functionCallExpressionAST (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mFunctionName (argument_0),
mExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionCallExpressionAST * GGS_functionCallExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionCallExpressionAST) ;
    return (cPtr_functionCallExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionCallExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionCallExpressionAST * ptr = dynamic_cast <const cPtr_functionCallExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionCallExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionCallExpressionAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionCallExpressionAST (& typeid (cPtr_functionCallExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionCallExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__functionCallExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionCallExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionCallExpressionAST (mFunctionName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_functionCallExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionCallExpressionAST ("functionCallExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_functionCallExpressionAST::
GGS_functionCallExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionAST::
GGS_functionCallExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionCallExpressionAST GGS_functionCallExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionCallExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_functionCallExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionCallExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionCallExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionAST GGS_functionCallExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_semanticExpressionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_functionCallExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_functionCallExpressionAST::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionAST *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_functionCallExpressionAST::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionAST *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionCallExpressionAST::actualTypeName (void) const {
  return "functionCallExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionCallExpressionAST ("functionCallExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_functionCallExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionCallExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionCallExpressionAST * p = NULL ;
    macroMyNew (p, GGS_functionCallExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionAST GGS_functionCallExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionCallExpressionAST * p = dynamic_cast <const GGS_functionCallExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionCallExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionCallExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionCallExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_varInExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_varInExpressionAST::
cPtr_varInExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mVarName (argument_0),
mStructFieldList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_varInExpressionAST * GGS_varInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_varInExpressionAST) ;
    return (cPtr_varInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_varInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_varInExpressionAST * ptr = dynamic_cast <const cPtr_varInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVarName.operator_isEqual (ptr->mVarName).boolValue ()
         && mStructFieldList.operator_isEqual (ptr->mStructFieldList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_varInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@varInExpressionAST:"
           << mVarName.reader_description (inIndentation + 1)
           << mStructFieldList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_varInExpressionAST (& typeid (cPtr_varInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_varInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__varInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_varInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_varInExpressionAST (mVarName, mStructFieldList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_varInExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_varInExpressionAST ("varInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_varInExpressionAST::
GGS_varInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionAST::
GGS_varInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_varInExpressionAST GGS_varInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_varInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_varInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_varInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_varInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_varInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionAST GGS_varInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_varInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_varInExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_varInExpressionAST::
reader_mVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionAST *) mPointer)->mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_varInExpressionAST::
reader_mStructFieldList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionAST *) mPointer)->mStructFieldList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_varInExpressionAST::actualTypeName (void) const {
  return "varInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__varInExpressionAST ("varInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_varInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_varInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_varInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_varInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionAST GGS_varInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_varInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_varInExpressionAST * p = dynamic_cast <const GGS_varInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_varInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_varInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_varInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalTypeInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalTypeInExpressionAST::
cPtr_literalTypeInExpressionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mLiteralTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalTypeInExpressionAST * GGS_literalTypeInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalTypeInExpressionAST) ;
    return (cPtr_literalTypeInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalTypeInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalTypeInExpressionAST * ptr = dynamic_cast <const cPtr_literalTypeInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralTypeName.operator_isEqual (ptr->mLiteralTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalTypeInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalTypeInExpressionAST:"
           << mLiteralTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalTypeInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalTypeInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalTypeInExpressionAST (& typeid (cPtr_literalTypeInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalTypeInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalTypeInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalTypeInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalTypeInExpressionAST (mLiteralTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalTypeInExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalTypeInExpressionAST ("literalTypeInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionAST::
GGS_literalTypeInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionAST::
GGS_literalTypeInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalTypeInExpressionAST GGS_literalTypeInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalTypeInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalTypeInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalTypeInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalTypeInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionAST GGS_literalTypeInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalTypeInExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_literalTypeInExpressionAST::
reader_mLiteralTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalTypeInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalTypeInExpressionAST *) mPointer)->mLiteralTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalTypeInExpressionAST::actualTypeName (void) const {
  return "literalTypeInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalTypeInExpressionAST ("literalTypeInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalTypeInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalTypeInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalTypeInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalTypeInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionAST GGS_literalTypeInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalTypeInExpressionAST * p = dynamic_cast <const GGS_literalTypeInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalTypeInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalTypeInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalTypeInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_castInExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInExpressionAST::
cPtr_castInExpressionAST (const GGS_semanticExpressionAST & argument_0,
                                const GGS_location & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticExpressionAST & argument_4,
                                const GGS_location & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mReceiverExpression (argument_0),
mEndOfReceiverExpression (argument_1),
mUseKindOfClass (argument_2),
mTypeName (argument_3),
mErrorLocationExpression (argument_4),
mEndOfErrorLocationExpression (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInExpressionAST * GGS_castInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_castInExpressionAST) ;
    return (cPtr_castInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInExpressionAST * ptr = dynamic_cast <const cPtr_castInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mEndOfReceiverExpression.operator_isEqual (ptr->mEndOfReceiverExpression).boolValue ()
         && mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue ()
         && mEndOfErrorLocationExpression.operator_isEqual (ptr->mEndOfErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@castInExpressionAST:"
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mEndOfReceiverExpression.reader_description (inIndentation + 1)
           << mUseKindOfClass.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mErrorLocationExpression.reader_description (inIndentation + 1)
           << mEndOfErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInExpressionAST (& typeid (cPtr_castInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_castInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__castInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_castInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_castInExpressionAST (mReceiverExpression, mEndOfReceiverExpression, mUseKindOfClass, mTypeName, mErrorLocationExpression, mEndOfErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_castInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInExpressionAST ("castInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_castInExpressionAST::
GGS_castInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionAST::
GGS_castInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_castInExpressionAST GGS_castInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_castInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_castInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionAST GGS_castInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionAST & argument_0,
                 const GGS_location & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_semanticExpressionAST & argument_4,
                 const GGS_location & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_castInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_castInExpressionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_castInExpressionAST::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_castInExpressionAST::
reader_mEndOfReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mEndOfReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInExpressionAST::
reader_mUseKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mUseKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInExpressionAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_castInExpressionAST::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_castInExpressionAST::
reader_mEndOfErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mEndOfErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInExpressionAST::actualTypeName (void) const {
  return "castInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__castInExpressionAST ("castInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_castInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_castInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_castInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionAST GGS_castInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInExpressionAST * p = dynamic_cast <const GGS_castInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_filewrapperObjectInstanciationInExpressionAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperObjectInstanciationInExpressionAST::
cPtr_filewrapperObjectInstanciationInExpressionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mFilewrapperName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperObjectInstanciationInExpressionAST * GGS_filewrapperObjectInstanciationInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperObjectInstanciationInExpressionAST) ;
    return (cPtr_filewrapperObjectInstanciationInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperObjectInstanciationInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperObjectInstanciationInExpressionAST * ptr = dynamic_cast <const cPtr_filewrapperObjectInstanciationInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperObjectInstanciationInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperObjectInstanciationInExpressionAST:"
           << mFilewrapperName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperObjectInstanciationInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperObjectInstanciationInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperObjectInstanciationInExpressionAST (& typeid (cPtr_filewrapperObjectInstanciationInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperObjectInstanciationInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperObjectInstanciationInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperObjectInstanciationInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperObjectInstanciationInExpressionAST (mFilewrapperName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_filewrapperObjectInstanciationInExpressionAST'      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionAST ("filewrapperObjectInstanciationInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionAST::
GGS_filewrapperObjectInstanciationInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionAST::
GGS_filewrapperObjectInstanciationInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperObjectInstanciationInExpressionAST GGS_filewrapperObjectInstanciationInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperObjectInstanciationInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperObjectInstanciationInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperObjectInstanciationInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperObjectInstanciationInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionAST GGS_filewrapperObjectInstanciationInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperObjectInstanciationInExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperObjectInstanciationInExpressionAST::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperObjectInstanciationInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperObjectInstanciationInExpressionAST *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperObjectInstanciationInExpressionAST::actualTypeName (void) const {
  return "filewrapperObjectInstanciationInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperObjectInstanciationInExpressionAST ("filewrapperObjectInstanciationInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperObjectInstanciationInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperObjectInstanciationInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperObjectInstanciationInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionAST GGS_filewrapperObjectInstanciationInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperObjectInstanciationInExpressionAST * p = dynamic_cast <const GGS_filewrapperObjectInstanciationInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperObjectInstanciationInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_filewrapperInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperInExpressionAST::
cPtr_filewrapperInExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mFilewrapperName (argument_0),
mFilewrapperPath (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperInExpressionAST * GGS_filewrapperInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperInExpressionAST) ;
    return (cPtr_filewrapperInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperInExpressionAST * ptr = dynamic_cast <const cPtr_filewrapperInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperPath.operator_isEqual (ptr->mFilewrapperPath).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperInExpressionAST:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperPath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperInExpressionAST (& typeid (cPtr_filewrapperInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperInExpressionAST (mFilewrapperName, mFilewrapperPath COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_filewrapperInExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperInExpressionAST ("filewrapperInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionAST::
GGS_filewrapperInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionAST::
GGS_filewrapperInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperInExpressionAST GGS_filewrapperInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionAST GGS_filewrapperInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperInExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperInExpressionAST::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperInExpressionAST *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperInExpressionAST::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperInExpressionAST *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperInExpressionAST::actualTypeName (void) const {
  return "filewrapperInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperInExpressionAST ("filewrapperInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_filewrapperInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionAST GGS_filewrapperInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperInExpressionAST * p = dynamic_cast <const GGS_filewrapperInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_filewrapperTemplateInExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperTemplateInExpressionAST::
cPtr_filewrapperTemplateInExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mFilewrapperName (argument_0),
mFilewrapperTemplateName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperTemplateInExpressionAST * GGS_filewrapperTemplateInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperTemplateInExpressionAST) ;
    return (cPtr_filewrapperTemplateInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperTemplateInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperTemplateInExpressionAST * ptr = dynamic_cast <const cPtr_filewrapperTemplateInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperTemplateName.operator_isEqual (ptr->mFilewrapperTemplateName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperTemplateInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperTemplateInExpressionAST:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperTemplateName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplateInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplateInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperTemplateInExpressionAST (& typeid (cPtr_filewrapperTemplateInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperTemplateInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperTemplateInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperTemplateInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperTemplateInExpressionAST (mFilewrapperName, mFilewrapperTemplateName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_filewrapperTemplateInExpressionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateInExpressionAST ("filewrapperTemplateInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionAST::
GGS_filewrapperTemplateInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionAST::
GGS_filewrapperTemplateInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperTemplateInExpressionAST GGS_filewrapperTemplateInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperTemplateInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperTemplateInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperTemplateInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperTemplateInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionAST GGS_filewrapperTemplateInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperTemplateInExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateInExpressionAST::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionAST *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateInExpressionAST::
reader_mFilewrapperTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionAST *) mPointer)->mFilewrapperTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_filewrapperTemplateInExpressionAST::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionAST *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperTemplateInExpressionAST::actualTypeName (void) const {
  return "filewrapperTemplateInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperTemplateInExpressionAST ("filewrapperTemplateInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_filewrapperTemplateInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionAST GGS_filewrapperTemplateInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateInExpressionAST * p = dynamic_cast <const GGS_filewrapperTemplateInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'formalArgumentPassingModeAST' Enumeration            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalArgumentPassingModeAST ("formalArgumentPassingModeAST", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_formalArgumentPassingModeAST::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_isEqual (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_isNotEqual (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_infOrEqual (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_supOrEqual (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_strictInf (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_strictSup (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_formalArgumentMessage (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "a constant input (\?\?) formal argument",
    "an input (\?) formal argument",
    "an input/output (\?!) formal argument",
    "an output (!) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_formalArgumentString (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "'\?\?'",
    "'\?'",
    "'\?!'",
    "'!'"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_string (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "\?\?",
    "\?",
    "\?!",
    "!"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_correspondingEffectiveParameterString (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "!",
    "!",
    "!\?",
    "\?"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_generation1ForFormalParameter (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "const ",
    "",
    "",
    ""
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_generation2ForFormalParameter (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "",
    "",
    " &",
    " &"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @formalArgumentPassingModeAST" ;
  switch (mValue) {
  case enum_argumentConstantIn:
    s << " argumentConstantIn>" ;
    break ;
  case enum_argumentIn:
    s << " argumentIn>" ;
    break ;
  case enum_argumentInOut:
    s << " argumentInOut>" ;
    break ;
  case enum_argumentOut:
    s << " argumentOut>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalArgumentPassingModeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalArgumentPassingModeAST * p = NULL ;
    macroMyNew (p, GGS_formalArgumentPassingModeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalArgumentPassingModeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalArgumentPassingModeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalArgumentPassingModeAST * p = dynamic_cast <const GGS_formalArgumentPassingModeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalArgumentPassingModeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalArgumentPassingModeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalArgumentPassingModeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@formalParameterListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalParameterListAST::
elementOf_GGS_formalParameterListAST (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalArgumentPassingMode (argument_0),
mFormalArgumentTypeName (argument_1),
mFormalArgumentName (argument_2),
mIsUnused (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalParameterListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalParameterListAST * ptr = dynamic_cast <const elementOf_GGS_formalParameterListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalArgumentPassingMode.operator_isEqual (ptr->mFormalArgumentPassingMode).boolValue ()
         && mFormalArgumentTypeName.operator_isEqual (ptr->mFormalArgumentTypeName).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue ()
         && mIsUnused.operator_isEqual (ptr->mIsUnused).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalParameterListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentPassingMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@formalParameterListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalParameterListAST ("formalParameterListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
internalAppendValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
internalPrependValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
addAssign_operation (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST GGS_formalParameterListAST::
operator_concat (const GGS_formalParameterListAST & inOperand) const {
  GGS_formalParameterListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
dotAssign_operation (const GGS_formalParameterListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalParameterListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalArgumentPassingModeAST p_0 = p->mFormalArgumentPassingMode ;
          GGS_lstring  p_1 = p->mFormalArgumentTypeName ;
          GGS_lstring  p_2 = p->mFormalArgumentName ;
          GGS_bool p_3 = p->mIsUnused ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_formalArgumentPassingModeAST& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalArgumentPassingMode,
                                ptr->mFormalArgumentTypeName,
                                ptr->mFormalArgumentName,
                                ptr->mIsUnused
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_formalParameterListAST::
constructor_emptyList (void) {
  GGS_formalParameterListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_formalParameterListAST::
constructor_listWithValue (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  GGS_formalParameterListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
internalSubListWithRange (GGS_formalParameterListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalArgumentPassingMode, ptr->mFormalArgumentTypeName, ptr->mFormalArgumentName, ptr->mIsUnused) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST GGS_formalParameterListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST GGS_formalParameterListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalParameterListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
method_first (C_Compiler & inLexique,
              GGS_formalArgumentPassingModeAST& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
method_last (C_Compiler & inLexique,
             GGS_formalArgumentPassingModeAST& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_formalArgumentPassingModeAST& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_formalArgumentPassingModeAST& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentPassingMode ;
    _out_1 = ptr->mFormalArgumentTypeName ;
    _out_2 = ptr->mFormalArgumentName ;
    _out_3 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalParameterListAST::
reader_mFormalArgumentPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameterListAST::
reader_mFormalArgumentTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameterListAST::
reader_mFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalParameterListAST::
reader_mIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_setMFormalArgumentPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_setMFormalArgumentTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_setMFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_setMIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeAST & GGS_formalParameterListAST::cEnumerator::_mFormalArgumentPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalParameterListAST::cEnumerator::_mFormalArgumentTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalParameterListAST::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalParameterListAST::cEnumerator::_mIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsUnused ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalParameterListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalParameterListAST * p = NULL ;
    macroMyNew (p, GGS_formalParameterListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST GGS_formalParameterListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalParameterListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalParameterListAST * p = dynamic_cast <const GGS_formalParameterListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalParameterListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalParameterListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalParameterListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@formalInputParameterListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalInputParameterListAST::
elementOf_GGS_formalInputParameterListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalArgumentTypeName (argument_0),
mFormalArgumentName (argument_1),
mIsUnused (argument_2),
mIsConstant (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalInputParameterListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalInputParameterListAST * ptr = dynamic_cast <const elementOf_GGS_formalInputParameterListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalArgumentTypeName.operator_isEqual (ptr->mFormalArgumentTypeName).boolValue ()
         && mFormalArgumentName.operator_isEqual (ptr->mFormalArgumentName).boolValue ()
         && mIsUnused.operator_isEqual (ptr->mIsUnused).boolValue ()
         && mIsConstant.operator_isEqual (ptr->mIsConstant).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalInputParameterListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalArgumentName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsConstant.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@formalInputParameterListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalInputParameterListAST ("formalInputParameterListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST GGS_formalInputParameterListAST::
operator_concat (const GGS_formalInputParameterListAST & inOperand) const {
  GGS_formalInputParameterListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
dotAssign_operation (const GGS_formalInputParameterListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalInputParameterListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFormalArgumentTypeName ;
          GGS_lstring  p_1 = p->mFormalArgumentName ;
          GGS_bool p_2 = p->mIsUnused ;
          GGS_bool p_3 = p->mIsConstant ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_bool& argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalArgumentTypeName,
                                ptr->mFormalArgumentName,
                                ptr->mIsUnused,
                                ptr->mIsConstant
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_formalInputParameterListAST::
constructor_emptyList (void) {
  GGS_formalInputParameterListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_formalInputParameterListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_bool& argument_3) {
  GGS_formalInputParameterListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
internalSubListWithRange (GGS_formalInputParameterListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalArgumentTypeName, ptr->mFormalArgumentName, ptr->mIsUnused, ptr->mIsConstant) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST GGS_formalInputParameterListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST GGS_formalInputParameterListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalInputParameterListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalInputParameterListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_bool& _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mIsUnused ;
    _out_3 = ptr->mIsConstant ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_bool& _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mIsUnused ;
    _out_3 = ptr->mIsConstant ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_bool& _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mIsUnused ;
    _out_3 = ptr->mIsConstant ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_bool& _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalArgumentTypeName ;
    _out_1 = ptr->mFormalArgumentName ;
    _out_2 = ptr->mIsUnused ;
    _out_3 = ptr->mIsConstant ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalInputParameterListAST::
reader_mFormalArgumentTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalInputParameterListAST::
reader_mFormalArgumentNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalArgumentName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalInputParameterListAST::
reader_mIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalInputParameterListAST::
reader_mIsConstantAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsConstant ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_setMFormalArgumentTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_setMFormalArgumentNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalArgumentName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_setMIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_setMIsConstantAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsConstant = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalInputParameterListAST::cEnumerator::_mFormalArgumentTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalInputParameterListAST::cEnumerator::_mFormalArgumentName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalArgumentName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalInputParameterListAST::cEnumerator::_mIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsUnused ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalInputParameterListAST::cEnumerator::_mIsConstant (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsConstant ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalInputParameterListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalInputParameterListAST * p = NULL ;
    macroMyNew (p, GGS_formalInputParameterListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST GGS_formalInputParameterListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalInputParameterListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalInputParameterListAST * p = dynamic_cast <const GGS_formalInputParameterListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalInputParameterListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalInputParameterListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalInputParameterListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_actualParameterAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_actualParameterAST::
cPtr_actualParameterAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mQualifierLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_actualParameterAST * GGS_actualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_actualParameterAST) ;
    return (cPtr_actualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_actualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@actualParameterAST:"
           << mQualifierLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_actualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_actualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_actualParameterAST (& typeid (cPtr_actualParameterAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_actualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__actualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_actualParameterAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterAST ("actualParameterAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_actualParameterAST::
GGS_actualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterAST::
GGS_actualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_actualParameterAST GGS_actualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_actualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_actualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_actualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_actualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_actualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_actualParameterAST::
reader_mQualifierLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_actualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_actualParameterAST *) mPointer)->mQualifierLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_actualParameterAST::actualTypeName (void) const {
  return "actualParameterAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_actualParameterAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__actualParameterAST ("actualParameterAST", & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterAST * p = NULL ;
    macroMyNew (p, GGS_actualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterAST GGS_actualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterAST * p = dynamic_cast <const GGS_actualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_outputActualParameterAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputActualParameterAST::
cPtr_outputActualParameterAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterAST (argument_0 COMMA_THERE),
mOutputActualParameterExpression (argument_1),
mEndOfExpressionLocation (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputActualParameterAST * GGS_outputActualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputActualParameterAST) ;
    return (cPtr_outputActualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputActualParameterAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputActualParameterAST * ptr = dynamic_cast <const cPtr_outputActualParameterAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mQualifierLocation.operator_isEqual (ptr->mQualifierLocation).boolValue ()
         && mOutputActualParameterExpression.operator_isEqual (ptr->mOutputActualParameterExpression).boolValue ()
         && mEndOfExpressionLocation.operator_isEqual (ptr->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputActualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputActualParameterAST:"
           << mQualifierLocation.reader_description (inIndentation + 1)
           << mOutputActualParameterExpression.reader_description (inIndentation + 1)
           << mEndOfExpressionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputActualParameterAST (& typeid (cPtr_outputActualParameterAST), & typeid (cPtr_actualParameterAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputActualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__outputActualParameterAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputActualParameterAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputActualParameterAST (mQualifierLocation, mOutputActualParameterExpression, mEndOfExpressionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_outputActualParameterAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputActualParameterAST ("outputActualParameterAST", true, & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_outputActualParameterAST::
GGS_outputActualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterAST::
GGS_outputActualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputActualParameterAST GGS_outputActualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputActualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_outputActualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputActualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputActualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterAST GGS_outputActualParameterAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterAST result ;
  macroMyNew (result.mPointer, cPtr_outputActualParameterAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_outputActualParameterAST::
reader_mOutputActualParameterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputActualParameterAST *) mPointer)->mOutputActualParameterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_outputActualParameterAST::
reader_mEndOfExpressionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputActualParameterAST *) mPointer)->mEndOfExpressionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputActualParameterAST::actualTypeName (void) const {
  return "outputActualParameterAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputActualParameterAST ("outputActualParameterAST", gClassInfoFor__actualParameterAST, & kTypeDescriptor_GGS_outputActualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputActualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputActualParameterAST * p = NULL ;
    macroMyNew (p, GGS_outputActualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterAST GGS_outputActualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputActualParameterAST * p = dynamic_cast <const GGS_outputActualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputActualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputActualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_outputInputActualParameterAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputInputActualParameterAST::
cPtr_outputInputActualParameterAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterAST (argument_0 COMMA_THERE),
mOutputInputActualParameterName (argument_1),
mStructAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputInputActualParameterAST * GGS_outputInputActualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputInputActualParameterAST) ;
    return (cPtr_outputInputActualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputInputActualParameterAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputInputActualParameterAST * ptr = dynamic_cast <const cPtr_outputInputActualParameterAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mQualifierLocation.operator_isEqual (ptr->mQualifierLocation).boolValue ()
         && mOutputInputActualParameterName.operator_isEqual (ptr->mOutputInputActualParameterName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputInputActualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputInputActualParameterAST:"
           << mQualifierLocation.reader_description (inIndentation + 1)
           << mOutputInputActualParameterName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputInputActualParameterAST (& typeid (cPtr_outputInputActualParameterAST), & typeid (cPtr_actualParameterAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputInputActualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__outputInputActualParameterAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputInputActualParameterAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputInputActualParameterAST (mQualifierLocation, mOutputInputActualParameterName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_outputInputActualParameterAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputInputActualParameterAST ("outputInputActualParameterAST", true, & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterAST::
GGS_outputInputActualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterAST::
GGS_outputInputActualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputInputActualParameterAST GGS_outputInputActualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputInputActualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_outputInputActualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputInputActualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputInputActualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterAST GGS_outputInputActualParameterAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterAST result ;
  macroMyNew (result.mPointer, cPtr_outputInputActualParameterAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_outputInputActualParameterAST::
reader_mOutputInputActualParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterAST *) mPointer)->mOutputInputActualParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_outputInputActualParameterAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputInputActualParameterAST::actualTypeName (void) const {
  return "outputInputActualParameterAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputInputActualParameterAST ("outputInputActualParameterAST", gClassInfoFor__actualParameterAST, & kTypeDescriptor_GGS_outputInputActualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputInputActualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputInputActualParameterAST * p = NULL ;
    macroMyNew (p, GGS_outputInputActualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterAST GGS_outputInputActualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputInputActualParameterAST * p = dynamic_cast <const GGS_outputInputActualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputInputActualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputInputActualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputInputActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_inputActualParameterAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputActualParameterAST::
cPtr_inputActualParameterAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterAST (argument_0 COMMA_THERE),
mInputActualParameterName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputActualParameterAST * GGS_inputActualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputActualParameterAST) ;
    return (cPtr_inputActualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputActualParameterAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_inputActualParameterAST * ptr = dynamic_cast <const cPtr_inputActualParameterAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mQualifierLocation.operator_isEqual (ptr->mQualifierLocation).boolValue ()
         && mInputActualParameterName.operator_isEqual (ptr->mInputActualParameterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_inputActualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@inputActualParameterAST:"
           << mQualifierLocation.reader_description (inIndentation + 1)
           << mInputActualParameterName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputActualParameterAST (& typeid (cPtr_inputActualParameterAST), & typeid (cPtr_actualParameterAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputActualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__inputActualParameterAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_inputActualParameterAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_inputActualParameterAST (mQualifierLocation, mInputActualParameterName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_inputActualParameterAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputActualParameterAST ("inputActualParameterAST", true, & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_inputActualParameterAST::
GGS_inputActualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterAST::
GGS_inputActualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputActualParameterAST GGS_inputActualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputActualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_inputActualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputActualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputActualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterAST GGS_inputActualParameterAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterAST result ;
  macroMyNew (result.mPointer, cPtr_inputActualParameterAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_inputActualParameterAST::
reader_mInputActualParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputActualParameterAST *) mPointer)->mInputActualParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputActualParameterAST::actualTypeName (void) const {
  return "inputActualParameterAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputActualParameterAST ("inputActualParameterAST", gClassInfoFor__actualParameterAST, & kTypeDescriptor_GGS_inputActualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputActualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputActualParameterAST * p = NULL ;
    macroMyNew (p, GGS_inputActualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterAST GGS_inputActualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputActualParameterAST * p = dynamic_cast <const GGS_inputActualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputActualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputActualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_inputJokerActualParameterAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputJokerActualParameterAST::
cPtr_inputJokerActualParameterAST (const GGS_location & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterAST (argument_0 COMMA_THERE),
mJokerIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputJokerActualParameterAST * GGS_inputJokerActualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputJokerActualParameterAST) ;
    return (cPtr_inputJokerActualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputJokerActualParameterAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_inputJokerActualParameterAST * ptr = dynamic_cast <const cPtr_inputJokerActualParameterAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mQualifierLocation.operator_isEqual (ptr->mQualifierLocation).boolValue ()
         && mJokerIndex.operator_isEqual (ptr->mJokerIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_inputJokerActualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@inputJokerActualParameterAST:"
           << mQualifierLocation.reader_description (inIndentation + 1)
           << mJokerIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputJokerActualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputJokerActualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputJokerActualParameterAST (& typeid (cPtr_inputJokerActualParameterAST), & typeid (cPtr_actualParameterAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputJokerActualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__inputJokerActualParameterAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_inputJokerActualParameterAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_inputJokerActualParameterAST (mQualifierLocation, mJokerIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_inputJokerActualParameterAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputJokerActualParameterAST ("inputJokerActualParameterAST", true, & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterAST::
GGS_inputJokerActualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterAST::
GGS_inputJokerActualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputJokerActualParameterAST GGS_inputJokerActualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputJokerActualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_inputJokerActualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputJokerActualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputJokerActualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterAST GGS_inputJokerActualParameterAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterAST result ;
  macroMyNew (result.mPointer, cPtr_inputJokerActualParameterAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_inputJokerActualParameterAST::
reader_mJokerIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputJokerActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputJokerActualParameterAST *) mPointer)->mJokerIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputJokerActualParameterAST::actualTypeName (void) const {
  return "inputJokerActualParameterAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputJokerActualParameterAST ("inputJokerActualParameterAST", gClassInfoFor__actualParameterAST, & kTypeDescriptor_GGS_inputJokerActualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputJokerActualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputJokerActualParameterAST * p = NULL ;
    macroMyNew (p, GGS_inputJokerActualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterAST GGS_inputJokerActualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputJokerActualParameterAST * p = dynamic_cast <const GGS_inputJokerActualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputJokerActualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputJokerActualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputJokerActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@actualParameterListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualParameterListAST::
elementOf_GGS_actualParameterListAST (const GGS_actualParameterAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mActualParameter (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualParameterListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_actualParameterListAST * ptr = dynamic_cast <const elementOf_GGS_actualParameterListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualParameter.operator_isEqual (ptr->mActualParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualParameterListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameter.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@actualParameterListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterListAST ("actualParameterListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
internalAppendValues (const GGS_actualParameterAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
internalPrependValues (const GGS_actualParameterAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
addAssign_operation (const GGS_actualParameterAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST GGS_actualParameterListAST::
operator_concat (const GGS_actualParameterListAST & inOperand) const {
  GGS_actualParameterListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
dotAssign_operation (const GGS_actualParameterListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_actualParameterListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_actualParameterAST  p_0 = p->mActualParameter ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_actualParameterAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActualParameter
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_actualParameterListAST::
constructor_emptyList (void) {
  GGS_actualParameterListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_actualParameterListAST::
constructor_listWithValue (const GGS_actualParameterAST & argument_0) {
  GGS_actualParameterListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
internalSubListWithRange (GGS_actualParameterListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActualParameter) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST GGS_actualParameterListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST GGS_actualParameterListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParameterListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@actualParameterListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
method_first (C_Compiler & inLexique,
              GGS_actualParameterAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
method_last (C_Compiler & inLexique,
             GGS_actualParameterAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_actualParameterAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_actualParameterAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterAST  GGS_actualParameterListAST::
reader_mActualParameterAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_actualParameterAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
modifier_setMActualParameterAtIndex (C_Compiler & inLexique,
                              const GGS_actualParameterAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_actualParameterAST  & GGS_actualParameterListAST::cEnumerator::_mActualParameter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameter ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterListAST * p = NULL ;
    macroMyNew (p, GGS_actualParameterListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST GGS_actualParameterListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterListAST * p = dynamic_cast <const GGS_actualParameterListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@actualInputParameterListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualInputParameterListAST::
elementOf_GGS_actualInputParameterListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mActualParameterTypeName (argument_0),
mActualParameterName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualInputParameterListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_actualInputParameterListAST * ptr = dynamic_cast <const elementOf_GGS_actualInputParameterListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualParameterTypeName.operator_isEqual (ptr->mActualParameterTypeName).boolValue ()
         && mActualParameterName.operator_isEqual (ptr->mActualParameterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualInputParameterListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@actualInputParameterListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualInputParameterListAST ("actualInputParameterListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST GGS_actualInputParameterListAST::
operator_concat (const GGS_actualInputParameterListAST & inOperand) const {
  GGS_actualInputParameterListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
dotAssign_operation (const GGS_actualInputParameterListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_actualInputParameterListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mActualParameterTypeName ;
          GGS_lstring  p_1 = p->mActualParameterName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActualParameterTypeName,
                                ptr->mActualParameterName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST  GGS_actualInputParameterListAST::
constructor_emptyList (void) {
  GGS_actualInputParameterListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST  GGS_actualInputParameterListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_actualInputParameterListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
internalSubListWithRange (GGS_actualInputParameterListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActualParameterTypeName, ptr->mActualParameterName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST GGS_actualInputParameterListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_actualInputParameterListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST GGS_actualInputParameterListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_actualInputParameterListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualInputParameterListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@actualInputParameterListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_actualInputParameterListAST::
reader_mActualParameterTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameterTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_actualInputParameterListAST::
reader_mActualParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_setMActualParameterTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameterTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_setMActualParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_actualInputParameterListAST::cEnumerator::_mActualParameterTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameterTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_actualInputParameterListAST::cEnumerator::_mActualParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameterName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_actualInputParameterListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualInputParameterListAST * p = NULL ;
    macroMyNew (p, GGS_actualInputParameterListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST GGS_actualInputParameterListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualInputParameterListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualInputParameterListAST * p = dynamic_cast <const GGS_actualInputParameterListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualInputParameterListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualInputParameterListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualInputParameterListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_syntaxInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstructionAST::
cPtr_syntaxInstructionAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mInstructionLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstructionAST * GGS_syntaxInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_syntaxInstructionAST) ;
    return (cPtr_syntaxInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_syntaxInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@syntaxInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_syntaxInstructionAST (& typeid (cPtr_syntaxInstructionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_syntaxInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__syntaxInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_syntaxInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_syntaxInstructionAST ("syntaxInstructionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_syntaxInstructionAST::
GGS_syntaxInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionAST::
GGS_syntaxInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_syntaxInstructionAST GGS_syntaxInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_syntaxInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_syntaxInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_syntaxInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_syntaxInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstructionAST::actualTypeName (void) const {
  return "syntaxInstructionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_syntaxInstructionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__syntaxInstructionAST ("syntaxInstructionAST", & kTypeDescriptor_GGS_syntaxInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_syntaxInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_syntaxInstructionAST * p = NULL ;
    macroMyNew (p, GGS_syntaxInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionAST GGS_syntaxInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_syntaxInstructionAST * p = dynamic_cast <const GGS_syntaxInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_syntaxInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_syntaxInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_syntaxInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_semanticInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstructionAST::
cPtr_semanticInstructionAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstructionAST * GGS_semanticInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticInstructionAST) ;
    return (cPtr_semanticInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticInstructionAST (& typeid (cPtr_semanticInstructionAST), & typeid (cPtr_syntaxInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__semanticInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_semanticInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionAST ("semanticInstructionAST", true, & kTypeDescriptor_GGS_syntaxInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_semanticInstructionAST::
GGS_semanticInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionAST::
GGS_semanticInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticInstructionAST GGS_semanticInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_semanticInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstructionAST::actualTypeName (void) const {
  return "semanticInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__semanticInstructionAST ("semanticInstructionAST", gClassInfoFor__syntaxInstructionAST, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionAST * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionAST GGS_semanticInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionAST * p = dynamic_cast <const GGS_semanticInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@semanticInstructionListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticInstructionListAST::
elementOf_GGS_semanticInstructionListAST (const GGS_semanticInstructionAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticInstructionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticInstructionListAST * ptr = dynamic_cast <const elementOf_GGS_semanticInstructionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticInstructionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@semanticInstructionListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionListAST ("semanticInstructionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
internalAppendValues (const GGS_semanticInstructionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
internalPrependValues (const GGS_semanticInstructionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
addAssign_operation (const GGS_semanticInstructionAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST GGS_semanticInstructionListAST::
operator_concat (const GGS_semanticInstructionListAST & inOperand) const {
  GGS_semanticInstructionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
dotAssign_operation (const GGS_semanticInstructionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticInstructionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstructionAST  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstructionAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_semanticInstructionListAST::
constructor_emptyList (void) {
  GGS_semanticInstructionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_semanticInstructionListAST::
constructor_listWithValue (const GGS_semanticInstructionAST & argument_0) {
  GGS_semanticInstructionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
internalSubListWithRange (GGS_semanticInstructionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST GGS_semanticInstructionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST GGS_semanticInstructionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticInstructionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
method_first (C_Compiler & inLexique,
              GGS_semanticInstructionAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
method_last (C_Compiler & inLexique,
             GGS_semanticInstructionAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticInstructionAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticInstructionAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionAST  GGS_semanticInstructionListAST::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionAST  & GGS_semanticInstructionListAST::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionListAST * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST GGS_semanticInstructionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionListAST * p = dynamic_cast <const GGS_semanticInstructionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_semanticDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclarationAST::
cPtr_semanticDeclarationAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclarationAST * GGS_semanticDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticDeclarationAST) ;
    return (cPtr_semanticDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticDeclarationAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclarationAST (& typeid (cPtr_semanticDeclarationAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__semanticDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_semanticDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationAST ("semanticDeclarationAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationAST::
GGS_semanticDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationAST::
GGS_semanticDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticDeclarationAST GGS_semanticDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclarationAST::actualTypeName (void) const {
  return "semanticDeclarationAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticDeclarationAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticDeclarationAST ("semanticDeclarationAST", & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationAST GGS_semanticDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationAST * p = dynamic_cast <const GGS_semanticDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@semanticDeclarationListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationListAST::
elementOf_GGS_semanticDeclarationListAST (const GGS_semanticDeclarationAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSemanticDeclaration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_semanticDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@semanticDeclarationListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationListAST ("semanticDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
internalAppendValues (const GGS_semanticDeclarationAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
internalPrependValues (const GGS_semanticDeclarationAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
addAssign_operation (const GGS_semanticDeclarationAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST GGS_semanticDeclarationListAST::
operator_concat (const GGS_semanticDeclarationListAST & inOperand) const {
  GGS_semanticDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
dotAssign_operation (const GGS_semanticDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticDeclarationAST  p_0 = p->mSemanticDeclaration ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticDeclarationAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSemanticDeclaration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST  GGS_semanticDeclarationListAST::
constructor_emptyList (void) {
  GGS_semanticDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST  GGS_semanticDeclarationListAST::
constructor_listWithValue (const GGS_semanticDeclarationAST & argument_0) {
  GGS_semanticDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
internalSubListWithRange (GGS_semanticDeclarationListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST GGS_semanticDeclarationListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST GGS_semanticDeclarationListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
method_first (C_Compiler & inLexique,
              GGS_semanticDeclarationAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
method_last (C_Compiler & inLexique,
             GGS_semanticDeclarationAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticDeclarationAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticDeclarationAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationAST  GGS_semanticDeclarationListAST::
reader_mSemanticDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSemanticDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
modifier_setMSemanticDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_semanticDeclarationAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSemanticDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationAST  & GGS_semanticDeclarationListAST::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST GGS_semanticDeclarationListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationListAST * p = dynamic_cast <const GGS_semanticDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_externRoutineDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externRoutineDeclarationAST::
cPtr_externRoutineDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mRoutineName (argument_0),
mFormalArgumentList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externRoutineDeclarationAST * GGS_externRoutineDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_externRoutineDeclarationAST) ;
    return (cPtr_externRoutineDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externRoutineDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externRoutineDeclarationAST * ptr = dynamic_cast <const cPtr_externRoutineDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externRoutineDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@externRoutineDeclarationAST:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externRoutineDeclarationAST (& typeid (cPtr_externRoutineDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_externRoutineDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__externRoutineDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_externRoutineDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_externRoutineDeclarationAST (mRoutineName, mFormalArgumentList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_externRoutineDeclarationAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externRoutineDeclarationAST ("externRoutineDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationAST::
GGS_externRoutineDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationAST::
GGS_externRoutineDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_externRoutineDeclarationAST GGS_externRoutineDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externRoutineDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_externRoutineDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_externRoutineDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externRoutineDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationAST GGS_externRoutineDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_externRoutineDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineDeclarationAST::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclarationAST *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_externRoutineDeclarationAST::
reader_mFormalArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclarationAST *) mPointer)->mFormalArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externRoutineDeclarationAST::actualTypeName (void) const {
  return "externRoutineDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__externRoutineDeclarationAST ("externRoutineDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_externRoutineDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_externRoutineDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externRoutineDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_externRoutineDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationAST GGS_externRoutineDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externRoutineDeclarationAST * p = dynamic_cast <const GGS_externRoutineDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externRoutineDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externRoutineDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externRoutineDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_routineDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineDeclarationAST::
cPtr_routineDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2,
                                const GGS_location & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_externRoutineDeclarationAST (argument_0, argument_1 COMMA_THERE),
mRoutineInstructionList (argument_2),
mEndOfRoutineInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineDeclarationAST * GGS_routineDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineDeclarationAST) ;
    return (cPtr_routineDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineDeclarationAST * ptr = dynamic_cast <const cPtr_routineDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue ()
         && mEndOfRoutineInstructionList.operator_isEqual (ptr->mEndOfRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineDeclarationAST:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1)
           << mRoutineInstructionList.reader_description (inIndentation + 1)
           << mEndOfRoutineInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineDeclarationAST (& typeid (cPtr_routineDeclarationAST), & typeid (cPtr_externRoutineDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__routineDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineDeclarationAST (mRoutineName, mFormalArgumentList, mRoutineInstructionList, mEndOfRoutineInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_routineDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineDeclarationAST ("routineDeclarationAST", true, & kTypeDescriptor_GGS_externRoutineDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_routineDeclarationAST::
GGS_routineDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationAST::
GGS_routineDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineDeclarationAST GGS_routineDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_routineDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationAST GGS_routineDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListAST & argument_1,
                 const GGS_semanticInstructionListAST & argument_2,
                 const GGS_location & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_routineDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_routineDeclarationAST::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclarationAST *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_routineDeclarationAST::
reader_mEndOfRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclarationAST *) mPointer)->mEndOfRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineDeclarationAST::actualTypeName (void) const {
  return "routineDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineDeclarationAST ("routineDeclarationAST", gClassInfoFor__externRoutineDeclarationAST, & kTypeDescriptor_GGS_routineDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_routineDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationAST GGS_routineDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineDeclarationAST * p = dynamic_cast <const GGS_routineDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_externFunctionDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externFunctionDeclarationAST::
cPtr_externFunctionDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mFunctionName (argument_0),
mFormalArgumentList (argument_1),
mResultTypeName (argument_2),
mResultVariableName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externFunctionDeclarationAST * GGS_externFunctionDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_externFunctionDeclarationAST) ;
    return (cPtr_externFunctionDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externFunctionDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externFunctionDeclarationAST * ptr = dynamic_cast <const cPtr_externFunctionDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externFunctionDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@externFunctionDeclarationAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externFunctionDeclarationAST (& typeid (cPtr_externFunctionDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_externFunctionDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__externFunctionDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_externFunctionDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_externFunctionDeclarationAST (mFunctionName, mFormalArgumentList, mResultTypeName, mResultVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_externFunctionDeclarationAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externFunctionDeclarationAST ("externFunctionDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationAST::
GGS_externFunctionDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationAST::
GGS_externFunctionDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_externFunctionDeclarationAST GGS_externFunctionDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externFunctionDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_externFunctionDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_externFunctionDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externFunctionDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationAST GGS_externFunctionDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalInputParameterListAST & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_externFunctionDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationAST::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationAST *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_externFunctionDeclarationAST::
reader_mFormalArgumentList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationAST *) mPointer)->mFormalArgumentList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationAST::
reader_mResultTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationAST *) mPointer)->mResultTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationAST::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationAST *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externFunctionDeclarationAST::actualTypeName (void) const {
  return "externFunctionDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__externFunctionDeclarationAST ("externFunctionDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_externFunctionDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_externFunctionDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externFunctionDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_externFunctionDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationAST GGS_externFunctionDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externFunctionDeclarationAST * p = dynamic_cast <const GGS_externFunctionDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externFunctionDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externFunctionDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externFunctionDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_functionDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionDeclarationAST::
cPtr_functionDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4,
                                const GGS_location & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_externFunctionDeclarationAST (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
mFunctionInstructionList (argument_4),
mEndOfFunctionInstructionList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionDeclarationAST * GGS_functionDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionDeclarationAST) ;
    return (cPtr_functionDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionDeclarationAST * ptr = dynamic_cast <const cPtr_functionDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalArgumentList.operator_isEqual (ptr->mFormalArgumentList).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue ()
         && mEndOfFunctionInstructionList.operator_isEqual (ptr->mEndOfFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionDeclarationAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalArgumentList.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1)
           << mEndOfFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionDeclarationAST (& typeid (cPtr_functionDeclarationAST), & typeid (cPtr_externFunctionDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__functionDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionDeclarationAST (mFunctionName, mFormalArgumentList, mResultTypeName, mResultVariableName, mFunctionInstructionList, mEndOfFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_functionDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionDeclarationAST ("functionDeclarationAST", true, & kTypeDescriptor_GGS_externFunctionDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_functionDeclarationAST::
GGS_functionDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationAST::
GGS_functionDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionDeclarationAST GGS_functionDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_functionDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationAST GGS_functionDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalInputParameterListAST & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_semanticInstructionListAST & argument_4,
                 const GGS_location & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_functionDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_functionDeclarationAST::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationAST *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_functionDeclarationAST::
reader_mEndOfFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationAST *) mPointer)->mEndOfFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionDeclarationAST::actualTypeName (void) const {
  return "functionDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionDeclarationAST ("functionDeclarationAST", gClassInfoFor__externFunctionDeclarationAST, & kTypeDescriptor_GGS_functionDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_functionDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationAST GGS_functionDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionDeclarationAST * p = dynamic_cast <const GGS_functionDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lazyFunctionDeclarationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lazyFunctionDeclarationAST::
cPtr_lazyFunctionDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticInstructionListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mFunctionName (argument_0),
mResultTypeName (argument_1),
mResultVariableName (argument_2),
mFunctionInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lazyFunctionDeclarationAST * GGS_lazyFunctionDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lazyFunctionDeclarationAST) ;
    return (cPtr_lazyFunctionDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lazyFunctionDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lazyFunctionDeclarationAST * ptr = dynamic_cast <const cPtr_lazyFunctionDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lazyFunctionDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lazyFunctionDeclarationAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lazyFunctionDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lazyFunctionDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lazyFunctionDeclarationAST (& typeid (cPtr_lazyFunctionDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lazyFunctionDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__lazyFunctionDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lazyFunctionDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lazyFunctionDeclarationAST (mFunctionName, mResultTypeName, mResultVariableName, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lazyFunctionDeclarationAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lazyFunctionDeclarationAST ("lazyFunctionDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationAST::
GGS_lazyFunctionDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationAST::
GGS_lazyFunctionDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lazyFunctionDeclarationAST GGS_lazyFunctionDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_lazyFunctionDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lazyFunctionDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lazyFunctionDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationAST GGS_lazyFunctionDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticInstructionListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_lazyFunctionDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationAST::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationAST *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationAST::
reader_mResultTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationAST *) mPointer)->mResultTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationAST::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationAST *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_lazyFunctionDeclarationAST::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationAST *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lazyFunctionDeclarationAST::actualTypeName (void) const {
  return "lazyFunctionDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lazyFunctionDeclarationAST ("lazyFunctionDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_lazyFunctionDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lazyFunctionDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lazyFunctionDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_lazyFunctionDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationAST GGS_lazyFunctionDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lazyFunctionDeclarationAST * p = dynamic_cast <const GGS_lazyFunctionDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lazyFunctionDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lazyFunctionDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lazyFunctionDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_localVariableDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationAST::
cPtr_localVariableDeclarationAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationAST * GGS_localVariableDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationAST) ;
    return (cPtr_localVariableDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationAST * ptr = dynamic_cast <const cPtr_localVariableDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationAST (& typeid (cPtr_localVariableDeclarationAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationAST (mInstructionLocation, mTypeName, mVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_localVariableDeclarationAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationAST ("localVariableDeclarationAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationAST::
GGS_localVariableDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationAST::
GGS_localVariableDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationAST GGS_localVariableDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationAST GGS_localVariableDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationAST::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationAST *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationAST::actualTypeName (void) const {
  return "localVariableDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationAST ("localVariableDeclarationAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_localVariableDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationAST GGS_localVariableDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationAST * p = dynamic_cast <const GGS_localVariableDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  class 'cPtr_localVariableOrConstantDeclarationWithConstructorCallAST'    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableOrConstantDeclarationWithConstructorCallAST::
cPtr_localVariableOrConstantDeclarationWithConstructorCallAST (const GGS_location & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_semanticExpressionListAST & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mIsConstant (argument_1),
mTypeName (argument_2),
mVariableName (argument_3),
mConstructorName (argument_4),
mConstructorExpressions (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableOrConstantDeclarationWithConstructorCallAST * GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableOrConstantDeclarationWithConstructorCallAST) ;
    return (cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableOrConstantDeclarationWithConstructorCallAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableOrConstantDeclarationWithConstructorCallAST * ptr = dynamic_cast <const cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mIsConstant.operator_isEqual (ptr->mIsConstant).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorExpressions.operator_isEqual (ptr->mConstructorExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableOrConstantDeclarationWithConstructorCallAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableOrConstantDeclarationWithConstructorCallAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mIsConstant.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mConstructorExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithConstructorCallAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithConstructorCallAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableOrConstantDeclarationWithConstructorCallAST (& typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableOrConstantDeclarationWithConstructorCallAST::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableOrConstantDeclarationWithConstructorCallAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableOrConstantDeclarationWithConstructorCallAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableOrConstantDeclarationWithConstructorCallAST (mInstructionLocation, mIsConstant, mTypeName, mVariableName, mConstructorName, mConstructorExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//GALGAS class 'GGS_localVariableOrConstantDeclarationWithConstructorCallAST'*
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallAST ("localVariableOrConstantDeclarationWithConstructorCallAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
GGS_localVariableOrConstantDeclarationWithConstructorCallAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
GGS_localVariableOrConstantDeclarationWithConstructorCallAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableOrConstantDeclarationWithConstructorCallAST GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableOrConstantDeclarationWithConstructorCallAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableOrConstantDeclarationWithConstructorCallAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallAST GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_semanticExpressionListAST & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallAST result ;
  macroMyNew (result.mPointer, cPtr_localVariableOrConstantDeclarationWithConstructorCallAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
reader_mIsConstant (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *) mPointer)->mIsConstant ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_localVariableOrConstantDeclarationWithConstructorCallAST::
reader_mConstructorExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithConstructorCallAST *) mPointer)->mConstructorExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableOrConstantDeclarationWithConstructorCallAST::actualTypeName (void) const {
  return "localVariableOrConstantDeclarationWithConstructorCallAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableOrConstantDeclarationWithConstructorCallAST ("localVariableOrConstantDeclarationWithConstructorCallAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableOrConstantDeclarationWithConstructorCallAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableOrConstantDeclarationWithConstructorCallAST * p = NULL ;
    macroMyNew (p, GGS_localVariableOrConstantDeclarationWithConstructorCallAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithConstructorCallAST GGS_localVariableOrConstantDeclarationWithConstructorCallAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithConstructorCallAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableOrConstantDeclarationWithConstructorCallAST * p = dynamic_cast <const GGS_localVariableOrConstantDeclarationWithConstructorCallAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableOrConstantDeclarationWithConstructorCallAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithConstructorCallAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     class 'cPtr_localVariableOrConstantDeclarationWithAssignmentAST'      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableOrConstantDeclarationWithAssignmentAST::
cPtr_localVariableOrConstantDeclarationWithAssignmentAST (const GGS_location & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticExpressionAST & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mIsConstant (argument_1),
mTypeName (argument_2),
mVariableName (argument_3),
mSourceExpression (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableOrConstantDeclarationWithAssignmentAST * GGS_localVariableOrConstantDeclarationWithAssignmentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableOrConstantDeclarationWithAssignmentAST) ;
    return (cPtr_localVariableOrConstantDeclarationWithAssignmentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableOrConstantDeclarationWithAssignmentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableOrConstantDeclarationWithAssignmentAST * ptr = dynamic_cast <const cPtr_localVariableOrConstantDeclarationWithAssignmentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mIsConstant.operator_isEqual (ptr->mIsConstant).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableOrConstantDeclarationWithAssignmentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableOrConstantDeclarationWithAssignmentAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mIsConstant.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithAssignmentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableOrConstantDeclarationWithAssignmentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableOrConstantDeclarationWithAssignmentAST (& typeid (cPtr_localVariableOrConstantDeclarationWithAssignmentAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableOrConstantDeclarationWithAssignmentAST::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableOrConstantDeclarationWithAssignmentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableOrConstantDeclarationWithAssignmentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableOrConstantDeclarationWithAssignmentAST (mInstructionLocation, mIsConstant, mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//  GALGAS class 'GGS_localVariableOrConstantDeclarationWithAssignmentAST'   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithAssignmentAST ("localVariableOrConstantDeclarationWithAssignmentAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithAssignmentAST::
GGS_localVariableOrConstantDeclarationWithAssignmentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithAssignmentAST::
GGS_localVariableOrConstantDeclarationWithAssignmentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableOrConstantDeclarationWithAssignmentAST GGS_localVariableOrConstantDeclarationWithAssignmentAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithAssignmentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithAssignmentAST *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableOrConstantDeclarationWithAssignmentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableOrConstantDeclarationWithAssignmentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableOrConstantDeclarationWithAssignmentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithAssignmentAST GGS_localVariableOrConstantDeclarationWithAssignmentAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_semanticExpressionAST & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithAssignmentAST result ;
  macroMyNew (result.mPointer, cPtr_localVariableOrConstantDeclarationWithAssignmentAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableOrConstantDeclarationWithAssignmentAST::
reader_mIsConstant (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithAssignmentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithAssignmentAST *) mPointer)->mIsConstant ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableOrConstantDeclarationWithAssignmentAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithAssignmentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithAssignmentAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableOrConstantDeclarationWithAssignmentAST::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithAssignmentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithAssignmentAST *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_localVariableOrConstantDeclarationWithAssignmentAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableOrConstantDeclarationWithAssignmentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableOrConstantDeclarationWithAssignmentAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableOrConstantDeclarationWithAssignmentAST::actualTypeName (void) const {
  return "localVariableOrConstantDeclarationWithAssignmentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableOrConstantDeclarationWithAssignmentAST ("localVariableOrConstantDeclarationWithAssignmentAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithAssignmentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableOrConstantDeclarationWithAssignmentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableOrConstantDeclarationWithAssignmentAST * p = NULL ;
    macroMyNew (p, GGS_localVariableOrConstantDeclarationWithAssignmentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableOrConstantDeclarationWithAssignmentAST GGS_localVariableOrConstantDeclarationWithAssignmentAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableOrConstantDeclarationWithAssignmentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableOrConstantDeclarationWithAssignmentAST * p = dynamic_cast <const GGS_localVariableOrConstantDeclarationWithAssignmentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithAssignmentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableOrConstantDeclarationWithAssignmentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableOrConstantDeclarationWithAssignmentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_assignmentInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstructionAST::
cPtr_assignmentInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTargetVariableName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstructionAST * GGS_assignmentInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_assignmentInstructionAST) ;
    return (cPtr_assignmentInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_assignmentInstructionAST * ptr = dynamic_cast <const cPtr_assignmentInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetVariableName.operator_isEqual (ptr->mTargetVariableName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@assignmentInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mTargetVariableName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_assignmentInstructionAST (& typeid (cPtr_assignmentInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_assignmentInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__assignmentInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_assignmentInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_assignmentInstructionAST (mInstructionLocation, mTargetVariableName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_assignmentInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_assignmentInstructionAST ("assignmentInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_assignmentInstructionAST::
GGS_assignmentInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionAST::
GGS_assignmentInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_assignmentInstructionAST GGS_assignmentInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_assignmentInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_assignmentInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_assignmentInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_assignmentInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionAST GGS_assignmentInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_assignmentInstructionAST::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionAST *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_assignmentInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_assignmentInstructionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstructionAST::actualTypeName (void) const {
  return "assignmentInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__assignmentInstructionAST ("assignmentInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_assignmentInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_assignmentInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_assignmentInstructionAST * p = NULL ;
    macroMyNew (p, GGS_assignmentInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionAST GGS_assignmentInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_assignmentInstructionAST * p = dynamic_cast <const GGS_assignmentInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_assignmentInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_assignmentInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_assignmentInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_appendInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstructionAST::
cPtr_appendInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTargetVariableName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstructionAST * GGS_appendInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_appendInstructionAST) ;
    return (cPtr_appendInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_appendInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_appendInstructionAST * ptr = dynamic_cast <const cPtr_appendInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTargetVariableName.operator_isEqual (ptr->mTargetVariableName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@appendInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mTargetVariableName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_appendInstructionAST (& typeid (cPtr_appendInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_appendInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__appendInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_appendInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_appendInstructionAST (mInstructionLocation, mTargetVariableName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_appendInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_appendInstructionAST ("appendInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_appendInstructionAST::
GGS_appendInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionAST::
GGS_appendInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_appendInstructionAST GGS_appendInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_appendInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_appendInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_appendInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_appendInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_appendInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionAST GGS_appendInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_appendInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_appendInstructionAST::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionAST *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_appendInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_appendInstructionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstructionAST::actualTypeName (void) const {
  return "appendInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__appendInstructionAST ("appendInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_appendInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_appendInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_appendInstructionAST * p = NULL ;
    macroMyNew (p, GGS_appendInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionAST GGS_appendInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_appendInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_appendInstructionAST * p = dynamic_cast <const GGS_appendInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_appendInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_appendInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_appendInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_sendInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sendInstructionAST::
cPtr_sendInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sendInstructionAST * GGS_sendInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sendInstructionAST) ;
    return (cPtr_sendInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sendInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sendInstructionAST * ptr = dynamic_cast <const cPtr_sendInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sendInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sendInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sendInstructionAST (& typeid (cPtr_sendInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sendInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__sendInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sendInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sendInstructionAST (mInstructionLocation, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_sendInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sendInstructionAST ("sendInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_sendInstructionAST::
GGS_sendInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionAST::
GGS_sendInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sendInstructionAST GGS_sendInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sendInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sendInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_sendInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sendInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sendInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionAST GGS_sendInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sendInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_sendInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_sendInstructionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sendInstructionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sendInstructionAST::actualTypeName (void) const {
  return "sendInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sendInstructionAST ("sendInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_sendInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sendInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sendInstructionAST * p = NULL ;
    macroMyNew (p, GGS_sendInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionAST GGS_sendInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sendInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sendInstructionAST * p = dynamic_cast <const GGS_sendInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sendInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sendInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sendInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Element of list '@foreachInstructionEnumeratedObjectElementListAST'     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST::
elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mTypeName (argument_0),
mConstantName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstantName.operator_isEqual (ptr->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         List '@foreachInstructionEnumeratedObjectElementListAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListAST ("foreachInstructionEnumeratedObjectElementListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST GGS_foreachInstructionEnumeratedObjectElementListAST::
operator_concat (const GGS_foreachInstructionEnumeratedObjectElementListAST & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectElementListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mTypeName ;
          GGS_lstring  p_1 = p->mConstantName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mTypeName,
                                ptr->mConstantName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST  GGS_foreachInstructionEnumeratedObjectElementListAST::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST  GGS_foreachInstructionEnumeratedObjectElementListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectElementListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mTypeName, ptr->mConstantName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachInstructionEnumeratedObjectElementListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mConstantName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mConstantName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mConstantName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mTypeName ;
    _out_1 = ptr->mConstantName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_mConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_setMConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_foreachInstructionEnumeratedObjectElementListAST::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_foreachInstructionEnumeratedObjectElementListAST::cEnumerator::_mConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectElementListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectElementListAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectElementListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST GGS_foreachInstructionEnumeratedObjectElementListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectElementListAST * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectElementListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectElementListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@foreachInstructionEnumeratedObjectListAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectListAST::
elementOf_GGS_foreachInstructionEnumeratedObjectListAST (const GGS_bool& argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_location & argument_2,
                                const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_3,
                                const GGS_location & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_lstring & argument_6
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsAscending (argument_0),
mEnumeratedExpression (argument_1),
mEndOfEnumerationExpression (argument_2),
mElementList (argument_3),
mEndOfElementList (argument_4),
mEndsWithEllipsis (argument_5),
mPrefix (argument_6) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectListAST * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mEnumeratedExpression.operator_isEqual (ptr->mEnumeratedExpression).boolValue ()
         && mEndOfEnumerationExpression.operator_isEqual (ptr->mEndOfEnumerationExpression).boolValue ()
         && mElementList.operator_isEqual (ptr->mElementList).boolValue ()
         && mEndOfElementList.operator_isEqual (ptr->mEndOfElementList).boolValue ()
         && mEndsWithEllipsis.operator_isEqual (ptr->mEndsWithEllipsis).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAscending.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfEnumerationExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElementList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfElementList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndsWithEllipsis.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPrefix.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@foreachInstructionEnumeratedObjectListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListAST ("foreachInstructionEnumeratedObjectListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionAST & argument_1,
                    const GGS_location & argument_2,
                    const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_3,
                    const GGS_location & argument_4,
                    const GGS_bool& argument_5,
                    const GGS_lstring & argument_6
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionAST & argument_1,
                    const GGS_location & argument_2,
                    const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_3,
                    const GGS_location & argument_4,
                    const GGS_bool& argument_5,
                    const GGS_lstring & argument_6
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_location & argument_2,
                                const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_3,
                                const GGS_location & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_lstring & argument_6) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()&& argument_5.isBuilt ()&& argument_6.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST GGS_foreachInstructionEnumeratedObjectListAST::
operator_concat (const GGS_foreachInstructionEnumeratedObjectListAST & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsAscending ;
          GGS_semanticExpressionAST  p_1 = p->mEnumeratedExpression ;
          GGS_location  p_2 = p->mEndOfEnumerationExpression ;
          GGS_foreachInstructionEnumeratedObjectElementListAST  p_3 = p->mElementList ;
          GGS_location  p_4 = p->mEndOfElementList ;
          GGS_bool p_5 = p->mEndsWithEllipsis ;
          GGS_lstring  p_6 = p->mPrefix ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5, p_6 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_semanticExpressionAST & argument_1,
                     const GGS_location & argument_2,
                     const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_3,
                     const GGS_location & argument_4,
                     const GGS_bool& argument_5,
                     const GGS_lstring & argument_6
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsAscending,
                                ptr->mEnumeratedExpression,
                                ptr->mEndOfEnumerationExpression,
                                ptr->mElementList,
                                ptr->mEndOfElementList,
                                ptr->mEndsWithEllipsis,
                                ptr->mPrefix
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST  GGS_foreachInstructionEnumeratedObjectListAST::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST  GGS_foreachInstructionEnumeratedObjectListAST::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_location & argument_2,
                                const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_3,
                                const GGS_location & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_lstring & argument_6) {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5, argument_6) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsAscending, ptr->mEnumeratedExpression, ptr->mEndOfEnumerationExpression, ptr->mElementList, ptr->mEndOfElementList, ptr->mEndsWithEllipsis, ptr->mPrefix) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST GGS_foreachInstructionEnumeratedObjectListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST GGS_foreachInstructionEnumeratedObjectListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachInstructionEnumeratedObjectListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_semanticExpressionAST & _out_1,
              GGS_location & _out_2,
              GGS_foreachInstructionEnumeratedObjectElementListAST & _out_3,
              GGS_location & _out_4,
              GGS_bool& _out_5,
              GGS_lstring & _out_6
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEndOfEnumerationExpression ;
    _out_3 = ptr->mElementList ;
    _out_4 = ptr->mEndOfElementList ;
    _out_5 = ptr->mEndsWithEllipsis ;
    _out_6 = ptr->mPrefix ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_semanticExpressionAST & _out_1,
             GGS_location & _out_2,
             GGS_foreachInstructionEnumeratedObjectElementListAST & _out_3,
             GGS_location & _out_4,
             GGS_bool& _out_5,
             GGS_lstring & _out_6
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEndOfEnumerationExpression ;
    _out_3 = ptr->mElementList ;
    _out_4 = ptr->mEndOfElementList ;
    _out_5 = ptr->mEndsWithEllipsis ;
    _out_6 = ptr->mPrefix ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_semanticExpressionAST & _out_1,
                 GGS_location & _out_2,
                 GGS_foreachInstructionEnumeratedObjectElementListAST & _out_3,
                 GGS_location & _out_4,
                 GGS_bool& _out_5,
                 GGS_lstring & _out_6
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEndOfEnumerationExpression ;
    _out_3 = ptr->mElementList ;
    _out_4 = ptr->mEndOfElementList ;
    _out_5 = ptr->mEndsWithEllipsis ;
    _out_6 = ptr->mPrefix ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_semanticExpressionAST & _out_1,
                GGS_location & _out_2,
                GGS_foreachInstructionEnumeratedObjectElementListAST & _out_3,
                GGS_location & _out_4,
                GGS_bool& _out_5,
                GGS_lstring & _out_6
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mEndOfEnumerationExpression ;
    _out_3 = ptr->mElementList ;
    _out_4 = ptr->mEndOfElementList ;
    _out_5 = ptr->mEndsWithEllipsis ;
    _out_6 = ptr->mPrefix ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
    _out_6.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectListAST::
reader_mIsAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_foreachInstructionEnumeratedObjectListAST::
reader_mEnumeratedExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionEnumeratedObjectListAST::
reader_mEndOfEnumerationExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfEnumerationExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST  GGS_foreachInstructionEnumeratedObjectListAST::
reader_mElementListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElementList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionEnumeratedObjectListAST::
reader_mEndOfElementListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfElementList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectListAST::
reader_mEndsWithEllipsisAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndsWithEllipsis ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedObjectListAST::
reader_mPrefixAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mPrefix ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMIsAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMEnumeratedExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMEndOfEnumerationExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfEnumerationExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMElementListAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElementListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElementList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMEndOfElementListAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfElementList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMEndsWithEllipsisAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndsWithEllipsis = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMPrefixAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mPrefix = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mIsAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsAscending ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionAST  & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mEnumeratedExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mEndOfEnumerationExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfEnumerationExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElementListAST  & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mElementList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mElementList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mEndOfElementList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfElementList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mEndsWithEllipsis (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndsWithEllipsis ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mPrefix (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mPrefix ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectListAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST GGS_foreachInstructionEnumeratedObjectListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectListAST * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_foreachInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionAST::
cPtr_foreachInstructionAST (const GGS_location & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionAST & argument_3,
                                const GGS_semanticInstructionListAST & argument_4,
                                const GGS_location & argument_5,
                                const GGS_semanticInstructionListAST & argument_6,
                                const GGS_location & argument_7,
                                const GGS_semanticInstructionListAST & argument_8,
                                const GGS_location & argument_9,
                                const GGS_semanticInstructionListAST & argument_10,
                                const GGS_location & argument_11,
                                const GGS_location & argument_12
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mEnumeratedObjectList (argument_1),
mIndexVariableName (argument_2),
mWhileExpression (argument_3),
mBeforeInstructionList (argument_4),
mEndOf_before_branch (argument_5),
mBetweenInstructionList (argument_6),
mEndOf_between_branch (argument_7),
mDoInstructionList (argument_8),
mEndOf_do_branch (argument_9),
mAfterInstructionList (argument_10),
mEndOf_after_branch (argument_11),
mEndOf_foreach_instruction (argument_12) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionAST * GGS_foreachInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionAST) ;
    return (cPtr_foreachInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionAST * ptr = dynamic_cast <const cPtr_foreachInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mEnumeratedObjectList.operator_isEqual (ptr->mEnumeratedObjectList).boolValue ()
         && mIndexVariableName.operator_isEqual (ptr->mIndexVariableName).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mEndOf_before_branch.operator_isEqual (ptr->mEndOf_before_branch).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mEndOf_between_branch.operator_isEqual (ptr->mEndOf_between_branch).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mEndOf_do_branch.operator_isEqual (ptr->mEndOf_do_branch).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue ()
         && mEndOf_after_branch.operator_isEqual (ptr->mEndOf_after_branch).boolValue ()
         && mEndOf_foreach_instruction.operator_isEqual (ptr->mEndOf_foreach_instruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@foreachInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mEnumeratedObjectList.reader_description (inIndentation + 1)
           << mIndexVariableName.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mEndOf_before_branch.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mEndOf_between_branch.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mEndOf_do_branch.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1)
           << mEndOf_after_branch.reader_description (inIndentation + 1)
           << mEndOf_foreach_instruction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionAST (& typeid (cPtr_foreachInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstructionAST (mInstructionLocation, mEnumeratedObjectList, mIndexVariableName, mWhileExpression, mBeforeInstructionList, mEndOf_before_branch, mBetweenInstructionList, mEndOf_between_branch, mDoInstructionList, mEndOf_do_branch, mAfterInstructionList, mEndOf_after_branch, mEndOf_foreach_instruction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_foreachInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionAST ("foreachInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionAST::
GGS_foreachInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionAST::
GGS_foreachInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionAST GGS_foreachInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionAST GGS_foreachInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectListAST & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionAST & argument_3,
                 const GGS_semanticInstructionListAST & argument_4,
                 const GGS_location & argument_5,
                 const GGS_semanticInstructionListAST & argument_6,
                 const GGS_location & argument_7,
                 const GGS_semanticInstructionListAST & argument_8,
                 const GGS_location & argument_9,
                 const GGS_semanticInstructionListAST & argument_10,
                 const GGS_location & argument_11,
                 const GGS_location & argument_12
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9,
                                argument_10,
                                argument_11,
                                argument_12 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST  GGS_foreachInstructionAST::
reader_mEnumeratedObjectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mEnumeratedObjectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionAST::
reader_mIndexVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mIndexVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_foreachInstructionAST::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_foreachInstructionAST::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionAST::
reader_mEndOf_before_branch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mEndOf_before_branch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_foreachInstructionAST::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionAST::
reader_mEndOf_between_branch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mEndOf_between_branch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_foreachInstructionAST::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionAST::
reader_mEndOf_do_branch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mEndOf_do_branch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_foreachInstructionAST::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionAST::
reader_mEndOf_after_branch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mEndOf_after_branch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_foreachInstructionAST::
reader_mEndOf_foreach_instruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mEndOf_foreach_instruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionAST::actualTypeName (void) const {
  return "foreachInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionAST ("foreachInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_foreachInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionAST GGS_foreachInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionAST * p = dynamic_cast <const GGS_foreachInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_ifInstructionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstructionAST::
cPtr_ifInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2,
                                const GGS_location & argument_3,
                                const GGS_semanticInstructionListAST & argument_4,
                                const GGS_location & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
m_if_expression (argument_1),
m_then_instructionList (argument_2),
mEndOf_then_branch (argument_3),
m_else_instructionList (argument_4),
mEndOf_if_instruction (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstructionAST * GGS_ifInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifInstructionAST) ;
    return (cPtr_ifInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifInstructionAST * ptr = dynamic_cast <const cPtr_ifInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && m_if_expression.operator_isEqual (ptr->m_if_expression).boolValue ()
         && m_then_instructionList.operator_isEqual (ptr->m_then_instructionList).boolValue ()
         && mEndOf_then_branch.operator_isEqual (ptr->mEndOf_then_branch).boolValue ()
         && m_else_instructionList.operator_isEqual (ptr->m_else_instructionList).boolValue ()
         && mEndOf_if_instruction.operator_isEqual (ptr->mEndOf_if_instruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << m_if_expression.reader_description (inIndentation + 1)
           << m_then_instructionList.reader_description (inIndentation + 1)
           << mEndOf_then_branch.reader_description (inIndentation + 1)
           << m_else_instructionList.reader_description (inIndentation + 1)
           << mEndOf_if_instruction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifInstructionAST (& typeid (cPtr_ifInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__ifInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifInstructionAST (mInstructionLocation, m_if_expression, m_then_instructionList, mEndOf_then_branch, m_else_instructionList, mEndOf_if_instruction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ifInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifInstructionAST ("ifInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_ifInstructionAST::
GGS_ifInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionAST::
GGS_ifInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifInstructionAST GGS_ifInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_ifInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionAST GGS_ifInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticInstructionListAST & argument_2,
                 const GGS_location & argument_3,
                 const GGS_semanticInstructionListAST & argument_4,
                 const GGS_location & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_ifInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_ifInstructionAST::
reader_m_if_expression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionAST *) mPointer)->m_if_expression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_ifInstructionAST::
reader_m_then_instructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionAST *) mPointer)->m_then_instructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_ifInstructionAST::
reader_mEndOf_then_branch (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionAST *) mPointer)->mEndOf_then_branch ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_ifInstructionAST::
reader_m_else_instructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionAST *) mPointer)->m_else_instructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_ifInstructionAST::
reader_mEndOf_if_instruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionAST *) mPointer)->mEndOf_if_instruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstructionAST::actualTypeName (void) const {
  return "ifInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifInstructionAST ("ifInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_ifInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifInstructionAST * p = NULL ;
    macroMyNew (p, GGS_ifInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionAST GGS_ifInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifInstructionAST * p = dynamic_cast <const GGS_ifInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_methodCallInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstructionAST::
cPtr_methodCallInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstructionAST * GGS_methodCallInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_methodCallInstructionAST) ;
    return (cPtr_methodCallInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_methodCallInstructionAST * ptr = dynamic_cast <const cPtr_methodCallInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@methodCallInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_methodCallInstructionAST (& typeid (cPtr_methodCallInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_methodCallInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__methodCallInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_methodCallInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_methodCallInstructionAST (mInstructionLocation, mReceiverExpression, mMethodName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_methodCallInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodCallInstructionAST ("methodCallInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_methodCallInstructionAST::
GGS_methodCallInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionAST::
GGS_methodCallInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_methodCallInstructionAST GGS_methodCallInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_methodCallInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_methodCallInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_methodCallInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_methodCallInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionAST GGS_methodCallInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_methodCallInstructionAST::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionAST *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodCallInstructionAST::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionAST *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_methodCallInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstructionAST::actualTypeName (void) const {
  return "methodCallInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__methodCallInstructionAST ("methodCallInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_methodCallInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_methodCallInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodCallInstructionAST * p = NULL ;
    macroMyNew (p, GGS_methodCallInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionAST GGS_methodCallInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodCallInstructionAST * p = dynamic_cast <const GGS_methodCallInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodCallInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodCallInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodCallInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_modifierCallInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstructionAST::
cPtr_modifierCallInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_actualParameterListAST & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mReceiverStructAttributes (argument_2),
mModifierName (argument_3),
mActualParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstructionAST * GGS_modifierCallInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_modifierCallInstructionAST) ;
    return (cPtr_modifierCallInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_modifierCallInstructionAST * ptr = dynamic_cast <const cPtr_modifierCallInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mReceiverStructAttributes.operator_isEqual (ptr->mReceiverStructAttributes).boolValue ()
         && mModifierName.operator_isEqual (ptr->mModifierName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@modifierCallInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mReceiverStructAttributes.reader_description (inIndentation + 1)
           << mModifierName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_modifierCallInstructionAST (& typeid (cPtr_modifierCallInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_modifierCallInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__modifierCallInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_modifierCallInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_modifierCallInstructionAST (mInstructionLocation, mReceiverName, mReceiverStructAttributes, mModifierName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_modifierCallInstructionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_modifierCallInstructionAST ("modifierCallInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionAST::
GGS_modifierCallInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionAST::
GGS_modifierCallInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_modifierCallInstructionAST GGS_modifierCallInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_modifierCallInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_modifierCallInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_modifierCallInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_modifierCallInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionAST GGS_modifierCallInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_actualParameterListAST & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_modifierCallInstructionAST::
reader_mReceiverStructAttributes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionAST *) mPointer)->mReceiverStructAttributes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstructionAST::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionAST *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_modifierCallInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstructionAST::actualTypeName (void) const {
  return "modifierCallInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__modifierCallInstructionAST ("modifierCallInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_modifierCallInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_modifierCallInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_modifierCallInstructionAST * p = NULL ;
    macroMyNew (p, GGS_modifierCallInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionAST GGS_modifierCallInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_modifierCallInstructionAST * p = dynamic_cast <const GGS_modifierCallInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_modifierCallInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_modifierCallInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_modifierCallInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_errorInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstructionAST::
cPtr_errorInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2,
                                const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mLocationExpression (argument_1),
mMessageExpression (argument_2),
mBuiltVariableList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstructionAST * GGS_errorInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_errorInstructionAST) ;
    return (cPtr_errorInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_errorInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_errorInstructionAST * ptr = dynamic_cast <const cPtr_errorInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mLocationExpression.operator_isEqual (ptr->mLocationExpression).boolValue ()
         && mMessageExpression.operator_isEqual (ptr->mMessageExpression).boolValue ()
         && mBuiltVariableList.operator_isEqual (ptr->mBuiltVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@errorInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mLocationExpression.reader_description (inIndentation + 1)
           << mMessageExpression.reader_description (inIndentation + 1)
           << mBuiltVariableList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_errorInstructionAST (& typeid (cPtr_errorInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_errorInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__errorInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_errorInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_errorInstructionAST (mInstructionLocation, mLocationExpression, mMessageExpression, mBuiltVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_errorInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_errorInstructionAST ("errorInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_errorInstructionAST::
GGS_errorInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionAST::
GGS_errorInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_errorInstructionAST GGS_errorInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_errorInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_errorInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_errorInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_errorInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_errorInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionAST GGS_errorInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2,
                 const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_errorInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_errorInstructionAST::
reader_mLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionAST *) mPointer)->mLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_errorInstructionAST::
reader_mMessageExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionAST *) mPointer)->mMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_errorInstructionAST::
reader_mBuiltVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionAST *) mPointer)->mBuiltVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstructionAST::actualTypeName (void) const {
  return "errorInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__errorInstructionAST ("errorInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_errorInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_errorInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_errorInstructionAST * p = NULL ;
    macroMyNew (p, GGS_errorInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionAST GGS_errorInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_errorInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_errorInstructionAST * p = dynamic_cast <const GGS_errorInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_errorInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_errorInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_errorInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_warningInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstructionAST::
cPtr_warningInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mLocationExpression (argument_1),
mMessageExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstructionAST * GGS_warningInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_warningInstructionAST) ;
    return (cPtr_warningInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_warningInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_warningInstructionAST * ptr = dynamic_cast <const cPtr_warningInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mLocationExpression.operator_isEqual (ptr->mLocationExpression).boolValue ()
         && mMessageExpression.operator_isEqual (ptr->mMessageExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@warningInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mLocationExpression.reader_description (inIndentation + 1)
           << mMessageExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_warningInstructionAST (& typeid (cPtr_warningInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_warningInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__warningInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_warningInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_warningInstructionAST (mInstructionLocation, mLocationExpression, mMessageExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_warningInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_warningInstructionAST ("warningInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_warningInstructionAST::
GGS_warningInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionAST::
GGS_warningInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_warningInstructionAST GGS_warningInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_warningInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_warningInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_warningInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_warningInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_warningInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionAST GGS_warningInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_warningInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_warningInstructionAST::
reader_mLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionAST *) mPointer)->mLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_warningInstructionAST::
reader_mMessageExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionAST *) mPointer)->mMessageExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstructionAST::actualTypeName (void) const {
  return "warningInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__warningInstructionAST ("warningInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_warningInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_warningInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_warningInstructionAST * p = NULL ;
    macroMyNew (p, GGS_warningInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionAST GGS_warningInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_warningInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_warningInstructionAST * p = dynamic_cast <const GGS_warningInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_warningInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_warningInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_warningInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_routineCallInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstructionAST::
cPtr_routineCallInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mRoutineName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstructionAST * GGS_routineCallInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineCallInstructionAST) ;
    return (cPtr_routineCallInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineCallInstructionAST * ptr = dynamic_cast <const cPtr_routineCallInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineCallInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mRoutineName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineCallInstructionAST (& typeid (cPtr_routineCallInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineCallInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__routineCallInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineCallInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineCallInstructionAST (mInstructionLocation, mRoutineName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_routineCallInstructionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineCallInstructionAST ("routineCallInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_routineCallInstructionAST::
GGS_routineCallInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionAST::
GGS_routineCallInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineCallInstructionAST GGS_routineCallInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineCallInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_routineCallInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineCallInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineCallInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionAST GGS_routineCallInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstructionAST::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionAST *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_routineCallInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstructionAST::actualTypeName (void) const {
  return "routineCallInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineCallInstructionAST ("routineCallInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_routineCallInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineCallInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineCallInstructionAST * p = NULL ;
    macroMyNew (p, GGS_routineCallInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionAST GGS_routineCallInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineCallInstructionAST * p = dynamic_cast <const GGS_routineCallInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineCallInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineCallInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineCallInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@matchEntryListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchEntryListAST::
elementOf_GGS_matchEntryListAST (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsType (argument_0),
mTypeNameOrEnumerationConstantName (argument_1),
mLocalConstantName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchEntryListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchEntryListAST * ptr = dynamic_cast <const elementOf_GGS_matchEntryListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsType.operator_isEqual (ptr->mIsType).boolValue ()
         && mTypeNameOrEnumerationConstantName.operator_isEqual (ptr->mTypeNameOrEnumerationConstantName).boolValue ()
         && mLocalConstantName.operator_isEqual (ptr->mLocalConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchEntryListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsType.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeNameOrEnumerationConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocalConstantName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@matchEntryListAST'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchEntryListAST ("matchEntryListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST GGS_matchEntryListAST::
operator_concat (const GGS_matchEntryListAST & inOperand) const {
  GGS_matchEntryListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
dotAssign_operation (const GGS_matchEntryListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_matchEntryListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsType ;
          GGS_lstring  p_1 = p->mTypeNameOrEnumerationConstantName ;
          GGS_lstring  p_2 = p->mLocalConstantName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsType,
                                ptr->mTypeNameOrEnumerationConstantName,
                                ptr->mLocalConstantName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST  GGS_matchEntryListAST::
constructor_emptyList (void) {
  GGS_matchEntryListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST  GGS_matchEntryListAST::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_matchEntryListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
internalSubListWithRange (GGS_matchEntryListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsType, ptr->mTypeNameOrEnumerationConstantName, ptr->mLocalConstantName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST GGS_matchEntryListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST GGS_matchEntryListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchEntryListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@matchEntryListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsType ;
    _out_1 = ptr->mTypeNameOrEnumerationConstantName ;
    _out_2 = ptr->mLocalConstantName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsType ;
    _out_1 = ptr->mTypeNameOrEnumerationConstantName ;
    _out_2 = ptr->mLocalConstantName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsType ;
    _out_1 = ptr->mTypeNameOrEnumerationConstantName ;
    _out_2 = ptr->mLocalConstantName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsType ;
    _out_1 = ptr->mTypeNameOrEnumerationConstantName ;
    _out_2 = ptr->mLocalConstantName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_matchEntryListAST::
reader_mIsTypeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsType ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_matchEntryListAST::
reader_mTypeNameOrEnumerationConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeNameOrEnumerationConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_matchEntryListAST::
reader_mLocalConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocalConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_setMIsTypeAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsType = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_setMTypeNameOrEnumerationConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeNameOrEnumerationConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_setMLocalConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocalConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_matchEntryListAST::cEnumerator::_mIsType (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsType ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_matchEntryListAST::cEnumerator::_mTypeNameOrEnumerationConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeNameOrEnumerationConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_matchEntryListAST::cEnumerator::_mLocalConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocalConstantName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_matchEntryListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchEntryListAST * p = NULL ;
    macroMyNew (p, GGS_matchEntryListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST GGS_matchEntryListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchEntryListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchEntryListAST * p = dynamic_cast <const GGS_matchEntryListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchEntryListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchEntryListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchEntryListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@matchInstructionBranchListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchInstructionBranchListAST::
elementOf_GGS_matchInstructionBranchListAST (const GGS_matchEntryListAST & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticInstructionListAST & argument_2,
                                const GGS_location & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMatchEntryList (argument_0),
mEndOfMatchEntryList (argument_1),
mMatchBranchInstructionList (argument_2),
mEndOf_instructionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchInstructionBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchInstructionBranchListAST * ptr = dynamic_cast <const elementOf_GGS_matchInstructionBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMatchEntryList.operator_isEqual (ptr->mMatchEntryList).boolValue ()
         && mEndOfMatchEntryList.operator_isEqual (ptr->mEndOfMatchEntryList).boolValue ()
         && mMatchBranchInstructionList.operator_isEqual (ptr->mMatchBranchInstructionList).boolValue ()
         && mEndOf_instructionList.operator_isEqual (ptr->mEndOf_instructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchInstructionBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchEntryList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfMatchEntryList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchBranchInstructionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOf_instructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@matchInstructionBranchListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchInstructionBranchListAST ("matchInstructionBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
internalAppendValues (const GGS_matchEntryListAST & argument_0,
                    const GGS_location & argument_1,
                    const GGS_semanticInstructionListAST & argument_2,
                    const GGS_location & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
internalPrependValues (const GGS_matchEntryListAST & argument_0,
                    const GGS_location & argument_1,
                    const GGS_semanticInstructionListAST & argument_2,
                    const GGS_location & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
addAssign_operation (const GGS_matchEntryListAST & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticInstructionListAST & argument_2,
                                const GGS_location & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST GGS_matchInstructionBranchListAST::
operator_concat (const GGS_matchInstructionBranchListAST & inOperand) const {
  GGS_matchInstructionBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
dotAssign_operation (const GGS_matchInstructionBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_matchInstructionBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntryListAST  p_0 = p->mMatchEntryList ;
          GGS_location  p_1 = p->mEndOfMatchEntryList ;
          GGS_semanticInstructionListAST  p_2 = p->mMatchBranchInstructionList ;
          GGS_location  p_3 = p->mEndOf_instructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntryListAST & argument_0,
                     const GGS_location & argument_1,
                     const GGS_semanticInstructionListAST & argument_2,
                     const GGS_location & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMatchEntryList,
                                ptr->mEndOfMatchEntryList,
                                ptr->mMatchBranchInstructionList,
                                ptr->mEndOf_instructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST  GGS_matchInstructionBranchListAST::
constructor_emptyList (void) {
  GGS_matchInstructionBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST  GGS_matchInstructionBranchListAST::
constructor_listWithValue (const GGS_matchEntryListAST & argument_0,
                                const GGS_location & argument_1,
                                const GGS_semanticInstructionListAST & argument_2,
                                const GGS_location & argument_3) {
  GGS_matchInstructionBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
internalSubListWithRange (GGS_matchInstructionBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMatchEntryList, ptr->mEndOfMatchEntryList, ptr->mMatchBranchInstructionList, ptr->mEndOf_instructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST GGS_matchInstructionBranchListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST GGS_matchInstructionBranchListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchInstructionBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@matchInstructionBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
method_first (C_Compiler & inLexique,
              GGS_matchEntryListAST & _out_0,
              GGS_location & _out_1,
              GGS_semanticInstructionListAST & _out_2,
              GGS_location & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mEndOfMatchEntryList ;
    _out_2 = ptr->mMatchBranchInstructionList ;
    _out_3 = ptr->mEndOf_instructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
method_last (C_Compiler & inLexique,
             GGS_matchEntryListAST & _out_0,
             GGS_location & _out_1,
             GGS_semanticInstructionListAST & _out_2,
             GGS_location & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mEndOfMatchEntryList ;
    _out_2 = ptr->mMatchBranchInstructionList ;
    _out_3 = ptr->mEndOf_instructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_matchEntryListAST & _out_0,
                 GGS_location & _out_1,
                 GGS_semanticInstructionListAST & _out_2,
                 GGS_location & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mEndOfMatchEntryList ;
    _out_2 = ptr->mMatchBranchInstructionList ;
    _out_3 = ptr->mEndOf_instructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_matchEntryListAST & _out_0,
                GGS_location & _out_1,
                GGS_semanticInstructionListAST & _out_2,
                GGS_location & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mEndOfMatchEntryList ;
    _out_2 = ptr->mMatchBranchInstructionList ;
    _out_3 = ptr->mEndOf_instructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST  GGS_matchInstructionBranchListAST::
reader_mMatchEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_matchInstructionBranchListAST::
reader_mEndOfMatchEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfMatchEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_matchInstructionBranchListAST::
reader_mMatchBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_matchInstructionBranchListAST::
reader_mEndOf_instructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOf_instructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_setMMatchEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntryListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_setMEndOfMatchEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfMatchEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_setMMatchBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_setMEndOf_instructionListAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOf_instructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntryListAST  & GGS_matchInstructionBranchListAST::cEnumerator::_mMatchEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchEntryList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_matchInstructionBranchListAST::cEnumerator::_mEndOfMatchEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfMatchEntryList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_matchInstructionBranchListAST::cEnumerator::_mMatchBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchBranchInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_matchInstructionBranchListAST::cEnumerator::_mEndOf_instructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOf_instructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_matchInstructionBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchInstructionBranchListAST * p = NULL ;
    macroMyNew (p, GGS_matchInstructionBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST GGS_matchInstructionBranchListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchInstructionBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchInstructionBranchListAST * p = dynamic_cast <const GGS_matchInstructionBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchInstructionBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchInstructionBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchInstructionBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_matchInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstructionAST::
cPtr_matchInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionListAST & argument_1,
                                const GGS_matchInstructionBranchListAST & argument_2,
                                const GGS_semanticInstructionListAST & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mMatchedExpressionList (argument_1),
mMatchInstructionBranchList (argument_2),
mElseInstructionList (argument_3),
mEndOf_match_instruction (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstructionAST * GGS_matchInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_matchInstructionAST) ;
    return (cPtr_matchInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_matchInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_matchInstructionAST * ptr = dynamic_cast <const cPtr_matchInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mMatchedExpressionList.operator_isEqual (ptr->mMatchedExpressionList).boolValue ()
         && mMatchInstructionBranchList.operator_isEqual (ptr->mMatchInstructionBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue ()
         && mEndOf_match_instruction.operator_isEqual (ptr->mEndOf_match_instruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@matchInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mMatchedExpressionList.reader_description (inIndentation + 1)
           << mMatchInstructionBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1)
           << mEndOf_match_instruction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchInstructionAST (& typeid (cPtr_matchInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_matchInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__matchInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_matchInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_matchInstructionAST (mInstructionLocation, mMatchedExpressionList, mMatchInstructionBranchList, mElseInstructionList, mEndOf_match_instruction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_matchInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchInstructionAST ("matchInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_matchInstructionAST::
GGS_matchInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionAST::
GGS_matchInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_matchInstructionAST GGS_matchInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_matchInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_matchInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionAST GGS_matchInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionListAST & argument_1,
                 const GGS_matchInstructionBranchListAST & argument_2,
                 const GGS_semanticInstructionListAST & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_matchInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_matchInstructionAST::
reader_mMatchedExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionAST *) mPointer)->mMatchedExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST  GGS_matchInstructionAST::
reader_mMatchInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionAST *) mPointer)->mMatchInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_matchInstructionAST::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionAST *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_matchInstructionAST::
reader_mEndOf_match_instruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionAST *) mPointer)->mEndOf_match_instruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstructionAST::actualTypeName (void) const {
  return "matchInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__matchInstructionAST ("matchInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_matchInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_matchInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchInstructionAST * p = NULL ;
    macroMyNew (p, GGS_matchInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionAST GGS_matchInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchInstructionAST * p = dynamic_cast <const GGS_matchInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@castInstructionBranchListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_castInstructionBranchListAST::
elementOf_GGS_castInstructionBranchListAST (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListAST & argument_4,
                                const GGS_location & argument_5
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mUseKindOfClass (argument_0),
mTypeName (argument_1),
mConstantVarName (argument_2),
mConstantVarNameIsUnused (argument_3),
mInstructionList (argument_4),
mEndOfInstructions (argument_5) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_castInstructionBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_castInstructionBranchListAST * ptr = dynamic_cast <const elementOf_GGS_castInstructionBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstantVarName.operator_isEqual (ptr->mConstantVarName).boolValue ()
         && mConstantVarNameIsUnused.operator_isEqual (ptr->mConstantVarNameIsUnused).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mEndOfInstructions.operator_isEqual (ptr->mEndOfInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_castInstructionBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarNameIsUnused.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfInstructions.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@castInstructionBranchListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInstructionBranchListAST ("castInstructionBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionListAST & argument_4,
                    const GGS_location & argument_5
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionListAST & argument_4,
                    const GGS_location & argument_5
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListAST & argument_4,
                                const GGS_location & argument_5) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()&& argument_5.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST GGS_castInstructionBranchListAST::
operator_concat (const GGS_castInstructionBranchListAST & inOperand) const {
  GGS_castInstructionBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
dotAssign_operation (const GGS_castInstructionBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_castInstructionBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mUseKindOfClass ;
          GGS_lstring  p_1 = p->mTypeName ;
          GGS_lstring  p_2 = p->mConstantVarName ;
          GGS_bool p_3 = p->mConstantVarNameIsUnused ;
          GGS_semanticInstructionListAST  p_4 = p->mInstructionList ;
          GGS_location  p_5 = p->mEndOfInstructions ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4, p_5 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_semanticInstructionListAST & argument_4,
                     const GGS_location & argument_5
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mUseKindOfClass,
                                ptr->mTypeName,
                                ptr->mConstantVarName,
                                ptr->mConstantVarNameIsUnused,
                                ptr->mInstructionList,
                                ptr->mEndOfInstructions
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST  GGS_castInstructionBranchListAST::
constructor_emptyList (void) {
  GGS_castInstructionBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST  GGS_castInstructionBranchListAST::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListAST & argument_4,
                                const GGS_location & argument_5) {
  GGS_castInstructionBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4, argument_5) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
internalSubListWithRange (GGS_castInstructionBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mUseKindOfClass, ptr->mTypeName, ptr->mConstantVarName, ptr->mConstantVarNameIsUnused, ptr->mInstructionList, ptr->mEndOfInstructions) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST GGS_castInstructionBranchListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST GGS_castInstructionBranchListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@castInstructionBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3,
              GGS_semanticInstructionListAST & _out_4,
              GGS_location & _out_5
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mInstructionList ;
    _out_5 = ptr->mEndOfInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3,
             GGS_semanticInstructionListAST & _out_4,
             GGS_location & _out_5
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mInstructionList ;
    _out_5 = ptr->mEndOfInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3,
                 GGS_semanticInstructionListAST & _out_4,
                 GGS_location & _out_5
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mInstructionList ;
    _out_5 = ptr->mEndOfInstructions ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3,
                GGS_semanticInstructionListAST & _out_4,
                GGS_location & _out_5
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mInstructionList ;
    _out_5 = ptr->mEndOfInstructions ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
    _out_5.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchListAST::
reader_mUseKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mUseKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchListAST::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchListAST::
reader_mConstantVarNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchListAST::
reader_mConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarNameIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_castInstructionBranchListAST::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_castInstructionBranchListAST::
reader_mEndOfInstructionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfInstructions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMUseKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mUseKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMConstantVarNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarNameIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMEndOfInstructionsAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfInstructions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchListAST::cEnumerator::_mUseKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mUseKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchListAST::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchListAST::cEnumerator::_mConstantVarName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantVarName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchListAST::cEnumerator::_mConstantVarNameIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantVarNameIsUnused ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_castInstructionBranchListAST::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_castInstructionBranchListAST::cEnumerator::_mEndOfInstructions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfInstructions ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_castInstructionBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInstructionBranchListAST * p = NULL ;
    macroMyNew (p, GGS_castInstructionBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST GGS_castInstructionBranchListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInstructionBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInstructionBranchListAST * p = dynamic_cast <const GGS_castInstructionBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInstructionBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInstructionBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInstructionBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_structuredCastInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structuredCastInstructionAST::
cPtr_structuredCastInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_castInstructionBranchListAST & argument_2,
                                const GGS_semanticInstructionListAST & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mCastExpression (argument_1),
mCastInstructionBranchList (argument_2),
mElseInstructionList (argument_3),
mEndOfCastInstruction (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structuredCastInstructionAST * GGS_structuredCastInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structuredCastInstructionAST) ;
    return (cPtr_structuredCastInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structuredCastInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structuredCastInstructionAST * ptr = dynamic_cast <const cPtr_structuredCastInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mCastExpression.operator_isEqual (ptr->mCastExpression).boolValue ()
         && mCastInstructionBranchList.operator_isEqual (ptr->mCastInstructionBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue ()
         && mEndOfCastInstruction.operator_isEqual (ptr->mEndOfCastInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structuredCastInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structuredCastInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mCastExpression.reader_description (inIndentation + 1)
           << mCastInstructionBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1)
           << mEndOfCastInstruction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structuredCastInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structuredCastInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structuredCastInstructionAST (& typeid (cPtr_structuredCastInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structuredCastInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__structuredCastInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structuredCastInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structuredCastInstructionAST (mInstructionLocation, mCastExpression, mCastInstructionBranchList, mElseInstructionList, mEndOfCastInstruction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_structuredCastInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structuredCastInstructionAST ("structuredCastInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionAST::
GGS_structuredCastInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionAST::
GGS_structuredCastInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structuredCastInstructionAST GGS_structuredCastInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structuredCastInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_structuredCastInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structuredCastInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structuredCastInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionAST GGS_structuredCastInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_castInstructionBranchListAST & argument_2,
                 const GGS_semanticInstructionListAST & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_structuredCastInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_structuredCastInstructionAST::
reader_mCastExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionAST *) mPointer)->mCastExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST  GGS_structuredCastInstructionAST::
reader_mCastInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_castInstructionBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionAST *) mPointer)->mCastInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_structuredCastInstructionAST::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionAST *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_structuredCastInstructionAST::
reader_mEndOfCastInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structuredCastInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structuredCastInstructionAST *) mPointer)->mEndOfCastInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structuredCastInstructionAST::actualTypeName (void) const {
  return "structuredCastInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structuredCastInstructionAST ("structuredCastInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_structuredCastInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structuredCastInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structuredCastInstructionAST * p = NULL ;
    macroMyNew (p, GGS_structuredCastInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structuredCastInstructionAST GGS_structuredCastInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structuredCastInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structuredCastInstructionAST * p = dynamic_cast <const GGS_structuredCastInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structuredCastInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structuredCastInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structuredCastInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_addInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addInstructionAST::
cPtr_addInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2),
mExpressions (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addInstructionAST * GGS_addInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addInstructionAST) ;
    return (cPtr_addInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addInstructionAST * ptr = dynamic_cast <const cPtr_addInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addInstructionAST (& typeid (cPtr_addInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__addInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addInstructionAST (mInstructionLocation, mReceiverName, mStructAttributeList, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_addInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addInstructionAST ("addInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_addInstructionAST::
GGS_addInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionAST::
GGS_addInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addInstructionAST GGS_addInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_addInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionAST GGS_addInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_addInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_addInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_addInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_addInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_addInstructionAST::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionAST *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addInstructionAST::actualTypeName (void) const {
  return "addInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addInstructionAST ("addInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_addInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addInstructionAST * p = NULL ;
    macroMyNew (p, GGS_addInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionAST GGS_addInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addInstructionAST * p = dynamic_cast <const GGS_addInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_incrementInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstructionAST::
cPtr_incrementInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstructionAST * GGS_incrementInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_incrementInstructionAST) ;
    return (cPtr_incrementInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementInstructionAST * ptr = dynamic_cast <const cPtr_incrementInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@incrementInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementInstructionAST (& typeid (cPtr_incrementInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_incrementInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__incrementInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_incrementInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_incrementInstructionAST (mInstructionLocation, mReceiverName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_incrementInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_incrementInstructionAST ("incrementInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_incrementInstructionAST::
GGS_incrementInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionAST::
GGS_incrementInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_incrementInstructionAST GGS_incrementInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_incrementInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_incrementInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionAST GGS_incrementInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_incrementInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_incrementInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_incrementInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstructionAST::actualTypeName (void) const {
  return "incrementInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__incrementInstructionAST ("incrementInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_incrementInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_incrementInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_incrementInstructionAST * p = NULL ;
    macroMyNew (p, GGS_incrementInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionAST GGS_incrementInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_incrementInstructionAST * p = dynamic_cast <const GGS_incrementInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_incrementInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_incrementInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_incrementInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_decrementInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstructionAST::
cPtr_decrementInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstructionAST * GGS_decrementInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_decrementInstructionAST) ;
    return (cPtr_decrementInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_decrementInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_decrementInstructionAST * ptr = dynamic_cast <const cPtr_decrementInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@decrementInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_decrementInstructionAST (& typeid (cPtr_decrementInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_decrementInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__decrementInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_decrementInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_decrementInstructionAST (mInstructionLocation, mReceiverName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_decrementInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_decrementInstructionAST ("decrementInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_decrementInstructionAST::
GGS_decrementInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionAST::
GGS_decrementInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_decrementInstructionAST GGS_decrementInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_decrementInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_decrementInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_decrementInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_decrementInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionAST GGS_decrementInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_decrementInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_decrementInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_decrementInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstructionAST::actualTypeName (void) const {
  return "decrementInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__decrementInstructionAST ("decrementInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_decrementInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_decrementInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_decrementInstructionAST * p = NULL ;
    macroMyNew (p, GGS_decrementInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionAST GGS_decrementInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_decrementInstructionAST * p = dynamic_cast <const GGS_decrementInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_decrementInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_decrementInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_decrementInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_loopInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstructionAST::
cPtr_loopInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_location & argument_2,
                                const GGS_semanticInstructionListAST & argument_3,
                                const GGS_location & argument_4,
                                const GGS_semanticExpressionAST & argument_5,
                                const GGS_location & argument_6,
                                const GGS_semanticInstructionListAST & argument_7,
                                const GGS_location & argument_8,
                                const GGS_location & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mVariantExpression (argument_1),
mEndOfVariantExpression (argument_2),
mFirstInstructions (argument_3),
mEndOfFirstInstructions (argument_4),
mLoopExpression (argument_5),
mEndOfLoopExpression (argument_6),
mSecondInstructions (argument_7),
mEndOfSecondInstructions (argument_8),
mEndOfLoopInstruction (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstructionAST * GGS_loopInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_loopInstructionAST) ;
    return (cPtr_loopInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loopInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loopInstructionAST * ptr = dynamic_cast <const cPtr_loopInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mEndOfVariantExpression.operator_isEqual (ptr->mEndOfVariantExpression).boolValue ()
         && mFirstInstructions.operator_isEqual (ptr->mFirstInstructions).boolValue ()
         && mEndOfFirstInstructions.operator_isEqual (ptr->mEndOfFirstInstructions).boolValue ()
         && mLoopExpression.operator_isEqual (ptr->mLoopExpression).boolValue ()
         && mEndOfLoopExpression.operator_isEqual (ptr->mEndOfLoopExpression).boolValue ()
         && mSecondInstructions.operator_isEqual (ptr->mSecondInstructions).boolValue ()
         && mEndOfSecondInstructions.operator_isEqual (ptr->mEndOfSecondInstructions).boolValue ()
         && mEndOfLoopInstruction.operator_isEqual (ptr->mEndOfLoopInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@loopInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mVariantExpression.reader_description (inIndentation + 1)
           << mEndOfVariantExpression.reader_description (inIndentation + 1)
           << mFirstInstructions.reader_description (inIndentation + 1)
           << mEndOfFirstInstructions.reader_description (inIndentation + 1)
           << mLoopExpression.reader_description (inIndentation + 1)
           << mEndOfLoopExpression.reader_description (inIndentation + 1)
           << mSecondInstructions.reader_description (inIndentation + 1)
           << mEndOfSecondInstructions.reader_description (inIndentation + 1)
           << mEndOfLoopInstruction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_loopInstructionAST (& typeid (cPtr_loopInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_loopInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__loopInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_loopInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_loopInstructionAST (mInstructionLocation, mVariantExpression, mEndOfVariantExpression, mFirstInstructions, mEndOfFirstInstructions, mLoopExpression, mEndOfLoopExpression, mSecondInstructions, mEndOfSecondInstructions, mEndOfLoopInstruction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_loopInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_loopInstructionAST ("loopInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_loopInstructionAST::
GGS_loopInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionAST::
GGS_loopInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_loopInstructionAST GGS_loopInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_loopInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_loopInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_loopInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_loopInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_loopInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionAST GGS_loopInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_location & argument_2,
                 const GGS_semanticInstructionListAST & argument_3,
                 const GGS_location & argument_4,
                 const GGS_semanticExpressionAST & argument_5,
                 const GGS_location & argument_6,
                 const GGS_semanticInstructionListAST & argument_7,
                 const GGS_location & argument_8,
                 const GGS_location & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_loopInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_loopInstructionAST::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_loopInstructionAST::
reader_mEndOfVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mEndOfVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_loopInstructionAST::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_loopInstructionAST::
reader_mEndOfFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mEndOfFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_loopInstructionAST::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_loopInstructionAST::
reader_mEndOfLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mEndOfLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_loopInstructionAST::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_loopInstructionAST::
reader_mEndOfSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mEndOfSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_loopInstructionAST::
reader_mEndOfLoopInstruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mEndOfLoopInstruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstructionAST::actualTypeName (void) const {
  return "loopInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__loopInstructionAST ("loopInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_loopInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_loopInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_loopInstructionAST * p = NULL ;
    macroMyNew (p, GGS_loopInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionAST GGS_loopInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_loopInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_loopInstructionAST * p = dynamic_cast <const GGS_loopInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_loopInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_loopInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_loopInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_messageInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstructionAST::
cPtr_messageInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstructionAST * GGS_messageInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_messageInstructionAST) ;
    return (cPtr_messageInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_messageInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_messageInstructionAST * ptr = dynamic_cast <const cPtr_messageInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@messageInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_messageInstructionAST (& typeid (cPtr_messageInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_messageInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__messageInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_messageInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_messageInstructionAST (mInstructionLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_messageInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_messageInstructionAST ("messageInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_messageInstructionAST::
GGS_messageInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionAST::
GGS_messageInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_messageInstructionAST GGS_messageInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_messageInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_messageInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_messageInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_messageInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_messageInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionAST GGS_messageInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_messageInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_messageInstructionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstructionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstructionAST::actualTypeName (void) const {
  return "messageInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__messageInstructionAST ("messageInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_messageInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_messageInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_messageInstructionAST * p = NULL ;
    macroMyNew (p, GGS_messageInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionAST GGS_messageInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_messageInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_messageInstructionAST * p = dynamic_cast <const GGS_messageInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_messageInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_messageInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_messageInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@logListAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_logListAST::
elementOf_GGS_logListAST (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mLogMessage (argument_0),
mLogExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_logListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_logListAST * ptr = dynamic_cast <const elementOf_GGS_logListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLogMessage.operator_isEqual (ptr->mLogMessage).boolValue ()
         && mLogExpression.operator_isEqual (ptr->mLogExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_logListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLogMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLogExpression.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@logListAST'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_logListAST ("logListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_logListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpressionAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpressionAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_logListAST GGS_logListAST::
operator_concat (const GGS_logListAST & inOperand) const {
  GGS_logListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
dotAssign_operation (const GGS_logListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_logListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLogMessage ;
          GGS_semanticExpressionAST  p_1 = p->mLogExpression ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_semanticExpressionAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLogMessage,
                                ptr->mLogExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_logListAST  GGS_logListAST::
constructor_emptyList (void) {
  GGS_logListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListAST  GGS_logListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionAST & argument_1) {
  GGS_logListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
internalSubListWithRange (GGS_logListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLogMessage, ptr->mLogExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_logListAST GGS_logListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_logListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListAST GGS_logListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_logListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_logListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@logListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_semanticExpressionAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_semanticExpressionAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_semanticExpressionAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_semanticExpressionAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_logListAST::
reader_mLogMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLogMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_logListAST::
reader_mLogExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLogExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_setMLogMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLogMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_setMLogExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLogExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_logListAST::cEnumerator::_mLogMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLogMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionAST  & GGS_logListAST::cEnumerator::_mLogExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLogExpression ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_logListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_logListAST * p = NULL ;
    macroMyNew (p, GGS_logListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListAST GGS_logListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_logListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_logListAST * p = dynamic_cast <const GGS_logListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_logListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_logListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_logListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_logInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstructionAST::
cPtr_logInstructionAST (const GGS_location & argument_0,
                                const GGS_logListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mLogList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstructionAST * GGS_logInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_logInstructionAST) ;
    return (cPtr_logInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_logInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_logInstructionAST * ptr = dynamic_cast <const cPtr_logInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mLogList.operator_isEqual (ptr->mLogList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@logInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mLogList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_logInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_logInstructionAST (& typeid (cPtr_logInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_logInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__logInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_logInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_logInstructionAST (mInstructionLocation, mLogList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_logInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_logInstructionAST ("logInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_logInstructionAST::
GGS_logInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionAST::
GGS_logInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_logInstructionAST GGS_logInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_logInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_logInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_logInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_logInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_logInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionAST GGS_logInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_logListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_logInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_logInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListAST  GGS_logInstructionAST::
reader_mLogList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_logListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstructionAST *) mPointer)->mLogList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstructionAST::actualTypeName (void) const {
  return "logInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__logInstructionAST ("logInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_logInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_logInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_logInstructionAST * p = NULL ;
    macroMyNew (p, GGS_logInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionAST GGS_logInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_logInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_logInstructionAST * p = dynamic_cast <const GGS_logInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_logInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_logInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_logInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_dropInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_dropInstructionAST::
cPtr_dropInstructionAST (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mDropList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_dropInstructionAST * GGS_dropInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_dropInstructionAST) ;
    return (cPtr_dropInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_dropInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_dropInstructionAST * ptr = dynamic_cast <const cPtr_dropInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mDropList.operator_isEqual (ptr->mDropList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_dropInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@dropInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mDropList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_dropInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_dropInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_dropInstructionAST (& typeid (cPtr_dropInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_dropInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__dropInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_dropInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_dropInstructionAST (mInstructionLocation, mDropList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_dropInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_dropInstructionAST ("dropInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_dropInstructionAST::
GGS_dropInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionAST::
GGS_dropInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_dropInstructionAST GGS_dropInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_dropInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_dropInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_dropInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_dropInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_dropInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionAST GGS_dropInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_dropInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_dropInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_dropInstructionAST::
reader_mDropList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_dropInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_dropInstructionAST *) mPointer)->mDropList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_dropInstructionAST::actualTypeName (void) const {
  return "dropInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__dropInstructionAST ("dropInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_dropInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_dropInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_dropInstructionAST * p = NULL ;
    macroMyNew (p, GGS_dropInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_dropInstructionAST GGS_dropInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_dropInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_dropInstructionAST * p = dynamic_cast <const GGS_dropInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_dropInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_dropInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_dropInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_grammarInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstructionAST::
cPtr_grammarInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionAST & argument_3,
                                const GGS_location & argument_4,
                                const GGS_bool& argument_5,
                                const GGS_actualParameterListAST & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mGrammarComponentName (argument_1),
mLabelName (argument_2),
mSourceExpression (argument_3),
mEndOfSourceExpression (argument_4),
mSourceExpressionIsFile (argument_5),
mActualParameterList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstructionAST * GGS_grammarInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_grammarInstructionAST) ;
    return (cPtr_grammarInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstructionAST * ptr = dynamic_cast <const cPtr_grammarInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mGrammarComponentName.operator_isEqual (ptr->mGrammarComponentName).boolValue ()
         && mLabelName.operator_isEqual (ptr->mLabelName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mEndOfSourceExpression.operator_isEqual (ptr->mEndOfSourceExpression).boolValue ()
         && mSourceExpressionIsFile.operator_isEqual (ptr->mSourceExpressionIsFile).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@grammarInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mGrammarComponentName.reader_description (inIndentation + 1)
           << mLabelName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1)
           << mEndOfSourceExpression.reader_description (inIndentation + 1)
           << mSourceExpressionIsFile.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstructionAST (& typeid (cPtr_grammarInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_grammarInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__grammarInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_grammarInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_grammarInstructionAST (mInstructionLocation, mGrammarComponentName, mLabelName, mSourceExpression, mEndOfSourceExpression, mSourceExpressionIsFile, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_grammarInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarInstructionAST ("grammarInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_grammarInstructionAST::
GGS_grammarInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionAST::
GGS_grammarInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_grammarInstructionAST GGS_grammarInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_grammarInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionAST GGS_grammarInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionAST & argument_3,
                 const GGS_location & argument_4,
                 const GGS_bool& argument_5,
                 const GGS_actualParameterListAST & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_grammarInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstructionAST::
reader_mGrammarComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mGrammarComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstructionAST::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_grammarInstructionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_grammarInstructionAST::
reader_mEndOfSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mEndOfSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarInstructionAST::
reader_mSourceExpressionIsFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mSourceExpressionIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_grammarInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstructionAST::actualTypeName (void) const {
  return "grammarInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__grammarInstructionAST ("grammarInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_grammarInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_grammarInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarInstructionAST * p = NULL ;
    macroMyNew (p, GGS_grammarInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionAST GGS_grammarInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarInstructionAST * p = dynamic_cast <const GGS_grammarInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_readAccessWithInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readAccessWithInstructionAST::
cPtr_readAccessWithInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_semanticExpressionAST & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticExpressionAST & argument_4,
                                const GGS_semanticInstructionListAST & argument_5,
                                const GGS_semanticInstructionListAST & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mPrefix (argument_1),
mReceiverExpression (argument_2),
mSearchMethodName (argument_3),
mKeyExpression (argument_4),
mDoBranchInstructions (argument_5),
mElseBranchInstructions (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readAccessWithInstructionAST * GGS_readAccessWithInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readAccessWithInstructionAST) ;
    return (cPtr_readAccessWithInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readAccessWithInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readAccessWithInstructionAST * ptr = dynamic_cast <const cPtr_readAccessWithInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mSearchMethodName.operator_isEqual (ptr->mSearchMethodName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructions.operator_isEqual (ptr->mDoBranchInstructions).boolValue ()
         && mElseBranchInstructions.operator_isEqual (ptr->mElseBranchInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readAccessWithInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readAccessWithInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mPrefix.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mSearchMethodName.reader_description (inIndentation + 1)
           << mKeyExpression.reader_description (inIndentation + 1)
           << mDoBranchInstructions.reader_description (inIndentation + 1)
           << mElseBranchInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readAccessWithInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readAccessWithInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readAccessWithInstructionAST (& typeid (cPtr_readAccessWithInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readAccessWithInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__readAccessWithInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readAccessWithInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readAccessWithInstructionAST (mInstructionLocation, mPrefix, mReceiverExpression, mSearchMethodName, mKeyExpression, mDoBranchInstructions, mElseBranchInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_readAccessWithInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readAccessWithInstructionAST ("readAccessWithInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_readAccessWithInstructionAST::
GGS_readAccessWithInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readAccessWithInstructionAST::
GGS_readAccessWithInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readAccessWithInstructionAST GGS_readAccessWithInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readAccessWithInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readAccessWithInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_readAccessWithInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readAccessWithInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readAccessWithInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readAccessWithInstructionAST GGS_readAccessWithInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_semanticExpressionAST & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_semanticExpressionAST & argument_4,
                 const GGS_semanticInstructionListAST & argument_5,
                 const GGS_semanticInstructionListAST & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_readAccessWithInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_readAccessWithInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readAccessWithInstructionAST::
reader_mPrefix (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readAccessWithInstructionAST *) mPointer)->mPrefix ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_readAccessWithInstructionAST::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readAccessWithInstructionAST *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readAccessWithInstructionAST::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readAccessWithInstructionAST *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_readAccessWithInstructionAST::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readAccessWithInstructionAST *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_readAccessWithInstructionAST::
reader_mDoBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readAccessWithInstructionAST *) mPointer)->mDoBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_readAccessWithInstructionAST::
reader_mElseBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readAccessWithInstructionAST *) mPointer)->mElseBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readAccessWithInstructionAST::actualTypeName (void) const {
  return "readAccessWithInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readAccessWithInstructionAST ("readAccessWithInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_readAccessWithInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readAccessWithInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readAccessWithInstructionAST * p = NULL ;
    macroMyNew (p, GGS_readAccessWithInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readAccessWithInstructionAST GGS_readAccessWithInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readAccessWithInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readAccessWithInstructionAST * p = dynamic_cast <const GGS_readAccessWithInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readAccessWithInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readAccessWithInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readAccessWithInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_readWriteAccessWithInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readWriteAccessWithInstructionAST::
cPtr_readWriteAccessWithInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_semanticExpressionAST & argument_5,
                                const GGS_semanticInstructionListAST & argument_6,
                                const GGS_location & argument_7,
                                const GGS_semanticInstructionListAST & argument_8,
                                const GGS_location & argument_9
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mPrefix (argument_1),
mReceiverName (argument_2),
mFieldList (argument_3),
mAccessName (argument_4),
mKeyExpression (argument_5),
m_do_Instructions (argument_6),
mEndOf_do_instructions (argument_7),
m_else_Instructions (argument_8),
mEndOf_else_instructions (argument_9) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readWriteAccessWithInstructionAST * GGS_readWriteAccessWithInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readWriteAccessWithInstructionAST) ;
    return (cPtr_readWriteAccessWithInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readWriteAccessWithInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readWriteAccessWithInstructionAST * ptr = dynamic_cast <const cPtr_readWriteAccessWithInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mFieldList.operator_isEqual (ptr->mFieldList).boolValue ()
         && mAccessName.operator_isEqual (ptr->mAccessName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && m_do_Instructions.operator_isEqual (ptr->m_do_Instructions).boolValue ()
         && mEndOf_do_instructions.operator_isEqual (ptr->mEndOf_do_instructions).boolValue ()
         && m_else_Instructions.operator_isEqual (ptr->m_else_Instructions).boolValue ()
         && mEndOf_else_instructions.operator_isEqual (ptr->mEndOf_else_instructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readWriteAccessWithInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readWriteAccessWithInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mPrefix.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mFieldList.reader_description (inIndentation + 1)
           << mAccessName.reader_description (inIndentation + 1)
           << mKeyExpression.reader_description (inIndentation + 1)
           << m_do_Instructions.reader_description (inIndentation + 1)
           << mEndOf_do_instructions.reader_description (inIndentation + 1)
           << m_else_Instructions.reader_description (inIndentation + 1)
           << mEndOf_else_instructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readWriteAccessWithInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readWriteAccessWithInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readWriteAccessWithInstructionAST (& typeid (cPtr_readWriteAccessWithInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readWriteAccessWithInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__readWriteAccessWithInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readWriteAccessWithInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readWriteAccessWithInstructionAST (mInstructionLocation, mPrefix, mReceiverName, mFieldList, mAccessName, mKeyExpression, m_do_Instructions, mEndOf_do_instructions, m_else_Instructions, mEndOf_else_instructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_readWriteAccessWithInstructionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readWriteAccessWithInstructionAST ("readWriteAccessWithInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_readWriteAccessWithInstructionAST::
GGS_readWriteAccessWithInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readWriteAccessWithInstructionAST::
GGS_readWriteAccessWithInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readWriteAccessWithInstructionAST GGS_readWriteAccessWithInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readWriteAccessWithInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_readWriteAccessWithInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readWriteAccessWithInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readWriteAccessWithInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readWriteAccessWithInstructionAST GGS_readWriteAccessWithInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_semanticExpressionAST & argument_5,
                 const GGS_semanticInstructionListAST & argument_6,
                 const GGS_location & argument_7,
                 const GGS_semanticInstructionListAST & argument_8,
                 const GGS_location & argument_9
                                COMMA_LOCATION_ARGS) {
  GGS_readWriteAccessWithInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_readWriteAccessWithInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7,
                                argument_8,
                                argument_9 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readWriteAccessWithInstructionAST::
reader_mPrefix (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->mPrefix ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readWriteAccessWithInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_readWriteAccessWithInstructionAST::
reader_mFieldList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->mFieldList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readWriteAccessWithInstructionAST::
reader_mAccessName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->mAccessName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_readWriteAccessWithInstructionAST::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_readWriteAccessWithInstructionAST::
reader_m_do_Instructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->m_do_Instructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_readWriteAccessWithInstructionAST::
reader_mEndOf_do_instructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->mEndOf_do_instructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_readWriteAccessWithInstructionAST::
reader_m_else_Instructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->m_else_Instructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_readWriteAccessWithInstructionAST::
reader_mEndOf_else_instructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readWriteAccessWithInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readWriteAccessWithInstructionAST *) mPointer)->mEndOf_else_instructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readWriteAccessWithInstructionAST::actualTypeName (void) const {
  return "readWriteAccessWithInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readWriteAccessWithInstructionAST ("readWriteAccessWithInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_readWriteAccessWithInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readWriteAccessWithInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readWriteAccessWithInstructionAST * p = NULL ;
    macroMyNew (p, GGS_readWriteAccessWithInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readWriteAccessWithInstructionAST GGS_readWriteAccessWithInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readWriteAccessWithInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readWriteAccessWithInstructionAST * p = dynamic_cast <const GGS_readWriteAccessWithInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readWriteAccessWithInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readWriteAccessWithInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readWriteAccessWithInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@switchBranchesAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_switchBranchesAST::
elementOf_GGS_switchBranchesAST (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListAST & argument_1,
                                const GGS_location & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSwitchConstantList (argument_0),
mInstructions (argument_1),
mEndOfBranch (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_switchBranchesAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_switchBranchesAST * ptr = dynamic_cast <const elementOf_GGS_switchBranchesAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchConstantList.operator_isEqual (ptr->mSwitchConstantList).boolValue ()
         && mInstructions.operator_isEqual (ptr->mInstructions).boolValue ()
         && mEndOfBranch.operator_isEqual (ptr->mEndOfBranch).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_switchBranchesAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSwitchConstantList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructions.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfBranch.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@switchBranchesAST'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_switchBranchesAST ("switchBranchesAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionListAST & argument_1,
                    const GGS_location & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionListAST & argument_1,
                    const GGS_location & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
addAssign_operation (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListAST & argument_1,
                                const GGS_location & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST GGS_switchBranchesAST::
operator_concat (const GGS_switchBranchesAST & inOperand) const {
  GGS_switchBranchesAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
dotAssign_operation (const GGS_switchBranchesAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_switchBranchesAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mSwitchConstantList ;
          GGS_semanticInstructionListAST  p_1 = p->mInstructions ;
          GGS_location  p_2 = p->mEndOfBranch ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_semanticInstructionListAST & argument_1,
                     const GGS_location & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSwitchConstantList,
                                ptr->mInstructions,
                                ptr->mEndOfBranch
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST  GGS_switchBranchesAST::
constructor_emptyList (void) {
  GGS_switchBranchesAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST  GGS_switchBranchesAST::
constructor_listWithValue (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListAST & argument_1,
                                const GGS_location & argument_2) {
  GGS_switchBranchesAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
internalSubListWithRange (GGS_switchBranchesAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSwitchConstantList, ptr->mInstructions, ptr->mEndOfBranch) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST GGS_switchBranchesAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranchesAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST GGS_switchBranchesAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranchesAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_switchBranchesAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@switchBranchesAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
method_first (C_Compiler & inLexique,
              GGS_lstringlist & _out_0,
              GGS_semanticInstructionListAST & _out_1,
              GGS_location & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    _out_2 = ptr->mEndOfBranch ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
method_last (C_Compiler & inLexique,
             GGS_lstringlist & _out_0,
             GGS_semanticInstructionListAST & _out_1,
             GGS_location & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    _out_2 = ptr->mEndOfBranch ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstringlist & _out_0,
                 GGS_semanticInstructionListAST & _out_1,
                 GGS_location & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    _out_2 = ptr->mEndOfBranch ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstringlist & _out_0,
                GGS_semanticInstructionListAST & _out_1,
                GGS_location & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    _out_2 = ptr->mEndOfBranch ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_switchBranchesAST::
reader_mSwitchConstantListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSwitchConstantList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_switchBranchesAST::
reader_mInstructionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_switchBranchesAST::
reader_mEndOfBranchAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfBranch ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_setMSwitchConstantListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSwitchConstantList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_setMInstructionsAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_setMEndOfBranchAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfBranch = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_switchBranchesAST::cEnumerator::_mSwitchConstantList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSwitchConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_switchBranchesAST::cEnumerator::_mInstructions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructions ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_switchBranchesAST::cEnumerator::_mEndOfBranch (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfBranch ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_switchBranchesAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_switchBranchesAST * p = NULL ;
    macroMyNew (p, GGS_switchBranchesAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST GGS_switchBranchesAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_switchBranchesAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_switchBranchesAST * p = dynamic_cast <const GGS_switchBranchesAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_switchBranchesAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_switchBranchesAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_switchBranchesAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_switchInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_switchInstructionAST::
cPtr_switchInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_location & argument_2,
                                const GGS_switchBranchesAST & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mSwitchExpression (argument_1),
mEndOfSwitchExpression (argument_2),
mBranches (argument_3),
mEndOf_switch_instruction (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_switchInstructionAST * GGS_switchInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_switchInstructionAST) ;
    return (cPtr_switchInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_switchInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_switchInstructionAST * ptr = dynamic_cast <const cPtr_switchInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mEndOfSwitchExpression.operator_isEqual (ptr->mEndOfSwitchExpression).boolValue ()
         && mBranches.operator_isEqual (ptr->mBranches).boolValue ()
         && mEndOf_switch_instruction.operator_isEqual (ptr->mEndOf_switch_instruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_switchInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@switchInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mSwitchExpression.reader_description (inIndentation + 1)
           << mEndOfSwitchExpression.reader_description (inIndentation + 1)
           << mBranches.reader_description (inIndentation + 1)
           << mEndOf_switch_instruction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_switchInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_switchInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_switchInstructionAST (& typeid (cPtr_switchInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_switchInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__switchInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_switchInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_switchInstructionAST (mInstructionLocation, mSwitchExpression, mEndOfSwitchExpression, mBranches, mEndOf_switch_instruction COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_switchInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_switchInstructionAST ("switchInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_switchInstructionAST::
GGS_switchInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionAST::
GGS_switchInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_switchInstructionAST GGS_switchInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_switchInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_switchInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_switchInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_switchInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_switchInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionAST GGS_switchInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_location & argument_2,
                 const GGS_switchBranchesAST & argument_3,
                 const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_switchInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_switchInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_switchInstructionAST::
reader_mSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionAST *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_switchInstructionAST::
reader_mEndOfSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionAST *) mPointer)->mEndOfSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST  GGS_switchInstructionAST::
reader_mBranches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_switchBranchesAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionAST *) mPointer)->mBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_switchInstructionAST::
reader_mEndOf_switch_instruction (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionAST *) mPointer)->mEndOf_switch_instruction ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_switchInstructionAST::actualTypeName (void) const {
  return "switchInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__switchInstructionAST ("switchInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_switchInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_switchInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_switchInstructionAST * p = NULL ;
    macroMyNew (p, GGS_switchInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionAST GGS_switchInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_switchInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_switchInstructionAST * p = dynamic_cast <const GGS_switchInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_switchInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_switchInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_switchInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeMethodCallInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodCallInstructionAST::
cPtr_typeMethodCallInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTypeName (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodCallInstructionAST * GGS_typeMethodCallInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMethodCallInstructionAST) ;
    return (cPtr_typeMethodCallInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodCallInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodCallInstructionAST * ptr = dynamic_cast <const cPtr_typeMethodCallInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstructionLocation.operator_isEqual (ptr->mInstructionLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodCallInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMethodCallInstructionAST:"
           << mInstructionLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodCallInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodCallInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodCallInstructionAST (& typeid (cPtr_typeMethodCallInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMethodCallInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodCallInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMethodCallInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMethodCallInstructionAST (mInstructionLocation, mTypeName, mMethodName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeMethodCallInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMethodCallInstructionAST ("typeMethodCallInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstructionAST::
GGS_typeMethodCallInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstructionAST::
GGS_typeMethodCallInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMethodCallInstructionAST GGS_typeMethodCallInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodCallInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodCallInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMethodCallInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodCallInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstructionAST GGS_typeMethodCallInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_typeMethodCallInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodCallInstructionAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstructionAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodCallInstructionAST::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstructionAST *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_typeMethodCallInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodCallInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodCallInstructionAST::actualTypeName (void) const {
  return "typeMethodCallInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMethodCallInstructionAST ("typeMethodCallInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_typeMethodCallInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMethodCallInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMethodCallInstructionAST * p = NULL ;
    macroMyNew (p, GGS_typeMethodCallInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodCallInstructionAST GGS_typeMethodCallInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMethodCallInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMethodCallInstructionAST * p = dynamic_cast <const GGS_typeMethodCallInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMethodCallInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMethodCallInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMethodCallInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@abstracMultiMethodListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstracMultiMethodListAST::
elementOf_GGS_abstracMultiMethodListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAbstractMultiMethodName (argument_0),
mAbstractCategoryFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstracMultiMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstracMultiMethodListAST * ptr = dynamic_cast <const elementOf_GGS_abstracMultiMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAbstractMultiMethodName.operator_isEqual (ptr->mAbstractMultiMethodName).boolValue ()
         && mAbstractCategoryFormalParameterList.operator_isEqual (ptr->mAbstractCategoryFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstracMultiMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractMultiMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalParameterList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@abstracMultiMethodListAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstracMultiMethodListAST ("abstracMultiMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstracMultiMethodListAST::
operator_concat (const GGS_abstracMultiMethodListAST & inOperand) const {
  GGS_abstracMultiMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
dotAssign_operation (const GGS_abstracMultiMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstracMultiMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractMultiMethodName ;
          GGS_formalParameterListAST  p_1 = p->mAbstractCategoryFormalParameterList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAbstractMultiMethodName,
                                ptr->mAbstractCategoryFormalParameterList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST  GGS_abstracMultiMethodListAST::
constructor_emptyList (void) {
  GGS_abstracMultiMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST  GGS_abstracMultiMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1) {
  GGS_abstracMultiMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
internalSubListWithRange (GGS_abstracMultiMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAbstractMultiMethodName, ptr->mAbstractCategoryFormalParameterList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstracMultiMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstracMultiMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstracMultiMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstracMultiMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractMultiMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractMultiMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractMultiMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractMultiMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstracMultiMethodListAST::
reader_mAbstractMultiMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractMultiMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_abstracMultiMethodListAST::
reader_mAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_setMAbstractMultiMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractMultiMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_setMAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstracMultiMethodListAST::cEnumerator::_mAbstractMultiMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractMultiMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_abstracMultiMethodListAST::cEnumerator::_mAbstractCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstracMultiMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstracMultiMethodListAST * p = NULL ;
    macroMyNew (p, GGS_abstracMultiMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstracMultiMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstracMultiMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstracMultiMethodListAST * p = dynamic_cast <const GGS_abstracMultiMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstracMultiMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstracMultiMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstracMultiMethodListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiMethodListMapAST ("abstractMultiMethodListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstracMultiMethodListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractMultiMethodListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractMultiMethodListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractMultiMethodListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST GGS_abstractMultiMethodListMapAST::
constructor_emptyMap (void) {
  GGS_abstractMultiMethodListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMultiMethodListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@abstractMultiMethodListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST GGS_abstractMultiMethodListMapAST::
operator_concat (const GGS_abstractMultiMethodListMapAST & inOperand) const {
  GGS_abstractMultiMethodListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiMethodListMapAST::
dotAssign_operation (const GGS_abstractMultiMethodListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_abstracMultiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiMethodListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListAST & inAttribute1) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_abstracMultiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstractMultiMethodListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstracMultiMethodListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractMultiMethodListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractMultiMethodListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST::cEnumerator::
cEnumerator (const GGS_abstractMultiMethodListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstracMultiMethodListAST & GGS_abstractMultiMethodListMapAST::cEnumerator::
_mList (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiMethodListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiMethodListMapAST * p = NULL ;
    macroMyNew (p, GGS_abstractMultiMethodListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST GGS_abstractMultiMethodListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiMethodListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiMethodListMapAST * p = dynamic_cast <const GGS_abstractMultiMethodListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiMethodListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiMethodListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiMethodListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@multiMethodListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_multiMethodListAST::
elementOf_GGS_multiMethodListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMultiMethodName (argument_0),
mCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_multiMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_multiMethodListAST * ptr = dynamic_cast <const elementOf_GGS_multiMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMultiMethodName.operator_isEqual (ptr->mMultiMethodName).boolValue ()
         && mCategoryFormalParameterList.operator_isEqual (ptr->mCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_multiMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMultiMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryFormalParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@multiMethodListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiMethodListAST ("multiMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListAST::
operator_concat (const GGS_multiMethodListAST & inOperand) const {
  GGS_multiMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
dotAssign_operation (const GGS_multiMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_multiMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMultiMethodName ;
          GGS_formalParameterListAST  p_1 = p->mCategoryFormalParameterList ;
          GGS_semanticInstructionListAST  p_2 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1,
                     const GGS_semanticInstructionListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMultiMethodName,
                                ptr->mCategoryFormalParameterList,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST  GGS_multiMethodListAST::
constructor_emptyList (void) {
  GGS_multiMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST  GGS_multiMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  GGS_multiMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
internalSubListWithRange (GGS_multiMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMultiMethodName, ptr->mCategoryFormalParameterList, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_multiMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_multiMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@multiMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1,
              GGS_semanticInstructionListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMultiMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1,
             GGS_semanticInstructionListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMultiMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1,
                 GGS_semanticInstructionListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMultiMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1,
                GGS_semanticInstructionListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMultiMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiMethodListAST::
reader_mMultiMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMultiMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_multiMethodListAST::
reader_mCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_multiMethodListAST::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_setMMultiMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMultiMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_setMCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiMethodListAST::cEnumerator::_mMultiMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMultiMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_multiMethodListAST::cEnumerator::_mCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_multiMethodListAST::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiMethodListAST * p = NULL ;
    macroMyNew (p, GGS_multiMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiMethodListAST * p = dynamic_cast <const GGS_multiMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiMethodListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiMethodListMapAST ("multiMethodListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_multiMethodListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_multiMethodListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_multiMethodListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_multiMethodListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST GGS_multiMethodListMapAST::
constructor_emptyMap (void) {
  GGS_multiMethodListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiMethodListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@multiMethodListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST GGS_multiMethodListMapAST::
operator_concat (const GGS_multiMethodListMapAST & inOperand) const {
  GGS_multiMethodListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListMapAST::
dotAssign_operation (const GGS_multiMethodListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_multiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListAST & inAttribute1,
                      const GGS_semanticInstructionListAST & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_multiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_multiMethodListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_multiMethodListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_multiMethodListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_multiMethodListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST::cEnumerator::
cEnumerator (const GGS_multiMethodListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_multiMethodListAST & GGS_multiMethodListMapAST::cEnumerator::
_mList (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiMethodListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiMethodListMapAST * p = NULL ;
    macroMyNew (p, GGS_multiMethodListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST GGS_multiMethodListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiMethodListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiMethodListMapAST * p = dynamic_cast <const GGS_multiMethodListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiMethodListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiMethodListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiMethodListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridingMultiMethodListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingMultiMethodListAST::
elementOf_GGS_overridingMultiMethodListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mOverridingMultiMethodMethodName (argument_0),
mOverridingCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingMultiMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingMultiMethodListAST * ptr = dynamic_cast <const elementOf_GGS_overridingMultiMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverridingMultiMethodMethodName.operator_isEqual (ptr->mOverridingMultiMethodMethodName).boolValue ()
         && mOverridingCategoryFormalParameterList.operator_isEqual (ptr->mOverridingCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingMultiMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingMultiMethodMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryFormalParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@overridingMultiMethodListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiMethodListAST ("overridingMultiMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListAST::
operator_concat (const GGS_overridingMultiMethodListAST & inOperand) const {
  GGS_overridingMultiMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
dotAssign_operation (const GGS_overridingMultiMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_overridingMultiMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingMultiMethodMethodName ;
          GGS_formalParameterListAST  p_1 = p->mOverridingCategoryFormalParameterList ;
          GGS_semanticInstructionListAST  p_2 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1,
                     const GGS_semanticInstructionListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOverridingMultiMethodMethodName,
                                ptr->mOverridingCategoryFormalParameterList,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST  GGS_overridingMultiMethodListAST::
constructor_emptyList (void) {
  GGS_overridingMultiMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST  GGS_overridingMultiMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  GGS_overridingMultiMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
internalSubListWithRange (GGS_overridingMultiMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverridingMultiMethodMethodName, ptr->mOverridingCategoryFormalParameterList, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingMultiMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@overridingMultiMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1,
              GGS_semanticInstructionListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingMultiMethodMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1,
             GGS_semanticInstructionListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingMultiMethodMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1,
                 GGS_semanticInstructionListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingMultiMethodMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1,
                GGS_semanticInstructionListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingMultiMethodMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiMethodListAST::
reader_mOverridingMultiMethodMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingMultiMethodMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_overridingMultiMethodListAST::
reader_mOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_overridingMultiMethodListAST::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_setMOverridingMultiMethodMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingMultiMethodMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_setMOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiMethodListAST::cEnumerator::_mOverridingMultiMethodMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingMultiMethodMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_overridingMultiMethodListAST::cEnumerator::_mOverridingCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_overridingMultiMethodListAST::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiMethodListAST * p = NULL ;
    macroMyNew (p, GGS_overridingMultiMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiMethodListAST * p = dynamic_cast <const GGS_overridingMultiMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiMethodListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiMethodListMapAST ("overridingMultiMethodListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingMultiMethodListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingMultiMethodListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingMultiMethodListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingMultiMethodListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST GGS_overridingMultiMethodListMapAST::
constructor_emptyMap (void) {
  GGS_overridingMultiMethodListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingMultiMethodListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@overridingMultiMethodListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST GGS_overridingMultiMethodListMapAST::
operator_concat (const GGS_overridingMultiMethodListMapAST & inOperand) const {
  GGS_overridingMultiMethodListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListMapAST::
dotAssign_operation (const GGS_overridingMultiMethodListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_overridingMultiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListAST & inAttribute1,
                      const GGS_semanticInstructionListAST & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_overridingMultiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingMultiMethodListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingMultiMethodListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingMultiMethodListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST::cEnumerator::
cEnumerator (const GGS_overridingMultiMethodListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingMultiMethodListAST & GGS_overridingMultiMethodListMapAST::cEnumerator::
_mList (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiMethodListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiMethodListMapAST * p = NULL ;
    macroMyNew (p, GGS_overridingMultiMethodListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST GGS_overridingMultiMethodListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiMethodListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiMethodListMapAST * p = dynamic_cast <const GGS_overridingMultiMethodListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiMethodListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiMethodListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiMethodListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@abstractMultiReaderListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMultiReaderListAST::
elementOf_GGS_abstractMultiReaderListAST (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAbstractMultiReaderName (argument_0),
mAbstractCategoryFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMultiReaderListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMultiReaderListAST * ptr = dynamic_cast <const elementOf_GGS_abstractMultiReaderListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAbstractMultiReaderName.operator_isEqual (ptr->mAbstractMultiReaderName).boolValue ()
         && mAbstractCategoryFormalInputParameterList.operator_isEqual (ptr->mAbstractCategoryFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMultiReaderListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractMultiReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@abstractMultiReaderListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiReaderListAST ("abstractMultiReaderListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListAST::
operator_concat (const GGS_abstractMultiReaderListAST & inOperand) const {
  GGS_abstractMultiReaderListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
dotAssign_operation (const GGS_abstractMultiReaderListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstractMultiReaderListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractMultiReaderName ;
          GGS_formalInputParameterListAST  p_1 = p->mAbstractCategoryFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListAST & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAbstractMultiReaderName,
                                ptr->mAbstractCategoryFormalInputParameterList,
                                ptr->mReturnedTypeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST  GGS_abstractMultiReaderListAST::
constructor_emptyList (void) {
  GGS_abstractMultiReaderListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST  GGS_abstractMultiReaderListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_abstractMultiReaderListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
internalSubListWithRange (GGS_abstractMultiReaderListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAbstractMultiReaderName, ptr->mAbstractCategoryFormalInputParameterList, ptr->mReturnedTypeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMultiReaderListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstractMultiReaderListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListAST & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractMultiReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListAST & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractMultiReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListAST & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractMultiReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListAST & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractMultiReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMultiReaderListAST::
reader_mAbstractMultiReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractMultiReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_abstractMultiReaderListAST::
reader_mAbstractCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMultiReaderListAST::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_setMAbstractMultiReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractMultiReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_setMAbstractCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMultiReaderListAST::cEnumerator::_mAbstractMultiReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractMultiReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_abstractMultiReaderListAST::cEnumerator::_mAbstractCategoryFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMultiReaderListAST::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiReaderListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiReaderListAST * p = NULL ;
    macroMyNew (p, GGS_abstractMultiReaderListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiReaderListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiReaderListAST * p = dynamic_cast <const GGS_abstractMultiReaderListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiReaderListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiReaderListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiReaderListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiReaderListMapAST ("abstractMultiReaderListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstractMultiReaderListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractMultiReaderListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractMultiReaderListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractMultiReaderListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST GGS_abstractMultiReaderListMapAST::
constructor_emptyMap (void) {
  GGS_abstractMultiReaderListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMultiReaderListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@abstractMultiReaderListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST GGS_abstractMultiReaderListMapAST::
operator_concat (const GGS_abstractMultiReaderListMapAST & inOperand) const {
  GGS_abstractMultiReaderListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListMapAST::
dotAssign_operation (const GGS_abstractMultiReaderListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_abstractMultiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListAST & inAttribute1,
                      const GGS_lstring & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_abstractMultiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstractMultiReaderListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractMultiReaderListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractMultiReaderListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST::cEnumerator::
cEnumerator (const GGS_abstractMultiReaderListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstractMultiReaderListAST & GGS_abstractMultiReaderListMapAST::cEnumerator::
_mList (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiReaderListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiReaderListMapAST * p = NULL ;
    macroMyNew (p, GGS_abstractMultiReaderListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST GGS_abstractMultiReaderListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiReaderListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiReaderListMapAST * p = dynamic_cast <const GGS_abstractMultiReaderListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiReaderListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiReaderListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiReaderListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@multiReaderListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_multiReaderListAST::
elementOf_GGS_multiReaderListAST (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMultiReaderName (argument_0),
mReaderCategoryFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2),
mReturnedVariableName (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_multiReaderListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_multiReaderListAST * ptr = dynamic_cast <const elementOf_GGS_multiReaderListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMultiReaderName.operator_isEqual (ptr->mMultiReaderName).boolValue ()
         && mReaderCategoryFormalInputParameterList.operator_isEqual (ptr->mReaderCategoryFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue ()
         && mReturnedVariableName.operator_isEqual (ptr->mReturnedVariableName).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_multiReaderListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMultiReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReaderCategoryFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@multiReaderListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiReaderListAST ("multiReaderListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListAST::
operator_concat (const GGS_multiReaderListAST & inOperand) const {
  GGS_multiReaderListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
dotAssign_operation (const GGS_multiReaderListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_multiReaderListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMultiReaderName ;
          GGS_formalInputParameterListAST  p_1 = p->mReaderCategoryFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_semanticInstructionListAST  p_4 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListAST & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_semanticInstructionListAST & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMultiReaderName,
                                ptr->mReaderCategoryFormalInputParameterList,
                                ptr->mReturnedTypeName,
                                ptr->mReturnedVariableName,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST  GGS_multiReaderListAST::
constructor_emptyList (void) {
  GGS_multiReaderListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST  GGS_multiReaderListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  GGS_multiReaderListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
internalSubListWithRange (GGS_multiReaderListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMultiReaderName, ptr->mReaderCategoryFormalInputParameterList, ptr->mReturnedTypeName, ptr->mReturnedVariableName, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_multiReaderListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_multiReaderListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiReaderListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@multiReaderListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListAST & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_semanticInstructionListAST & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMultiReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListAST & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_semanticInstructionListAST & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMultiReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListAST & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_semanticInstructionListAST & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMultiReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListAST & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_semanticInstructionListAST & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMultiReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListAST::
reader_mMultiReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMultiReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_multiReaderListAST::
reader_mReaderCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReaderCategoryFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListAST::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListAST::
reader_mReturnedVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_multiReaderListAST::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMMultiReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMultiReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMReaderCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReaderCategoryFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMReturnedVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListAST::cEnumerator::_mMultiReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMultiReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_multiReaderListAST::cEnumerator::_mReaderCategoryFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReaderCategoryFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListAST::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListAST::cEnumerator::_mReturnedVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedVariableName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_multiReaderListAST::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiReaderListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiReaderListAST * p = NULL ;
    macroMyNew (p, GGS_multiReaderListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiReaderListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiReaderListAST * p = dynamic_cast <const GGS_multiReaderListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiReaderListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiReaderListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiReaderListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiReaderListMapAST ("multiReaderListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_multiReaderListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_multiReaderListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_multiReaderListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_multiReaderListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST GGS_multiReaderListMapAST::
constructor_emptyMap (void) {
  GGS_multiReaderListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiReaderListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@multiReaderListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST GGS_multiReaderListMapAST::
operator_concat (const GGS_multiReaderListMapAST & inOperand) const {
  GGS_multiReaderListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListMapAST::
dotAssign_operation (const GGS_multiReaderListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_multiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListAST & inAttribute1,
                      const GGS_lstring & inAttribute2,
                      const GGS_lstring & inAttribute3,
                      const GGS_semanticInstructionListAST & inAttribute4) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt () && inAttribute3.isBuilt () && inAttribute4.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_multiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2, inAttribute3, inAttribute4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_multiReaderListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_multiReaderListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_multiReaderListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_multiReaderListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST::cEnumerator::
cEnumerator (const GGS_multiReaderListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_multiReaderListAST & GGS_multiReaderListMapAST::cEnumerator::
_mList (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiReaderListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiReaderListMapAST * p = NULL ;
    macroMyNew (p, GGS_multiReaderListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST GGS_multiReaderListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiReaderListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiReaderListMapAST * p = dynamic_cast <const GGS_multiReaderListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiReaderListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiReaderListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiReaderListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridingMultiReaderListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingMultiReaderListAST::
elementOf_GGS_overridingMultiReaderListAST (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mOverridingMultiReaderName (argument_0),
mOverridingReaderFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2),
mReturnedVariableName (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingMultiReaderListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingMultiReaderListAST * ptr = dynamic_cast <const elementOf_GGS_overridingMultiReaderListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverridingMultiReaderName.operator_isEqual (ptr->mOverridingMultiReaderName).boolValue ()
         && mOverridingReaderFormalInputParameterList.operator_isEqual (ptr->mOverridingReaderFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue ()
         && mReturnedVariableName.operator_isEqual (ptr->mReturnedVariableName).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingMultiReaderListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingMultiReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingReaderFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@overridingMultiReaderListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiReaderListAST ("overridingMultiReaderListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListAST::
operator_concat (const GGS_overridingMultiReaderListAST & inOperand) const {
  GGS_overridingMultiReaderListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
dotAssign_operation (const GGS_overridingMultiReaderListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_overridingMultiReaderListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingMultiReaderName ;
          GGS_formalInputParameterListAST  p_1 = p->mOverridingReaderFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_semanticInstructionListAST  p_4 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListAST & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_semanticInstructionListAST & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOverridingMultiReaderName,
                                ptr->mOverridingReaderFormalInputParameterList,
                                ptr->mReturnedTypeName,
                                ptr->mReturnedVariableName,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST  GGS_overridingMultiReaderListAST::
constructor_emptyList (void) {
  GGS_overridingMultiReaderListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST  GGS_overridingMultiReaderListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  GGS_overridingMultiReaderListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
internalSubListWithRange (GGS_overridingMultiReaderListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverridingMultiReaderName, ptr->mOverridingReaderFormalInputParameterList, ptr->mReturnedTypeName, ptr->mReturnedVariableName, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingMultiReaderListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@overridingMultiReaderListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListAST & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_semanticInstructionListAST & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingMultiReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListAST & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_semanticInstructionListAST & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingMultiReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListAST & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_semanticInstructionListAST & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingMultiReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListAST & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_semanticInstructionListAST & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingMultiReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListAST::
reader_mOverridingMultiReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingMultiReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_overridingMultiReaderListAST::
reader_mOverridingReaderFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingReaderFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListAST::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListAST::
reader_mReturnedVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_overridingMultiReaderListAST::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMOverridingMultiReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingMultiReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMOverridingReaderFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingReaderFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMReturnedVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListAST::cEnumerator::_mOverridingMultiReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingMultiReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_overridingMultiReaderListAST::cEnumerator::_mOverridingReaderFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingReaderFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListAST::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListAST::cEnumerator::_mReturnedVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedVariableName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_overridingMultiReaderListAST::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiReaderListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiReaderListAST * p = NULL ;
    macroMyNew (p, GGS_overridingMultiReaderListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiReaderListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiReaderListAST * p = dynamic_cast <const GGS_overridingMultiReaderListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiReaderListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiReaderListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiReaderListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiReaderListMapAST ("overridingMultiReaderListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingMultiReaderListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingMultiReaderListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingMultiReaderListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingMultiReaderListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST GGS_overridingMultiReaderListMapAST::
constructor_emptyMap (void) {
  GGS_overridingMultiReaderListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingMultiReaderListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@overridingMultiReaderListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST GGS_overridingMultiReaderListMapAST::
operator_concat (const GGS_overridingMultiReaderListMapAST & inOperand) const {
  GGS_overridingMultiReaderListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListMapAST::
dotAssign_operation (const GGS_overridingMultiReaderListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_overridingMultiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListAST & inAttribute1,
                      const GGS_lstring & inAttribute2,
                      const GGS_lstring & inAttribute3,
                      const GGS_semanticInstructionListAST & inAttribute4) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt () && inAttribute3.isBuilt () && inAttribute4.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_overridingMultiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2, inAttribute3, inAttribute4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingMultiReaderListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingMultiReaderListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingMultiReaderListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST::cEnumerator::
cEnumerator (const GGS_overridingMultiReaderListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingMultiReaderListAST & GGS_overridingMultiReaderListMapAST::cEnumerator::
_mList (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiReaderListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiReaderListMapAST * p = NULL ;
    macroMyNew (p, GGS_overridingMultiReaderListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST GGS_overridingMultiReaderListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiReaderListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiReaderListMapAST * p = dynamic_cast <const GGS_overridingMultiReaderListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiReaderListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiReaderListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiReaderListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of 'semanticDeclarationStructAST' struct           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationStructAST ("semanticDeclarationStructAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST::GGS_semanticDeclarationStructAST (void) :
mSemanticDeclarationList (),
mAbstractCategoryMethodListMap (),
mCategoryMethodListMap (),
mOverridingCategoryMethodListMap (),
mAbstractCategoryReaderListMap (),
mCategoryReaderListMap (),
mOverridingCategoryReaderListMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST::~GGS_semanticDeclarationStructAST (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationStructAST::drop (void) {
  mSemanticDeclarationList.drop () ;
  mAbstractCategoryMethodListMap.drop () ;
  mCategoryMethodListMap.drop () ;
  mOverridingCategoryMethodListMap.drop () ;
  mAbstractCategoryReaderListMap.drop () ;
  mCategoryReaderListMap.drop () ;
  mOverridingCategoryReaderListMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticDeclarationStructAST::isBuilt (void) const {
  return mSemanticDeclarationList.isBuilt ()
    && mAbstractCategoryMethodListMap.isBuilt ()
    && mCategoryMethodListMap.isBuilt ()
    && mOverridingCategoryMethodListMap.isBuilt ()
    && mAbstractCategoryReaderListMap.isBuilt ()
    && mCategoryReaderListMap.isBuilt ()
    && mOverridingCategoryReaderListMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStructAST::
operator_isEqual (const GGS_semanticDeclarationStructAST & inOperand) const {
  return mSemanticDeclarationList.operator_isEqual (inOperand.mSemanticDeclarationList)
    .operator_and (mAbstractCategoryMethodListMap.operator_isEqual (inOperand.mAbstractCategoryMethodListMap))
    .operator_and (mCategoryMethodListMap.operator_isEqual (inOperand.mCategoryMethodListMap))
    .operator_and (mOverridingCategoryMethodListMap.operator_isEqual (inOperand.mOverridingCategoryMethodListMap))
    .operator_and (mAbstractCategoryReaderListMap.operator_isEqual (inOperand.mAbstractCategoryReaderListMap))
    .operator_and (mCategoryReaderListMap.operator_isEqual (inOperand.mCategoryReaderListMap))
    .operator_and (mOverridingCategoryReaderListMap.operator_isEqual (inOperand.mOverridingCategoryReaderListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStructAST::
operator_isNotEqual (const GGS_semanticDeclarationStructAST & inOperand) const {
  return mSemanticDeclarationList.operator_isNotEqual (inOperand.mSemanticDeclarationList)
    .operator_or (mAbstractCategoryMethodListMap.operator_isNotEqual (inOperand.mAbstractCategoryMethodListMap))
    .operator_or (mCategoryMethodListMap.operator_isNotEqual (inOperand.mCategoryMethodListMap))
    .operator_or (mOverridingCategoryMethodListMap.operator_isNotEqual (inOperand.mOverridingCategoryMethodListMap))
    .operator_or (mAbstractCategoryReaderListMap.operator_isNotEqual (inOperand.mAbstractCategoryReaderListMap))
    .operator_or (mCategoryReaderListMap.operator_isNotEqual (inOperand.mCategoryReaderListMap))
    .operator_or (mOverridingCategoryReaderListMap.operator_isNotEqual (inOperand.mOverridingCategoryReaderListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST GGS_semanticDeclarationStructAST::
constructor_new (const GGS_semanticDeclarationListAST & argument_0,
                 const GGS_abstractMultiMethodListMapAST& argument_1,
                 const GGS_multiMethodListMapAST& argument_2,
                 const GGS_overridingMultiMethodListMapAST& argument_3,
                 const GGS_abstractMultiReaderListMapAST& argument_4,
                 const GGS_multiReaderListMapAST& argument_5,
                 const GGS_overridingMultiReaderListMapAST& argument_6) {
  GGS_semanticDeclarationStructAST result ;
  result.mSemanticDeclarationList = argument_0 ;
  result.mAbstractCategoryMethodListMap = argument_1 ;
  result.mCategoryMethodListMap = argument_2 ;
  result.mOverridingCategoryMethodListMap = argument_3 ;
  result.mAbstractCategoryReaderListMap = argument_4 ;
  result.mCategoryReaderListMap = argument_5 ;
  result.mOverridingCategoryReaderListMap = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationStructAST::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticDeclarationStructAST" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mSemanticDeclarationList " ;
    _s << mSemanticDeclarationList.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryMethodListMap " ;
    _s << mAbstractCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryMethodListMap " ;
    _s << mCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryMethodListMap " ;
    _s << mOverridingCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryReaderListMap " ;
    _s << mAbstractCategoryReaderListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryReaderListMap " ;
    _s << mCategoryReaderListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryReaderListMap " ;
    _s << mOverridingCategoryReaderListMap.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationStructAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationStructAST * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationStructAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST GGS_semanticDeclarationStructAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationStructAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationStructAST * p = dynamic_cast <const GGS_semanticDeclarationStructAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationStructAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationStructAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationStructAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@attributeInCollectionListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeInCollectionListAST::
elementOf_GGS_attributeInCollectionListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeInCollectionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_attributeInCollectionListAST * ptr = dynamic_cast <const elementOf_GGS_attributeInCollectionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeName.operator_isEqual (ptr->mAttributeTypeName).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeInCollectionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@attributeInCollectionListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_attributeInCollectionListAST ("attributeInCollectionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST GGS_attributeInCollectionListAST::
operator_concat (const GGS_attributeInCollectionListAST & inOperand) const {
  GGS_attributeInCollectionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
dotAssign_operation (const GGS_attributeInCollectionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_attributeInCollectionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeName,
                                ptr->mAttributeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_attributeInCollectionListAST::
constructor_emptyList (void) {
  GGS_attributeInCollectionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_attributeInCollectionListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_attributeInCollectionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
internalSubListWithRange (GGS_attributeInCollectionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeName, ptr->mAttributeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST GGS_attributeInCollectionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST GGS_attributeInCollectionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeInCollectionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@attributeInCollectionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollectionListAST::
reader_mAttributeTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollectionListAST::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_setMAttributeTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_attributeInCollectionListAST::cEnumerator::_mAttributeTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_attributeInCollectionListAST::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_attributeInCollectionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_attributeInCollectionListAST * p = NULL ;
    macroMyNew (p, GGS_attributeInCollectionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST GGS_attributeInCollectionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_attributeInCollectionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_attributeInCollectionListAST * p = dynamic_cast <const GGS_attributeInCollectionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_attributeInCollectionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_attributeInCollectionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_attributeInCollectionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_listmapDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listmapDeclarationAST::
cPtr_listmapDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mListmapTypeName (argument_0),
mAssociatedListTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listmapDeclarationAST * GGS_listmapDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listmapDeclarationAST) ;
    return (cPtr_listmapDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listmapDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listmapDeclarationAST * ptr = dynamic_cast <const cPtr_listmapDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListmapTypeName.operator_isEqual (ptr->mListmapTypeName).boolValue ()
         && mAssociatedListTypeName.operator_isEqual (ptr->mAssociatedListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listmapDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listmapDeclarationAST:"
           << mListmapTypeName.reader_description (inIndentation + 1)
           << mAssociatedListTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listmapDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listmapDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listmapDeclarationAST (& typeid (cPtr_listmapDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listmapDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__listmapDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listmapDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listmapDeclarationAST (mListmapTypeName, mAssociatedListTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_listmapDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listmapDeclarationAST ("listmapDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_listmapDeclarationAST::
GGS_listmapDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationAST::
GGS_listmapDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listmapDeclarationAST GGS_listmapDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listmapDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_listmapDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listmapDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listmapDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationAST GGS_listmapDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_listmapDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listmapDeclarationAST::
reader_mListmapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapDeclarationAST *) mPointer)->mListmapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listmapDeclarationAST::
reader_mAssociatedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapDeclarationAST *) mPointer)->mAssociatedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listmapDeclarationAST::actualTypeName (void) const {
  return "listmapDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listmapDeclarationAST ("listmapDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_listmapDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listmapDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listmapDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_listmapDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationAST GGS_listmapDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listmapDeclarationAST * p = dynamic_cast <const GGS_listmapDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listmapDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listmapDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listmapDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Class for 'mapAutomatonMessageKind' Enumeration               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapAutomatonMessageKind ("mapAutomatonMessageKind", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_mapAutomatonMessageKind::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonMessageKind::
operator_isEqual (const GGS_mapAutomatonMessageKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonMessageKind::
operator_isNotEqual (const GGS_mapAutomatonMessageKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonMessageKind::
operator_infOrEqual (const GGS_mapAutomatonMessageKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonMessageKind::
operator_supOrEqual (const GGS_mapAutomatonMessageKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonMessageKind::
operator_strictInf (const GGS_mapAutomatonMessageKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_mapAutomatonMessageKind::
operator_strictSup (const GGS_mapAutomatonMessageKind inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapAutomatonMessageKind::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @mapAutomatonMessageKind" ;
  switch (mValue) {
  case enum_errorMessage:
    s << " errorMessage>" ;
    break ;
  case enum_noMessage:
    s << " noMessage>" ;
    break ;
  case enum_warningMessage:
    s << " warningMessage>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapAutomatonMessageKind::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapAutomatonMessageKind * p = NULL ;
    macroMyNew (p, GGS_mapAutomatonMessageKind (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonMessageKind GGS_mapAutomatonMessageKind::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapAutomatonMessageKind result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapAutomatonMessageKind * p = dynamic_cast <const GGS_mapAutomatonMessageKind *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapAutomatonMessageKind, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapAutomatonMessageKind::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapAutomatonMessageKind ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@mapStateTransitionList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapStateTransitionList::
elementOf_GGS_mapStateTransitionList (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_mapAutomatonMessageKind& argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mActionName (argument_0),
mTargetStateName (argument_1),
mTransitionMessageKind (argument_2),
mTransitionMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapStateTransitionList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapStateTransitionList * ptr = dynamic_cast <const elementOf_GGS_mapStateTransitionList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActionName.operator_isEqual (ptr->mActionName).boolValue ()
         && mTargetStateName.operator_isEqual (ptr->mTargetStateName).boolValue ()
         && mTransitionMessageKind.operator_isEqual (ptr->mTransitionMessageKind).boolValue ()
         && mTransitionMessage.operator_isEqual (ptr->mTransitionMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapStateTransitionList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTargetStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionMessageKind.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@mapStateTransitionList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapStateTransitionList ("mapStateTransitionList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_mapAutomatonMessageKind& argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_mapAutomatonMessageKind& argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_mapAutomatonMessageKind& argument_2,
                                const GGS_lstring & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionList GGS_mapStateTransitionList::
operator_concat (const GGS_mapStateTransitionList & inOperand) const {
  GGS_mapStateTransitionList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
dotAssign_operation (const GGS_mapStateTransitionList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapStateTransitionList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mActionName ;
          GGS_lstring  p_1 = p->mTargetStateName ;
          GGS_mapAutomatonMessageKind p_2 = p->mTransitionMessageKind ;
          GGS_lstring  p_3 = p->mTransitionMessage ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_mapAutomatonMessageKind& argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActionName,
                                ptr->mTargetStateName,
                                ptr->mTransitionMessageKind,
                                ptr->mTransitionMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionList  GGS_mapStateTransitionList::
constructor_emptyList (void) {
  GGS_mapStateTransitionList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionList  GGS_mapStateTransitionList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_mapAutomatonMessageKind& argument_2,
                                const GGS_lstring & argument_3) {
  GGS_mapStateTransitionList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
internalSubListWithRange (GGS_mapStateTransitionList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActionName, ptr->mTargetStateName, ptr->mTransitionMessageKind, ptr->mTransitionMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionList GGS_mapStateTransitionList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapStateTransitionList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionList GGS_mapStateTransitionList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapStateTransitionList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapStateTransitionList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapStateTransitionList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_mapAutomatonMessageKind& _out_2,
              GGS_lstring & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionName ;
    _out_1 = ptr->mTargetStateName ;
    _out_2 = ptr->mTransitionMessageKind ;
    _out_3 = ptr->mTransitionMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_mapAutomatonMessageKind& _out_2,
             GGS_lstring & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionName ;
    _out_1 = ptr->mTargetStateName ;
    _out_2 = ptr->mTransitionMessageKind ;
    _out_3 = ptr->mTransitionMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_mapAutomatonMessageKind& _out_2,
                 GGS_lstring & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionName ;
    _out_1 = ptr->mTargetStateName ;
    _out_2 = ptr->mTransitionMessageKind ;
    _out_3 = ptr->mTransitionMessage ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_mapAutomatonMessageKind& _out_2,
                GGS_lstring & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActionName ;
    _out_1 = ptr->mTargetStateName ;
    _out_2 = ptr->mTransitionMessageKind ;
    _out_3 = ptr->mTransitionMessage ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapStateTransitionList::
reader_mActionNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActionName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapStateTransitionList::
reader_mTargetStateNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTargetStateName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonMessageKind GGS_mapStateTransitionList::
reader_mTransitionMessageKindAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_mapAutomatonMessageKind result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTransitionMessageKind ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapStateTransitionList::
reader_mTransitionMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTransitionMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
modifier_setMActionNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActionName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
modifier_setMTargetStateNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTargetStateName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
modifier_setMTransitionMessageKindAtIndex (C_Compiler & inLexique,
                              const GGS_mapAutomatonMessageKind & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTransitionMessageKind = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateTransitionList::
modifier_setMTransitionMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTransitionMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapStateTransitionList::cEnumerator::_mActionName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActionName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapStateTransitionList::cEnumerator::_mTargetStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTargetStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapAutomatonMessageKind & GGS_mapStateTransitionList::cEnumerator::_mTransitionMessageKind (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionMessageKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapStateTransitionList::cEnumerator::_mTransitionMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapStateTransitionList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapStateTransitionList * p = NULL ;
    macroMyNew (p, GGS_mapStateTransitionList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionList GGS_mapStateTransitionList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapStateTransitionList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapStateTransitionList * p = dynamic_cast <const GGS_mapStateTransitionList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapStateTransitionList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapStateTransitionList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapStateTransitionList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     Element of list '@mapStateList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapStateList::
elementOf_GGS_mapStateList (const GGS_lstring & argument_0,
                                const GGS_mapAutomatonMessageKind& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_mapStateTransitionList & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mStateName (argument_0),
mStateMessageKind (argument_1),
mStateMessage (argument_2),
mTransitionList (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapStateList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapStateList * ptr = dynamic_cast <const elementOf_GGS_mapStateList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStateName.operator_isEqual (ptr->mStateName).boolValue ()
         && mStateMessageKind.operator_isEqual (ptr->mStateMessageKind).boolValue ()
         && mStateMessage.operator_isEqual (ptr->mStateMessage).boolValue ()
         && mTransitionList.operator_isEqual (ptr->mTransitionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapStateList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateMessageKind.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStateMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTransitionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           List '@mapStateList'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapStateList ("mapStateList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_mapStateList::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_mapAutomatonMessageKind& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_mapStateTransitionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_mapAutomatonMessageKind& argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_mapStateTransitionList & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_mapAutomatonMessageKind& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_mapStateTransitionList & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateList GGS_mapStateList::
operator_concat (const GGS_mapStateList & inOperand) const {
  GGS_mapStateList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
dotAssign_operation (const GGS_mapStateList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapStateList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mStateName ;
          GGS_mapAutomatonMessageKind p_1 = p->mStateMessageKind ;
          GGS_lstring  p_2 = p->mStateMessage ;
          GGS_mapStateTransitionList  p_3 = p->mTransitionList ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_mapAutomatonMessageKind& argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_mapStateTransitionList & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStateName,
                                ptr->mStateMessageKind,
                                ptr->mStateMessage,
                                ptr->mTransitionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateList  GGS_mapStateList::
constructor_emptyList (void) {
  GGS_mapStateList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateList  GGS_mapStateList::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_mapAutomatonMessageKind& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_mapStateTransitionList & argument_3) {
  GGS_mapStateList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
internalSubListWithRange (GGS_mapStateList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mStateName, ptr->mStateMessageKind, ptr->mStateMessage, ptr->mTransitionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapStateList GGS_mapStateList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapStateList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateList GGS_mapStateList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapStateList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapStateList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapStateList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_mapAutomatonMessageKind& _out_1,
              GGS_lstring & _out_2,
              GGS_mapStateTransitionList & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateName ;
    _out_1 = ptr->mStateMessageKind ;
    _out_2 = ptr->mStateMessage ;
    _out_3 = ptr->mTransitionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_mapAutomatonMessageKind& _out_1,
             GGS_lstring & _out_2,
             GGS_mapStateTransitionList & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateName ;
    _out_1 = ptr->mStateMessageKind ;
    _out_2 = ptr->mStateMessage ;
    _out_3 = ptr->mTransitionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_mapAutomatonMessageKind& _out_1,
                 GGS_lstring & _out_2,
                 GGS_mapStateTransitionList & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateName ;
    _out_1 = ptr->mStateMessageKind ;
    _out_2 = ptr->mStateMessage ;
    _out_3 = ptr->mTransitionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_mapAutomatonMessageKind& _out_1,
                GGS_lstring & _out_2,
                GGS_mapStateTransitionList & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStateName ;
    _out_1 = ptr->mStateMessageKind ;
    _out_2 = ptr->mStateMessage ;
    _out_3 = ptr->mTransitionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapStateList::
reader_mStateNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStateName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapAutomatonMessageKind GGS_mapStateList::
reader_mStateMessageKindAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_mapAutomatonMessageKind result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStateMessageKind ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapStateList::
reader_mStateMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStateMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateTransitionList  GGS_mapStateList::
reader_mTransitionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_mapStateTransitionList  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTransitionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
modifier_setMStateNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStateName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
modifier_setMStateMessageKindAtIndex (C_Compiler & inLexique,
                              const GGS_mapAutomatonMessageKind & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStateMessageKind = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
modifier_setMStateMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStateMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapStateList::
modifier_setMTransitionListAtIndex (C_Compiler & inLexique,
                              const GGS_mapStateTransitionList  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTransitionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapStateList::cEnumerator::_mStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapAutomatonMessageKind & GGS_mapStateList::cEnumerator::_mStateMessageKind (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateMessageKind ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapStateList::cEnumerator::_mStateMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStateMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_mapStateTransitionList  & GGS_mapStateList::cEnumerator::_mTransitionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTransitionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapStateList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapStateList * p = NULL ;
    macroMyNew (p, GGS_mapStateList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateList GGS_mapStateList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapStateList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapStateList * p = dynamic_cast <const GGS_mapStateList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapStateList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapStateList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapStateList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@insertMethodListAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertMethodListAST::
elementOf_GGS_insertMethodListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMethodName (argument_0),
mErrorMessage (argument_1),
mShadowErrorMessage (argument_2),
mInitialStateName (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_insertMethodListAST * ptr = dynamic_cast <const elementOf_GGS_insertMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mErrorMessage.operator_isEqual (ptr->mErrorMessage).boolValue ()
         && mShadowErrorMessage.operator_isEqual (ptr->mShadowErrorMessage).boolValue ()
         && mInitialStateName.operator_isEqual (ptr->mInitialStateName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInitialStateName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@insertMethodListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_insertMethodListAST ("insertMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST GGS_insertMethodListAST::
operator_concat (const GGS_insertMethodListAST & inOperand) const {
  GGS_insertMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
dotAssign_operation (const GGS_insertMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_insertMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mErrorMessage ;
          GGS_lstring  p_2 = p->mShadowErrorMessage ;
          GGS_lstring  p_3 = p->mInitialStateName ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mErrorMessage,
                                ptr->mShadowErrorMessage,
                                ptr->mInitialStateName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST  GGS_insertMethodListAST::
constructor_emptyList (void) {
  GGS_insertMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST  GGS_insertMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) {
  GGS_insertMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
internalSubListWithRange (GGS_insertMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mErrorMessage, ptr->mShadowErrorMessage, ptr->mInitialStateName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST GGS_insertMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_insertMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST GGS_insertMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_insertMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@insertMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mShadowErrorMessage ;
    _out_3 = ptr->mInitialStateName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mShadowErrorMessage ;
    _out_3 = ptr->mInitialStateName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mShadowErrorMessage ;
    _out_3 = ptr->mInitialStateName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mShadowErrorMessage ;
    _out_3 = ptr->mInitialStateName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_insertMethodListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_insertMethodListAST::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_insertMethodListAST::
reader_mShadowErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mShadowErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_insertMethodListAST::
reader_mInitialStateNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInitialStateName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
modifier_setMShadowErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mShadowErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertMethodListAST::
modifier_setMInitialStateNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInitialStateName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_insertMethodListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_insertMethodListAST::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_insertMethodListAST::cEnumerator::_mShadowErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mShadowErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_insertMethodListAST::cEnumerator::_mInitialStateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInitialStateName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_insertMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_insertMethodListAST * p = NULL ;
    macroMyNew (p, GGS_insertMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST GGS_insertMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_insertMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_insertMethodListAST * p = dynamic_cast <const GGS_insertMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_insertMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_insertMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_insertMethodListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@mapSearchMethodListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapSearchMethodListAST::
elementOf_GGS_mapSearchMethodListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMethodName (argument_0),
mErrorMessage (argument_1),
mActionName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapSearchMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapSearchMethodListAST * ptr = dynamic_cast <const elementOf_GGS_mapSearchMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mErrorMessage.operator_isEqual (ptr->mErrorMessage).boolValue ()
         && mActionName.operator_isEqual (ptr->mActionName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapSearchMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActionName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@mapSearchMethodListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapSearchMethodListAST ("mapSearchMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST GGS_mapSearchMethodListAST::
operator_concat (const GGS_mapSearchMethodListAST & inOperand) const {
  GGS_mapSearchMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
dotAssign_operation (const GGS_mapSearchMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapSearchMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mErrorMessage ;
          GGS_lstring  p_2 = p->mActionName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mErrorMessage,
                                ptr->mActionName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_mapSearchMethodListAST::
constructor_emptyList (void) {
  GGS_mapSearchMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_mapSearchMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_mapSearchMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
internalSubListWithRange (GGS_mapSearchMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mErrorMessage, ptr->mActionName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST GGS_mapSearchMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST GGS_mapSearchMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapSearchMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapSearchMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mActionName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mActionName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mActionName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    _out_2 = ptr->mActionName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapSearchMethodListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapSearchMethodListAST::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapSearchMethodListAST::
reader_mActionNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActionName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapSearchMethodListAST::
modifier_setMActionNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActionName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapSearchMethodListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapSearchMethodListAST::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapSearchMethodListAST::cEnumerator::_mActionName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActionName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapSearchMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapSearchMethodListAST * p = NULL ;
    macroMyNew (p, GGS_mapSearchMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST GGS_mapSearchMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapSearchMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapSearchMethodListAST * p = dynamic_cast <const GGS_mapSearchMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapSearchMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapSearchMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapSearchMethodListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@mapRemoveMethodListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapRemoveMethodListAST::
elementOf_GGS_mapRemoveMethodListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMethodName (argument_0),
mErrorMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapRemoveMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapRemoveMethodListAST * ptr = dynamic_cast <const elementOf_GGS_mapRemoveMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mErrorMessage.operator_isEqual (ptr->mErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapRemoveMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@mapRemoveMethodListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapRemoveMethodListAST ("mapRemoveMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST GGS_mapRemoveMethodListAST::
operator_concat (const GGS_mapRemoveMethodListAST & inOperand) const {
  GGS_mapRemoveMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
dotAssign_operation (const GGS_mapRemoveMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapRemoveMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mErrorMessage ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mErrorMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST  GGS_mapRemoveMethodListAST::
constructor_emptyList (void) {
  GGS_mapRemoveMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST  GGS_mapRemoveMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_mapRemoveMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
internalSubListWithRange (GGS_mapRemoveMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mErrorMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST GGS_mapRemoveMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapRemoveMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST GGS_mapRemoveMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapRemoveMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapRemoveMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapRemoveMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mErrorMessage ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapRemoveMethodListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapRemoveMethodListAST::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapRemoveMethodListAST::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapRemoveMethodListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapRemoveMethodListAST::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapRemoveMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapRemoveMethodListAST * p = NULL ;
    macroMyNew (p, GGS_mapRemoveMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST GGS_mapRemoveMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapRemoveMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapRemoveMethodListAST * p = dynamic_cast <const GGS_mapRemoveMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapRemoveMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapRemoveMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapRemoveMethodListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@insertOrReplaceDeclarationListAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_insertOrReplaceDeclarationListAST::
elementOf_GGS_insertOrReplaceDeclarationListAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInsertOrReplaceDeclarationLocation (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_insertOrReplaceDeclarationListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_insertOrReplaceDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_insertOrReplaceDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInsertOrReplaceDeclarationLocation.operator_isEqual (ptr->mInsertOrReplaceDeclarationLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_insertOrReplaceDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInsertOrReplaceDeclarationLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@insertOrReplaceDeclarationListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_insertOrReplaceDeclarationListAST ("insertOrReplaceDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
internalAppendValues (const GGS_location & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
internalPrependValues (const GGS_location & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
addAssign_operation (const GGS_location & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrReplaceDeclarationListAST GGS_insertOrReplaceDeclarationListAST::
operator_concat (const GGS_insertOrReplaceDeclarationListAST & inOperand) const {
  GGS_insertOrReplaceDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
dotAssign_operation (const GGS_insertOrReplaceDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_insertOrReplaceDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mInsertOrReplaceDeclarationLocation ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInsertOrReplaceDeclarationLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrReplaceDeclarationListAST  GGS_insertOrReplaceDeclarationListAST::
constructor_emptyList (void) {
  GGS_insertOrReplaceDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrReplaceDeclarationListAST  GGS_insertOrReplaceDeclarationListAST::
constructor_listWithValue (const GGS_location & argument_0) {
  GGS_insertOrReplaceDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
internalSubListWithRange (GGS_insertOrReplaceDeclarationListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInsertOrReplaceDeclarationLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_insertOrReplaceDeclarationListAST GGS_insertOrReplaceDeclarationListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_insertOrReplaceDeclarationListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrReplaceDeclarationListAST GGS_insertOrReplaceDeclarationListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_insertOrReplaceDeclarationListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_insertOrReplaceDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@insertOrReplaceDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
method_first (C_Compiler & inLexique,
              GGS_location & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInsertOrReplaceDeclarationLocation ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
method_last (C_Compiler & inLexique,
             GGS_location & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInsertOrReplaceDeclarationLocation ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_location & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInsertOrReplaceDeclarationLocation ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_location & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInsertOrReplaceDeclarationLocation ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_location  GGS_insertOrReplaceDeclarationListAST::
reader_mInsertOrReplaceDeclarationLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInsertOrReplaceDeclarationLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_insertOrReplaceDeclarationListAST::
modifier_setMInsertOrReplaceDeclarationLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInsertOrReplaceDeclarationLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_insertOrReplaceDeclarationListAST::cEnumerator::_mInsertOrReplaceDeclarationLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInsertOrReplaceDeclarationLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_insertOrReplaceDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_insertOrReplaceDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_insertOrReplaceDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrReplaceDeclarationListAST GGS_insertOrReplaceDeclarationListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_insertOrReplaceDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_insertOrReplaceDeclarationListAST * p = dynamic_cast <const GGS_insertOrReplaceDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_insertOrReplaceDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_insertOrReplaceDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_insertOrReplaceDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_mapDeclarationAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapDeclarationAST::
cPtr_mapDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1,
                                const GGS_insertMethodListAST & argument_2,
                                const GGS_mapSearchMethodListAST & argument_3,
                                const GGS_mapRemoveMethodListAST & argument_4,
                                const GGS_insertOrReplaceDeclarationListAST & argument_5,
                                const GGS_mapStateList & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mMapTypeName (argument_0),
mAttributeList (argument_1),
mInsertMethodList (argument_2),
mSearchMethodList (argument_3),
mRemoveMethodList (argument_4),
mInsertOrReplaceDeclarationListAST (argument_5),
mMapStateList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapDeclarationAST * GGS_mapDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapDeclarationAST) ;
    return (cPtr_mapDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapDeclarationAST * ptr = dynamic_cast <const cPtr_mapDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && mRemoveMethodList.operator_isEqual (ptr->mRemoveMethodList).boolValue ()
         && mInsertOrReplaceDeclarationListAST.operator_isEqual (ptr->mInsertOrReplaceDeclarationListAST).boolValue ()
         && mMapStateList.operator_isEqual (ptr->mMapStateList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapDeclarationAST:"
           << mMapTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mInsertMethodList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1)
           << mRemoveMethodList.reader_description (inIndentation + 1)
           << mInsertOrReplaceDeclarationListAST.reader_description (inIndentation + 1)
           << mMapStateList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapDeclarationAST (& typeid (cPtr_mapDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__mapDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapDeclarationAST (mMapTypeName, mAttributeList, mInsertMethodList, mSearchMethodList, mRemoveMethodList, mInsertOrReplaceDeclarationListAST, mMapStateList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_mapDeclarationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapDeclarationAST ("mapDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_mapDeclarationAST::
GGS_mapDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationAST::
GGS_mapDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapDeclarationAST GGS_mapDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_mapDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationAST GGS_mapDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListAST & argument_1,
                 const GGS_insertMethodListAST & argument_2,
                 const GGS_mapSearchMethodListAST & argument_3,
                 const GGS_mapRemoveMethodListAST & argument_4,
                 const GGS_insertOrReplaceDeclarationListAST & argument_5,
                 const GGS_mapStateList & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_mapDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclarationAST::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_mapDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertMethodListAST  GGS_mapDeclarationAST::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapSearchMethodListAST  GGS_mapDeclarationAST::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapSearchMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapRemoveMethodListAST  GGS_mapDeclarationAST::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapRemoveMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_insertOrReplaceDeclarationListAST  GGS_mapDeclarationAST::
reader_mInsertOrReplaceDeclarationListAST (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_insertOrReplaceDeclarationListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mInsertOrReplaceDeclarationListAST ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapStateList  GGS_mapDeclarationAST::
reader_mMapStateList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapStateList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mMapStateList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapDeclarationAST::actualTypeName (void) const {
  return "mapDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapDeclarationAST ("mapDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_mapDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_mapDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationAST GGS_mapDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapDeclarationAST * p = dynamic_cast <const GGS_mapDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_mapProxyDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapProxyDeclarationAST::
cPtr_mapProxyDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mMapProxyTypeName (argument_0),
mAssociatedMapTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapProxyDeclarationAST * GGS_mapProxyDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapProxyDeclarationAST) ;
    return (cPtr_mapProxyDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapProxyDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapProxyDeclarationAST * ptr = dynamic_cast <const cPtr_mapProxyDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapProxyTypeName.operator_isEqual (ptr->mMapProxyTypeName).boolValue ()
         && mAssociatedMapTypeName.operator_isEqual (ptr->mAssociatedMapTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapProxyDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapProxyDeclarationAST:"
           << mMapProxyTypeName.reader_description (inIndentation + 1)
           << mAssociatedMapTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapProxyDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapProxyDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapProxyDeclarationAST (& typeid (cPtr_mapProxyDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapProxyDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__mapProxyDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapProxyDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapProxyDeclarationAST (mMapProxyTypeName, mAssociatedMapTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_mapProxyDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapProxyDeclarationAST ("mapProxyDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_mapProxyDeclarationAST::
GGS_mapProxyDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyDeclarationAST::
GGS_mapProxyDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapProxyDeclarationAST GGS_mapProxyDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapProxyDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapProxyDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_mapProxyDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapProxyDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapProxyDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyDeclarationAST GGS_mapProxyDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_mapProxyDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_mapProxyDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapProxyDeclarationAST::
reader_mMapProxyTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapProxyDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapProxyDeclarationAST *) mPointer)->mMapProxyTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapProxyDeclarationAST::
reader_mAssociatedMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapProxyDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapProxyDeclarationAST *) mPointer)->mAssociatedMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapProxyDeclarationAST::actualTypeName (void) const {
  return "mapProxyDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapProxyDeclarationAST ("mapProxyDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_mapProxyDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapProxyDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapProxyDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_mapProxyDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapProxyDeclarationAST GGS_mapProxyDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapProxyDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapProxyDeclarationAST * p = dynamic_cast <const GGS_mapProxyDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapProxyDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapProxyDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapProxyDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@abstractMethodDefinitionListAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMethodDefinitionListAST::
elementOf_GGS_abstractMethodDefinitionListAST (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsOverriding (argument_0),
mMethodName (argument_1),
mSignature (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMethodDefinitionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMethodDefinitionListAST * ptr = dynamic_cast <const elementOf_GGS_abstractMethodDefinitionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsOverriding.operator_isEqual (ptr->mIsOverriding).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMethodDefinitionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsOverriding.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@abstractMethodDefinitionListAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMethodDefinitionListAST ("abstractMethodDefinitionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST GGS_abstractMethodDefinitionListAST::
operator_concat (const GGS_abstractMethodDefinitionListAST & inOperand) const {
  GGS_abstractMethodDefinitionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
dotAssign_operation (const GGS_abstractMethodDefinitionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstractMethodDefinitionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsOverriding ;
          GGS_lstring  p_1 = p->mMethodName ;
          GGS_formalParameterListAST  p_2 = p->mSignature ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalParameterListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsOverriding,
                                ptr->mMethodName,
                                ptr->mSignature
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST  GGS_abstractMethodDefinitionListAST::
constructor_emptyList (void) {
  GGS_abstractMethodDefinitionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST  GGS_abstractMethodDefinitionListAST::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListAST & argument_2) {
  GGS_abstractMethodDefinitionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
internalSubListWithRange (GGS_abstractMethodDefinitionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsOverriding, ptr->mMethodName, ptr->mSignature) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST GGS_abstractMethodDefinitionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST GGS_abstractMethodDefinitionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMethodDefinitionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstractMethodDefinitionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_formalParameterListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_formalParameterListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalParameterListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_formalParameterListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_abstractMethodDefinitionListAST::
reader_mIsOverridingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsOverriding ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinitionListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_abstractMethodDefinitionListAST::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_setMIsOverridingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsOverriding = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_abstractMethodDefinitionListAST::cEnumerator::_mIsOverriding (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsOverriding ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMethodDefinitionListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_abstractMethodDefinitionListAST::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMethodDefinitionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMethodDefinitionListAST * p = NULL ;
    macroMyNew (p, GGS_abstractMethodDefinitionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST GGS_abstractMethodDefinitionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMethodDefinitionListAST * p = dynamic_cast <const GGS_abstractMethodDefinitionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMethodDefinitionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMethodDefinitionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMethodDefinitionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@methodDefinitionListAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_methodDefinitionListAST::
elementOf_GGS_methodDefinitionListAST (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListAST & argument_2,
                                const GGS_semanticInstructionListAST & argument_3,
                                const GGS_location & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsOverriding (argument_0),
mMethodName (argument_1),
mSignature (argument_2),
mInstructionList (argument_3),
mEndOfMethodLocation (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_methodDefinitionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_methodDefinitionListAST * ptr = dynamic_cast <const elementOf_GGS_methodDefinitionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsOverriding.operator_isEqual (ptr->mIsOverriding).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue ()
         && mEndOfMethodLocation.operator_isEqual (ptr->mEndOfMethodLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_methodDefinitionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsOverriding.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfMethodLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@methodDefinitionListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodDefinitionListAST ("methodDefinitionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListAST & argument_2,
                    const GGS_semanticInstructionListAST & argument_3,
                    const GGS_location & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalParameterListAST & argument_2,
                    const GGS_semanticInstructionListAST & argument_3,
                    const GGS_location & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListAST & argument_2,
                                const GGS_semanticInstructionListAST & argument_3,
                                const GGS_location & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST GGS_methodDefinitionListAST::
operator_concat (const GGS_methodDefinitionListAST & inOperand) const {
  GGS_methodDefinitionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
dotAssign_operation (const GGS_methodDefinitionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_methodDefinitionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsOverriding ;
          GGS_lstring  p_1 = p->mMethodName ;
          GGS_formalParameterListAST  p_2 = p->mSignature ;
          GGS_semanticInstructionListAST  p_3 = p->mInstructionList ;
          GGS_location  p_4 = p->mEndOfMethodLocation ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalParameterListAST & argument_2,
                     const GGS_semanticInstructionListAST & argument_3,
                     const GGS_location & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsOverriding,
                                ptr->mMethodName,
                                ptr->mSignature,
                                ptr->mInstructionList,
                                ptr->mEndOfMethodLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST  GGS_methodDefinitionListAST::
constructor_emptyList (void) {
  GGS_methodDefinitionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST  GGS_methodDefinitionListAST::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalParameterListAST & argument_2,
                                const GGS_semanticInstructionListAST & argument_3,
                                const GGS_location & argument_4) {
  GGS_methodDefinitionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
internalSubListWithRange (GGS_methodDefinitionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsOverriding, ptr->mMethodName, ptr->mSignature, ptr->mInstructionList, ptr->mEndOfMethodLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST GGS_methodDefinitionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST GGS_methodDefinitionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodDefinitionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@methodDefinitionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_formalParameterListAST & _out_2,
              GGS_semanticInstructionListAST & _out_3,
              GGS_location & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
    _out_4 = ptr->mEndOfMethodLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_formalParameterListAST & _out_2,
             GGS_semanticInstructionListAST & _out_3,
             GGS_location & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
    _out_4 = ptr->mEndOfMethodLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalParameterListAST & _out_2,
                 GGS_semanticInstructionListAST & _out_3,
                 GGS_location & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
    _out_4 = ptr->mEndOfMethodLocation ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_formalParameterListAST & _out_2,
                GGS_semanticInstructionListAST & _out_3,
                GGS_location & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsOverriding ;
    _out_1 = ptr->mMethodName ;
    _out_2 = ptr->mSignature ;
    _out_3 = ptr->mInstructionList ;
    _out_4 = ptr->mEndOfMethodLocation ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_methodDefinitionListAST::
reader_mIsOverridingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsOverriding ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodDefinitionListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_methodDefinitionListAST::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_methodDefinitionListAST::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_methodDefinitionListAST::
reader_mEndOfMethodLocationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfMethodLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_setMIsOverridingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsOverriding = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_setMEndOfMethodLocationAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfMethodLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_methodDefinitionListAST::cEnumerator::_mIsOverriding (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsOverriding ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_methodDefinitionListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_methodDefinitionListAST::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_methodDefinitionListAST::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_methodDefinitionListAST::cEnumerator::_mEndOfMethodLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfMethodLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_methodDefinitionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodDefinitionListAST * p = NULL ;
    macroMyNew (p, GGS_methodDefinitionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST GGS_methodDefinitionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodDefinitionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodDefinitionListAST * p = dynamic_cast <const GGS_methodDefinitionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodDefinitionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodDefinitionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodDefinitionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Element of list '@lazyAttributeListAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lazyAttributeListAST::
elementOf_GGS_lazyAttributeListAST (const GGS_location & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mLocationMagicNumber (argument_0),
mAttributeList (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lazyAttributeListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_lazyAttributeListAST * ptr = dynamic_cast <const elementOf_GGS_lazyAttributeListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocationMagicNumber.operator_isEqual (ptr->mLocationMagicNumber).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lazyAttributeListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLocationMagicNumber.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@lazyAttributeListAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lazyAttributeListAST ("lazyAttributeListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
internalAppendValues (const GGS_location & argument_0,
                    const GGS_attributeInCollectionListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
internalPrependValues (const GGS_location & argument_0,
                    const GGS_attributeInCollectionListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
addAssign_operation (const GGS_location & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListAST GGS_lazyAttributeListAST::
operator_concat (const GGS_lazyAttributeListAST & inOperand) const {
  GGS_lazyAttributeListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
dotAssign_operation (const GGS_lazyAttributeListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_lazyAttributeListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_location  p_0 = p->mLocationMagicNumber ;
          GGS_attributeInCollectionListAST  p_1 = p->mAttributeList ;
          GGS_semanticInstructionListAST  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_location & argument_0,
                     const GGS_attributeInCollectionListAST & argument_1,
                     const GGS_semanticInstructionListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLocationMagicNumber,
                                ptr->mAttributeList,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListAST  GGS_lazyAttributeListAST::
constructor_emptyList (void) {
  GGS_lazyAttributeListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListAST  GGS_lazyAttributeListAST::
constructor_listWithValue (const GGS_location & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  GGS_lazyAttributeListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
internalSubListWithRange (GGS_lazyAttributeListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLocationMagicNumber, ptr->mAttributeList, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListAST GGS_lazyAttributeListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_lazyAttributeListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListAST GGS_lazyAttributeListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_lazyAttributeListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lazyAttributeListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@lazyAttributeListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
method_first (C_Compiler & inLexique,
              GGS_location & _out_0,
              GGS_attributeInCollectionListAST & _out_1,
              GGS_semanticInstructionListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mAttributeList ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
method_last (C_Compiler & inLexique,
             GGS_location & _out_0,
             GGS_attributeInCollectionListAST & _out_1,
             GGS_semanticInstructionListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mAttributeList ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_location & _out_0,
                 GGS_attributeInCollectionListAST & _out_1,
                 GGS_semanticInstructionListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mAttributeList ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_location & _out_0,
                GGS_attributeInCollectionListAST & _out_1,
                GGS_semanticInstructionListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLocationMagicNumber ;
    _out_1 = ptr->mAttributeList ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lazyAttributeListAST::
reader_mLocationMagicNumberAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLocationMagicNumber ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_lazyAttributeListAST::
reader_mAttributeListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_lazyAttributeListAST::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
modifier_setMLocationMagicNumberAtIndex (C_Compiler & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLocationMagicNumber = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
modifier_setMAttributeListAtIndex (C_Compiler & inLexique,
                              const GGS_attributeInCollectionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lazyAttributeListAST::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_lazyAttributeListAST::cEnumerator::_mLocationMagicNumber (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLocationMagicNumber ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_attributeInCollectionListAST  & GGS_lazyAttributeListAST::cEnumerator::_mAttributeList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_lazyAttributeListAST::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_lazyAttributeListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lazyAttributeListAST * p = NULL ;
    macroMyNew (p, GGS_lazyAttributeListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListAST GGS_lazyAttributeListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lazyAttributeListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lazyAttributeListAST * p = dynamic_cast <const GGS_lazyAttributeListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lazyAttributeListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lazyAttributeListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lazyAttributeListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_classDeclarationAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classDeclarationAST::
cPtr_classDeclarationAST (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_attributeInCollectionListAST & argument_4,
                                const GGS_abstractMethodDefinitionListAST & argument_5,
                                const GGS_methodDefinitionListAST & argument_6,
                                const GGS_lazyAttributeListAST & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mIsAbstract (argument_0),
mClassTypeName (argument_1),
mSuperClassName (argument_2),
mClassFeatureList (argument_3),
mAttributeList (argument_4),
mAbstractMethodList (argument_5),
mMethodList (argument_6),
mLazyAttributeList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classDeclarationAST * GGS_classDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_classDeclarationAST) ;
    return (cPtr_classDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classDeclarationAST * ptr = dynamic_cast <const cPtr_classDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && mClassTypeName.operator_isEqual (ptr->mClassTypeName).boolValue ()
         && mSuperClassName.operator_isEqual (ptr->mSuperClassName).boolValue ()
         && mClassFeatureList.operator_isEqual (ptr->mClassFeatureList).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mAbstractMethodList.operator_isEqual (ptr->mAbstractMethodList).boolValue ()
         && mMethodList.operator_isEqual (ptr->mMethodList).boolValue ()
         && mLazyAttributeList.operator_isEqual (ptr->mLazyAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@classDeclarationAST:"
           << mIsAbstract.reader_description (inIndentation + 1)
           << mClassTypeName.reader_description (inIndentation + 1)
           << mSuperClassName.reader_description (inIndentation + 1)
           << mClassFeatureList.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mAbstractMethodList.reader_description (inIndentation + 1)
           << mMethodList.reader_description (inIndentation + 1)
           << mLazyAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classDeclarationAST (& typeid (cPtr_classDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_classDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__classDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classDeclarationAST (mIsAbstract, mClassTypeName, mSuperClassName, mClassFeatureList, mAttributeList, mAbstractMethodList, mMethodList, mLazyAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_classDeclarationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classDeclarationAST ("classDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_classDeclarationAST::
GGS_classDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationAST::
GGS_classDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classDeclarationAST GGS_classDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_classDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationAST GGS_classDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_attributeInCollectionListAST & argument_4,
                 const GGS_abstractMethodDefinitionListAST & argument_5,
                 const GGS_methodDefinitionListAST & argument_6,
                 const GGS_lazyAttributeListAST & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_classDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_classDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classDeclarationAST::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclarationAST::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclarationAST::
reader_mSuperClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_classDeclarationAST::
reader_mClassFeatureList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mClassFeatureList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_classDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST  GGS_classDeclarationAST::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST  GGS_classDeclarationAST::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_methodDefinitionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyAttributeListAST  GGS_classDeclarationAST::
reader_mLazyAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lazyAttributeListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mLazyAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classDeclarationAST::actualTypeName (void) const {
  return "classDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__classDeclarationAST ("classDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_classDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_classDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_classDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationAST GGS_classDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classDeclarationAST * p = dynamic_cast <const GGS_classDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_listDeclarationAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listDeclarationAST::
cPtr_listDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listDeclarationAST * GGS_listDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listDeclarationAST) ;
    return (cPtr_listDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listDeclarationAST * ptr = dynamic_cast <const cPtr_listDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listDeclarationAST:"
           << mListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listDeclarationAST (& typeid (cPtr_listDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__listDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listDeclarationAST (mListTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_listDeclarationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listDeclarationAST ("listDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_listDeclarationAST::
GGS_listDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationAST::
GGS_listDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listDeclarationAST GGS_listDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_listDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationAST GGS_listDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_listDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listDeclarationAST::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclarationAST *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_listDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listDeclarationAST::actualTypeName (void) const {
  return "listDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listDeclarationAST ("listDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_listDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_listDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationAST GGS_listDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listDeclarationAST * p = dynamic_cast <const GGS_listDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_structDeclarationAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structDeclarationAST::
cPtr_structDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mStructTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structDeclarationAST * GGS_structDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structDeclarationAST) ;
    return (cPtr_structDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structDeclarationAST * ptr = dynamic_cast <const cPtr_structDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStructTypeName.operator_isEqual (ptr->mStructTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structDeclarationAST:"
           << mStructTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structDeclarationAST (& typeid (cPtr_structDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__structDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structDeclarationAST (mStructTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_structDeclarationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structDeclarationAST ("structDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_structDeclarationAST::
GGS_structDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationAST::
GGS_structDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structDeclarationAST GGS_structDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_structDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationAST GGS_structDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_structDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_structDeclarationAST::
reader_mStructTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclarationAST *) mPointer)->mStructTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_structDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structDeclarationAST::actualTypeName (void) const {
  return "structDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structDeclarationAST ("structDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_structDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_structDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationAST GGS_structDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structDeclarationAST * p = dynamic_cast <const GGS_structDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@sortedListSortDescriptorListAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortedListSortDescriptorListAST::
elementOf_GGS_sortedListSortDescriptorListAST (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSortedAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortedListSortDescriptorListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortedListSortDescriptorListAST * ptr = dynamic_cast <const elementOf_GGS_sortedListSortDescriptorListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSortedAttributeName.operator_isEqual (ptr->mSortedAttributeName).boolValue ()
         && mAscending.operator_isEqual (ptr->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortedListSortDescriptorListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortedAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@sortedListSortDescriptorListAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedListSortDescriptorListAST ("sortedListSortDescriptorListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST GGS_sortedListSortDescriptorListAST::
operator_concat (const GGS_sortedListSortDescriptorListAST & inOperand) const {
  GGS_sortedListSortDescriptorListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
dotAssign_operation (const GGS_sortedListSortDescriptorListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sortedListSortDescriptorListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortedAttributeName ;
          GGS_bool p_1 = p->mAscending ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSortedAttributeName,
                                ptr->mAscending
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST  GGS_sortedListSortDescriptorListAST::
constructor_emptyList (void) {
  GGS_sortedListSortDescriptorListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST  GGS_sortedListSortDescriptorListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  GGS_sortedListSortDescriptorListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
internalSubListWithRange (GGS_sortedListSortDescriptorListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSortedAttributeName, ptr->mAscending) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST GGS_sortedListSortDescriptorListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST GGS_sortedListSortDescriptorListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortedListSortDescriptorListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sortedListSortDescriptorListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListSortDescriptorListAST::
reader_mSortedAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSortedAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedListSortDescriptorListAST::
reader_mAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_setMSortedAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSortedAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_setMAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_sortedListSortDescriptorListAST::cEnumerator::_mSortedAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSortedAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_sortedListSortDescriptorListAST::cEnumerator::_mAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscending ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sortedListSortDescriptorListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedListSortDescriptorListAST * p = NULL ;
    macroMyNew (p, GGS_sortedListSortDescriptorListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST GGS_sortedListSortDescriptorListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedListSortDescriptorListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedListSortDescriptorListAST * p = dynamic_cast <const GGS_sortedListSortDescriptorListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedListSortDescriptorListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedListSortDescriptorListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedListSortDescriptorListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_sortedListDeclarationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListDeclarationAST::
cPtr_sortedListDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1,
                                const GGS_sortedListSortDescriptorListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mSortedListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListDeclarationAST * GGS_sortedListDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sortedListDeclarationAST) ;
    return (cPtr_sortedListDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedListDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedListDeclarationAST * ptr = dynamic_cast <const cPtr_sortedListDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSortedListTypeName.operator_isEqual (ptr->mSortedListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sortedListDeclarationAST:"
           << mSortedListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mSortDescriptorList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedListDeclarationAST (& typeid (cPtr_sortedListDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sortedListDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__sortedListDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sortedListDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sortedListDeclarationAST (mSortedListTypeName, mAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_sortedListDeclarationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedListDeclarationAST ("sortedListDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationAST::
GGS_sortedListDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationAST::
GGS_sortedListDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sortedListDeclarationAST GGS_sortedListDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedListDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_sortedListDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sortedListDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedListDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationAST GGS_sortedListDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListAST & argument_1,
                 const GGS_sortedListSortDescriptorListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_sortedListDeclarationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListDeclarationAST::
reader_mSortedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationAST *) mPointer)->mSortedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_sortedListDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST  GGS_sortedListDeclarationAST::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationAST *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListDeclarationAST::actualTypeName (void) const {
  return "sortedListDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sortedListDeclarationAST ("sortedListDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_sortedListDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sortedListDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedListDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_sortedListDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationAST GGS_sortedListDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedListDeclarationAST * p = dynamic_cast <const GGS_sortedListDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedListDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedListDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedListDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@enumMessageAssociationListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageAssociationListAST::
elementOf_GGS_enumMessageAssociationListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mConstantName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageAssociationListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageAssociationListAST * ptr = dynamic_cast <const elementOf_GGS_enumMessageAssociationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantName.operator_isEqual (ptr->mConstantName).boolValue ()
         && mMessage.operator_isEqual (ptr->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageAssociationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@enumMessageAssociationListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageAssociationListAST ("enumMessageAssociationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST GGS_enumMessageAssociationListAST::
operator_concat (const GGS_enumMessageAssociationListAST & inOperand) const {
  GGS_enumMessageAssociationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
dotAssign_operation (const GGS_enumMessageAssociationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageAssociationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_lstring  p_1 = p->mMessage ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantName,
                                ptr->mMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST  GGS_enumMessageAssociationListAST::
constructor_emptyList (void) {
  GGS_enumMessageAssociationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST  GGS_enumMessageAssociationListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_enumMessageAssociationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
internalSubListWithRange (GGS_enumMessageAssociationListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mConstantName, ptr->mMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST GGS_enumMessageAssociationListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST GGS_enumMessageAssociationListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageAssociationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageAssociationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationListAST::
reader_mConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationListAST::
reader_mMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_setMConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_setMMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageAssociationListAST::cEnumerator::_mConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageAssociationListAST::cEnumerator::_mMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageAssociationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageAssociationListAST * p = NULL ;
    macroMyNew (p, GGS_enumMessageAssociationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST GGS_enumMessageAssociationListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageAssociationListAST * p = dynamic_cast <const GGS_enumMessageAssociationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageAssociationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageAssociationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageAssociationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@enumMessageListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageListAST::
elementOf_GGS_enumMessageListAST (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageListAST * ptr = dynamic_cast <const elementOf_GGS_enumMessageListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumMessageName.operator_isEqual (ptr->mEnumMessageName).boolValue ()
         && mMessageAssociationList.operator_isEqual (ptr->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@enumMessageListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageListAST ("enumMessageListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST GGS_enumMessageListAST::
operator_concat (const GGS_enumMessageListAST & inOperand) const {
  GGS_enumMessageListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
dotAssign_operation (const GGS_enumMessageListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumMessageName ;
          GGS_enumMessageAssociationListAST  p_1 = p->mMessageAssociationList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_enumMessageAssociationListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumMessageName,
                                ptr->mMessageAssociationList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST  GGS_enumMessageListAST::
constructor_emptyList (void) {
  GGS_enumMessageListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST  GGS_enumMessageListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListAST & argument_1) {
  GGS_enumMessageListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
internalSubListWithRange (GGS_enumMessageListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumMessageName, ptr->mMessageAssociationList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST GGS_enumMessageListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST GGS_enumMessageListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_enumMessageAssociationListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_enumMessageAssociationListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_enumMessageAssociationListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_enumMessageAssociationListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageListAST::
reader_mEnumMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST  GGS_enumMessageListAST::
reader_mMessageAssociationListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageAssociationList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_setMEnumMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_setMMessageAssociationListAtIndex (C_Compiler & inLexique,
                              const GGS_enumMessageAssociationListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageAssociationList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageListAST::cEnumerator::_mEnumMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumMessageAssociationListAST  & GGS_enumMessageListAST::cEnumerator::_mMessageAssociationList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageAssociationList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageListAST * p = NULL ;
    macroMyNew (p, GGS_enumMessageListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST GGS_enumMessageListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageListAST * p = dynamic_cast <const GGS_enumMessageListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_enumDeclarationAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumDeclarationAST::
cPtr_enumDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_enumMessageListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mEnumTypeName (argument_0),
mConstantList (argument_1),
mEnumMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumDeclarationAST * GGS_enumDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_enumDeclarationAST) ;
    return (cPtr_enumDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumDeclarationAST * ptr = dynamic_cast <const cPtr_enumDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mConstantList.operator_isEqual (ptr->mConstantList).boolValue ()
         && mEnumMessageList.operator_isEqual (ptr->mEnumMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@enumDeclarationAST:"
           << mEnumTypeName.reader_description (inIndentation + 1)
           << mConstantList.reader_description (inIndentation + 1)
           << mEnumMessageList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumDeclarationAST (& typeid (cPtr_enumDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_enumDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__enumDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumDeclarationAST (mEnumTypeName, mConstantList, mEnumMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_enumDeclarationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumDeclarationAST ("enumDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_enumDeclarationAST::
GGS_enumDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationAST::
GGS_enumDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumDeclarationAST GGS_enumDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_enumDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationAST GGS_enumDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_enumMessageListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_enumDeclarationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumDeclarationAST::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationAST *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclarationAST::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationAST *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST  GGS_enumDeclarationAST::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationAST *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumDeclarationAST::actualTypeName (void) const {
  return "enumDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__enumDeclarationAST ("enumDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_enumDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_enumDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_enumDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationAST GGS_enumDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumDeclarationAST * p = dynamic_cast <const GGS_enumDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@filewrapperTemplateListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateListAST::
elementOf_GGS_filewrapperTemplateListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFilewrapperTemplateName (argument_0),
mFilewrapperTemplatePath (argument_1),
mFilewrapperTemplateFormalInputParameters (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_filewrapperTemplateListAST * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperTemplateName.operator_isEqual (ptr->mFilewrapperTemplateName).boolValue ()
         && mFilewrapperTemplatePath.operator_isEqual (ptr->mFilewrapperTemplatePath).boolValue ()
         && mFilewrapperTemplateFormalInputParameters.operator_isEqual (ptr->mFilewrapperTemplateFormalInputParameters).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplatePath.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateFormalInputParameters.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@filewrapperTemplateListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateListAST ("filewrapperTemplateListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  macroRetainObject (newElement) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST GGS_filewrapperTemplateListAST::
operator_concat (const GGS_filewrapperTemplateListAST & inOperand) const {
  GGS_filewrapperTemplateListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
dotAssign_operation (const GGS_filewrapperTemplateListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_filewrapperTemplateListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFilewrapperTemplateName ;
          GGS_lstring  p_1 = p->mFilewrapperTemplatePath ;
          GGS_formalInputParameterListAST  p_2 = p->mFilewrapperTemplateFormalInputParameters ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalInputParameterListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFilewrapperTemplateName,
                                ptr->mFilewrapperTemplatePath,
                                ptr->mFilewrapperTemplateFormalInputParameters
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST  GGS_filewrapperTemplateListAST::
constructor_emptyList (void) {
  GGS_filewrapperTemplateListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST  GGS_filewrapperTemplateListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListAST & argument_2) {
  GGS_filewrapperTemplateListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
internalSubListWithRange (GGS_filewrapperTemplateListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFilewrapperTemplateName, ptr->mFilewrapperTemplatePath, ptr->mFilewrapperTemplateFormalInputParameters) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST GGS_filewrapperTemplateListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST GGS_filewrapperTemplateListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@filewrapperTemplateListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_formalInputParameterListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_formalInputParameterListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalInputParameterListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_formalInputParameterListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateListAST::
reader_mFilewrapperTemplateNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateListAST::
reader_mFilewrapperTemplatePathAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplatePath ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_filewrapperTemplateListAST::
reader_mFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateFormalInputParameters ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_setMFilewrapperTemplateNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_setMFilewrapperTemplatePathAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplatePath = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_setMFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateFormalInputParameters = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateListAST::cEnumerator::_mFilewrapperTemplateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateListAST::cEnumerator::_mFilewrapperTemplatePath (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplatePath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_filewrapperTemplateListAST::cEnumerator::_mFilewrapperTemplateFormalInputParameters (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplateFormalInputParameters ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateListAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST GGS_filewrapperTemplateListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateListAST * p = dynamic_cast <const GGS_filewrapperTemplateListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_filewrapperDeclarationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperDeclarationAST::
cPtr_filewrapperDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_filewrapperTemplateListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mFilewrapperName (argument_0),
mFilewrapperPath (argument_1),
mFilewrapperExtensionList (argument_2),
mFilewrapperTemplateList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperDeclarationAST * GGS_filewrapperDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperDeclarationAST) ;
    return (cPtr_filewrapperDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperDeclarationAST * ptr = dynamic_cast <const cPtr_filewrapperDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperPath.operator_isEqual (ptr->mFilewrapperPath).boolValue ()
         && mFilewrapperExtensionList.operator_isEqual (ptr->mFilewrapperExtensionList).boolValue ()
         && mFilewrapperTemplateList.operator_isEqual (ptr->mFilewrapperTemplateList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperDeclarationAST:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperPath.reader_description (inIndentation + 1)
           << mFilewrapperExtensionList.reader_description (inIndentation + 1)
           << mFilewrapperTemplateList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperDeclarationAST (& typeid (cPtr_filewrapperDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperDeclarationAST (mFilewrapperName, mFilewrapperPath, mFilewrapperExtensionList, mFilewrapperTemplateList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_filewrapperDeclarationAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperDeclarationAST ("filewrapperDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationAST::
GGS_filewrapperDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationAST::
GGS_filewrapperDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperDeclarationAST GGS_filewrapperDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationAST GGS_filewrapperDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_filewrapperTemplateListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclarationAST::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationAST *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclarationAST::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationAST *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_filewrapperDeclarationAST::
reader_mFilewrapperExtensionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationAST *) mPointer)->mFilewrapperExtensionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST  GGS_filewrapperDeclarationAST::
reader_mFilewrapperTemplateList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationAST *) mPointer)->mFilewrapperTemplateList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperDeclarationAST::actualTypeName (void) const {
  return "filewrapperDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperDeclarationAST ("filewrapperDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_filewrapperDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationAST GGS_filewrapperDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperDeclarationAST * p = dynamic_cast <const GGS_filewrapperDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_semanticsComponentAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticsComponentAST::
cPtr_semanticsComponentAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticDeclarationStructAST& argument_2,
                                const GGS_location & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mSemanticsComponentName (argument_0),
mImportedComponentFileNameList (argument_1),
mSemanticDeclarations (argument_2),
mEndOfSourceFile (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticsComponentAST * GGS_semanticsComponentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticsComponentAST) ;
    return (cPtr_semanticsComponentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_semanticsComponentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_semanticsComponentAST * ptr = dynamic_cast <const cPtr_semanticsComponentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSemanticsComponentName.operator_isEqual (ptr->mSemanticsComponentName).boolValue ()
         && mImportedComponentFileNameList.operator_isEqual (ptr->mImportedComponentFileNameList).boolValue ()
         && mSemanticDeclarations.operator_isEqual (ptr->mSemanticDeclarations).boolValue ()
         && mEndOfSourceFile.operator_isEqual (ptr->mEndOfSourceFile).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticsComponentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticsComponentAST:"
           << mSemanticsComponentName.reader_description (inIndentation + 1)
           << mImportedComponentFileNameList.reader_description (inIndentation + 1)
           << mSemanticDeclarations.reader_description (inIndentation + 1)
           << mEndOfSourceFile.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticsComponentAST (& typeid (cPtr_semanticsComponentAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticsComponentAST::galgasRTTI (void) const {
  return & gClassInfoFor__semanticsComponentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_semanticsComponentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_semanticsComponentAST (mSemanticsComponentName, mImportedComponentFileNameList, mSemanticDeclarations, mEndOfSourceFile COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_semanticsComponentAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticsComponentAST ("semanticsComponentAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticsComponentAST::
GGS_semanticsComponentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentAST::
GGS_semanticsComponentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticsComponentAST GGS_semanticsComponentAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticsComponentAST *> (inPointer) != NULL)
      : (typeid (cPtr_semanticsComponentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticsComponentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticsComponentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentAST GGS_semanticsComponentAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticDeclarationStructAST& argument_2,
                 const GGS_location & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentAST result ;
  macroMyNew (result.mPointer, cPtr_semanticsComponentAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_semanticsComponentAST::
reader_mSemanticsComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentAST *) mPointer)->mSemanticsComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_semanticsComponentAST::
reader_mImportedComponentFileNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentAST *) mPointer)->mImportedComponentFileNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST GGS_semanticsComponentAST::
reader_mSemanticDeclarations (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticDeclarationStructAST  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentAST *) mPointer)->mSemanticDeclarations ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_semanticsComponentAST::
reader_mEndOfSourceFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentAST *) mPointer)->mEndOfSourceFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticsComponentAST::actualTypeName (void) const {
  return "semanticsComponentAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticsComponentAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticsComponentAST ("semanticsComponentAST", & kTypeDescriptor_GGS_semanticsComponentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticsComponentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticsComponentAST * p = NULL ;
    macroMyNew (p, GGS_semanticsComponentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentAST GGS_semanticsComponentAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticsComponentAST * p = dynamic_cast <const GGS_semanticsComponentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticsComponentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticsComponentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticsComponentAST ;
}

//---------------------------------------------------------------------------*

