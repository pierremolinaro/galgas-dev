//---------------------------------------------------------------------------*
//                                                                           *
//                     File 'semanticsTypesForAST.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 12th, 2010, at 21h8'47"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsTypesForAST.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsTypesForAST.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_semanticExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticExpressionAST::
cPtr_semanticExpressionAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticExpressionAST * GGS_semanticExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticExpressionAST) ;
    return (cPtr_semanticExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticExpressionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticExpressionAST (& typeid (cPtr_semanticExpressionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__semanticExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_semanticExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionAST ("semanticExpressionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST::
GGS_semanticExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST::
GGS_semanticExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticExpressionAST GGS_semanticExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_semanticExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticExpressionAST::actualTypeName (void) const {
  return "semanticExpressionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticExpressionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticExpressionAST ("semanticExpressionAST", & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionAST * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST GGS_semanticExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionAST * p = dynamic_cast <const GGS_semanticExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@semanticExpressionListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticExpressionListAST::
elementOf_GGS_semanticExpressionListAST (const GGS_semanticExpressionAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mExpression (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticExpressionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticExpressionListAST * ptr = dynamic_cast <const elementOf_GGS_semanticExpressionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticExpressionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@semanticExpressionListAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticExpressionListAST ("semanticExpressionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
internalAppendValues (const GGS_semanticExpressionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
internalPrependValues (const GGS_semanticExpressionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
addAssign_operation (const GGS_semanticExpressionAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST GGS_semanticExpressionListAST::
operator_concat (const GGS_semanticExpressionListAST & inOperand) const {
  GGS_semanticExpressionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
dotAssign_operation (const GGS_semanticExpressionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticExpressionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionAST  p_0 = p->mExpression ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpressionAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_semanticExpressionListAST::
constructor_emptyList (void) {
  GGS_semanticExpressionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_semanticExpressionListAST::
constructor_listWithValue (const GGS_semanticExpressionAST & argument_0) {
  GGS_semanticExpressionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
internalSubListWithRange (GGS_semanticExpressionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST GGS_semanticExpressionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST GGS_semanticExpressionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticExpressionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticExpressionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
method_first (C_Compiler & inLexique,
              GGS_semanticExpressionAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
method_last (C_Compiler & inLexique,
             GGS_semanticExpressionAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticExpressionAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticExpressionAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_semanticExpressionListAST::
reader_mExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticExpressionListAST::
modifier_setMExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionAST  & GGS_semanticExpressionListAST::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticExpressionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticExpressionListAST * p = NULL ;
    macroMyNew (p, GGS_semanticExpressionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST GGS_semanticExpressionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticExpressionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticExpressionListAST * p = dynamic_cast <const GGS_semanticExpressionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticExpressionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticExpressionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticExpressionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_outSemanticExpressionListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outSemanticExpressionListAST::
cPtr_outSemanticExpressionListAST (const GGS_semanticExpressionListAST & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mExpression (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outSemanticExpressionListAST * GGS_outSemanticExpressionListAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outSemanticExpressionListAST) ;
    return (cPtr_outSemanticExpressionListAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outSemanticExpressionListAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outSemanticExpressionListAST * ptr = dynamic_cast <const cPtr_outSemanticExpressionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mEndOfExpressionLocation.operator_isEqual (ptr->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outSemanticExpressionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outSemanticExpressionListAST:"
           << mExpression.reader_description (inIndentation + 1)
           << mEndOfExpressionLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outSemanticExpressionListAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outSemanticExpressionListAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outSemanticExpressionListAST (& typeid (cPtr_outSemanticExpressionListAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outSemanticExpressionListAST::galgasRTTI (void) const {
  return & gClassInfoFor__outSemanticExpressionListAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outSemanticExpressionListAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outSemanticExpressionListAST (mExpression, mEndOfExpressionLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_outSemanticExpressionListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outSemanticExpressionListAST ("outSemanticExpressionListAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST::
GGS_outSemanticExpressionListAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST::
GGS_outSemanticExpressionListAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outSemanticExpressionListAST GGS_outSemanticExpressionListAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outSemanticExpressionListAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outSemanticExpressionListAST *> (inPointer) != NULL)
      : (typeid (cPtr_outSemanticExpressionListAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outSemanticExpressionListAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outSemanticExpressionListAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST GGS_outSemanticExpressionListAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionListAST & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_outSemanticExpressionListAST result ;
  macroMyNew (result.mPointer, cPtr_outSemanticExpressionListAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionListAST  GGS_outSemanticExpressionListAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outSemanticExpressionListAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outSemanticExpressionListAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_outSemanticExpressionListAST::
reader_mEndOfExpressionLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outSemanticExpressionListAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outSemanticExpressionListAST *) mPointer)->mEndOfExpressionLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outSemanticExpressionListAST::actualTypeName (void) const {
  return "outSemanticExpressionListAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_outSemanticExpressionListAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__outSemanticExpressionListAST ("outSemanticExpressionListAST", & kTypeDescriptor_GGS_outSemanticExpressionListAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outSemanticExpressionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outSemanticExpressionListAST * p = NULL ;
    macroMyNew (p, GGS_outSemanticExpressionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST GGS_outSemanticExpressionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outSemanticExpressionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outSemanticExpressionListAST * p = dynamic_cast <const GGS_outSemanticExpressionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outSemanticExpressionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outSemanticExpressionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outSemanticExpressionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_selfInExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_selfInExpressionAST::
cPtr_selfInExpressionAST (LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_selfInExpressionAST * GGS_selfInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_selfInExpressionAST) ;
    return (cPtr_selfInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_selfInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_selfInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@selfInExpressionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_selfInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_selfInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_selfInExpressionAST (& typeid (cPtr_selfInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_selfInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__selfInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_selfInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_selfInExpressionAST ("selfInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_selfInExpressionAST::
GGS_selfInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionAST::
GGS_selfInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_selfInExpressionAST GGS_selfInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_selfInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_selfInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_selfInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_selfInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_selfInExpressionAST * gSingleton_selfInExpressionAST = NULL ;

//---------------------------------------------------------------------------*

GGS_selfInExpressionAST GGS_selfInExpressionAST::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionAST result ;
  if (NULL == gSingleton_selfInExpressionAST) {
    macroMyNew (gSingleton_selfInExpressionAST, cPtr_selfInExpressionAST (THERE)) ;
    macroRetainObject (gSingleton_selfInExpressionAST) ;
  }
  macroAssignObject (result.mPointer, gSingleton_selfInExpressionAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_selfInExpressionAST::actualTypeName (void) const {
  return "selfInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__selfInExpressionAST ("selfInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_selfInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_selfInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_selfInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_selfInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_selfInExpressionAST GGS_selfInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_selfInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_selfInExpressionAST * p = dynamic_cast <const GGS_selfInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_selfInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_selfInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_selfInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_hereExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_hereExpressionAST::
cPtr_hereExpressionAST (LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_hereExpressionAST * GGS_hereExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_hereExpressionAST) ;
    return (cPtr_hereExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_hereExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_hereExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@hereExpressionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_hereExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_hereExpressionAST (& typeid (cPtr_hereExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_hereExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__hereExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_hereExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_hereExpressionAST ("hereExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_hereExpressionAST::
GGS_hereExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionAST::
GGS_hereExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_hereExpressionAST GGS_hereExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_hereExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_hereExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_hereExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_hereExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_hereExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_hereExpressionAST * gSingleton_hereExpressionAST = NULL ;

//---------------------------------------------------------------------------*

GGS_hereExpressionAST GGS_hereExpressionAST::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_hereExpressionAST result ;
  if (NULL == gSingleton_hereExpressionAST) {
    macroMyNew (gSingleton_hereExpressionAST, cPtr_hereExpressionAST (THERE)) ;
    macroRetainObject (gSingleton_hereExpressionAST) ;
  }
  macroAssignObject (result.mPointer, gSingleton_hereExpressionAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_hereExpressionAST::actualTypeName (void) const {
  return "hereExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__hereExpressionAST ("hereExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_hereExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_hereExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_hereExpressionAST * p = NULL ;
    macroMyNew (p, GGS_hereExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_hereExpressionAST GGS_hereExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_hereExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_hereExpressionAST * p = dynamic_cast <const GGS_hereExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_hereExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_hereExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_hereExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_trueExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_trueExpressionAST::
cPtr_trueExpressionAST (LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_trueExpressionAST * GGS_trueExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_trueExpressionAST) ;
    return (cPtr_trueExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_trueExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_trueExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@trueExpressionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_trueExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_trueExpressionAST (& typeid (cPtr_trueExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_trueExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__trueExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_trueExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_trueExpressionAST ("trueExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_trueExpressionAST::
GGS_trueExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionAST::
GGS_trueExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_trueExpressionAST GGS_trueExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_trueExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_trueExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_trueExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_trueExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_trueExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_trueExpressionAST * gSingleton_trueExpressionAST = NULL ;

//---------------------------------------------------------------------------*

GGS_trueExpressionAST GGS_trueExpressionAST::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_trueExpressionAST result ;
  if (NULL == gSingleton_trueExpressionAST) {
    macroMyNew (gSingleton_trueExpressionAST, cPtr_trueExpressionAST (THERE)) ;
    macroRetainObject (gSingleton_trueExpressionAST) ;
  }
  macroAssignObject (result.mPointer, gSingleton_trueExpressionAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_trueExpressionAST::actualTypeName (void) const {
  return "trueExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__trueExpressionAST ("trueExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_trueExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_trueExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_trueExpressionAST * p = NULL ;
    macroMyNew (p, GGS_trueExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_trueExpressionAST GGS_trueExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_trueExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_trueExpressionAST * p = dynamic_cast <const GGS_trueExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_trueExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_trueExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_trueExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_falseExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_falseExpressionAST::
cPtr_falseExpressionAST (LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_falseExpressionAST * GGS_falseExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_falseExpressionAST) ;
    return (cPtr_falseExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_falseExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_falseExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@falseExpressionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_falseExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_falseExpressionAST (& typeid (cPtr_falseExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_falseExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__falseExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_falseExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_falseExpressionAST ("falseExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_falseExpressionAST::
GGS_falseExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionAST::
GGS_falseExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_falseExpressionAST GGS_falseExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_falseExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_falseExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_falseExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_falseExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_falseExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_falseExpressionAST * gSingleton_falseExpressionAST = NULL ;

//---------------------------------------------------------------------------*

GGS_falseExpressionAST GGS_falseExpressionAST::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_falseExpressionAST result ;
  if (NULL == gSingleton_falseExpressionAST) {
    macroMyNew (gSingleton_falseExpressionAST, cPtr_falseExpressionAST (THERE)) ;
    macroRetainObject (gSingleton_falseExpressionAST) ;
  }
  macroAssignObject (result.mPointer, gSingleton_falseExpressionAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_falseExpressionAST::actualTypeName (void) const {
  return "falseExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__falseExpressionAST ("falseExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_falseExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_falseExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_falseExpressionAST * p = NULL ;
    macroMyNew (p, GGS_falseExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_falseExpressionAST GGS_falseExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_falseExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_falseExpressionAST * p = dynamic_cast <const GGS_falseExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_falseExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_falseExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_falseExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_literalCharExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalCharExpressionAST::
cPtr_literalCharExpressionAST (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mCharacter (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalCharExpressionAST * GGS_literalCharExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalCharExpressionAST) ;
    return (cPtr_literalCharExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalCharExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalCharExpressionAST * ptr = dynamic_cast <const cPtr_literalCharExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCharacter.operator_isEqual (ptr->mCharacter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalCharExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalCharExpressionAST:"
           << mCharacter.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalCharExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalCharExpressionAST (& typeid (cPtr_literalCharExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalCharExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalCharExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalCharExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalCharExpressionAST (mCharacter COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_literalCharExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalCharExpressionAST ("literalCharExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalCharExpressionAST::
GGS_literalCharExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionAST::
GGS_literalCharExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalCharExpressionAST GGS_literalCharExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalCharExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalCharExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalCharExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalCharExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionAST GGS_literalCharExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalCharExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_literalCharExpressionAST::
reader_mCharacter (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalCharExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalCharExpressionAST *) mPointer)->mCharacter ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalCharExpressionAST::actualTypeName (void) const {
  return "literalCharExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalCharExpressionAST ("literalCharExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalCharExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalCharExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalCharExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalCharExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalCharExpressionAST GGS_literalCharExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalCharExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalCharExpressionAST * p = dynamic_cast <const GGS_literalCharExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalCharExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalCharExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalCharExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalStringExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalStringExpressionAST::
cPtr_literalStringExpressionAST (const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mStringSequence (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalStringExpressionAST * GGS_literalStringExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalStringExpressionAST) ;
    return (cPtr_literalStringExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalStringExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalStringExpressionAST * ptr = dynamic_cast <const cPtr_literalStringExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStringSequence.operator_isEqual (ptr->mStringSequence).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalStringExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalStringExpressionAST:"
           << mStringSequence.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalStringExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalStringExpressionAST (& typeid (cPtr_literalStringExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalStringExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalStringExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalStringExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalStringExpressionAST (mStringSequence COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalStringExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalStringExpressionAST ("literalStringExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalStringExpressionAST::
GGS_literalStringExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionAST::
GGS_literalStringExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalStringExpressionAST GGS_literalStringExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalStringExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalStringExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalStringExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalStringExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionAST GGS_literalStringExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_stringlist & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalStringExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_literalStringExpressionAST::
reader_mStringSequence (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalStringExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalStringExpressionAST *) mPointer)->mStringSequence ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalStringExpressionAST::actualTypeName (void) const {
  return "literalStringExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalStringExpressionAST ("literalStringExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalStringExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalStringExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalStringExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalStringExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalStringExpressionAST GGS_literalStringExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalStringExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalStringExpressionAST * p = dynamic_cast <const GGS_literalStringExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalStringExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalStringExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalStringExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalDoubleExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalDoubleExpressionAST::
cPtr_literalDoubleExpressionAST (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalDoubleExpressionAST * GGS_literalDoubleExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalDoubleExpressionAST) ;
    return (cPtr_literalDoubleExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalDoubleExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalDoubleExpressionAST * ptr = dynamic_cast <const cPtr_literalDoubleExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalDoubleExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalDoubleExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalDoubleExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalDoubleExpressionAST (& typeid (cPtr_literalDoubleExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalDoubleExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalDoubleExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalDoubleExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalDoubleExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalDoubleExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalDoubleExpressionAST ("literalDoubleExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionAST::
GGS_literalDoubleExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionAST::
GGS_literalDoubleExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalDoubleExpressionAST GGS_literalDoubleExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalDoubleExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalDoubleExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalDoubleExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalDoubleExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionAST GGS_literalDoubleExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalDoubleExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_literalDoubleExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalDoubleExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalDoubleExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalDoubleExpressionAST::actualTypeName (void) const {
  return "literalDoubleExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalDoubleExpressionAST ("literalDoubleExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalDoubleExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalDoubleExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalDoubleExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalDoubleExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalDoubleExpressionAST GGS_literalDoubleExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalDoubleExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalDoubleExpressionAST * p = dynamic_cast <const GGS_literalDoubleExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalDoubleExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalDoubleExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalDoubleExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_literalUIntExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUIntExpressionAST::
cPtr_literalUIntExpressionAST (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUIntExpressionAST * GGS_literalUIntExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUIntExpressionAST) ;
    return (cPtr_literalUIntExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUIntExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUIntExpressionAST * ptr = dynamic_cast <const cPtr_literalUIntExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUIntExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUIntExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUIntExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUIntExpressionAST (& typeid (cPtr_literalUIntExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUIntExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalUIntExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUIntExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUIntExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_literalUIntExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUIntExpressionAST ("literalUIntExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionAST::
GGS_literalUIntExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionAST::
GGS_literalUIntExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUIntExpressionAST GGS_literalUIntExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUIntExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalUIntExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUIntExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUIntExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionAST GGS_literalUIntExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalUIntExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_literalUIntExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUIntExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUIntExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUIntExpressionAST::actualTypeName (void) const {
  return "literalUIntExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUIntExpressionAST ("literalUIntExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalUIntExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUIntExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUIntExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalUIntExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUIntExpressionAST GGS_literalUIntExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUIntExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUIntExpressionAST * p = dynamic_cast <const GGS_literalUIntExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUIntExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUIntExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUIntExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalUInt64ExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalUInt64ExpressionAST::
cPtr_literalUInt64ExpressionAST (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalUInt64ExpressionAST * GGS_literalUInt64ExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalUInt64ExpressionAST) ;
    return (cPtr_literalUInt64ExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalUInt64ExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalUInt64ExpressionAST * ptr = dynamic_cast <const cPtr_literalUInt64ExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalUInt64ExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalUInt64ExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalUInt64ExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalUInt64ExpressionAST (& typeid (cPtr_literalUInt64ExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalUInt64ExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalUInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalUInt64ExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalUInt64ExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalUInt64ExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalUInt64ExpressionAST ("literalUInt64ExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionAST::
GGS_literalUInt64ExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionAST::
GGS_literalUInt64ExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalUInt64ExpressionAST GGS_literalUInt64ExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalUInt64ExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalUInt64ExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalUInt64ExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalUInt64ExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionAST GGS_literalUInt64ExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalUInt64ExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_literalUInt64ExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalUInt64ExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalUInt64ExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalUInt64ExpressionAST::actualTypeName (void) const {
  return "literalUInt64ExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalUInt64ExpressionAST ("literalUInt64ExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalUInt64ExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalUInt64ExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalUInt64ExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalUInt64ExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalUInt64ExpressionAST GGS_literalUInt64ExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalUInt64ExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalUInt64ExpressionAST * p = dynamic_cast <const GGS_literalUInt64ExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalUInt64ExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalUInt64ExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalUInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_literalSIntExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSIntExpressionAST::
cPtr_literalSIntExpressionAST (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSIntExpressionAST * GGS_literalSIntExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSIntExpressionAST) ;
    return (cPtr_literalSIntExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSIntExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSIntExpressionAST * ptr = dynamic_cast <const cPtr_literalSIntExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSIntExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSIntExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSIntExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSIntExpressionAST (& typeid (cPtr_literalSIntExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSIntExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalSIntExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSIntExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSIntExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_literalSIntExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSIntExpressionAST ("literalSIntExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionAST::
GGS_literalSIntExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionAST::
GGS_literalSIntExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSIntExpressionAST GGS_literalSIntExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSIntExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalSIntExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSIntExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSIntExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionAST GGS_literalSIntExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalSIntExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_literalSIntExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSIntExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSIntExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSIntExpressionAST::actualTypeName (void) const {
  return "literalSIntExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSIntExpressionAST ("literalSIntExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalSIntExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSIntExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSIntExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalSIntExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSIntExpressionAST GGS_literalSIntExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSIntExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSIntExpressionAST * p = dynamic_cast <const GGS_literalSIntExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSIntExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSIntExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSIntExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalSInt64ExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalSInt64ExpressionAST::
cPtr_literalSInt64ExpressionAST (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mValue (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalSInt64ExpressionAST * GGS_literalSInt64ExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalSInt64ExpressionAST) ;
    return (cPtr_literalSInt64ExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalSInt64ExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalSInt64ExpressionAST * ptr = dynamic_cast <const cPtr_literalSInt64ExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mValue.operator_isEqual (ptr->mValue).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalSInt64ExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalSInt64ExpressionAST:"
           << mValue.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalSInt64ExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalSInt64ExpressionAST (& typeid (cPtr_literalSInt64ExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalSInt64ExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalSInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalSInt64ExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalSInt64ExpressionAST (mValue COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalSInt64ExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalSInt64ExpressionAST ("literalSInt64ExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionAST::
GGS_literalSInt64ExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionAST::
GGS_literalSInt64ExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalSInt64ExpressionAST GGS_literalSInt64ExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalSInt64ExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalSInt64ExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalSInt64ExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalSInt64ExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionAST GGS_literalSInt64ExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalSInt64ExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_literalSInt64ExpressionAST::
reader_mValue (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalSInt64ExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalSInt64ExpressionAST *) mPointer)->mValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalSInt64ExpressionAST::actualTypeName (void) const {
  return "literalSInt64ExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalSInt64ExpressionAST ("literalSInt64ExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalSInt64ExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalSInt64ExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalSInt64ExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalSInt64ExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalSInt64ExpressionAST GGS_literalSInt64ExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalSInt64ExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalSInt64ExpressionAST * p = dynamic_cast <const GGS_literalSInt64ExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalSInt64ExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalSInt64ExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalSInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_constructorExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constructorExpressionAST::
cPtr_constructorExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outSemanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mTypeName (argument_0),
mConstructorName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constructorExpressionAST * GGS_constructorExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_constructorExpressionAST) ;
    return (cPtr_constructorExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constructorExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constructorExpressionAST * ptr = dynamic_cast <const cPtr_constructorExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constructorExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@constructorExpressionAST:"
           << mTypeName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constructorExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constructorExpressionAST (& typeid (cPtr_constructorExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_constructorExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__constructorExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_constructorExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_constructorExpressionAST (mTypeName, mConstructorName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_constructorExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constructorExpressionAST ("constructorExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_constructorExpressionAST::
GGS_constructorExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionAST::
GGS_constructorExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_constructorExpressionAST GGS_constructorExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constructorExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_constructorExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_constructorExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constructorExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionAST GGS_constructorExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outSemanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_constructorExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpressionAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constructorExpressionAST::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionAST *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST  GGS_constructorExpressionAST::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constructorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constructorExpressionAST *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constructorExpressionAST::actualTypeName (void) const {
  return "constructorExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__constructorExpressionAST ("constructorExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_constructorExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_constructorExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constructorExpressionAST * p = NULL ;
    macroMyNew (p, GGS_constructorExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constructorExpressionAST GGS_constructorExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constructorExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constructorExpressionAST * p = dynamic_cast <const GGS_constructorExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constructorExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constructorExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constructorExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_readerCallExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_readerCallExpressionAST::
cPtr_readerCallExpressionAST (const GGS_semanticExpressionAST & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outSemanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mReceiver (argument_0),
mReaderName (argument_1),
mExpressions (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_readerCallExpressionAST * GGS_readerCallExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_readerCallExpressionAST) ;
    return (cPtr_readerCallExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_readerCallExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_readerCallExpressionAST * ptr = dynamic_cast <const cPtr_readerCallExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiver.operator_isEqual (ptr->mReceiver).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_readerCallExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@readerCallExpressionAST:"
           << mReceiver.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_readerCallExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_readerCallExpressionAST (& typeid (cPtr_readerCallExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_readerCallExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__readerCallExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_readerCallExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_readerCallExpressionAST (mReceiver, mReaderName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_readerCallExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_readerCallExpressionAST ("readerCallExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_readerCallExpressionAST::
GGS_readerCallExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionAST::
GGS_readerCallExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_readerCallExpressionAST GGS_readerCallExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_readerCallExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_readerCallExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_readerCallExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_readerCallExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionAST GGS_readerCallExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionAST & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outSemanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_readerCallExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_readerCallExpressionAST::
reader_mReceiver (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionAST *) mPointer)->mReceiver ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_readerCallExpressionAST::
reader_mReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionAST *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST  GGS_readerCallExpressionAST::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_readerCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_readerCallExpressionAST *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_readerCallExpressionAST::actualTypeName (void) const {
  return "readerCallExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__readerCallExpressionAST ("readerCallExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_readerCallExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_readerCallExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_readerCallExpressionAST * p = NULL ;
    macroMyNew (p, GGS_readerCallExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_readerCallExpressionAST GGS_readerCallExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_readerCallExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_readerCallExpressionAST * p = dynamic_cast <const GGS_readerCallExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_readerCallExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_readerCallExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_readerCallExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_optionExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_optionExpressionAST::
cPtr_optionExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOptionComponentName (argument_0),
mOptionEntryName (argument_1),
mOptionReaderName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_optionExpressionAST * GGS_optionExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_optionExpressionAST) ;
    return (cPtr_optionExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_optionExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_optionExpressionAST * ptr = dynamic_cast <const cPtr_optionExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionEntryName.operator_isEqual (ptr->mOptionEntryName).boolValue ()
         && mOptionReaderName.operator_isEqual (ptr->mOptionReaderName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_optionExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@optionExpressionAST:"
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionEntryName.reader_description (inIndentation + 1)
           << mOptionReaderName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_optionExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_optionExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_optionExpressionAST (& typeid (cPtr_optionExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_optionExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__optionExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_optionExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_optionExpressionAST (mOptionComponentName, mOptionEntryName, mOptionReaderName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_optionExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionExpressionAST ("optionExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_optionExpressionAST::
GGS_optionExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionAST::
GGS_optionExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_optionExpressionAST GGS_optionExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_optionExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_optionExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_optionExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_optionExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_optionExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionAST GGS_optionExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_optionExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_optionExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionAST::
reader_mOptionComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionAST *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionAST::
reader_mOptionEntryName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionAST *) mPointer)->mOptionEntryName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_optionExpressionAST::
reader_mOptionReaderName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_optionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_optionExpressionAST *) mPointer)->mOptionReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_optionExpressionAST::actualTypeName (void) const {
  return "optionExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__optionExpressionAST ("optionExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_optionExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_optionExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionExpressionAST * p = NULL ;
    macroMyNew (p, GGS_optionExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionExpressionAST GGS_optionExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionExpressionAST * p = dynamic_cast <const GGS_optionExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_concatExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_concatExpressionAST::
cPtr_concatExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_concatExpressionAST * GGS_concatExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_concatExpressionAST) ;
    return (cPtr_concatExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_concatExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_concatExpressionAST * ptr = dynamic_cast <const cPtr_concatExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_concatExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@concatExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_concatExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_concatExpressionAST (& typeid (cPtr_concatExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_concatExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__concatExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_concatExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_concatExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_concatExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_concatExpressionAST ("concatExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_concatExpressionAST::
GGS_concatExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionAST::
GGS_concatExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_concatExpressionAST GGS_concatExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_concatExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_concatExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_concatExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_concatExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_concatExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionAST GGS_concatExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_concatExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_concatExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_concatExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_concatExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_concatExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_concatExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_concatExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_concatExpressionAST::actualTypeName (void) const {
  return "concatExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__concatExpressionAST ("concatExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_concatExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_concatExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_concatExpressionAST * p = NULL ;
    macroMyNew (p, GGS_concatExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_concatExpressionAST GGS_concatExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_concatExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_concatExpressionAST * p = dynamic_cast <const GGS_concatExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_concatExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_concatExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_concatExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_orExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_orExpressionAST::
cPtr_orExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_orExpressionAST * GGS_orExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_orExpressionAST) ;
    return (cPtr_orExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_orExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_orExpressionAST * ptr = dynamic_cast <const cPtr_orExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_orExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@orExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_orExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_orExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_orExpressionAST (& typeid (cPtr_orExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_orExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__orExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_orExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_orExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_orExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_orExpressionAST ("orExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_orExpressionAST::
GGS_orExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionAST::
GGS_orExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_orExpressionAST GGS_orExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_orExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_orExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_orExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_orExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_orExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionAST GGS_orExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_orExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_orExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_orExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_orExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_orExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_orExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_orExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_orExpressionAST::actualTypeName (void) const {
  return "orExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__orExpressionAST ("orExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_orExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_orExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_orExpressionAST * p = NULL ;
    macroMyNew (p, GGS_orExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_orExpressionAST GGS_orExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_orExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_orExpressionAST * p = dynamic_cast <const GGS_orExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_orExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_orExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_orExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_xorExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_xorExpressionAST::
cPtr_xorExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_xorExpressionAST * GGS_xorExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_xorExpressionAST) ;
    return (cPtr_xorExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_xorExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_xorExpressionAST * ptr = dynamic_cast <const cPtr_xorExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_xorExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@xorExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_xorExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_xorExpressionAST (& typeid (cPtr_xorExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_xorExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__xorExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_xorExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_xorExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_xorExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_xorExpressionAST ("xorExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_xorExpressionAST::
GGS_xorExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionAST::
GGS_xorExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_xorExpressionAST GGS_xorExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_xorExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_xorExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_xorExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_xorExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_xorExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionAST GGS_xorExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_xorExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_xorExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_xorExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_xorExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_xorExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_xorExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_xorExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_xorExpressionAST::actualTypeName (void) const {
  return "xorExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__xorExpressionAST ("xorExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_xorExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_xorExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_xorExpressionAST * p = NULL ;
    macroMyNew (p, GGS_xorExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_xorExpressionAST GGS_xorExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_xorExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_xorExpressionAST * p = dynamic_cast <const GGS_xorExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_xorExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_xorExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_xorExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_andExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_andExpressionAST::
cPtr_andExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_andExpressionAST * GGS_andExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_andExpressionAST) ;
    return (cPtr_andExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_andExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_andExpressionAST * ptr = dynamic_cast <const cPtr_andExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_andExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@andExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_andExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_andExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_andExpressionAST (& typeid (cPtr_andExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_andExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__andExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_andExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_andExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_andExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_andExpressionAST ("andExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_andExpressionAST::
GGS_andExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionAST::
GGS_andExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_andExpressionAST GGS_andExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_andExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_andExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_andExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_andExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_andExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionAST GGS_andExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_andExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_andExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_andExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_andExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_andExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_andExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_andExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_andExpressionAST::actualTypeName (void) const {
  return "andExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__andExpressionAST ("andExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_andExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_andExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_andExpressionAST * p = NULL ;
    macroMyNew (p, GGS_andExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_andExpressionAST GGS_andExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_andExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_andExpressionAST * p = dynamic_cast <const GGS_andExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_andExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_andExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_andExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_equalExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_equalExpressionAST::
cPtr_equalExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_equalExpressionAST * GGS_equalExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_equalExpressionAST) ;
    return (cPtr_equalExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_equalExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_equalExpressionAST * ptr = dynamic_cast <const cPtr_equalExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_equalExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@equalExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_equalExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_equalExpressionAST (& typeid (cPtr_equalExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_equalExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__equalExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_equalExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_equalExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_equalExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_equalExpressionAST ("equalExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_equalExpressionAST::
GGS_equalExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionAST::
GGS_equalExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_equalExpressionAST GGS_equalExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_equalExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_equalExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_equalExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_equalExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_equalExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionAST GGS_equalExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_equalExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_equalExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_equalExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_equalExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_equalExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_equalExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_equalExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_equalExpressionAST::actualTypeName (void) const {
  return "equalExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__equalExpressionAST ("equalExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_equalExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_equalExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_equalExpressionAST * p = NULL ;
    macroMyNew (p, GGS_equalExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_equalExpressionAST GGS_equalExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_equalExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_equalExpressionAST * p = dynamic_cast <const GGS_equalExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_equalExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_equalExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_equalExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_notEqualExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notEqualExpressionAST::
cPtr_notEqualExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notEqualExpressionAST * GGS_notEqualExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notEqualExpressionAST) ;
    return (cPtr_notEqualExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notEqualExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notEqualExpressionAST * ptr = dynamic_cast <const cPtr_notEqualExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notEqualExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notEqualExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notEqualExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notEqualExpressionAST (& typeid (cPtr_notEqualExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notEqualExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__notEqualExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notEqualExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notEqualExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_notEqualExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notEqualExpressionAST ("notEqualExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_notEqualExpressionAST::
GGS_notEqualExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionAST::
GGS_notEqualExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notEqualExpressionAST GGS_notEqualExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notEqualExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_notEqualExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notEqualExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notEqualExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionAST GGS_notEqualExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_notEqualExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notEqualExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_notEqualExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_notEqualExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notEqualExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notEqualExpressionAST::actualTypeName (void) const {
  return "notEqualExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notEqualExpressionAST ("notEqualExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_notEqualExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notEqualExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notEqualExpressionAST * p = NULL ;
    macroMyNew (p, GGS_notEqualExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notEqualExpressionAST GGS_notEqualExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notEqualExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notEqualExpressionAST * p = dynamic_cast <const GGS_notEqualExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notEqualExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notEqualExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notEqualExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_lowerOrEqualExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lowerOrEqualExpressionAST::
cPtr_lowerOrEqualExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lowerOrEqualExpressionAST * GGS_lowerOrEqualExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lowerOrEqualExpressionAST) ;
    return (cPtr_lowerOrEqualExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lowerOrEqualExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lowerOrEqualExpressionAST * ptr = dynamic_cast <const cPtr_lowerOrEqualExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lowerOrEqualExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lowerOrEqualExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lowerOrEqualExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lowerOrEqualExpressionAST (& typeid (cPtr_lowerOrEqualExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lowerOrEqualExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__lowerOrEqualExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lowerOrEqualExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lowerOrEqualExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_lowerOrEqualExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lowerOrEqualExpressionAST ("lowerOrEqualExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionAST::
GGS_lowerOrEqualExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionAST::
GGS_lowerOrEqualExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lowerOrEqualExpressionAST GGS_lowerOrEqualExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lowerOrEqualExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_lowerOrEqualExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lowerOrEqualExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lowerOrEqualExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionAST GGS_lowerOrEqualExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_lowerOrEqualExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_lowerOrEqualExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_lowerOrEqualExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_lowerOrEqualExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lowerOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lowerOrEqualExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lowerOrEqualExpressionAST::actualTypeName (void) const {
  return "lowerOrEqualExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lowerOrEqualExpressionAST ("lowerOrEqualExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_lowerOrEqualExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lowerOrEqualExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lowerOrEqualExpressionAST * p = NULL ;
    macroMyNew (p, GGS_lowerOrEqualExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lowerOrEqualExpressionAST GGS_lowerOrEqualExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lowerOrEqualExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lowerOrEqualExpressionAST * p = dynamic_cast <const GGS_lowerOrEqualExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lowerOrEqualExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lowerOrEqualExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lowerOrEqualExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_greaterOrEqualExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_greaterOrEqualExpressionAST::
cPtr_greaterOrEqualExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_greaterOrEqualExpressionAST * GGS_greaterOrEqualExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_greaterOrEqualExpressionAST) ;
    return (cPtr_greaterOrEqualExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_greaterOrEqualExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_greaterOrEqualExpressionAST * ptr = dynamic_cast <const cPtr_greaterOrEqualExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_greaterOrEqualExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@greaterOrEqualExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_greaterOrEqualExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_greaterOrEqualExpressionAST (& typeid (cPtr_greaterOrEqualExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_greaterOrEqualExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__greaterOrEqualExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_greaterOrEqualExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_greaterOrEqualExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_greaterOrEqualExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_greaterOrEqualExpressionAST ("greaterOrEqualExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionAST::
GGS_greaterOrEqualExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionAST::
GGS_greaterOrEqualExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_greaterOrEqualExpressionAST GGS_greaterOrEqualExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_greaterOrEqualExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_greaterOrEqualExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_greaterOrEqualExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_greaterOrEqualExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionAST GGS_greaterOrEqualExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_greaterOrEqualExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_greaterOrEqualExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_greaterOrEqualExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_greaterOrEqualExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_greaterOrEqualExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_greaterOrEqualExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_greaterOrEqualExpressionAST::actualTypeName (void) const {
  return "greaterOrEqualExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__greaterOrEqualExpressionAST ("greaterOrEqualExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_greaterOrEqualExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_greaterOrEqualExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_greaterOrEqualExpressionAST * p = NULL ;
    macroMyNew (p, GGS_greaterOrEqualExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_greaterOrEqualExpressionAST GGS_greaterOrEqualExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_greaterOrEqualExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_greaterOrEqualExpressionAST * p = dynamic_cast <const GGS_greaterOrEqualExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_greaterOrEqualExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_greaterOrEqualExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_greaterOrEqualExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_strictGreaterExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictGreaterExpressionAST::
cPtr_strictGreaterExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictGreaterExpressionAST * GGS_strictGreaterExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictGreaterExpressionAST) ;
    return (cPtr_strictGreaterExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictGreaterExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictGreaterExpressionAST * ptr = dynamic_cast <const cPtr_strictGreaterExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictGreaterExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictGreaterExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictGreaterExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictGreaterExpressionAST (& typeid (cPtr_strictGreaterExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictGreaterExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__strictGreaterExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictGreaterExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictGreaterExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_strictGreaterExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictGreaterExpressionAST ("strictGreaterExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionAST::
GGS_strictGreaterExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionAST::
GGS_strictGreaterExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictGreaterExpressionAST GGS_strictGreaterExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictGreaterExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_strictGreaterExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictGreaterExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictGreaterExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionAST GGS_strictGreaterExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_strictGreaterExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictGreaterExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_strictGreaterExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_strictGreaterExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictGreaterExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictGreaterExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictGreaterExpressionAST::actualTypeName (void) const {
  return "strictGreaterExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictGreaterExpressionAST ("strictGreaterExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_strictGreaterExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictGreaterExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictGreaterExpressionAST * p = NULL ;
    macroMyNew (p, GGS_strictGreaterExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictGreaterExpressionAST GGS_strictGreaterExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictGreaterExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictGreaterExpressionAST * p = dynamic_cast <const GGS_strictGreaterExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictGreaterExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictGreaterExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictGreaterExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_strictLowerExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_strictLowerExpressionAST::
cPtr_strictLowerExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_strictLowerExpressionAST * GGS_strictLowerExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_strictLowerExpressionAST) ;
    return (cPtr_strictLowerExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_strictLowerExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_strictLowerExpressionAST * ptr = dynamic_cast <const cPtr_strictLowerExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_strictLowerExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@strictLowerExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_strictLowerExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_strictLowerExpressionAST (& typeid (cPtr_strictLowerExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_strictLowerExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__strictLowerExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_strictLowerExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_strictLowerExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_strictLowerExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_strictLowerExpressionAST ("strictLowerExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionAST::
GGS_strictLowerExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionAST::
GGS_strictLowerExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_strictLowerExpressionAST GGS_strictLowerExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_strictLowerExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_strictLowerExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_strictLowerExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_strictLowerExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionAST GGS_strictLowerExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_strictLowerExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_strictLowerExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_strictLowerExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_strictLowerExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_strictLowerExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_strictLowerExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_strictLowerExpressionAST::actualTypeName (void) const {
  return "strictLowerExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__strictLowerExpressionAST ("strictLowerExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_strictLowerExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_strictLowerExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_strictLowerExpressionAST * p = NULL ;
    macroMyNew (p, GGS_strictLowerExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_strictLowerExpressionAST GGS_strictLowerExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_strictLowerExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_strictLowerExpressionAST * p = dynamic_cast <const GGS_strictLowerExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_strictLowerExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_strictLowerExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_strictLowerExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_rightShiftExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_rightShiftExpressionAST::
cPtr_rightShiftExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_rightShiftExpressionAST * GGS_rightShiftExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_rightShiftExpressionAST) ;
    return (cPtr_rightShiftExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_rightShiftExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_rightShiftExpressionAST * ptr = dynamic_cast <const cPtr_rightShiftExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_rightShiftExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@rightShiftExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_rightShiftExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_rightShiftExpressionAST (& typeid (cPtr_rightShiftExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_rightShiftExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__rightShiftExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_rightShiftExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_rightShiftExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_rightShiftExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_rightShiftExpressionAST ("rightShiftExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionAST::
GGS_rightShiftExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionAST::
GGS_rightShiftExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_rightShiftExpressionAST GGS_rightShiftExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_rightShiftExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_rightShiftExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_rightShiftExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_rightShiftExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionAST GGS_rightShiftExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_rightShiftExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_rightShiftExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_rightShiftExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_rightShiftExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_rightShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_rightShiftExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_rightShiftExpressionAST::actualTypeName (void) const {
  return "rightShiftExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__rightShiftExpressionAST ("rightShiftExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_rightShiftExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_rightShiftExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_rightShiftExpressionAST * p = NULL ;
    macroMyNew (p, GGS_rightShiftExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_rightShiftExpressionAST GGS_rightShiftExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_rightShiftExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_rightShiftExpressionAST * p = dynamic_cast <const GGS_rightShiftExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_rightShiftExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_rightShiftExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_rightShiftExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_leftShiftExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_leftShiftExpressionAST::
cPtr_leftShiftExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_leftShiftExpressionAST * GGS_leftShiftExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_leftShiftExpressionAST) ;
    return (cPtr_leftShiftExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_leftShiftExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_leftShiftExpressionAST * ptr = dynamic_cast <const cPtr_leftShiftExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_leftShiftExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@leftShiftExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_leftShiftExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_leftShiftExpressionAST (& typeid (cPtr_leftShiftExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_leftShiftExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__leftShiftExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_leftShiftExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_leftShiftExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_leftShiftExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_leftShiftExpressionAST ("leftShiftExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionAST::
GGS_leftShiftExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionAST::
GGS_leftShiftExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_leftShiftExpressionAST GGS_leftShiftExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_leftShiftExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_leftShiftExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_leftShiftExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_leftShiftExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionAST GGS_leftShiftExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_leftShiftExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_leftShiftExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_leftShiftExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_leftShiftExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_leftShiftExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_leftShiftExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_leftShiftExpressionAST::actualTypeName (void) const {
  return "leftShiftExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__leftShiftExpressionAST ("leftShiftExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_leftShiftExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_leftShiftExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_leftShiftExpressionAST * p = NULL ;
    macroMyNew (p, GGS_leftShiftExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_leftShiftExpressionAST GGS_leftShiftExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_leftShiftExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_leftShiftExpressionAST * p = dynamic_cast <const GGS_leftShiftExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_leftShiftExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_leftShiftExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_leftShiftExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_addExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addExpressionAST::
cPtr_addExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addExpressionAST * GGS_addExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addExpressionAST) ;
    return (cPtr_addExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addExpressionAST * ptr = dynamic_cast <const cPtr_addExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addExpressionAST (& typeid (cPtr_addExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__addExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_addExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addExpressionAST ("addExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_addExpressionAST::
GGS_addExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionAST::
GGS_addExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addExpressionAST GGS_addExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_addExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionAST GGS_addExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_addExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_addExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_addExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_addExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_addExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addExpressionAST::actualTypeName (void) const {
  return "addExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addExpressionAST ("addExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_addExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addExpressionAST * p = NULL ;
    macroMyNew (p, GGS_addExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addExpressionAST GGS_addExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addExpressionAST * p = dynamic_cast <const GGS_addExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_subExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_subExpressionAST::
cPtr_subExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_subExpressionAST * GGS_subExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_subExpressionAST) ;
    return (cPtr_subExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_subExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_subExpressionAST * ptr = dynamic_cast <const cPtr_subExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_subExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@subExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_subExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_subExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_subExpressionAST (& typeid (cPtr_subExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_subExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__subExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_subExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_subExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_subExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_subExpressionAST ("subExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_subExpressionAST::
GGS_subExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionAST::
GGS_subExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_subExpressionAST GGS_subExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_subExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_subExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_subExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_subExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_subExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionAST GGS_subExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_subExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_subExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_subExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_subExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_subExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_subExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_subExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_subExpressionAST::actualTypeName (void) const {
  return "subExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__subExpressionAST ("subExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_subExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_subExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_subExpressionAST * p = NULL ;
    macroMyNew (p, GGS_subExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_subExpressionAST GGS_subExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_subExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_subExpressionAST * p = dynamic_cast <const GGS_subExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_subExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_subExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_subExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_multiplicationExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_multiplicationExpressionAST::
cPtr_multiplicationExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_multiplicationExpressionAST * GGS_multiplicationExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_multiplicationExpressionAST) ;
    return (cPtr_multiplicationExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_multiplicationExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_multiplicationExpressionAST * ptr = dynamic_cast <const cPtr_multiplicationExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_multiplicationExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@multiplicationExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_multiplicationExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_multiplicationExpressionAST (& typeid (cPtr_multiplicationExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_multiplicationExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__multiplicationExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_multiplicationExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_multiplicationExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_multiplicationExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiplicationExpressionAST ("multiplicationExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionAST::
GGS_multiplicationExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionAST::
GGS_multiplicationExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_multiplicationExpressionAST GGS_multiplicationExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_multiplicationExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_multiplicationExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_multiplicationExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_multiplicationExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionAST GGS_multiplicationExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_multiplicationExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_multiplicationExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_multiplicationExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_multiplicationExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_multiplicationExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_multiplicationExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiplicationExpressionAST::actualTypeName (void) const {
  return "multiplicationExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__multiplicationExpressionAST ("multiplicationExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_multiplicationExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_multiplicationExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiplicationExpressionAST * p = NULL ;
    macroMyNew (p, GGS_multiplicationExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiplicationExpressionAST GGS_multiplicationExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiplicationExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiplicationExpressionAST * p = dynamic_cast <const GGS_multiplicationExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiplicationExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiplicationExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiplicationExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_divisionExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_divisionExpressionAST::
cPtr_divisionExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_divisionExpressionAST * GGS_divisionExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_divisionExpressionAST) ;
    return (cPtr_divisionExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_divisionExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_divisionExpressionAST * ptr = dynamic_cast <const cPtr_divisionExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_divisionExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@divisionExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_divisionExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_divisionExpressionAST (& typeid (cPtr_divisionExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_divisionExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__divisionExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_divisionExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_divisionExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_divisionExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_divisionExpressionAST ("divisionExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_divisionExpressionAST::
GGS_divisionExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionAST::
GGS_divisionExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_divisionExpressionAST GGS_divisionExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_divisionExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_divisionExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_divisionExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_divisionExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionAST GGS_divisionExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_divisionExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_divisionExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_divisionExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_divisionExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_divisionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_divisionExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_divisionExpressionAST::actualTypeName (void) const {
  return "divisionExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__divisionExpressionAST ("divisionExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_divisionExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_divisionExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_divisionExpressionAST * p = NULL ;
    macroMyNew (p, GGS_divisionExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_divisionExpressionAST GGS_divisionExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_divisionExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_divisionExpressionAST * p = dynamic_cast <const GGS_divisionExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_divisionExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_divisionExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_divisionExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_moduloExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_moduloExpressionAST::
cPtr_moduloExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_moduloExpressionAST * GGS_moduloExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_moduloExpressionAST) ;
    return (cPtr_moduloExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_moduloExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_moduloExpressionAST * ptr = dynamic_cast <const cPtr_moduloExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_moduloExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@moduloExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_moduloExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_moduloExpressionAST (& typeid (cPtr_moduloExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_moduloExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__moduloExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_moduloExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_moduloExpressionAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_moduloExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_moduloExpressionAST ("moduloExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_moduloExpressionAST::
GGS_moduloExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionAST::
GGS_moduloExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_moduloExpressionAST GGS_moduloExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_moduloExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_moduloExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_moduloExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_moduloExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionAST GGS_moduloExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_moduloExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_moduloExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_moduloExpressionAST::
reader_mLeftExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_moduloExpressionAST::
reader_mRightExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_moduloExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_moduloExpressionAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_moduloExpressionAST::actualTypeName (void) const {
  return "moduloExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__moduloExpressionAST ("moduloExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_moduloExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_moduloExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_moduloExpressionAST * p = NULL ;
    macroMyNew (p, GGS_moduloExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_moduloExpressionAST GGS_moduloExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_moduloExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_moduloExpressionAST * p = dynamic_cast <const GGS_moduloExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_moduloExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_moduloExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_moduloExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_unaryMinusExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_unaryMinusExpressionAST::
cPtr_unaryMinusExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_unaryMinusExpressionAST * GGS_unaryMinusExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_unaryMinusExpressionAST) ;
    return (cPtr_unaryMinusExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_unaryMinusExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_unaryMinusExpressionAST * ptr = dynamic_cast <const cPtr_unaryMinusExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_unaryMinusExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@unaryMinusExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_unaryMinusExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_unaryMinusExpressionAST (& typeid (cPtr_unaryMinusExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_unaryMinusExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__unaryMinusExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_unaryMinusExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_unaryMinusExpressionAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_unaryMinusExpressionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_unaryMinusExpressionAST ("unaryMinusExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionAST::
GGS_unaryMinusExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionAST::
GGS_unaryMinusExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_unaryMinusExpressionAST GGS_unaryMinusExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_unaryMinusExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_unaryMinusExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_unaryMinusExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_unaryMinusExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionAST GGS_unaryMinusExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_unaryMinusExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_unaryMinusExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_unaryMinusExpressionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_unaryMinusExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_unaryMinusExpressionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_unaryMinusExpressionAST::actualTypeName (void) const {
  return "unaryMinusExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__unaryMinusExpressionAST ("unaryMinusExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_unaryMinusExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_unaryMinusExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_unaryMinusExpressionAST * p = NULL ;
    macroMyNew (p, GGS_unaryMinusExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_unaryMinusExpressionAST GGS_unaryMinusExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_unaryMinusExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_unaryMinusExpressionAST * p = dynamic_cast <const GGS_unaryMinusExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_unaryMinusExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_unaryMinusExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_unaryMinusExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_notExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_notExpressionAST::
cPtr_notExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_notExpressionAST * GGS_notExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_notExpressionAST) ;
    return (cPtr_notExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_notExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_notExpressionAST * ptr = dynamic_cast <const cPtr_notExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_notExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@notExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_notExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_notExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_notExpressionAST (& typeid (cPtr_notExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_notExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__notExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_notExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_notExpressionAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_notExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_notExpressionAST ("notExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_notExpressionAST::
GGS_notExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionAST::
GGS_notExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_notExpressionAST GGS_notExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_notExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_notExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_notExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_notExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_notExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionAST GGS_notExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_notExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_notExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_notExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_notExpressionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_notExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_notExpressionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_notExpressionAST::actualTypeName (void) const {
  return "notExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__notExpressionAST ("notExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_notExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_notExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_notExpressionAST * p = NULL ;
    macroMyNew (p, GGS_notExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_notExpressionAST GGS_notExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_notExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_notExpressionAST * p = dynamic_cast <const GGS_notExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_notExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_notExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_notExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_negateExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_negateExpressionAST::
cPtr_negateExpressionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_negateExpressionAST * GGS_negateExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_negateExpressionAST) ;
    return (cPtr_negateExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_negateExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_negateExpressionAST * ptr = dynamic_cast <const cPtr_negateExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_negateExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@negateExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_negateExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_negateExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_negateExpressionAST (& typeid (cPtr_negateExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_negateExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__negateExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_negateExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_negateExpressionAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_negateExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_negateExpressionAST ("negateExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_negateExpressionAST::
GGS_negateExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_negateExpressionAST::
GGS_negateExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_negateExpressionAST GGS_negateExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_negateExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_negateExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_negateExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_negateExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_negateExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_negateExpressionAST GGS_negateExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_negateExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_negateExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_negateExpressionAST::
reader_mOperatorLocation (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_negateExpressionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_negateExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_negateExpressionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_negateExpressionAST::actualTypeName (void) const {
  return "negateExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__negateExpressionAST ("negateExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_negateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_negateExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_negateExpressionAST * p = NULL ;
    macroMyNew (p, GGS_negateExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_negateExpressionAST GGS_negateExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_negateExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_negateExpressionAST * p = dynamic_cast <const GGS_negateExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_negateExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_negateExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_negateExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'cPtr_ifExpressionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifExpressionAST::
cPtr_ifExpressionAST (const GGS_semanticExpressionAST & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mIfExpression (argument_0),
mThenExpression (argument_1),
mElseExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifExpressionAST * GGS_ifExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifExpressionAST) ;
    return (cPtr_ifExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifExpressionAST * ptr = dynamic_cast <const cPtr_ifExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIfExpression.operator_isEqual (ptr->mIfExpression).boolValue ()
         && mThenExpression.operator_isEqual (ptr->mThenExpression).boolValue ()
         && mElseExpression.operator_isEqual (ptr->mElseExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifExpressionAST:"
           << mIfExpression.reader_description (inIndentation + 1)
           << mThenExpression.reader_description (inIndentation + 1)
           << mElseExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifExpressionAST (& typeid (cPtr_ifExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__ifExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifExpressionAST (mIfExpression, mThenExpression, mElseExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_ifExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifExpressionAST ("ifExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_ifExpressionAST::
GGS_ifExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionAST::
GGS_ifExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifExpressionAST GGS_ifExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_ifExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionAST GGS_ifExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionAST & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ifExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_ifExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_ifExpressionAST::
reader_mIfExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionAST *) mPointer)->mIfExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_ifExpressionAST::
reader_mThenExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionAST *) mPointer)->mThenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_ifExpressionAST::
reader_mElseExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifExpressionAST *) mPointer)->mElseExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifExpressionAST::actualTypeName (void) const {
  return "ifExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifExpressionAST ("ifExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_ifExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifExpressionAST * p = NULL ;
    macroMyNew (p, GGS_ifExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifExpressionAST GGS_ifExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifExpressionAST * p = dynamic_cast <const GGS_ifExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_functionCallExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionCallExpressionAST::
cPtr_functionCallExpressionAST (const GGS_lstring & argument_0,
                                const GGS_outSemanticExpressionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mFunctionName (argument_0),
mExpressions (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionCallExpressionAST * GGS_functionCallExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionCallExpressionAST) ;
    return (cPtr_functionCallExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionCallExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionCallExpressionAST * ptr = dynamic_cast <const cPtr_functionCallExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mExpressions.operator_isEqual (ptr->mExpressions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionCallExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionCallExpressionAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mExpressions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionCallExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionCallExpressionAST (& typeid (cPtr_functionCallExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionCallExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__functionCallExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionCallExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionCallExpressionAST (mFunctionName, mExpressions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_functionCallExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionCallExpressionAST ("functionCallExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_functionCallExpressionAST::
GGS_functionCallExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionAST::
GGS_functionCallExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionCallExpressionAST GGS_functionCallExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionCallExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_functionCallExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionCallExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionCallExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionAST GGS_functionCallExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_outSemanticExpressionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_functionCallExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_functionCallExpressionAST::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionAST *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST  GGS_functionCallExpressionAST::
reader_mExpressions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionCallExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionCallExpressionAST *) mPointer)->mExpressions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionCallExpressionAST::actualTypeName (void) const {
  return "functionCallExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionCallExpressionAST ("functionCallExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_functionCallExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionCallExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionCallExpressionAST * p = NULL ;
    macroMyNew (p, GGS_functionCallExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionCallExpressionAST GGS_functionCallExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionCallExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionCallExpressionAST * p = dynamic_cast <const GGS_functionCallExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionCallExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionCallExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionCallExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_varInExpressionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_varInExpressionAST::
cPtr_varInExpressionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mVarName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_varInExpressionAST * GGS_varInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_varInExpressionAST) ;
    return (cPtr_varInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_varInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_varInExpressionAST * ptr = dynamic_cast <const cPtr_varInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVarName.operator_isEqual (ptr->mVarName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_varInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@varInExpressionAST:"
           << mVarName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_varInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_varInExpressionAST (& typeid (cPtr_varInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_varInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__varInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_varInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_varInExpressionAST (mVarName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_varInExpressionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_varInExpressionAST ("varInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_varInExpressionAST::
GGS_varInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionAST::
GGS_varInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_varInExpressionAST GGS_varInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_varInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_varInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_varInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_varInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_varInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionAST GGS_varInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_varInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_varInExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_varInExpressionAST::
reader_mVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_varInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_varInExpressionAST *) mPointer)->mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_varInExpressionAST::actualTypeName (void) const {
  return "varInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__varInExpressionAST ("varInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_varInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_varInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_varInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_varInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_varInExpressionAST GGS_varInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_varInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_varInExpressionAST * p = dynamic_cast <const GGS_varInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_varInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_varInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_varInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_literalTypeInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_literalTypeInExpressionAST::
cPtr_literalTypeInExpressionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mVarName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_literalTypeInExpressionAST * GGS_literalTypeInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_literalTypeInExpressionAST) ;
    return (cPtr_literalTypeInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_literalTypeInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_literalTypeInExpressionAST * ptr = dynamic_cast <const cPtr_literalTypeInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVarName.operator_isEqual (ptr->mVarName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_literalTypeInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@literalTypeInExpressionAST:"
           << mVarName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_literalTypeInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_literalTypeInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_literalTypeInExpressionAST (& typeid (cPtr_literalTypeInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_literalTypeInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__literalTypeInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_literalTypeInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_literalTypeInExpressionAST (mVarName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_literalTypeInExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_literalTypeInExpressionAST ("literalTypeInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionAST::
GGS_literalTypeInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionAST::
GGS_literalTypeInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_literalTypeInExpressionAST GGS_literalTypeInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_literalTypeInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_literalTypeInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_literalTypeInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_literalTypeInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionAST GGS_literalTypeInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_literalTypeInExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_literalTypeInExpressionAST::
reader_mVarName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_literalTypeInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_literalTypeInExpressionAST *) mPointer)->mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_literalTypeInExpressionAST::actualTypeName (void) const {
  return "literalTypeInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__literalTypeInExpressionAST ("literalTypeInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_literalTypeInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_literalTypeInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_literalTypeInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_literalTypeInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_literalTypeInExpressionAST GGS_literalTypeInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_literalTypeInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_literalTypeInExpressionAST * p = dynamic_cast <const GGS_literalTypeInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_literalTypeInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_literalTypeInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_literalTypeInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_castInExpressionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInExpressionAST::
cPtr_castInExpressionAST (const GGS_semanticExpressionAST & argument_0,
                                const GGS_bool& argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mReceiverExpression (argument_0),
mUseKindOfClass (argument_1),
mTypeName (argument_2),
mErrorLocationExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInExpressionAST * GGS_castInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_castInExpressionAST) ;
    return (cPtr_castInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInExpressionAST * ptr = dynamic_cast <const cPtr_castInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@castInExpressionAST:"
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mUseKindOfClass.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInExpressionAST (& typeid (cPtr_castInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_castInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__castInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_castInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_castInExpressionAST (mReceiverExpression, mUseKindOfClass, mTypeName, mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_castInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInExpressionAST ("castInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_castInExpressionAST::
GGS_castInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionAST::
GGS_castInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_castInExpressionAST GGS_castInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_castInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_castInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionAST GGS_castInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionAST & argument_0,
                 const GGS_bool& argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_castInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_castInExpressionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_castInExpressionAST::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInExpressionAST::
reader_mUseKindOfClass (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mUseKindOfClass ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInExpressionAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_castInExpressionAST::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInExpressionAST *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInExpressionAST::actualTypeName (void) const {
  return "castInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__castInExpressionAST ("castInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_castInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_castInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_castInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInExpressionAST GGS_castInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInExpressionAST * p = dynamic_cast <const GGS_castInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_filewrapperObjectInstanciationInExpressionAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperObjectInstanciationInExpressionAST::
cPtr_filewrapperObjectInstanciationInExpressionAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mFilewrapperName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperObjectInstanciationInExpressionAST * GGS_filewrapperObjectInstanciationInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperObjectInstanciationInExpressionAST) ;
    return (cPtr_filewrapperObjectInstanciationInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperObjectInstanciationInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperObjectInstanciationInExpressionAST * ptr = dynamic_cast <const cPtr_filewrapperObjectInstanciationInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperObjectInstanciationInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperObjectInstanciationInExpressionAST:"
           << mFilewrapperName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperObjectInstanciationInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperObjectInstanciationInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperObjectInstanciationInExpressionAST (& typeid (cPtr_filewrapperObjectInstanciationInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperObjectInstanciationInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperObjectInstanciationInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperObjectInstanciationInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperObjectInstanciationInExpressionAST (mFilewrapperName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_filewrapperObjectInstanciationInExpressionAST'      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionAST ("filewrapperObjectInstanciationInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionAST::
GGS_filewrapperObjectInstanciationInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionAST::
GGS_filewrapperObjectInstanciationInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperObjectInstanciationInExpressionAST GGS_filewrapperObjectInstanciationInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperObjectInstanciationInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperObjectInstanciationInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperObjectInstanciationInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperObjectInstanciationInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionAST GGS_filewrapperObjectInstanciationInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperObjectInstanciationInExpressionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperObjectInstanciationInExpressionAST::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperObjectInstanciationInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperObjectInstanciationInExpressionAST *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperObjectInstanciationInExpressionAST::actualTypeName (void) const {
  return "filewrapperObjectInstanciationInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperObjectInstanciationInExpressionAST ("filewrapperObjectInstanciationInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperObjectInstanciationInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperObjectInstanciationInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperObjectInstanciationInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperObjectInstanciationInExpressionAST GGS_filewrapperObjectInstanciationInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperObjectInstanciationInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperObjectInstanciationInExpressionAST * p = dynamic_cast <const GGS_filewrapperObjectInstanciationInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperObjectInstanciationInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperObjectInstanciationInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_filewrapperInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperInExpressionAST::
cPtr_filewrapperInExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mFilewrapperName (argument_0),
mFilewrapperPath (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperInExpressionAST * GGS_filewrapperInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperInExpressionAST) ;
    return (cPtr_filewrapperInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperInExpressionAST * ptr = dynamic_cast <const cPtr_filewrapperInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperPath.operator_isEqual (ptr->mFilewrapperPath).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperInExpressionAST:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperPath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperInExpressionAST (& typeid (cPtr_filewrapperInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperInExpressionAST (mFilewrapperName, mFilewrapperPath COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_filewrapperInExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperInExpressionAST ("filewrapperInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionAST::
GGS_filewrapperInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionAST::
GGS_filewrapperInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperInExpressionAST GGS_filewrapperInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionAST GGS_filewrapperInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperInExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperInExpressionAST::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperInExpressionAST *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperInExpressionAST::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperInExpressionAST *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperInExpressionAST::actualTypeName (void) const {
  return "filewrapperInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperInExpressionAST ("filewrapperInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_filewrapperInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperInExpressionAST GGS_filewrapperInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperInExpressionAST * p = dynamic_cast <const GGS_filewrapperInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_filewrapperTemplateInExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperTemplateInExpressionAST::
cPtr_filewrapperTemplateInExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_outSemanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticExpressionAST (THERE),
mFilewrapperName (argument_0),
mFilewrapperTemplateName (argument_1),
mActualOutputParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperTemplateInExpressionAST * GGS_filewrapperTemplateInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperTemplateInExpressionAST) ;
    return (cPtr_filewrapperTemplateInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperTemplateInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperTemplateInExpressionAST * ptr = dynamic_cast <const cPtr_filewrapperTemplateInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperTemplateName.operator_isEqual (ptr->mFilewrapperTemplateName).boolValue ()
         && mActualOutputParameterList.operator_isEqual (ptr->mActualOutputParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperTemplateInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperTemplateInExpressionAST:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperTemplateName.reader_description (inIndentation + 1)
           << mActualOutputParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplateInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperTemplateInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperTemplateInExpressionAST (& typeid (cPtr_filewrapperTemplateInExpressionAST), & typeid (cPtr_semanticExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperTemplateInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperTemplateInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperTemplateInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperTemplateInExpressionAST (mFilewrapperName, mFilewrapperTemplateName, mActualOutputParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_filewrapperTemplateInExpressionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateInExpressionAST ("filewrapperTemplateInExpressionAST", true, & kTypeDescriptor_GGS_semanticExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionAST::
GGS_filewrapperTemplateInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionAST::
GGS_filewrapperTemplateInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperTemplateInExpressionAST GGS_filewrapperTemplateInExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperTemplateInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperTemplateInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperTemplateInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperTemplateInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionAST GGS_filewrapperTemplateInExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_outSemanticExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperTemplateInExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateInExpressionAST::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionAST *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateInExpressionAST::
reader_mFilewrapperTemplateName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionAST *) mPointer)->mFilewrapperTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST  GGS_filewrapperTemplateInExpressionAST::
reader_mActualOutputParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperTemplateInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperTemplateInExpressionAST *) mPointer)->mActualOutputParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperTemplateInExpressionAST::actualTypeName (void) const {
  return "filewrapperTemplateInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperTemplateInExpressionAST ("filewrapperTemplateInExpressionAST", gClassInfoFor__semanticExpressionAST, & kTypeDescriptor_GGS_filewrapperTemplateInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateInExpressionAST GGS_filewrapperTemplateInExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateInExpressionAST * p = dynamic_cast <const GGS_filewrapperTemplateInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'formalArgumentPassingModeAST' Enumeration            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalArgumentPassingModeAST ("formalArgumentPassingModeAST", false, NULL) ;

//---------------------------------------------------------------------------*

bool GGS_formalArgumentPassingModeAST::
isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_isEqual (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_isNotEqual (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_infOrEqual (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_supOrEqual (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_strictInf (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingModeAST::
operator_strictSup (const GGS_formalArgumentPassingModeAST inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_formalArgumentMessage (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "a constant input (\?\?) formal argument",
    "an input (\?) formal argument",
    "an input/output (\?!) argument",
    "an output (!) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_formalArgumentString (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "'\?\?'",
    "'\?'",
    "'\?!'",
    "'!'"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_string (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "\?\?",
    "\?",
    "\?!",
    "!"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_generation1ForFormalParameter (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "const ",
    "",
    "",
    ""
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_generation2ForFormalParameter (C_Compiler & /* inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "",
    "",
    " &",
    " &"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingModeAST::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @formalArgumentPassingModeAST" ;
  switch (mValue) {
  case enum_argumentConstantIn:
    s << " argumentConstantIn>" ;
    break ;
  case enum_argumentIn:
    s << " argumentIn>" ;
    break ;
  case enum_argumentInOut:
    s << " argumentInOut>" ;
    break ;
  case enum_argumentOut:
    s << " argumentOut>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalArgumentPassingModeAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalArgumentPassingModeAST * p = NULL ;
    macroMyNew (p, GGS_formalArgumentPassingModeAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalArgumentPassingModeAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalArgumentPassingModeAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalArgumentPassingModeAST * p = dynamic_cast <const GGS_formalArgumentPassingModeAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalArgumentPassingModeAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalArgumentPassingModeAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalArgumentPassingModeAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@formalParameterListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalParameterListAST::
elementOf_GGS_formalParameterListAST (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalParameterPassingMode (argument_0),
mFormalParameterTypeName (argument_1),
mFormalParameterName (argument_2),
mIsUnused (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalParameterListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalParameterListAST * ptr = dynamic_cast <const elementOf_GGS_formalParameterListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalParameterPassingMode.operator_isEqual (ptr->mFormalParameterPassingMode).boolValue ()
         && mFormalParameterTypeName.operator_isEqual (ptr->mFormalParameterTypeName).boolValue ()
         && mFormalParameterName.operator_isEqual (ptr->mFormalParameterName).boolValue ()
         && mIsUnused.operator_isEqual (ptr->mIsUnused).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalParameterListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterPassingMode.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@formalParameterListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalParameterListAST ("formalParameterListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
internalAppendValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
internalPrependValues (const GGS_formalArgumentPassingModeAST& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
addAssign_operation (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST GGS_formalParameterListAST::
operator_concat (const GGS_formalParameterListAST & inOperand) const {
  GGS_formalParameterListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
dotAssign_operation (const GGS_formalParameterListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalParameterListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_formalArgumentPassingModeAST p_0 = p->mFormalParameterPassingMode ;
          GGS_lstring  p_1 = p->mFormalParameterTypeName ;
          GGS_lstring  p_2 = p->mFormalParameterName ;
          GGS_bool p_3 = p->mIsUnused ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_formalArgumentPassingModeAST& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalParameterPassingMode,
                                ptr->mFormalParameterTypeName,
                                ptr->mFormalParameterName,
                                ptr->mIsUnused
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_formalParameterListAST::
constructor_emptyList (void) {
  GGS_formalParameterListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_formalParameterListAST::
constructor_listWithValue (const GGS_formalArgumentPassingModeAST& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3) {
  GGS_formalParameterListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
internalSubListWithRange (GGS_formalParameterListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalParameterPassingMode, ptr->mFormalParameterTypeName, ptr->mFormalParameterName, ptr->mIsUnused) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST GGS_formalParameterListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST GGS_formalParameterListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalParameterListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalParameterListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
method_first (C_Compiler & inLexique,
              GGS_formalArgumentPassingModeAST& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterPassingMode ;
    _out_1 = ptr->mFormalParameterTypeName ;
    _out_2 = ptr->mFormalParameterName ;
    _out_3 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
method_last (C_Compiler & inLexique,
             GGS_formalArgumentPassingModeAST& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterPassingMode ;
    _out_1 = ptr->mFormalParameterTypeName ;
    _out_2 = ptr->mFormalParameterName ;
    _out_3 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_formalArgumentPassingModeAST& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterPassingMode ;
    _out_1 = ptr->mFormalParameterTypeName ;
    _out_2 = ptr->mFormalParameterName ;
    _out_3 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_formalArgumentPassingModeAST& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterPassingMode ;
    _out_1 = ptr->mFormalParameterTypeName ;
    _out_2 = ptr->mFormalParameterName ;
    _out_3 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalArgumentPassingModeAST GGS_formalParameterListAST::
reader_mFormalParameterPassingModeAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalArgumentPassingModeAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterPassingMode ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameterListAST::
reader_mFormalParameterTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalParameterListAST::
reader_mFormalParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalParameterListAST::
reader_mIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_setMFormalParameterPassingModeAtIndex (C_Compiler & inLexique,
                              const GGS_formalArgumentPassingModeAST & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterPassingMode = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_setMFormalParameterTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_setMFormalParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalParameterListAST::
modifier_setMIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalArgumentPassingModeAST & GGS_formalParameterListAST::cEnumerator::_mFormalParameterPassingMode (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterPassingMode ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalParameterListAST::cEnumerator::_mFormalParameterTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalParameterListAST::cEnumerator::_mFormalParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalParameterListAST::cEnumerator::_mIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsUnused ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalParameterListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalParameterListAST * p = NULL ;
    macroMyNew (p, GGS_formalParameterListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST GGS_formalParameterListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalParameterListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalParameterListAST * p = dynamic_cast <const GGS_formalParameterListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalParameterListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalParameterListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalParameterListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@formalInputParameterListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_formalInputParameterListAST::
elementOf_GGS_formalInputParameterListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFormalParameterTypeName (argument_0),
mFormalParameterName (argument_1),
mIsUnused (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_formalInputParameterListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_formalInputParameterListAST * ptr = dynamic_cast <const elementOf_GGS_formalInputParameterListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFormalParameterTypeName.operator_isEqual (ptr->mFormalParameterTypeName).boolValue ()
         && mFormalParameterName.operator_isEqual (ptr->mFormalParameterName).boolValue ()
         && mIsUnused.operator_isEqual (ptr->mIsUnused).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_formalInputParameterListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFormalParameterName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsUnused.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@formalInputParameterListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_formalInputParameterListAST ("formalInputParameterListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST GGS_formalInputParameterListAST::
operator_concat (const GGS_formalInputParameterListAST & inOperand) const {
  GGS_formalInputParameterListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
dotAssign_operation (const GGS_formalInputParameterListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_formalInputParameterListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFormalParameterTypeName ;
          GGS_lstring  p_1 = p->mFormalParameterName ;
          GGS_bool p_2 = p->mIsUnused ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_bool& argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFormalParameterTypeName,
                                ptr->mFormalParameterName,
                                ptr->mIsUnused
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_formalInputParameterListAST::
constructor_emptyList (void) {
  GGS_formalInputParameterListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_formalInputParameterListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2) {
  GGS_formalInputParameterListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
internalSubListWithRange (GGS_formalInputParameterListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFormalParameterTypeName, ptr->mFormalParameterName, ptr->mIsUnused) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST GGS_formalInputParameterListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST GGS_formalInputParameterListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalInputParameterListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@formalInputParameterListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_bool& _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterTypeName ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_bool& _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterTypeName ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_bool& _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterTypeName ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_bool& _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFormalParameterTypeName ;
    _out_1 = ptr->mFormalParameterName ;
    _out_2 = ptr->mIsUnused ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalInputParameterListAST::
reader_mFormalParameterTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_formalInputParameterListAST::
reader_mFormalParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFormalParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalInputParameterListAST::
reader_mIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_setMFormalParameterTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_setMFormalParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFormalParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_formalInputParameterListAST::
modifier_setMIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalInputParameterListAST::cEnumerator::_mFormalParameterTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_formalInputParameterListAST::cEnumerator::_mFormalParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFormalParameterName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_formalInputParameterListAST::cEnumerator::_mIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsUnused ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_formalInputParameterListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_formalInputParameterListAST * p = NULL ;
    macroMyNew (p, GGS_formalInputParameterListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST GGS_formalInputParameterListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_formalInputParameterListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_formalInputParameterListAST * p = dynamic_cast <const GGS_formalInputParameterListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_formalInputParameterListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_formalInputParameterListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_formalInputParameterListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_actualParameterAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_actualParameterAST::
cPtr_actualParameterAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_actualParameterAST * GGS_actualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_actualParameterAST) ;
    return (cPtr_actualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_actualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@actualParameterAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_actualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_actualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_actualParameterAST (& typeid (cPtr_actualParameterAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_actualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__actualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_actualParameterAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterAST ("actualParameterAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_actualParameterAST::
GGS_actualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterAST::
GGS_actualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_actualParameterAST GGS_actualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_actualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_actualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_actualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_actualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_actualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_actualParameterAST::actualTypeName (void) const {
  return "actualParameterAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_actualParameterAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__actualParameterAST ("actualParameterAST", & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterAST * p = NULL ;
    macroMyNew (p, GGS_actualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterAST GGS_actualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterAST * p = dynamic_cast <const GGS_actualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_outputActualParameterAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputActualParameterAST::
cPtr_outputActualParameterAST (const GGS_semanticExpressionAST & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterAST (THERE),
mOutputActualParameterExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputActualParameterAST * GGS_outputActualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputActualParameterAST) ;
    return (cPtr_outputActualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputActualParameterAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputActualParameterAST * ptr = dynamic_cast <const cPtr_outputActualParameterAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOutputActualParameterExpression.operator_isEqual (ptr->mOutputActualParameterExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputActualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputActualParameterAST:"
           << mOutputActualParameterExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputActualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputActualParameterAST (& typeid (cPtr_outputActualParameterAST), & typeid (cPtr_actualParameterAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputActualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__outputActualParameterAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputActualParameterAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputActualParameterAST (mOutputActualParameterExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_outputActualParameterAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputActualParameterAST ("outputActualParameterAST", true, & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_outputActualParameterAST::
GGS_outputActualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterAST::
GGS_outputActualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputActualParameterAST GGS_outputActualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputActualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_outputActualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputActualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputActualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterAST GGS_outputActualParameterAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionAST & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterAST result ;
  macroMyNew (result.mPointer, cPtr_outputActualParameterAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_outputActualParameterAST::
reader_mOutputActualParameterExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputActualParameterAST *) mPointer)->mOutputActualParameterExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputActualParameterAST::actualTypeName (void) const {
  return "outputActualParameterAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputActualParameterAST ("outputActualParameterAST", gClassInfoFor__actualParameterAST, & kTypeDescriptor_GGS_outputActualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputActualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputActualParameterAST * p = NULL ;
    macroMyNew (p, GGS_outputActualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputActualParameterAST GGS_outputActualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputActualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputActualParameterAST * p = dynamic_cast <const GGS_outputActualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputActualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputActualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_outputInputActualParameterAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_outputInputActualParameterAST::
cPtr_outputInputActualParameterAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterAST (THERE),
mOutputInputActualParameterName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_outputInputActualParameterAST * GGS_outputInputActualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_outputInputActualParameterAST) ;
    return (cPtr_outputInputActualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_outputInputActualParameterAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_outputInputActualParameterAST * ptr = dynamic_cast <const cPtr_outputInputActualParameterAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOutputInputActualParameterName.operator_isEqual (ptr->mOutputInputActualParameterName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_outputInputActualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@outputInputActualParameterAST:"
           << mOutputInputActualParameterName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_outputInputActualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_outputInputActualParameterAST (& typeid (cPtr_outputInputActualParameterAST), & typeid (cPtr_actualParameterAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_outputInputActualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__outputInputActualParameterAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_outputInputActualParameterAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_outputInputActualParameterAST (mOutputInputActualParameterName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_outputInputActualParameterAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_outputInputActualParameterAST ("outputInputActualParameterAST", true, & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterAST::
GGS_outputInputActualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterAST::
GGS_outputInputActualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_outputInputActualParameterAST GGS_outputInputActualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_outputInputActualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_outputInputActualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_outputInputActualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_outputInputActualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterAST GGS_outputInputActualParameterAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterAST result ;
  macroMyNew (result.mPointer, cPtr_outputInputActualParameterAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_outputInputActualParameterAST::
reader_mOutputInputActualParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterAST *) mPointer)->mOutputInputActualParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_outputInputActualParameterAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_outputInputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_outputInputActualParameterAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_outputInputActualParameterAST::actualTypeName (void) const {
  return "outputInputActualParameterAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__outputInputActualParameterAST ("outputInputActualParameterAST", gClassInfoFor__actualParameterAST, & kTypeDescriptor_GGS_outputInputActualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_outputInputActualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_outputInputActualParameterAST * p = NULL ;
    macroMyNew (p, GGS_outputInputActualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outputInputActualParameterAST GGS_outputInputActualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_outputInputActualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_outputInputActualParameterAST * p = dynamic_cast <const GGS_outputInputActualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_outputInputActualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_outputInputActualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_outputInputActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_inputActualParameterAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputActualParameterAST::
cPtr_inputActualParameterAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_actualParameterAST (THERE),
mDeclarationTypeName (argument_0),
mInputActualParameterName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputActualParameterAST * GGS_inputActualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputActualParameterAST) ;
    return (cPtr_inputActualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputActualParameterAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_inputActualParameterAST * ptr = dynamic_cast <const cPtr_inputActualParameterAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDeclarationTypeName.operator_isEqual (ptr->mDeclarationTypeName).boolValue ()
         && mInputActualParameterName.operator_isEqual (ptr->mInputActualParameterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_inputActualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@inputActualParameterAST:"
           << mDeclarationTypeName.reader_description (inIndentation + 1)
           << mInputActualParameterName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputActualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputActualParameterAST (& typeid (cPtr_inputActualParameterAST), & typeid (cPtr_actualParameterAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputActualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__inputActualParameterAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_inputActualParameterAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_inputActualParameterAST (mDeclarationTypeName, mInputActualParameterName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_inputActualParameterAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputActualParameterAST ("inputActualParameterAST", true, & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_inputActualParameterAST::
GGS_inputActualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterAST::
GGS_inputActualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputActualParameterAST GGS_inputActualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputActualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_inputActualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputActualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputActualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterAST GGS_inputActualParameterAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterAST result ;
  macroMyNew (result.mPointer, cPtr_inputActualParameterAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_inputActualParameterAST::
reader_mDeclarationTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputActualParameterAST *) mPointer)->mDeclarationTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_inputActualParameterAST::
reader_mInputActualParameterName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_inputActualParameterAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_inputActualParameterAST *) mPointer)->mInputActualParameterName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputActualParameterAST::actualTypeName (void) const {
  return "inputActualParameterAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputActualParameterAST ("inputActualParameterAST", gClassInfoFor__actualParameterAST, & kTypeDescriptor_GGS_inputActualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputActualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputActualParameterAST * p = NULL ;
    macroMyNew (p, GGS_inputActualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputActualParameterAST GGS_inputActualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputActualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputActualParameterAST * p = dynamic_cast <const GGS_inputActualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputActualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputActualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_inputJokerActualParameterAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_inputJokerActualParameterAST::
cPtr_inputJokerActualParameterAST (LOCATION_ARGS)
:cPtr_actualParameterAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_inputJokerActualParameterAST * GGS_inputJokerActualParameterAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_inputJokerActualParameterAST) ;
    return (cPtr_inputJokerActualParameterAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_inputJokerActualParameterAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_inputJokerActualParameterAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@inputJokerActualParameterAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_inputJokerActualParameterAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_inputJokerActualParameterAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_inputJokerActualParameterAST (& typeid (cPtr_inputJokerActualParameterAST), & typeid (cPtr_actualParameterAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_inputJokerActualParameterAST::galgasRTTI (void) const {
  return & gClassInfoFor__inputJokerActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_inputJokerActualParameterAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_inputJokerActualParameterAST ("inputJokerActualParameterAST", true, & kTypeDescriptor_GGS_actualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterAST::
GGS_inputJokerActualParameterAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterAST::
GGS_inputJokerActualParameterAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_inputJokerActualParameterAST GGS_inputJokerActualParameterAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_inputJokerActualParameterAST *> (inPointer) != NULL)
      : (typeid (cPtr_inputJokerActualParameterAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_inputJokerActualParameterAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_inputJokerActualParameterAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_inputJokerActualParameterAST * gSingleton_inputJokerActualParameterAST = NULL ;

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterAST GGS_inputJokerActualParameterAST::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterAST result ;
  if (NULL == gSingleton_inputJokerActualParameterAST) {
    macroMyNew (gSingleton_inputJokerActualParameterAST, cPtr_inputJokerActualParameterAST (THERE)) ;
    macroRetainObject (gSingleton_inputJokerActualParameterAST) ;
  }
  macroAssignObject (result.mPointer, gSingleton_inputJokerActualParameterAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_inputJokerActualParameterAST::actualTypeName (void) const {
  return "inputJokerActualParameterAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__inputJokerActualParameterAST ("inputJokerActualParameterAST", gClassInfoFor__actualParameterAST, & kTypeDescriptor_GGS_inputJokerActualParameterAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_inputJokerActualParameterAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_inputJokerActualParameterAST * p = NULL ;
    macroMyNew (p, GGS_inputJokerActualParameterAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_inputJokerActualParameterAST GGS_inputJokerActualParameterAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_inputJokerActualParameterAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_inputJokerActualParameterAST * p = dynamic_cast <const GGS_inputJokerActualParameterAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_inputJokerActualParameterAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_inputJokerActualParameterAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_inputJokerActualParameterAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@actualParameterListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualParameterListAST::
elementOf_GGS_actualParameterListAST (const GGS_actualParameterAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mActualParameter (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualParameterListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_actualParameterListAST * ptr = dynamic_cast <const elementOf_GGS_actualParameterListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualParameter.operator_isEqual (ptr->mActualParameter).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualParameterListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameter.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@actualParameterListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualParameterListAST ("actualParameterListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
internalAppendValues (const GGS_actualParameterAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
internalPrependValues (const GGS_actualParameterAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
addAssign_operation (const GGS_actualParameterAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST GGS_actualParameterListAST::
operator_concat (const GGS_actualParameterListAST & inOperand) const {
  GGS_actualParameterListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
dotAssign_operation (const GGS_actualParameterListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_actualParameterListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_actualParameterAST  p_0 = p->mActualParameter ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_actualParameterAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActualParameter
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_actualParameterListAST::
constructor_emptyList (void) {
  GGS_actualParameterListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_actualParameterListAST::
constructor_listWithValue (const GGS_actualParameterAST & argument_0) {
  GGS_actualParameterListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
internalSubListWithRange (GGS_actualParameterListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActualParameter) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST GGS_actualParameterListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST GGS_actualParameterListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_actualParameterListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParameterListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@actualParameterListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
method_first (C_Compiler & inLexique,
              GGS_actualParameterAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
method_last (C_Compiler & inLexique,
             GGS_actualParameterAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_actualParameterAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_actualParameterAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameter ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualParameterAST  GGS_actualParameterListAST::
reader_mActualParameterAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_actualParameterAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameter ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualParameterListAST::
modifier_setMActualParameterAtIndex (C_Compiler & inLexique,
                              const GGS_actualParameterAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameter = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_actualParameterAST  & GGS_actualParameterListAST::cEnumerator::_mActualParameter (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameter ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_actualParameterListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualParameterListAST * p = NULL ;
    macroMyNew (p, GGS_actualParameterListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST GGS_actualParameterListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualParameterListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualParameterListAST * p = dynamic_cast <const GGS_actualParameterListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualParameterListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualParameterListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualParameterListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@actualInputParameterListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_actualInputParameterListAST::
elementOf_GGS_actualInputParameterListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mActualParameterTypeName (argument_0),
mActualParameterName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_actualInputParameterListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_actualInputParameterListAST * ptr = dynamic_cast <const elementOf_GGS_actualInputParameterListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mActualParameterTypeName.operator_isEqual (ptr->mActualParameterTypeName).boolValue ()
         && mActualParameterName.operator_isEqual (ptr->mActualParameterName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_actualInputParameterListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mActualParameterName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@actualInputParameterListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_actualInputParameterListAST ("actualInputParameterListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST GGS_actualInputParameterListAST::
operator_concat (const GGS_actualInputParameterListAST & inOperand) const {
  GGS_actualInputParameterListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
dotAssign_operation (const GGS_actualInputParameterListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_actualInputParameterListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mActualParameterTypeName ;
          GGS_lstring  p_1 = p->mActualParameterName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mActualParameterTypeName,
                                ptr->mActualParameterName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST  GGS_actualInputParameterListAST::
constructor_emptyList (void) {
  GGS_actualInputParameterListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST  GGS_actualInputParameterListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_actualInputParameterListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
internalSubListWithRange (GGS_actualInputParameterListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mActualParameterTypeName, ptr->mActualParameterName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST GGS_actualInputParameterListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_actualInputParameterListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST GGS_actualInputParameterListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_actualInputParameterListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualInputParameterListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@actualInputParameterListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mActualParameterTypeName ;
    _out_1 = ptr->mActualParameterName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_actualInputParameterListAST::
reader_mActualParameterTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameterTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_actualInputParameterListAST::
reader_mActualParameterNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mActualParameterName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_setMActualParameterTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameterTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_actualInputParameterListAST::
modifier_setMActualParameterNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mActualParameterName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_actualInputParameterListAST::cEnumerator::_mActualParameterTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameterTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_actualInputParameterListAST::cEnumerator::_mActualParameterName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mActualParameterName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_actualInputParameterListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_actualInputParameterListAST * p = NULL ;
    macroMyNew (p, GGS_actualInputParameterListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualInputParameterListAST GGS_actualInputParameterListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_actualInputParameterListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_actualInputParameterListAST * p = dynamic_cast <const GGS_actualInputParameterListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_actualInputParameterListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_actualInputParameterListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_actualInputParameterListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_syntaxInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_syntaxInstructionAST::
cPtr_syntaxInstructionAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mStartLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_syntaxInstructionAST * GGS_syntaxInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_syntaxInstructionAST) ;
    return (cPtr_syntaxInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_syntaxInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@syntaxInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_syntaxInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_syntaxInstructionAST (& typeid (cPtr_syntaxInstructionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_syntaxInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__syntaxInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_syntaxInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_syntaxInstructionAST ("syntaxInstructionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_syntaxInstructionAST::
GGS_syntaxInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionAST::
GGS_syntaxInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_syntaxInstructionAST GGS_syntaxInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_syntaxInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_syntaxInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_syntaxInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_syntaxInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_syntaxInstructionAST::actualTypeName (void) const {
  return "syntaxInstructionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_syntaxInstructionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__syntaxInstructionAST ("syntaxInstructionAST", & kTypeDescriptor_GGS_syntaxInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_syntaxInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_syntaxInstructionAST * p = NULL ;
    macroMyNew (p, GGS_syntaxInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_syntaxInstructionAST GGS_syntaxInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_syntaxInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_syntaxInstructionAST * p = dynamic_cast <const GGS_syntaxInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_syntaxInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_syntaxInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_syntaxInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_semanticInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticInstructionAST::
cPtr_semanticInstructionAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_syntaxInstructionAST (argument_0 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticInstructionAST * GGS_semanticInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticInstructionAST) ;
    return (cPtr_semanticInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticInstructionAST (& typeid (cPtr_semanticInstructionAST), & typeid (cPtr_syntaxInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__semanticInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_semanticInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionAST ("semanticInstructionAST", true, & kTypeDescriptor_GGS_syntaxInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_semanticInstructionAST::
GGS_semanticInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionAST::
GGS_semanticInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticInstructionAST GGS_semanticInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_semanticInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticInstructionAST::actualTypeName (void) const {
  return "semanticInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__semanticInstructionAST ("semanticInstructionAST", gClassInfoFor__syntaxInstructionAST, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionAST * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionAST GGS_semanticInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionAST * p = dynamic_cast <const GGS_semanticInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@semanticInstructionListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticInstructionListAST::
elementOf_GGS_semanticInstructionListAST (const GGS_semanticInstructionAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticInstructionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticInstructionListAST * ptr = dynamic_cast <const elementOf_GGS_semanticInstructionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticInstructionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@semanticInstructionListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticInstructionListAST ("semanticInstructionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
internalAppendValues (const GGS_semanticInstructionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
internalPrependValues (const GGS_semanticInstructionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
addAssign_operation (const GGS_semanticInstructionAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST GGS_semanticInstructionListAST::
operator_concat (const GGS_semanticInstructionListAST & inOperand) const {
  GGS_semanticInstructionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
dotAssign_operation (const GGS_semanticInstructionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticInstructionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticInstructionAST  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticInstructionAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_semanticInstructionListAST::
constructor_emptyList (void) {
  GGS_semanticInstructionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_semanticInstructionListAST::
constructor_listWithValue (const GGS_semanticInstructionAST & argument_0) {
  GGS_semanticInstructionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
internalSubListWithRange (GGS_semanticInstructionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST GGS_semanticInstructionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST GGS_semanticInstructionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticInstructionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticInstructionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
method_first (C_Compiler & inLexique,
              GGS_semanticInstructionAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
method_last (C_Compiler & inLexique,
             GGS_semanticInstructionAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticInstructionAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticInstructionAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionAST  GGS_semanticInstructionListAST::
reader_mInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticInstructionListAST::
modifier_setMInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionAST  & GGS_semanticInstructionListAST::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticInstructionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticInstructionListAST * p = NULL ;
    macroMyNew (p, GGS_semanticInstructionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST GGS_semanticInstructionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticInstructionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticInstructionListAST * p = dynamic_cast <const GGS_semanticInstructionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticInstructionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticInstructionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticInstructionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_semanticDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticDeclarationAST::
cPtr_semanticDeclarationAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticDeclarationAST * GGS_semanticDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticDeclarationAST) ;
    return (cPtr_semanticDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_semanticDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@semanticDeclarationAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticDeclarationAST (& typeid (cPtr_semanticDeclarationAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__semanticDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_semanticDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationAST ("semanticDeclarationAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationAST::
GGS_semanticDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationAST::
GGS_semanticDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticDeclarationAST GGS_semanticDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_semanticDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticDeclarationAST::actualTypeName (void) const {
  return "semanticDeclarationAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticDeclarationAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticDeclarationAST ("semanticDeclarationAST", & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationAST GGS_semanticDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationAST * p = dynamic_cast <const GGS_semanticDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@semanticDeclarationListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_semanticDeclarationListAST::
elementOf_GGS_semanticDeclarationListAST (const GGS_semanticDeclarationAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSemanticDeclaration (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_semanticDeclarationListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_semanticDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_semanticDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_semanticDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@semanticDeclarationListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationListAST ("semanticDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
internalAppendValues (const GGS_semanticDeclarationAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
internalPrependValues (const GGS_semanticDeclarationAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
addAssign_operation (const GGS_semanticDeclarationAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST GGS_semanticDeclarationListAST::
operator_concat (const GGS_semanticDeclarationListAST & inOperand) const {
  GGS_semanticDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
dotAssign_operation (const GGS_semanticDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_semanticDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticDeclarationAST  p_0 = p->mSemanticDeclaration ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticDeclarationAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSemanticDeclaration
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST  GGS_semanticDeclarationListAST::
constructor_emptyList (void) {
  GGS_semanticDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST  GGS_semanticDeclarationListAST::
constructor_listWithValue (const GGS_semanticDeclarationAST & argument_0) {
  GGS_semanticDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
internalSubListWithRange (GGS_semanticDeclarationListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST GGS_semanticDeclarationListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST GGS_semanticDeclarationListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@semanticDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
method_first (C_Compiler & inLexique,
              GGS_semanticDeclarationAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
method_last (C_Compiler & inLexique,
             GGS_semanticDeclarationAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticDeclarationAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticDeclarationAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSemanticDeclaration ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationAST  GGS_semanticDeclarationListAST::
reader_mSemanticDeclarationAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticDeclarationAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSemanticDeclaration ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationListAST::
modifier_setMSemanticDeclarationAtIndex (C_Compiler & inLexique,
                              const GGS_semanticDeclarationAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSemanticDeclaration = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationAST  & GGS_semanticDeclarationListAST::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationListAST GGS_semanticDeclarationListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationListAST * p = dynamic_cast <const GGS_semanticDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_externRoutineDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externRoutineDeclarationAST::
cPtr_externRoutineDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mRoutineName (argument_0),
mFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externRoutineDeclarationAST * GGS_externRoutineDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_externRoutineDeclarationAST) ;
    return (cPtr_externRoutineDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externRoutineDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externRoutineDeclarationAST * ptr = dynamic_cast <const cPtr_externRoutineDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externRoutineDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@externRoutineDeclarationAST:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externRoutineDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externRoutineDeclarationAST (& typeid (cPtr_externRoutineDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_externRoutineDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__externRoutineDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_externRoutineDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_externRoutineDeclarationAST (mRoutineName, mFormalParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_externRoutineDeclarationAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externRoutineDeclarationAST ("externRoutineDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationAST::
GGS_externRoutineDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationAST::
GGS_externRoutineDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_externRoutineDeclarationAST GGS_externRoutineDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externRoutineDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_externRoutineDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_externRoutineDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externRoutineDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationAST GGS_externRoutineDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_externRoutineDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externRoutineDeclarationAST::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclarationAST *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_externRoutineDeclarationAST::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externRoutineDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externRoutineDeclarationAST *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externRoutineDeclarationAST::actualTypeName (void) const {
  return "externRoutineDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__externRoutineDeclarationAST ("externRoutineDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_externRoutineDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_externRoutineDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externRoutineDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_externRoutineDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externRoutineDeclarationAST GGS_externRoutineDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externRoutineDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externRoutineDeclarationAST * p = dynamic_cast <const GGS_externRoutineDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externRoutineDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externRoutineDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externRoutineDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_routinePrototypeDeclarationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routinePrototypeDeclarationAST::
cPtr_routinePrototypeDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_externRoutineDeclarationAST (argument_0, argument_1 COMMA_THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routinePrototypeDeclarationAST * GGS_routinePrototypeDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routinePrototypeDeclarationAST) ;
    return (cPtr_routinePrototypeDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routinePrototypeDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routinePrototypeDeclarationAST * ptr = dynamic_cast <const cPtr_routinePrototypeDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routinePrototypeDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routinePrototypeDeclarationAST:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routinePrototypeDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routinePrototypeDeclarationAST (& typeid (cPtr_routinePrototypeDeclarationAST), & typeid (cPtr_externRoutineDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routinePrototypeDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__routinePrototypeDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routinePrototypeDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routinePrototypeDeclarationAST (mRoutineName, mFormalParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_routinePrototypeDeclarationAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routinePrototypeDeclarationAST ("routinePrototypeDeclarationAST", true, & kTypeDescriptor_GGS_externRoutineDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationAST::
GGS_routinePrototypeDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationAST::
GGS_routinePrototypeDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routinePrototypeDeclarationAST GGS_routinePrototypeDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routinePrototypeDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_routinePrototypeDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routinePrototypeDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routinePrototypeDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationAST GGS_routinePrototypeDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_routinePrototypeDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routinePrototypeDeclarationAST::actualTypeName (void) const {
  return "routinePrototypeDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routinePrototypeDeclarationAST ("routinePrototypeDeclarationAST", gClassInfoFor__externRoutineDeclarationAST, & kTypeDescriptor_GGS_routinePrototypeDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routinePrototypeDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routinePrototypeDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_routinePrototypeDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routinePrototypeDeclarationAST GGS_routinePrototypeDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routinePrototypeDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routinePrototypeDeclarationAST * p = dynamic_cast <const GGS_routinePrototypeDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routinePrototypeDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routinePrototypeDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routinePrototypeDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_routineDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineDeclarationAST::
cPtr_routineDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_routinePrototypeDeclarationAST (argument_0, argument_1 COMMA_THERE),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineDeclarationAST * GGS_routineDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineDeclarationAST) ;
    return (cPtr_routineDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineDeclarationAST * ptr = dynamic_cast <const cPtr_routineDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineDeclarationAST:"
           << mRoutineName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1)
           << mRoutineInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineDeclarationAST (& typeid (cPtr_routineDeclarationAST), & typeid (cPtr_routinePrototypeDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__routineDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineDeclarationAST (mRoutineName, mFormalParameterList, mRoutineInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_routineDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineDeclarationAST ("routineDeclarationAST", true, & kTypeDescriptor_GGS_routinePrototypeDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_routineDeclarationAST::
GGS_routineDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationAST::
GGS_routineDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineDeclarationAST GGS_routineDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_routineDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationAST GGS_routineDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListAST & argument_1,
                 const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_routineDeclarationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_routineDeclarationAST::
reader_mRoutineInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineDeclarationAST *) mPointer)->mRoutineInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineDeclarationAST::actualTypeName (void) const {
  return "routineDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineDeclarationAST ("routineDeclarationAST", gClassInfoFor__routinePrototypeDeclarationAST, & kTypeDescriptor_GGS_routineDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_routineDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineDeclarationAST GGS_routineDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineDeclarationAST * p = dynamic_cast <const GGS_routineDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_externFunctionDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_externFunctionDeclarationAST::
cPtr_externFunctionDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mFunctionName (argument_0),
mFormalParameterList (argument_1),
mResultTypeName (argument_2),
mResultVariableName (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_externFunctionDeclarationAST * GGS_externFunctionDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_externFunctionDeclarationAST) ;
    return (cPtr_externFunctionDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_externFunctionDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_externFunctionDeclarationAST * ptr = dynamic_cast <const cPtr_externFunctionDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_externFunctionDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@externFunctionDeclarationAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_externFunctionDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_externFunctionDeclarationAST (& typeid (cPtr_externFunctionDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_externFunctionDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__externFunctionDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_externFunctionDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_externFunctionDeclarationAST (mFunctionName, mFormalParameterList, mResultTypeName, mResultVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_externFunctionDeclarationAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_externFunctionDeclarationAST ("externFunctionDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationAST::
GGS_externFunctionDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationAST::
GGS_externFunctionDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_externFunctionDeclarationAST GGS_externFunctionDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_externFunctionDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_externFunctionDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_externFunctionDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_externFunctionDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationAST GGS_externFunctionDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListAST & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_externFunctionDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationAST::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationAST *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_externFunctionDeclarationAST::
reader_mFormalParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_formalParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationAST *) mPointer)->mFormalParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationAST::
reader_mResultTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationAST *) mPointer)->mResultTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_externFunctionDeclarationAST::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_externFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_externFunctionDeclarationAST *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_externFunctionDeclarationAST::actualTypeName (void) const {
  return "externFunctionDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__externFunctionDeclarationAST ("externFunctionDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_externFunctionDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_externFunctionDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_externFunctionDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_externFunctionDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_externFunctionDeclarationAST GGS_externFunctionDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_externFunctionDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_externFunctionDeclarationAST * p = dynamic_cast <const GGS_externFunctionDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_externFunctionDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_externFunctionDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_externFunctionDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_functionDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_functionDeclarationAST::
cPtr_functionDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_externFunctionDeclarationAST (argument_0, argument_1, argument_2, argument_3 COMMA_THERE),
mFunctionInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_functionDeclarationAST * GGS_functionDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_functionDeclarationAST) ;
    return (cPtr_functionDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_functionDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_functionDeclarationAST * ptr = dynamic_cast <const cPtr_functionDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mFormalParameterList.operator_isEqual (ptr->mFormalParameterList).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_functionDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@functionDeclarationAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mFormalParameterList.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_functionDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_functionDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_functionDeclarationAST (& typeid (cPtr_functionDeclarationAST), & typeid (cPtr_externFunctionDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_functionDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__functionDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_functionDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_functionDeclarationAST (mFunctionName, mFormalParameterList, mResultTypeName, mResultVariableName, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_functionDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionDeclarationAST ("functionDeclarationAST", true, & kTypeDescriptor_GGS_externFunctionDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_functionDeclarationAST::
GGS_functionDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationAST::
GGS_functionDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_functionDeclarationAST GGS_functionDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_functionDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_functionDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_functionDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_functionDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationAST GGS_functionDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_formalParameterListAST & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_functionDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_functionDeclarationAST::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_functionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_functionDeclarationAST *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_functionDeclarationAST::actualTypeName (void) const {
  return "functionDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__functionDeclarationAST ("functionDeclarationAST", gClassInfoFor__externFunctionDeclarationAST, & kTypeDescriptor_GGS_functionDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_functionDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_functionDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionDeclarationAST GGS_functionDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionDeclarationAST * p = dynamic_cast <const GGS_functionDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_lazyFunctionDeclarationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_lazyFunctionDeclarationAST::
cPtr_lazyFunctionDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticInstructionListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mFunctionName (argument_0),
mResultTypeName (argument_1),
mResultVariableName (argument_2),
mFunctionInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_lazyFunctionDeclarationAST * GGS_lazyFunctionDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_lazyFunctionDeclarationAST) ;
    return (cPtr_lazyFunctionDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_lazyFunctionDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_lazyFunctionDeclarationAST * ptr = dynamic_cast <const cPtr_lazyFunctionDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mResultTypeName.operator_isEqual (ptr->mResultTypeName).boolValue ()
         && mResultVariableName.operator_isEqual (ptr->mResultVariableName).boolValue ()
         && mFunctionInstructionList.operator_isEqual (ptr->mFunctionInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_lazyFunctionDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@lazyFunctionDeclarationAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mResultTypeName.reader_description (inIndentation + 1)
           << mResultVariableName.reader_description (inIndentation + 1)
           << mFunctionInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_lazyFunctionDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_lazyFunctionDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_lazyFunctionDeclarationAST (& typeid (cPtr_lazyFunctionDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_lazyFunctionDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__lazyFunctionDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_lazyFunctionDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_lazyFunctionDeclarationAST (mFunctionName, mResultTypeName, mResultVariableName, mFunctionInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_lazyFunctionDeclarationAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_lazyFunctionDeclarationAST ("lazyFunctionDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationAST::
GGS_lazyFunctionDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationAST::
GGS_lazyFunctionDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_lazyFunctionDeclarationAST GGS_lazyFunctionDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_lazyFunctionDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_lazyFunctionDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_lazyFunctionDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationAST GGS_lazyFunctionDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticInstructionListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_lazyFunctionDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationAST::
reader_mFunctionName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationAST *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationAST::
reader_mResultTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationAST *) mPointer)->mResultTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_lazyFunctionDeclarationAST::
reader_mResultVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationAST *) mPointer)->mResultVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_lazyFunctionDeclarationAST::
reader_mFunctionInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_lazyFunctionDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_lazyFunctionDeclarationAST *) mPointer)->mFunctionInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_lazyFunctionDeclarationAST::actualTypeName (void) const {
  return "lazyFunctionDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__lazyFunctionDeclarationAST ("lazyFunctionDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_lazyFunctionDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_lazyFunctionDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_lazyFunctionDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_lazyFunctionDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lazyFunctionDeclarationAST GGS_lazyFunctionDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_lazyFunctionDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_lazyFunctionDeclarationAST * p = dynamic_cast <const GGS_lazyFunctionDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_lazyFunctionDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_lazyFunctionDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_lazyFunctionDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_localVariableDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationAST::
cPtr_localVariableDeclarationAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationAST * GGS_localVariableDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationAST) ;
    return (cPtr_localVariableDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationAST * ptr = dynamic_cast <const cPtr_localVariableDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationAST (& typeid (cPtr_localVariableDeclarationAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationAST (mStartLocation, mTypeName, mVariableName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_localVariableDeclarationAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationAST ("localVariableDeclarationAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationAST::
GGS_localVariableDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationAST::
GGS_localVariableDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationAST GGS_localVariableDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationAST GGS_localVariableDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationAST::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationAST *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationAST::actualTypeName (void) const {
  return "localVariableDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationAST ("localVariableDeclarationAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_localVariableDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationAST GGS_localVariableDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationAST * p = dynamic_cast <const GGS_localVariableDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_localVariableDeclarationWithInitializationAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithInitializationAST::
cPtr_localVariableDeclarationWithInitializationAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_outSemanticExpressionListAST & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mConstructorName (argument_3),
mConstructorArguments (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithInitializationAST * GGS_localVariableDeclarationWithInitializationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationWithInitializationAST) ;
    return (cPtr_localVariableDeclarationWithInitializationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithInitializationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithInitializationAST * ptr = dynamic_cast <const cPtr_localVariableDeclarationWithInitializationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorArguments.operator_isEqual (ptr->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithInitializationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationWithInitializationAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mConstructorArguments.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitializationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithInitializationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithInitializationAST (& typeid (cPtr_localVariableDeclarationWithInitializationAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationWithInitializationAST::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationWithInitializationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationWithInitializationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationWithInitializationAST (mStartLocation, mTypeName, mVariableName, mConstructorName, mConstructorArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_localVariableDeclarationWithInitializationAST'      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationWithInitializationAST ("localVariableDeclarationWithInitializationAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationAST::
GGS_localVariableDeclarationWithInitializationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationAST::
GGS_localVariableDeclarationWithInitializationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithInitializationAST GGS_localVariableDeclarationWithInitializationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitializationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithInitializationAST *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithInitializationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationWithInitializationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithInitializationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationAST GGS_localVariableDeclarationWithInitializationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_outSemanticExpressionListAST & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitializationAST result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithInitializationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitializationAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitializationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitializationAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitializationAST::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitializationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitializationAST *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithInitializationAST::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitializationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitializationAST *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST  GGS_localVariableDeclarationWithInitializationAST::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithInitializationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithInitializationAST *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithInitializationAST::actualTypeName (void) const {
  return "localVariableDeclarationWithInitializationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationWithInitializationAST ("localVariableDeclarationWithInitializationAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_localVariableDeclarationWithInitializationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationWithInitializationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationWithInitializationAST * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationWithInitializationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithInitializationAST GGS_localVariableDeclarationWithInitializationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithInitializationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationWithInitializationAST * p = dynamic_cast <const GGS_localVariableDeclarationWithInitializationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationWithInitializationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationWithInitializationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationWithInitializationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_localVariableDeclarationWithAssignmentAST'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localVariableDeclarationWithAssignmentAST::
cPtr_localVariableDeclarationWithAssignmentAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localVariableDeclarationWithAssignmentAST * GGS_localVariableDeclarationWithAssignmentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localVariableDeclarationWithAssignmentAST) ;
    return (cPtr_localVariableDeclarationWithAssignmentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localVariableDeclarationWithAssignmentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localVariableDeclarationWithAssignmentAST * ptr = dynamic_cast <const cPtr_localVariableDeclarationWithAssignmentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localVariableDeclarationWithAssignmentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localVariableDeclarationWithAssignmentAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignmentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localVariableDeclarationWithAssignmentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localVariableDeclarationWithAssignmentAST (& typeid (cPtr_localVariableDeclarationWithAssignmentAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localVariableDeclarationWithAssignmentAST::galgasRTTI (void) const {
  return & gClassInfoFor__localVariableDeclarationWithAssignmentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localVariableDeclarationWithAssignmentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localVariableDeclarationWithAssignmentAST (mStartLocation, mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_localVariableDeclarationWithAssignmentAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localVariableDeclarationWithAssignmentAST ("localVariableDeclarationWithAssignmentAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignmentAST::
GGS_localVariableDeclarationWithAssignmentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignmentAST::
GGS_localVariableDeclarationWithAssignmentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localVariableDeclarationWithAssignmentAST GGS_localVariableDeclarationWithAssignmentAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignmentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localVariableDeclarationWithAssignmentAST *> (inPointer) != NULL)
      : (typeid (cPtr_localVariableDeclarationWithAssignmentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localVariableDeclarationWithAssignmentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localVariableDeclarationWithAssignmentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignmentAST GGS_localVariableDeclarationWithAssignmentAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignmentAST result ;
  macroMyNew (result.mPointer, cPtr_localVariableDeclarationWithAssignmentAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignmentAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignmentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignmentAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localVariableDeclarationWithAssignmentAST::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignmentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignmentAST *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_localVariableDeclarationWithAssignmentAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localVariableDeclarationWithAssignmentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localVariableDeclarationWithAssignmentAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localVariableDeclarationWithAssignmentAST::actualTypeName (void) const {
  return "localVariableDeclarationWithAssignmentAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localVariableDeclarationWithAssignmentAST ("localVariableDeclarationWithAssignmentAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_localVariableDeclarationWithAssignmentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localVariableDeclarationWithAssignmentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localVariableDeclarationWithAssignmentAST * p = NULL ;
    macroMyNew (p, GGS_localVariableDeclarationWithAssignmentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localVariableDeclarationWithAssignmentAST GGS_localVariableDeclarationWithAssignmentAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localVariableDeclarationWithAssignmentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localVariableDeclarationWithAssignmentAST * p = dynamic_cast <const GGS_localVariableDeclarationWithAssignmentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localVariableDeclarationWithAssignmentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localVariableDeclarationWithAssignmentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localVariableDeclarationWithAssignmentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       class 'cPtr_localConstantDeclarationWithSourceExpressionAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localConstantDeclarationWithSourceExpressionAST::
cPtr_localConstantDeclarationWithSourceExpressionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localConstantDeclarationWithSourceExpressionAST * GGS_localConstantDeclarationWithSourceExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localConstantDeclarationWithSourceExpressionAST) ;
    return (cPtr_localConstantDeclarationWithSourceExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localConstantDeclarationWithSourceExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localConstantDeclarationWithSourceExpressionAST * ptr = dynamic_cast <const cPtr_localConstantDeclarationWithSourceExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localConstantDeclarationWithSourceExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localConstantDeclarationWithSourceExpressionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithSourceExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithSourceExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localConstantDeclarationWithSourceExpressionAST (& typeid (cPtr_localConstantDeclarationWithSourceExpressionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localConstantDeclarationWithSourceExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__localConstantDeclarationWithSourceExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localConstantDeclarationWithSourceExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localConstantDeclarationWithSourceExpressionAST (mStartLocation, mTypeName, mVariableName, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    GALGAS class 'GGS_localConstantDeclarationWithSourceExpressionAST'     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localConstantDeclarationWithSourceExpressionAST ("localConstantDeclarationWithSourceExpressionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpressionAST::
GGS_localConstantDeclarationWithSourceExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpressionAST::
GGS_localConstantDeclarationWithSourceExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localConstantDeclarationWithSourceExpressionAST GGS_localConstantDeclarationWithSourceExpressionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithSourceExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_localConstantDeclarationWithSourceExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localConstantDeclarationWithSourceExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localConstantDeclarationWithSourceExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpressionAST GGS_localConstantDeclarationWithSourceExpressionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithSourceExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_localConstantDeclarationWithSourceExpressionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithSourceExpressionAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpressionAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithSourceExpressionAST::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpressionAST *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_localConstantDeclarationWithSourceExpressionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithSourceExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithSourceExpressionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localConstantDeclarationWithSourceExpressionAST::actualTypeName (void) const {
  return "localConstantDeclarationWithSourceExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localConstantDeclarationWithSourceExpressionAST ("localConstantDeclarationWithSourceExpressionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_localConstantDeclarationWithSourceExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localConstantDeclarationWithSourceExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localConstantDeclarationWithSourceExpressionAST * p = NULL ;
    macroMyNew (p, GGS_localConstantDeclarationWithSourceExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithSourceExpressionAST GGS_localConstantDeclarationWithSourceExpressionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithSourceExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localConstantDeclarationWithSourceExpressionAST * p = dynamic_cast <const GGS_localConstantDeclarationWithSourceExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localConstantDeclarationWithSourceExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localConstantDeclarationWithSourceExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localConstantDeclarationWithSourceExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       class 'cPtr_localConstantDeclarationWithConstructorCallAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_localConstantDeclarationWithConstructorCallAST::
cPtr_localConstantDeclarationWithConstructorCallAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_outSemanticExpressionListAST & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTypeName (argument_1),
mVariableName (argument_2),
mConstructorName (argument_3),
mConstructorArguments (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_localConstantDeclarationWithConstructorCallAST * GGS_localConstantDeclarationWithConstructorCallAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_localConstantDeclarationWithConstructorCallAST) ;
    return (cPtr_localConstantDeclarationWithConstructorCallAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_localConstantDeclarationWithConstructorCallAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_localConstantDeclarationWithConstructorCallAST * ptr = dynamic_cast <const cPtr_localConstantDeclarationWithConstructorCallAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mVariableName.operator_isEqual (ptr->mVariableName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mConstructorArguments.operator_isEqual (ptr->mConstructorArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_localConstantDeclarationWithConstructorCallAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@localConstantDeclarationWithConstructorCallAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mVariableName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mConstructorArguments.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithConstructorCallAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_localConstantDeclarationWithConstructorCallAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_localConstantDeclarationWithConstructorCallAST (& typeid (cPtr_localConstantDeclarationWithConstructorCallAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_localConstantDeclarationWithConstructorCallAST::galgasRTTI (void) const {
  return & gClassInfoFor__localConstantDeclarationWithConstructorCallAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_localConstantDeclarationWithConstructorCallAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_localConstantDeclarationWithConstructorCallAST (mStartLocation, mTypeName, mVariableName, mConstructorName, mConstructorArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    GALGAS class 'GGS_localConstantDeclarationWithConstructorCallAST'      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_localConstantDeclarationWithConstructorCallAST ("localConstantDeclarationWithConstructorCallAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCallAST::
GGS_localConstantDeclarationWithConstructorCallAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCallAST::
GGS_localConstantDeclarationWithConstructorCallAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_localConstantDeclarationWithConstructorCallAST GGS_localConstantDeclarationWithConstructorCallAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithConstructorCallAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallAST *> (inPointer) != NULL)
      : (typeid (cPtr_localConstantDeclarationWithConstructorCallAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_localConstantDeclarationWithConstructorCallAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_localConstantDeclarationWithConstructorCallAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCallAST GGS_localConstantDeclarationWithConstructorCallAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_outSemanticExpressionListAST & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithConstructorCallAST result ;
  macroMyNew (result.mPointer, cPtr_localConstantDeclarationWithConstructorCallAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCallAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCallAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCallAST::
reader_mVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCallAST *) mPointer)->mVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_localConstantDeclarationWithConstructorCallAST::
reader_mConstructorName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCallAST *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST  GGS_localConstantDeclarationWithConstructorCallAST::
reader_mConstructorArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_localConstantDeclarationWithConstructorCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_localConstantDeclarationWithConstructorCallAST *) mPointer)->mConstructorArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_localConstantDeclarationWithConstructorCallAST::actualTypeName (void) const {
  return "localConstantDeclarationWithConstructorCallAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__localConstantDeclarationWithConstructorCallAST ("localConstantDeclarationWithConstructorCallAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_localConstantDeclarationWithConstructorCallAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_localConstantDeclarationWithConstructorCallAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_localConstantDeclarationWithConstructorCallAST * p = NULL ;
    macroMyNew (p, GGS_localConstantDeclarationWithConstructorCallAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_localConstantDeclarationWithConstructorCallAST GGS_localConstantDeclarationWithConstructorCallAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_localConstantDeclarationWithConstructorCallAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_localConstantDeclarationWithConstructorCallAST * p = dynamic_cast <const GGS_localConstantDeclarationWithConstructorCallAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_localConstantDeclarationWithConstructorCallAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_localConstantDeclarationWithConstructorCallAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_localConstantDeclarationWithConstructorCallAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_assignmentInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_assignmentInstructionAST::
cPtr_assignmentInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTargetVariableName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_assignmentInstructionAST * GGS_assignmentInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_assignmentInstructionAST) ;
    return (cPtr_assignmentInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_assignmentInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_assignmentInstructionAST * ptr = dynamic_cast <const cPtr_assignmentInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTargetVariableName.operator_isEqual (ptr->mTargetVariableName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_assignmentInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@assignmentInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTargetVariableName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_assignmentInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_assignmentInstructionAST (& typeid (cPtr_assignmentInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_assignmentInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__assignmentInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_assignmentInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_assignmentInstructionAST (mStartLocation, mTargetVariableName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_assignmentInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_assignmentInstructionAST ("assignmentInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_assignmentInstructionAST::
GGS_assignmentInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionAST::
GGS_assignmentInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_assignmentInstructionAST GGS_assignmentInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_assignmentInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_assignmentInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_assignmentInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_assignmentInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionAST GGS_assignmentInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_assignmentInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_assignmentInstructionAST::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionAST *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_assignmentInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_assignmentInstructionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_assignmentInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_assignmentInstructionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_assignmentInstructionAST::actualTypeName (void) const {
  return "assignmentInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__assignmentInstructionAST ("assignmentInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_assignmentInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_assignmentInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_assignmentInstructionAST * p = NULL ;
    macroMyNew (p, GGS_assignmentInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_assignmentInstructionAST GGS_assignmentInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_assignmentInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_assignmentInstructionAST * p = dynamic_cast <const GGS_assignmentInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_assignmentInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_assignmentInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_assignmentInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_appendInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_appendInstructionAST::
cPtr_appendInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTargetVariableName (argument_1),
mStructAttributeList (argument_2),
mSourceExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_appendInstructionAST * GGS_appendInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_appendInstructionAST) ;
    return (cPtr_appendInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_appendInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_appendInstructionAST * ptr = dynamic_cast <const cPtr_appendInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTargetVariableName.operator_isEqual (ptr->mTargetVariableName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_appendInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@appendInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTargetVariableName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_appendInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_appendInstructionAST (& typeid (cPtr_appendInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_appendInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__appendInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_appendInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_appendInstructionAST (mStartLocation, mTargetVariableName, mStructAttributeList, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_appendInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_appendInstructionAST ("appendInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_appendInstructionAST::
GGS_appendInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionAST::
GGS_appendInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_appendInstructionAST GGS_appendInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_appendInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_appendInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_appendInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_appendInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_appendInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionAST GGS_appendInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_appendInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_appendInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_appendInstructionAST::
reader_mTargetVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionAST *) mPointer)->mTargetVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_appendInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_appendInstructionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_appendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_appendInstructionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_appendInstructionAST::actualTypeName (void) const {
  return "appendInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__appendInstructionAST ("appendInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_appendInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_appendInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_appendInstructionAST * p = NULL ;
    macroMyNew (p, GGS_appendInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_appendInstructionAST GGS_appendInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_appendInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_appendInstructionAST * p = dynamic_cast <const GGS_appendInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_appendInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_appendInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_appendInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_sendInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sendInstructionAST::
cPtr_sendInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mSourceExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sendInstructionAST * GGS_sendInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sendInstructionAST) ;
    return (cPtr_sendInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sendInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sendInstructionAST * ptr = dynamic_cast <const cPtr_sendInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sendInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sendInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sendInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sendInstructionAST (& typeid (cPtr_sendInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sendInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__sendInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sendInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sendInstructionAST (mStartLocation, mSourceExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_sendInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sendInstructionAST ("sendInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_sendInstructionAST::
GGS_sendInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionAST::
GGS_sendInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sendInstructionAST GGS_sendInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sendInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sendInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_sendInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sendInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sendInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionAST GGS_sendInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_sendInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_sendInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_sendInstructionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sendInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sendInstructionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sendInstructionAST::actualTypeName (void) const {
  return "sendInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sendInstructionAST ("sendInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_sendInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sendInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sendInstructionAST * p = NULL ;
    macroMyNew (p, GGS_sendInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sendInstructionAST GGS_sendInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sendInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sendInstructionAST * p = dynamic_cast <const GGS_sendInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sendInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sendInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sendInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        class 'cPtr_foreachInstructionEnumeratedObjectElementAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedObjectElementAST::
cPtr_foreachInstructionEnumeratedObjectElementAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedObjectElementAST * GGS_foreachInstructionEnumeratedObjectElementAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionEnumeratedObjectElementAST) ;
    return (cPtr_foreachInstructionEnumeratedObjectElementAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedObjectElementAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@foreachInstructionEnumeratedObjectElementAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElementAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedObjectElementAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedObjectElementAST (& typeid (cPtr_foreachInstructionEnumeratedObjectElementAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionEnumeratedObjectElementAST::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionEnumeratedObjectElementAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//     GALGAS class 'GGS_foreachInstructionEnumeratedObjectElementAST'       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementAST ("foreachInstructionEnumeratedObjectElementAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementAST::
GGS_foreachInstructionEnumeratedObjectElementAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementAST::
GGS_foreachInstructionEnumeratedObjectElementAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedObjectElementAST GGS_foreachInstructionEnumeratedObjectElementAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedObjectElementAST *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedObjectElementAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionEnumeratedObjectElementAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedObjectElementAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedObjectElementAST::actualTypeName (void) const {
  return "foreachInstructionEnumeratedObjectElementAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_foreachInstructionEnumeratedObjectElementAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__foreachInstructionEnumeratedObjectElementAST ("foreachInstructionEnumeratedObjectElementAST", & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectElementAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectElementAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectElementAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementAST GGS_foreachInstructionEnumeratedObjectElementAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectElementAST * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectElementAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectElementAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_foreachInstructionJokerAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionJokerAST::
cPtr_foreachInstructionJokerAST (LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElementAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionJokerAST * GGS_foreachInstructionJokerAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionJokerAST) ;
    return (cPtr_foreachInstructionJokerAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionJokerAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionJokerAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@foreachInstructionJokerAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJokerAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionJokerAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionJokerAST (& typeid (cPtr_foreachInstructionJokerAST), & typeid (cPtr_foreachInstructionEnumeratedObjectElementAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionJokerAST::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionJokerAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_foreachInstructionJokerAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionJokerAST ("foreachInstructionJokerAST", true, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementAST) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionJokerAST::
GGS_foreachInstructionJokerAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJokerAST::
GGS_foreachInstructionJokerAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionJokerAST GGS_foreachInstructionJokerAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJokerAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionJokerAST *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionJokerAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionJokerAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionJokerAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_foreachInstructionJokerAST * gSingleton_foreachInstructionJokerAST = NULL ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionJokerAST GGS_foreachInstructionJokerAST::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJokerAST result ;
  if (NULL == gSingleton_foreachInstructionJokerAST) {
    macroMyNew (gSingleton_foreachInstructionJokerAST, cPtr_foreachInstructionJokerAST (THERE)) ;
    macroRetainObject (gSingleton_foreachInstructionJokerAST) ;
  }
  macroAssignObject (result.mPointer, gSingleton_foreachInstructionJokerAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionJokerAST::actualTypeName (void) const {
  return "foreachInstructionJokerAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionJokerAST ("foreachInstructionJokerAST", gClassInfoFor__foreachInstructionEnumeratedObjectElementAST, & kTypeDescriptor_GGS_foreachInstructionJokerAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionJokerAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionJokerAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionJokerAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionJokerAST GGS_foreachInstructionJokerAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionJokerAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionJokerAST * p = dynamic_cast <const GGS_foreachInstructionJokerAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionJokerAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionJokerAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionJokerAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_foreachInstructionEnumeratedConstantAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionEnumeratedConstantAST::
cPtr_foreachInstructionEnumeratedConstantAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_foreachInstructionEnumeratedObjectElementAST (THERE),
mTypeName (argument_0),
mConstantName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionEnumeratedConstantAST * GGS_foreachInstructionEnumeratedConstantAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionEnumeratedConstantAST) ;
    return (cPtr_foreachInstructionEnumeratedConstantAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionEnumeratedConstantAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionEnumeratedConstantAST * ptr = dynamic_cast <const cPtr_foreachInstructionEnumeratedConstantAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstantName.operator_isEqual (ptr->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionEnumeratedConstantAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@foreachInstructionEnumeratedConstantAST:"
           << mTypeName.reader_description (inIndentation + 1)
           << mConstantName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstantAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionEnumeratedConstantAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionEnumeratedConstantAST (& typeid (cPtr_foreachInstructionEnumeratedConstantAST), & typeid (cPtr_foreachInstructionEnumeratedObjectElementAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionEnumeratedConstantAST::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionEnumeratedConstantAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstructionEnumeratedConstantAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstructionEnumeratedConstantAST (mTypeName, mConstantName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_foreachInstructionEnumeratedConstantAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedConstantAST ("foreachInstructionEnumeratedConstantAST", true, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementAST) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstantAST::
GGS_foreachInstructionEnumeratedConstantAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstantAST::
GGS_foreachInstructionEnumeratedConstantAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionEnumeratedConstantAST GGS_foreachInstructionEnumeratedConstantAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstantAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionEnumeratedConstantAST *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionEnumeratedConstantAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionEnumeratedConstantAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionEnumeratedConstantAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstantAST GGS_foreachInstructionEnumeratedConstantAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstantAST result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionEnumeratedConstantAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstantAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstantAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstantAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedConstantAST::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionEnumeratedConstantAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionEnumeratedConstantAST *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionEnumeratedConstantAST::actualTypeName (void) const {
  return "foreachInstructionEnumeratedConstantAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionEnumeratedConstantAST ("foreachInstructionEnumeratedConstantAST", gClassInfoFor__foreachInstructionEnumeratedObjectElementAST, & kTypeDescriptor_GGS_foreachInstructionEnumeratedConstantAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedConstantAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedConstantAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedConstantAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedConstantAST GGS_foreachInstructionEnumeratedConstantAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedConstantAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedConstantAST * p = dynamic_cast <const GGS_foreachInstructionEnumeratedConstantAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedConstantAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedConstantAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedConstantAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Element of list '@foreachInstructionEnumeratedObjectElementListAST'     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST::
elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST (const GGS_foreachInstructionEnumeratedObjectElementAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mElement (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mElement.operator_isEqual (ptr->mElement).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElement.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         List '@foreachInstructionEnumeratedObjectElementListAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListAST ("foreachInstructionEnumeratedObjectElementListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
internalAppendValues (const GGS_foreachInstructionEnumeratedObjectElementAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
internalPrependValues (const GGS_foreachInstructionEnumeratedObjectElementAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
addAssign_operation (const GGS_foreachInstructionEnumeratedObjectElementAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST GGS_foreachInstructionEnumeratedObjectElementListAST::
operator_concat (const GGS_foreachInstructionEnumeratedObjectElementListAST & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectElementListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectElementListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_foreachInstructionEnumeratedObjectElementAST  p_0 = p->mElement ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_foreachInstructionEnumeratedObjectElementAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mElement
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST  GGS_foreachInstructionEnumeratedObjectElementListAST::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST  GGS_foreachInstructionEnumeratedObjectElementListAST::
constructor_listWithValue (const GGS_foreachInstructionEnumeratedObjectElementAST & argument_0) {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectElementListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mElement) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachInstructionEnumeratedObjectElementListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
method_first (C_Compiler & inLexique,
              GGS_foreachInstructionEnumeratedObjectElementAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
method_last (C_Compiler & inLexique,
             GGS_foreachInstructionEnumeratedObjectElementAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_foreachInstructionEnumeratedObjectElementAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_foreachInstructionEnumeratedObjectElementAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mElement ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementAST  GGS_foreachInstructionEnumeratedObjectElementListAST::
reader_mElementAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElement ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectElementListAST::
modifier_setMElementAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElementAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElement = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElementAST  & GGS_foreachInstructionEnumeratedObjectElementListAST::cEnumerator::_mElement (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mElement ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectElementListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectElementListAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectElementListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST GGS_foreachInstructionEnumeratedObjectElementListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectElementListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectElementListAST * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectElementListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectElementListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectElementListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Element of list '@foreachInstructionEnumeratedObjectListAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_foreachInstructionEnumeratedObjectListAST::
elementOf_GGS_foreachInstructionEnumeratedObjectListAST (const GGS_bool& argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIsAscending (argument_0),
mEnumeratedExpression (argument_1),
mElementList (argument_2),
mEndsWithEllipsis (argument_3),
mPrefix (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_foreachInstructionEnumeratedObjectListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_foreachInstructionEnumeratedObjectListAST * ptr = dynamic_cast <const elementOf_GGS_foreachInstructionEnumeratedObjectListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mEnumeratedExpression.operator_isEqual (ptr->mEnumeratedExpression).boolValue ()
         && mElementList.operator_isEqual (ptr->mElementList).boolValue ()
         && mEndsWithEllipsis.operator_isEqual (ptr->mEndsWithEllipsis).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_foreachInstructionEnumeratedObjectListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAscending.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumeratedExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mElementList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndsWithEllipsis.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mPrefix.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            List '@foreachInstructionEnumeratedObjectListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListAST ("foreachInstructionEnumeratedObjectListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionAST & argument_1,
                    const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_lstring & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_semanticExpressionAST & argument_1,
                    const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_lstring & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST GGS_foreachInstructionEnumeratedObjectListAST::
operator_concat (const GGS_foreachInstructionEnumeratedObjectListAST & inOperand) const {
  GGS_foreachInstructionEnumeratedObjectListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
dotAssign_operation (const GGS_foreachInstructionEnumeratedObjectListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_foreachInstructionEnumeratedObjectListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mIsAscending ;
          GGS_semanticExpressionAST  p_1 = p->mEnumeratedExpression ;
          GGS_foreachInstructionEnumeratedObjectElementListAST  p_2 = p->mElementList ;
          GGS_bool p_3 = p->mEndsWithEllipsis ;
          GGS_lstring  p_4 = p->mPrefix ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_semanticExpressionAST & argument_1,
                     const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_lstring & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIsAscending,
                                ptr->mEnumeratedExpression,
                                ptr->mElementList,
                                ptr->mEndsWithEllipsis,
                                ptr->mPrefix
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST  GGS_foreachInstructionEnumeratedObjectListAST::
constructor_emptyList (void) {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST  GGS_foreachInstructionEnumeratedObjectListAST::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_lstring & argument_4) {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
internalSubListWithRange (GGS_foreachInstructionEnumeratedObjectListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIsAscending, ptr->mEnumeratedExpression, ptr->mElementList, ptr->mEndsWithEllipsis, ptr->mPrefix) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST GGS_foreachInstructionEnumeratedObjectListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST GGS_foreachInstructionEnumeratedObjectListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_foreachInstructionEnumeratedObjectListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@foreachInstructionEnumeratedObjectListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_semanticExpressionAST & _out_1,
              GGS_foreachInstructionEnumeratedObjectElementListAST & _out_2,
              GGS_bool& _out_3,
              GGS_lstring & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_semanticExpressionAST & _out_1,
             GGS_foreachInstructionEnumeratedObjectElementListAST & _out_2,
             GGS_bool& _out_3,
             GGS_lstring & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_semanticExpressionAST & _out_1,
                 GGS_foreachInstructionEnumeratedObjectElementListAST & _out_2,
                 GGS_bool& _out_3,
                 GGS_lstring & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_semanticExpressionAST & _out_1,
                GGS_foreachInstructionEnumeratedObjectElementListAST & _out_2,
                GGS_bool& _out_3,
                GGS_lstring & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIsAscending ;
    _out_1 = ptr->mEnumeratedExpression ;
    _out_2 = ptr->mElementList ;
    _out_3 = ptr->mEndsWithEllipsis ;
    _out_4 = ptr->mPrefix ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectListAST::
reader_mIsAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIsAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_foreachInstructionEnumeratedObjectListAST::
reader_mEnumeratedExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumeratedExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST  GGS_foreachInstructionEnumeratedObjectListAST::
reader_mElementListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mElementList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_foreachInstructionEnumeratedObjectListAST::
reader_mEndsWithEllipsisAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndsWithEllipsis ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionEnumeratedObjectListAST::
reader_mPrefixAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mPrefix ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMIsAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIsAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMEnumeratedExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumeratedExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMElementListAtIndex (C_Compiler & inLexique,
                              const GGS_foreachInstructionEnumeratedObjectElementListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mElementList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMEndsWithEllipsisAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndsWithEllipsis = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_foreachInstructionEnumeratedObjectListAST::
modifier_setMPrefixAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mPrefix = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mIsAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIsAscending ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionAST  & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mEnumeratedExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumeratedExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_foreachInstructionEnumeratedObjectElementListAST  & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mElementList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mElementList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mEndsWithEllipsis (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndsWithEllipsis ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_foreachInstructionEnumeratedObjectListAST::cEnumerator::_mPrefix (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mPrefix ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionEnumeratedObjectListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionEnumeratedObjectListAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionEnumeratedObjectListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST GGS_foreachInstructionEnumeratedObjectListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionEnumeratedObjectListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionEnumeratedObjectListAST * p = dynamic_cast <const GGS_foreachInstructionEnumeratedObjectListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionEnumeratedObjectListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionEnumeratedObjectListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_foreachInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_foreachInstructionAST::
cPtr_foreachInstructionAST (const GGS_location & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionAST & argument_3,
                                const GGS_semanticInstructionListAST & argument_4,
                                const GGS_semanticInstructionListAST & argument_5,
                                const GGS_semanticInstructionListAST & argument_6,
                                const GGS_semanticInstructionListAST & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mEnumeratedObjectList (argument_1),
mIndexVariableName (argument_2),
mWhileExpression (argument_3),
mBeforeInstructionList (argument_4),
mBetweenInstructionList (argument_5),
mDoInstructionList (argument_6),
mAfterInstructionList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_foreachInstructionAST * GGS_foreachInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_foreachInstructionAST) ;
    return (cPtr_foreachInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_foreachInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_foreachInstructionAST * ptr = dynamic_cast <const cPtr_foreachInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mEnumeratedObjectList.operator_isEqual (ptr->mEnumeratedObjectList).boolValue ()
         && mIndexVariableName.operator_isEqual (ptr->mIndexVariableName).boolValue ()
         && mWhileExpression.operator_isEqual (ptr->mWhileExpression).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_foreachInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@foreachInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mEnumeratedObjectList.reader_description (inIndentation + 1)
           << mIndexVariableName.reader_description (inIndentation + 1)
           << mWhileExpression.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_foreachInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_foreachInstructionAST (& typeid (cPtr_foreachInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_foreachInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__foreachInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_foreachInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_foreachInstructionAST (mStartLocation, mEnumeratedObjectList, mIndexVariableName, mWhileExpression, mBeforeInstructionList, mBetweenInstructionList, mDoInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_foreachInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_foreachInstructionAST ("foreachInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_foreachInstructionAST::
GGS_foreachInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionAST::
GGS_foreachInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_foreachInstructionAST GGS_foreachInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_foreachInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_foreachInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_foreachInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_foreachInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionAST GGS_foreachInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectListAST & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionAST & argument_3,
                 const GGS_semanticInstructionListAST & argument_4,
                 const GGS_semanticInstructionListAST & argument_5,
                 const GGS_semanticInstructionListAST & argument_6,
                 const GGS_semanticInstructionListAST & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_foreachInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectListAST  GGS_foreachInstructionAST::
reader_mEnumeratedObjectList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mEnumeratedObjectList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_foreachInstructionAST::
reader_mIndexVariableName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mIndexVariableName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_foreachInstructionAST::
reader_mWhileExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mWhileExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_foreachInstructionAST::
reader_mBeforeInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_foreachInstructionAST::
reader_mBetweenInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_foreachInstructionAST::
reader_mDoInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_foreachInstructionAST::
reader_mAfterInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_foreachInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_foreachInstructionAST *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_foreachInstructionAST::actualTypeName (void) const {
  return "foreachInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__foreachInstructionAST ("foreachInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_foreachInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_foreachInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_foreachInstructionAST * p = NULL ;
    macroMyNew (p, GGS_foreachInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionAST GGS_foreachInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_foreachInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_foreachInstructionAST * p = dynamic_cast <const GGS_foreachInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_foreachInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_foreachInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_foreachInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    Element of list '@ifBranchListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_ifBranchListAST::
elementOf_GGS_ifBranchListAST (const GGS_semanticExpressionAST & argument_0,
                                const GGS_semanticInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mIFexpression (argument_0),
mIFinstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_ifBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_ifBranchListAST * ptr = dynamic_cast <const elementOf_GGS_ifBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIFexpression.operator_isEqual (ptr->mIFexpression).boolValue ()
         && mIFinstructionList.operator_isEqual (ptr->mIFinstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_ifBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFexpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIFinstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@ifBranchListAST'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifBranchListAST ("ifBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
internalAppendValues (const GGS_semanticExpressionAST & argument_0,
                    const GGS_semanticInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
internalPrependValues (const GGS_semanticExpressionAST & argument_0,
                    const GGS_semanticInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
addAssign_operation (const GGS_semanticExpressionAST & argument_0,
                                const GGS_semanticInstructionListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchListAST GGS_ifBranchListAST::
operator_concat (const GGS_ifBranchListAST & inOperand) const {
  GGS_ifBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
dotAssign_operation (const GGS_ifBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_ifBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_semanticExpressionAST  p_0 = p->mIFexpression ;
          GGS_semanticInstructionListAST  p_1 = p->mIFinstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_semanticExpressionAST & argument_0,
                     const GGS_semanticInstructionListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mIFexpression,
                                ptr->mIFinstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchListAST  GGS_ifBranchListAST::
constructor_emptyList (void) {
  GGS_ifBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchListAST  GGS_ifBranchListAST::
constructor_listWithValue (const GGS_semanticExpressionAST & argument_0,
                                const GGS_semanticInstructionListAST & argument_1) {
  GGS_ifBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
internalSubListWithRange (GGS_ifBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mIFexpression, ptr->mIFinstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_ifBranchListAST GGS_ifBranchListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchListAST GGS_ifBranchListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_ifBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_ifBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@ifBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
method_first (C_Compiler & inLexique,
              GGS_semanticExpressionAST & _out_0,
              GGS_semanticInstructionListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
method_last (C_Compiler & inLexique,
             GGS_semanticExpressionAST & _out_0,
             GGS_semanticInstructionListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_semanticExpressionAST & _out_0,
                 GGS_semanticInstructionListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_semanticExpressionAST & _out_0,
                GGS_semanticInstructionListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mIFexpression ;
    _out_1 = ptr->mIFinstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_ifBranchListAST::
reader_mIFexpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFexpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_ifBranchListAST::
reader_mIFinstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mIFinstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
modifier_setMIFexpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFexpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_ifBranchListAST::
modifier_setMIFinstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mIFinstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionAST  & GGS_ifBranchListAST::cEnumerator::_mIFexpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIFexpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_ifBranchListAST::cEnumerator::_mIFinstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mIFinstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_ifBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifBranchListAST * p = NULL ;
    macroMyNew (p, GGS_ifBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchListAST GGS_ifBranchListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifBranchListAST * p = dynamic_cast <const GGS_ifBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_ifInstructionAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_ifInstructionAST::
cPtr_ifInstructionAST (const GGS_location & argument_0,
                                const GGS_ifBranchListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mBranchList (argument_1),
mElseInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_ifInstructionAST * GGS_ifInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_ifInstructionAST) ;
    return (cPtr_ifInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_ifInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_ifInstructionAST * ptr = dynamic_cast <const cPtr_ifInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mBranchList.operator_isEqual (ptr->mBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_ifInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@ifInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_ifInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_ifInstructionAST (& typeid (cPtr_ifInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_ifInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__ifInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_ifInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_ifInstructionAST (mStartLocation, mBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_ifInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_ifInstructionAST ("ifInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_ifInstructionAST::
GGS_ifInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionAST::
GGS_ifInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_ifInstructionAST GGS_ifInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_ifInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_ifInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_ifInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_ifInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_ifInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionAST GGS_ifInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_ifBranchListAST & argument_1,
                 const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_ifInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_ifInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifBranchListAST  GGS_ifInstructionAST::
reader_mBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ifBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionAST *) mPointer)->mBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_ifInstructionAST::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_ifInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_ifInstructionAST *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_ifInstructionAST::actualTypeName (void) const {
  return "ifInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__ifInstructionAST ("ifInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_ifInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_ifInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_ifInstructionAST * p = NULL ;
    macroMyNew (p, GGS_ifInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ifInstructionAST GGS_ifInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_ifInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_ifInstructionAST * p = dynamic_cast <const GGS_ifInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_ifInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_ifInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_ifInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_methodCallInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_methodCallInstructionAST::
cPtr_methodCallInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_methodCallInstructionAST * GGS_methodCallInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_methodCallInstructionAST) ;
    return (cPtr_methodCallInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_methodCallInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_methodCallInstructionAST * ptr = dynamic_cast <const cPtr_methodCallInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_methodCallInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@methodCallInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_methodCallInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_methodCallInstructionAST (& typeid (cPtr_methodCallInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_methodCallInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__methodCallInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_methodCallInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_methodCallInstructionAST (mStartLocation, mReceiverExpression, mMethodName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_methodCallInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodCallInstructionAST ("methodCallInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_methodCallInstructionAST::
GGS_methodCallInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionAST::
GGS_methodCallInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_methodCallInstructionAST GGS_methodCallInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_methodCallInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_methodCallInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_methodCallInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_methodCallInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionAST GGS_methodCallInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_methodCallInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_methodCallInstructionAST::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionAST *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodCallInstructionAST::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionAST *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_methodCallInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_methodCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_methodCallInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_methodCallInstructionAST::actualTypeName (void) const {
  return "methodCallInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__methodCallInstructionAST ("methodCallInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_methodCallInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_methodCallInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodCallInstructionAST * p = NULL ;
    macroMyNew (p, GGS_methodCallInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodCallInstructionAST GGS_methodCallInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodCallInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodCallInstructionAST * p = dynamic_cast <const GGS_methodCallInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodCallInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodCallInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodCallInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_modifierCallInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_modifierCallInstructionAST::
cPtr_modifierCallInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_actualParameterListAST & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mReceiverStructAttributes (argument_2),
mModifierName (argument_3),
mActualParameterList (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_modifierCallInstructionAST * GGS_modifierCallInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_modifierCallInstructionAST) ;
    return (cPtr_modifierCallInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_modifierCallInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_modifierCallInstructionAST * ptr = dynamic_cast <const cPtr_modifierCallInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mReceiverStructAttributes.operator_isEqual (ptr->mReceiverStructAttributes).boolValue ()
         && mModifierName.operator_isEqual (ptr->mModifierName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_modifierCallInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@modifierCallInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mReceiverStructAttributes.reader_description (inIndentation + 1)
           << mModifierName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_modifierCallInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_modifierCallInstructionAST (& typeid (cPtr_modifierCallInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_modifierCallInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__modifierCallInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_modifierCallInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_modifierCallInstructionAST (mStartLocation, mReceiverName, mReceiverStructAttributes, mModifierName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_modifierCallInstructionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_modifierCallInstructionAST ("modifierCallInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionAST::
GGS_modifierCallInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionAST::
GGS_modifierCallInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_modifierCallInstructionAST GGS_modifierCallInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_modifierCallInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_modifierCallInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_modifierCallInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_modifierCallInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionAST GGS_modifierCallInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_lstring & argument_3,
                 const GGS_actualParameterListAST & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_modifierCallInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_modifierCallInstructionAST::
reader_mReceiverStructAttributes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionAST *) mPointer)->mReceiverStructAttributes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_modifierCallInstructionAST::
reader_mModifierName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionAST *) mPointer)->mModifierName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_modifierCallInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_modifierCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_modifierCallInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_modifierCallInstructionAST::actualTypeName (void) const {
  return "modifierCallInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__modifierCallInstructionAST ("modifierCallInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_modifierCallInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_modifierCallInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_modifierCallInstructionAST * p = NULL ;
    macroMyNew (p, GGS_modifierCallInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_modifierCallInstructionAST GGS_modifierCallInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_modifierCallInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_modifierCallInstructionAST * p = dynamic_cast <const GGS_modifierCallInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_modifierCallInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_modifierCallInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_modifierCallInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_errorInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_errorInstructionAST::
cPtr_errorInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2,
                                const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mErrorExpression (argument_2),
mBuiltVariableList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_errorInstructionAST * GGS_errorInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_errorInstructionAST) ;
    return (cPtr_errorInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_errorInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_errorInstructionAST * ptr = dynamic_cast <const cPtr_errorInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mErrorExpression.operator_isEqual (ptr->mErrorExpression).boolValue ()
         && mBuiltVariableList.operator_isEqual (ptr->mBuiltVariableList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_errorInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@errorInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mErrorExpression.reader_description (inIndentation + 1)
           << mBuiltVariableList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_errorInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_errorInstructionAST (& typeid (cPtr_errorInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_errorInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__errorInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_errorInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_errorInstructionAST (mStartLocation, mReceiverExpression, mErrorExpression, mBuiltVariableList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_errorInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_errorInstructionAST ("errorInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_errorInstructionAST::
GGS_errorInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionAST::
GGS_errorInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_errorInstructionAST GGS_errorInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_errorInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_errorInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_errorInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_errorInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_errorInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionAST GGS_errorInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2,
                 const GGS_lstringlist & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_errorInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_errorInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_errorInstructionAST::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionAST *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_errorInstructionAST::
reader_mErrorExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionAST *) mPointer)->mErrorExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_errorInstructionAST::
reader_mBuiltVariableList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_errorInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_errorInstructionAST *) mPointer)->mBuiltVariableList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_errorInstructionAST::actualTypeName (void) const {
  return "errorInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__errorInstructionAST ("errorInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_errorInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_errorInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_errorInstructionAST * p = NULL ;
    macroMyNew (p, GGS_errorInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_errorInstructionAST GGS_errorInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_errorInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_errorInstructionAST * p = dynamic_cast <const GGS_errorInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_errorInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_errorInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_errorInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_warningInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_warningInstructionAST::
cPtr_warningInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverExpression (argument_1),
mWarningExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_warningInstructionAST * GGS_warningInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_warningInstructionAST) ;
    return (cPtr_warningInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_warningInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_warningInstructionAST * ptr = dynamic_cast <const cPtr_warningInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mWarningExpression.operator_isEqual (ptr->mWarningExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_warningInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@warningInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mWarningExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_warningInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_warningInstructionAST (& typeid (cPtr_warningInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_warningInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__warningInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_warningInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_warningInstructionAST (mStartLocation, mReceiverExpression, mWarningExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_warningInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_warningInstructionAST ("warningInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_warningInstructionAST::
GGS_warningInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionAST::
GGS_warningInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_warningInstructionAST GGS_warningInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_warningInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_warningInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_warningInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_warningInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_warningInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionAST GGS_warningInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_warningInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_warningInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_warningInstructionAST::
reader_mReceiverExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionAST *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_warningInstructionAST::
reader_mWarningExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_warningInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_warningInstructionAST *) mPointer)->mWarningExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_warningInstructionAST::actualTypeName (void) const {
  return "warningInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__warningInstructionAST ("warningInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_warningInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_warningInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_warningInstructionAST * p = NULL ;
    macroMyNew (p, GGS_warningInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_warningInstructionAST GGS_warningInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_warningInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_warningInstructionAST * p = dynamic_cast <const GGS_warningInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_warningInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_warningInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_warningInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_routineCallInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_routineCallInstructionAST::
cPtr_routineCallInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_actualParameterListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mRoutineName (argument_1),
mActualParameterList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_routineCallInstructionAST * GGS_routineCallInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_routineCallInstructionAST) ;
    return (cPtr_routineCallInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_routineCallInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_routineCallInstructionAST * ptr = dynamic_cast <const cPtr_routineCallInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mRoutineName.operator_isEqual (ptr->mRoutineName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_routineCallInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@routineCallInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mRoutineName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_routineCallInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_routineCallInstructionAST (& typeid (cPtr_routineCallInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_routineCallInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__routineCallInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_routineCallInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_routineCallInstructionAST (mStartLocation, mRoutineName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_routineCallInstructionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineCallInstructionAST ("routineCallInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_routineCallInstructionAST::
GGS_routineCallInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionAST::
GGS_routineCallInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_routineCallInstructionAST GGS_routineCallInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_routineCallInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_routineCallInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_routineCallInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_routineCallInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionAST GGS_routineCallInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_actualParameterListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_routineCallInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_routineCallInstructionAST::
reader_mRoutineName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionAST *) mPointer)->mRoutineName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_routineCallInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_routineCallInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_routineCallInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_routineCallInstructionAST::actualTypeName (void) const {
  return "routineCallInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__routineCallInstructionAST ("routineCallInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_routineCallInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_routineCallInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineCallInstructionAST * p = NULL ;
    macroMyNew (p, GGS_routineCallInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineCallInstructionAST GGS_routineCallInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineCallInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineCallInstructionAST * p = dynamic_cast <const GGS_routineCallInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineCallInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineCallInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineCallInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'cPtr_matchEntryAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchEntryAST::
cPtr_matchEntryAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchEntryAST * GGS_matchEntryAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_matchEntryAST) ;
    return (cPtr_matchEntryAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_matchEntryAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@matchEntryAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchEntryAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchEntryAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchEntryAST (& typeid (cPtr_matchEntryAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_matchEntryAST::galgasRTTI (void) const {
  return & gClassInfoFor__matchEntryAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_matchEntryAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchEntryAST ("matchEntryAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_matchEntryAST::
GGS_matchEntryAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryAST::
GGS_matchEntryAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_matchEntryAST GGS_matchEntryAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchEntryAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchEntryAST *> (inPointer) != NULL)
      : (typeid (cPtr_matchEntryAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_matchEntryAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchEntryAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchEntryAST::actualTypeName (void) const {
  return "matchEntryAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_matchEntryAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__matchEntryAST ("matchEntryAST", & kTypeDescriptor_GGS_matchEntryAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_matchEntryAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchEntryAST * p = NULL ;
    macroMyNew (p, GGS_matchEntryAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryAST GGS_matchEntryAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchEntryAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchEntryAST * p = dynamic_cast <const GGS_matchEntryAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchEntryAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchEntryAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchEntryAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@matchEntryListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchEntryListAST::
elementOf_GGS_matchEntryListAST (const GGS_matchEntryAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEntry (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchEntryListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchEntryListAST * ptr = dynamic_cast <const elementOf_GGS_matchEntryListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEntry.operator_isEqual (ptr->mEntry).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchEntryListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntry.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@matchEntryListAST'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchEntryListAST ("matchEntryListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
internalAppendValues (const GGS_matchEntryAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
internalPrependValues (const GGS_matchEntryAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
addAssign_operation (const GGS_matchEntryAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST GGS_matchEntryListAST::
operator_concat (const GGS_matchEntryListAST & inOperand) const {
  GGS_matchEntryListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
dotAssign_operation (const GGS_matchEntryListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_matchEntryListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntryAST  p_0 = p->mEntry ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntryAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEntry
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST  GGS_matchEntryListAST::
constructor_emptyList (void) {
  GGS_matchEntryListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST  GGS_matchEntryListAST::
constructor_listWithValue (const GGS_matchEntryAST & argument_0) {
  GGS_matchEntryListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
internalSubListWithRange (GGS_matchEntryListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEntry) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST GGS_matchEntryListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST GGS_matchEntryListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchEntryListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@matchEntryListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
method_first (C_Compiler & inLexique,
              GGS_matchEntryAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
method_last (C_Compiler & inLexique,
             GGS_matchEntryAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_matchEntryAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_matchEntryAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEntry ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryAST  GGS_matchEntryListAST::
reader_mEntryAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntryAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEntry ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchEntryListAST::
modifier_setMEntryAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntryAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEntry = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntryAST  & GGS_matchEntryListAST::cEnumerator::_mEntry (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEntry ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_matchEntryListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchEntryListAST * p = NULL ;
    macroMyNew (p, GGS_matchEntryListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST GGS_matchEntryListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchEntryListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchEntryListAST * p = dynamic_cast <const GGS_matchEntryListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchEntryListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchEntryListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchEntryListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_constantMatchEntryAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_constantMatchEntryAST::
cPtr_constantMatchEntryAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntryAST (THERE),
mConstantName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_constantMatchEntryAST * GGS_constantMatchEntryAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_constantMatchEntryAST) ;
    return (cPtr_constantMatchEntryAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_constantMatchEntryAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_constantMatchEntryAST * ptr = dynamic_cast <const cPtr_constantMatchEntryAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantName.operator_isEqual (ptr->mConstantName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_constantMatchEntryAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@constantMatchEntryAST:"
           << mConstantName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntryAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_constantMatchEntryAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_constantMatchEntryAST (& typeid (cPtr_constantMatchEntryAST), & typeid (cPtr_matchEntryAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_constantMatchEntryAST::galgasRTTI (void) const {
  return & gClassInfoFor__constantMatchEntryAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_constantMatchEntryAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_constantMatchEntryAST (mConstantName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_constantMatchEntryAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_constantMatchEntryAST ("constantMatchEntryAST", true, & kTypeDescriptor_GGS_matchEntryAST) ;

//---------------------------------------------------------------------------*

GGS_constantMatchEntryAST::
GGS_constantMatchEntryAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntryAST::
GGS_constantMatchEntryAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_constantMatchEntryAST GGS_constantMatchEntryAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntryAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_constantMatchEntryAST *> (inPointer) != NULL)
      : (typeid (cPtr_constantMatchEntryAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_constantMatchEntryAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_constantMatchEntryAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntryAST GGS_constantMatchEntryAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntryAST result ;
  macroMyNew (result.mPointer, cPtr_constantMatchEntryAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_constantMatchEntryAST::
reader_mConstantName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_constantMatchEntryAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_constantMatchEntryAST *) mPointer)->mConstantName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_constantMatchEntryAST::actualTypeName (void) const {
  return "constantMatchEntryAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__constantMatchEntryAST ("constantMatchEntryAST", gClassInfoFor__matchEntryAST, & kTypeDescriptor_GGS_constantMatchEntryAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_constantMatchEntryAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_constantMatchEntryAST * p = NULL ;
    macroMyNew (p, GGS_constantMatchEntryAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_constantMatchEntryAST GGS_constantMatchEntryAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_constantMatchEntryAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_constantMatchEntryAST * p = dynamic_cast <const GGS_constantMatchEntryAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_constantMatchEntryAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_constantMatchEntryAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_constantMatchEntryAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_classMatchEntryAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classMatchEntryAST::
cPtr_classMatchEntryAST (const GGS_lstring & argument_0,
                                const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_1,
                                const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_matchEntryAST (THERE),
mClassName (argument_0),
mElements (argument_1),
mEndsWithEllipsis (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classMatchEntryAST * GGS_classMatchEntryAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_classMatchEntryAST) ;
    return (cPtr_classMatchEntryAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classMatchEntryAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classMatchEntryAST * ptr = dynamic_cast <const cPtr_classMatchEntryAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mClassName.operator_isEqual (ptr->mClassName).boolValue ()
         && mElements.operator_isEqual (ptr->mElements).boolValue ()
         && mEndsWithEllipsis.operator_isEqual (ptr->mEndsWithEllipsis).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classMatchEntryAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@classMatchEntryAST:"
           << mClassName.reader_description (inIndentation + 1)
           << mElements.reader_description (inIndentation + 1)
           << mEndsWithEllipsis.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntryAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classMatchEntryAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classMatchEntryAST (& typeid (cPtr_classMatchEntryAST), & typeid (cPtr_matchEntryAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_classMatchEntryAST::galgasRTTI (void) const {
  return & gClassInfoFor__classMatchEntryAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classMatchEntryAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classMatchEntryAST (mClassName, mElements, mEndsWithEllipsis COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_classMatchEntryAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classMatchEntryAST ("classMatchEntryAST", true, & kTypeDescriptor_GGS_matchEntryAST) ;

//---------------------------------------------------------------------------*

GGS_classMatchEntryAST::
GGS_classMatchEntryAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntryAST::
GGS_classMatchEntryAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classMatchEntryAST GGS_classMatchEntryAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classMatchEntryAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classMatchEntryAST *> (inPointer) != NULL)
      : (typeid (cPtr_classMatchEntryAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classMatchEntryAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classMatchEntryAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntryAST GGS_classMatchEntryAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_foreachInstructionEnumeratedObjectElementListAST & argument_1,
                 const GGS_bool& argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_classMatchEntryAST result ;
  macroMyNew (result.mPointer, cPtr_classMatchEntryAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classMatchEntryAST::
reader_mClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntryAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntryAST *) mPointer)->mClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_foreachInstructionEnumeratedObjectElementListAST  GGS_classMatchEntryAST::
reader_mElements (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_foreachInstructionEnumeratedObjectElementListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntryAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntryAST *) mPointer)->mElements ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classMatchEntryAST::
reader_mEndsWithEllipsis (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classMatchEntryAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classMatchEntryAST *) mPointer)->mEndsWithEllipsis ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classMatchEntryAST::actualTypeName (void) const {
  return "classMatchEntryAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__classMatchEntryAST ("classMatchEntryAST", gClassInfoFor__matchEntryAST, & kTypeDescriptor_GGS_classMatchEntryAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_classMatchEntryAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classMatchEntryAST * p = NULL ;
    macroMyNew (p, GGS_classMatchEntryAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classMatchEntryAST GGS_classMatchEntryAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classMatchEntryAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classMatchEntryAST * p = dynamic_cast <const GGS_classMatchEntryAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classMatchEntryAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classMatchEntryAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classMatchEntryAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@matchInstructionBranchListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_matchInstructionBranchListAST::
elementOf_GGS_matchInstructionBranchListAST (const GGS_matchEntryListAST & argument_0,
                                const GGS_semanticInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMatchEntryList (argument_0),
mMatchBranchInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_matchInstructionBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_matchInstructionBranchListAST * ptr = dynamic_cast <const elementOf_GGS_matchInstructionBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMatchEntryList.operator_isEqual (ptr->mMatchEntryList).boolValue ()
         && mMatchBranchInstructionList.operator_isEqual (ptr->mMatchBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_matchInstructionBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchEntryList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMatchBranchInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@matchInstructionBranchListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchInstructionBranchListAST ("matchInstructionBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
internalAppendValues (const GGS_matchEntryListAST & argument_0,
                    const GGS_semanticInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
internalPrependValues (const GGS_matchEntryListAST & argument_0,
                    const GGS_semanticInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
addAssign_operation (const GGS_matchEntryListAST & argument_0,
                                const GGS_semanticInstructionListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST GGS_matchInstructionBranchListAST::
operator_concat (const GGS_matchInstructionBranchListAST & inOperand) const {
  GGS_matchInstructionBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
dotAssign_operation (const GGS_matchInstructionBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_matchInstructionBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_matchEntryListAST  p_0 = p->mMatchEntryList ;
          GGS_semanticInstructionListAST  p_1 = p->mMatchBranchInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_matchEntryListAST & argument_0,
                     const GGS_semanticInstructionListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMatchEntryList,
                                ptr->mMatchBranchInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST  GGS_matchInstructionBranchListAST::
constructor_emptyList (void) {
  GGS_matchInstructionBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST  GGS_matchInstructionBranchListAST::
constructor_listWithValue (const GGS_matchEntryListAST & argument_0,
                                const GGS_semanticInstructionListAST & argument_1) {
  GGS_matchInstructionBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
internalSubListWithRange (GGS_matchInstructionBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMatchEntryList, ptr->mMatchBranchInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST GGS_matchInstructionBranchListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST GGS_matchInstructionBranchListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_matchInstructionBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@matchInstructionBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
method_first (C_Compiler & inLexique,
              GGS_matchEntryListAST & _out_0,
              GGS_semanticInstructionListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
method_last (C_Compiler & inLexique,
             GGS_matchEntryListAST & _out_0,
             GGS_semanticInstructionListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_matchEntryListAST & _out_0,
                 GGS_semanticInstructionListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_matchEntryListAST & _out_0,
                GGS_semanticInstructionListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMatchEntryList ;
    _out_1 = ptr->mMatchBranchInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_matchEntryListAST  GGS_matchInstructionBranchListAST::
reader_mMatchEntryListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_matchEntryListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchEntryList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_matchInstructionBranchListAST::
reader_mMatchBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMatchBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_setMMatchEntryListAtIndex (C_Compiler & inLexique,
                              const GGS_matchEntryListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchEntryList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_matchInstructionBranchListAST::
modifier_setMMatchBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMatchBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_matchEntryListAST  & GGS_matchInstructionBranchListAST::cEnumerator::_mMatchEntryList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchEntryList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_matchInstructionBranchListAST::cEnumerator::_mMatchBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMatchBranchInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_matchInstructionBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchInstructionBranchListAST * p = NULL ;
    macroMyNew (p, GGS_matchInstructionBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST GGS_matchInstructionBranchListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchInstructionBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchInstructionBranchListAST * p = dynamic_cast <const GGS_matchInstructionBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchInstructionBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchInstructionBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchInstructionBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_matchInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_matchInstructionAST::
cPtr_matchInstructionAST (const GGS_location & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_matchInstructionBranchListAST & argument_2,
                                const GGS_semanticInstructionListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mMatchedVariableNameList (argument_1),
mMatchInstructionBranchList (argument_2),
mElseInstructionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_matchInstructionAST * GGS_matchInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_matchInstructionAST) ;
    return (cPtr_matchInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_matchInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_matchInstructionAST * ptr = dynamic_cast <const cPtr_matchInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mMatchedVariableNameList.operator_isEqual (ptr->mMatchedVariableNameList).boolValue ()
         && mMatchInstructionBranchList.operator_isEqual (ptr->mMatchInstructionBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_matchInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@matchInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mMatchedVariableNameList.reader_description (inIndentation + 1)
           << mMatchInstructionBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_matchInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_matchInstructionAST (& typeid (cPtr_matchInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_matchInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__matchInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_matchInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_matchInstructionAST (mStartLocation, mMatchedVariableNameList, mMatchInstructionBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_matchInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_matchInstructionAST ("matchInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_matchInstructionAST::
GGS_matchInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionAST::
GGS_matchInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_matchInstructionAST GGS_matchInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_matchInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_matchInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_matchInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_matchInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_matchInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionAST GGS_matchInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_matchInstructionBranchListAST & argument_2,
                 const GGS_semanticInstructionListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_matchInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_matchInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_matchInstructionAST::
reader_mMatchedVariableNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionAST *) mPointer)->mMatchedVariableNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionBranchListAST  GGS_matchInstructionAST::
reader_mMatchInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_matchInstructionBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionAST *) mPointer)->mMatchInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_matchInstructionAST::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_matchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_matchInstructionAST *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_matchInstructionAST::actualTypeName (void) const {
  return "matchInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__matchInstructionAST ("matchInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_matchInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_matchInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_matchInstructionAST * p = NULL ;
    macroMyNew (p, GGS_matchInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_matchInstructionAST GGS_matchInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_matchInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_matchInstructionAST * p = dynamic_cast <const GGS_matchInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_matchInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_matchInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_matchInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@castInstructionBranchListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_castInstructionBranchListAST::
elementOf_GGS_castInstructionBranchListAST (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mUseKindOfClass (argument_0),
mTypeName (argument_1),
mConstantVarName (argument_2),
mConstantVarNameIsUnused (argument_3),
mCastBranchInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_castInstructionBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_castInstructionBranchListAST * ptr = dynamic_cast <const elementOf_GGS_castInstructionBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUseKindOfClass.operator_isEqual (ptr->mUseKindOfClass).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstantVarName.operator_isEqual (ptr->mConstantVarName).boolValue ()
         && mConstantVarNameIsUnused.operator_isEqual (ptr->mConstantVarNameIsUnused).boolValue ()
         && mCastBranchInstructionList.operator_isEqual (ptr->mCastBranchInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_castInstructionBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUseKindOfClass.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantVarNameIsUnused.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCastBranchInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@castInstructionBranchListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInstructionBranchListAST ("castInstructionBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
internalAppendValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
internalPrependValues (const GGS_bool& argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_bool& argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
addAssign_operation (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST GGS_castInstructionBranchListAST::
operator_concat (const GGS_castInstructionBranchListAST & inOperand) const {
  GGS_castInstructionBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
dotAssign_operation (const GGS_castInstructionBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_castInstructionBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_bool p_0 = p->mUseKindOfClass ;
          GGS_lstring  p_1 = p->mTypeName ;
          GGS_lstring  p_2 = p->mConstantVarName ;
          GGS_bool p_3 = p->mConstantVarNameIsUnused ;
          GGS_semanticInstructionListAST  p_4 = p->mCastBranchInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_bool& argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_bool& argument_3,
                     const GGS_semanticInstructionListAST & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mUseKindOfClass,
                                ptr->mTypeName,
                                ptr->mConstantVarName,
                                ptr->mConstantVarNameIsUnused,
                                ptr->mCastBranchInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST  GGS_castInstructionBranchListAST::
constructor_emptyList (void) {
  GGS_castInstructionBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST  GGS_castInstructionBranchListAST::
constructor_listWithValue (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_bool& argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  GGS_castInstructionBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
internalSubListWithRange (GGS_castInstructionBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mUseKindOfClass, ptr->mTypeName, ptr->mConstantVarName, ptr->mConstantVarNameIsUnused, ptr->mCastBranchInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST GGS_castInstructionBranchListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST GGS_castInstructionBranchListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_castInstructionBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_castInstructionBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@castInstructionBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
method_first (C_Compiler & inLexique,
              GGS_bool& _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_bool& _out_3,
              GGS_semanticInstructionListAST & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
method_last (C_Compiler & inLexique,
             GGS_bool& _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_bool& _out_3,
             GGS_semanticInstructionListAST & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_bool& _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_bool& _out_3,
                 GGS_semanticInstructionListAST & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_bool& _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_bool& _out_3,
                GGS_semanticInstructionListAST & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mUseKindOfClass ;
    _out_1 = ptr->mTypeName ;
    _out_2 = ptr->mConstantVarName ;
    _out_3 = ptr->mConstantVarNameIsUnused ;
    _out_4 = ptr->mCastBranchInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchListAST::
reader_mUseKindOfClassAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mUseKindOfClass ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchListAST::
reader_mTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_castInstructionBranchListAST::
reader_mConstantVarNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_castInstructionBranchListAST::
reader_mConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantVarNameIsUnused ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_castInstructionBranchListAST::
reader_mCastBranchInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCastBranchInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMUseKindOfClassAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mUseKindOfClass = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMConstantVarNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMConstantVarNameIsUnusedAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantVarNameIsUnused = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_castInstructionBranchListAST::
modifier_setMCastBranchInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCastBranchInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchListAST::cEnumerator::_mUseKindOfClass (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mUseKindOfClass ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchListAST::cEnumerator::_mTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_castInstructionBranchListAST::cEnumerator::_mConstantVarName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantVarName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_castInstructionBranchListAST::cEnumerator::_mConstantVarNameIsUnused (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantVarNameIsUnused ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_castInstructionBranchListAST::cEnumerator::_mCastBranchInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCastBranchInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_castInstructionBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInstructionBranchListAST * p = NULL ;
    macroMyNew (p, GGS_castInstructionBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST GGS_castInstructionBranchListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInstructionBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInstructionBranchListAST * p = dynamic_cast <const GGS_castInstructionBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInstructionBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInstructionBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInstructionBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_elseOrDefaultForCastInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseOrDefaultForCastInstructionAST::
cPtr_elseOrDefaultForCastInstructionAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseOrDefaultForCastInstructionAST * GGS_elseOrDefaultForCastInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_elseOrDefaultForCastInstructionAST) ;
    return (cPtr_elseOrDefaultForCastInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_elseOrDefaultForCastInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@elseOrDefaultForCastInstructionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseOrDefaultForCastInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseOrDefaultForCastInstructionAST (& typeid (cPtr_elseOrDefaultForCastInstructionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_elseOrDefaultForCastInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__elseOrDefaultForCastInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_elseOrDefaultForCastInstructionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_elseOrDefaultForCastInstructionAST ("elseOrDefaultForCastInstructionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstructionAST::
GGS_elseOrDefaultForCastInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstructionAST::
GGS_elseOrDefaultForCastInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_elseOrDefaultForCastInstructionAST GGS_elseOrDefaultForCastInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseOrDefaultForCastInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseOrDefaultForCastInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_elseOrDefaultForCastInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_elseOrDefaultForCastInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseOrDefaultForCastInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseOrDefaultForCastInstructionAST::actualTypeName (void) const {
  return "elseOrDefaultForCastInstructionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_elseOrDefaultForCastInstructionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__elseOrDefaultForCastInstructionAST ("elseOrDefaultForCastInstructionAST", & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_elseOrDefaultForCastInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_elseOrDefaultForCastInstructionAST * p = NULL ;
    macroMyNew (p, GGS_elseOrDefaultForCastInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstructionAST GGS_elseOrDefaultForCastInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_elseOrDefaultForCastInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_elseOrDefaultForCastInstructionAST * p = dynamic_cast <const GGS_elseOrDefaultForCastInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_elseOrDefaultForCastInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_elseForCastInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_elseForCastInstructionAST::
cPtr_elseForCastInstructionAST (const GGS_semanticInstructionListAST & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstructionAST (THERE),
mElseInstructionList (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_elseForCastInstructionAST * GGS_elseForCastInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_elseForCastInstructionAST) ;
    return (cPtr_elseForCastInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_elseForCastInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_elseForCastInstructionAST * ptr = dynamic_cast <const cPtr_elseForCastInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_elseForCastInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@elseForCastInstructionAST:"
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_elseForCastInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_elseForCastInstructionAST (& typeid (cPtr_elseForCastInstructionAST), & typeid (cPtr_elseOrDefaultForCastInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_elseForCastInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__elseForCastInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_elseForCastInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_elseForCastInstructionAST (mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_elseForCastInstructionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_elseForCastInstructionAST ("elseForCastInstructionAST", true, & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_elseForCastInstructionAST::
GGS_elseForCastInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstructionAST::
GGS_elseForCastInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_elseForCastInstructionAST GGS_elseForCastInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_elseForCastInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_elseForCastInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_elseForCastInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_elseForCastInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstructionAST GGS_elseForCastInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticInstructionListAST & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_elseForCastInstructionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_elseForCastInstructionAST::
reader_mElseInstructionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_elseForCastInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_elseForCastInstructionAST *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_elseForCastInstructionAST::actualTypeName (void) const {
  return "elseForCastInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__elseForCastInstructionAST ("elseForCastInstructionAST", gClassInfoFor__elseOrDefaultForCastInstructionAST, & kTypeDescriptor_GGS_elseForCastInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_elseForCastInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_elseForCastInstructionAST * p = NULL ;
    macroMyNew (p, GGS_elseForCastInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseForCastInstructionAST GGS_elseForCastInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_elseForCastInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_elseForCastInstructionAST * p = dynamic_cast <const GGS_elseForCastInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_elseForCastInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_elseForCastInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_elseForCastInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_defaultForCastInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_defaultForCastInstructionAST::
cPtr_defaultForCastInstructionAST (const GGS_semanticExpressionAST & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_elseOrDefaultForCastInstructionAST (THERE),
mErrorLocationExpression (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_defaultForCastInstructionAST * GGS_defaultForCastInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_defaultForCastInstructionAST) ;
    return (cPtr_defaultForCastInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_defaultForCastInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_defaultForCastInstructionAST * ptr = dynamic_cast <const cPtr_defaultForCastInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorLocationExpression.operator_isEqual (ptr->mErrorLocationExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_defaultForCastInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@defaultForCastInstructionAST:"
           << mErrorLocationExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_defaultForCastInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_defaultForCastInstructionAST (& typeid (cPtr_defaultForCastInstructionAST), & typeid (cPtr_elseOrDefaultForCastInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_defaultForCastInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__defaultForCastInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_defaultForCastInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_defaultForCastInstructionAST (mErrorLocationExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_defaultForCastInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_defaultForCastInstructionAST ("defaultForCastInstructionAST", true, & kTypeDescriptor_GGS_elseOrDefaultForCastInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_defaultForCastInstructionAST::
GGS_defaultForCastInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstructionAST::
GGS_defaultForCastInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_defaultForCastInstructionAST GGS_defaultForCastInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_defaultForCastInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_defaultForCastInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_defaultForCastInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_defaultForCastInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstructionAST GGS_defaultForCastInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_semanticExpressionAST & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_defaultForCastInstructionAST (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_defaultForCastInstructionAST::
reader_mErrorLocationExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_defaultForCastInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_defaultForCastInstructionAST *) mPointer)->mErrorLocationExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_defaultForCastInstructionAST::actualTypeName (void) const {
  return "defaultForCastInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__defaultForCastInstructionAST ("defaultForCastInstructionAST", gClassInfoFor__elseOrDefaultForCastInstructionAST, & kTypeDescriptor_GGS_defaultForCastInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_defaultForCastInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_defaultForCastInstructionAST * p = NULL ;
    macroMyNew (p, GGS_defaultForCastInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_defaultForCastInstructionAST GGS_defaultForCastInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_defaultForCastInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_defaultForCastInstructionAST * p = dynamic_cast <const GGS_defaultForCastInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_defaultForCastInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_defaultForCastInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_defaultForCastInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_castInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_castInstructionAST::
cPtr_castInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_castInstructionBranchListAST & argument_2,
                                const GGS_elseOrDefaultForCastInstructionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mExpression (argument_1),
mCastInstructionBranchList (argument_2),
mElseOrDefault (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_castInstructionAST * GGS_castInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_castInstructionAST) ;
    return (cPtr_castInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_castInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_castInstructionAST * ptr = dynamic_cast <const cPtr_castInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mCastInstructionBranchList.operator_isEqual (ptr->mCastInstructionBranchList).boolValue ()
         && mElseOrDefault.operator_isEqual (ptr->mElseOrDefault).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_castInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@castInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1)
           << mCastInstructionBranchList.reader_description (inIndentation + 1)
           << mElseOrDefault.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_castInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_castInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_castInstructionAST (& typeid (cPtr_castInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_castInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__castInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_castInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_castInstructionAST (mStartLocation, mExpression, mCastInstructionBranchList, mElseOrDefault COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_castInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_castInstructionAST ("castInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_castInstructionAST::
GGS_castInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionAST::
GGS_castInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_castInstructionAST GGS_castInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_castInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_castInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_castInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_castInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_castInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionAST GGS_castInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_castInstructionBranchListAST & argument_2,
                 const GGS_elseOrDefaultForCastInstructionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_castInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_castInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_castInstructionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionBranchListAST  GGS_castInstructionAST::
reader_mCastInstructionBranchList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_castInstructionBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionAST *) mPointer)->mCastInstructionBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_elseOrDefaultForCastInstructionAST  GGS_castInstructionAST::
reader_mElseOrDefault (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_elseOrDefaultForCastInstructionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_castInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_castInstructionAST *) mPointer)->mElseOrDefault ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_castInstructionAST::actualTypeName (void) const {
  return "castInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__castInstructionAST ("castInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_castInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_castInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_castInstructionAST * p = NULL ;
    macroMyNew (p, GGS_castInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_castInstructionAST GGS_castInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_castInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_castInstructionAST * p = dynamic_cast <const GGS_castInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_castInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_castInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_castInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_addInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_addInstructionAST::
cPtr_addInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_outSemanticExpressionListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2),
mExpressionList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_addInstructionAST * GGS_addInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_addInstructionAST) ;
    return (cPtr_addInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_addInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_addInstructionAST * ptr = dynamic_cast <const cPtr_addInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_addInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@addInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_addInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_addInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_addInstructionAST (& typeid (cPtr_addInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_addInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__addInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_addInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_addInstructionAST (mStartLocation, mReceiverName, mStructAttributeList, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_addInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_addInstructionAST ("addInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_addInstructionAST::
GGS_addInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionAST::
GGS_addInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_addInstructionAST GGS_addInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_addInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_addInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_addInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_addInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_addInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionAST GGS_addInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_outSemanticExpressionListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_addInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_addInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_addInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_addInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_outSemanticExpressionListAST  GGS_addInstructionAST::
reader_mExpressionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_outSemanticExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_addInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_addInstructionAST *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_addInstructionAST::actualTypeName (void) const {
  return "addInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__addInstructionAST ("addInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_addInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_addInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_addInstructionAST * p = NULL ;
    macroMyNew (p, GGS_addInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_addInstructionAST GGS_addInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_addInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_addInstructionAST * p = dynamic_cast <const GGS_addInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_addInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_addInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_addInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_removeInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_removeInstructionAST::
cPtr_removeInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2),
mExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_removeInstructionAST * GGS_removeInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_removeInstructionAST) ;
    return (cPtr_removeInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_removeInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_removeInstructionAST * ptr = dynamic_cast <const cPtr_removeInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_removeInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@removeInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_removeInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_removeInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_removeInstructionAST (& typeid (cPtr_removeInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_removeInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__removeInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_removeInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_removeInstructionAST (mStartLocation, mReceiverName, mStructAttributeList, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_removeInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_removeInstructionAST ("removeInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_removeInstructionAST::
GGS_removeInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_removeInstructionAST::
GGS_removeInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_removeInstructionAST GGS_removeInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_removeInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_removeInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_removeInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_removeInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_removeInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_removeInstructionAST GGS_removeInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_semanticExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_removeInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_removeInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_removeInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_removeInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_removeInstructionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_removeInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_removeInstructionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_removeInstructionAST::actualTypeName (void) const {
  return "removeInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__removeInstructionAST ("removeInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_removeInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_removeInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_removeInstructionAST * p = NULL ;
    macroMyNew (p, GGS_removeInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_removeInstructionAST GGS_removeInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_removeInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_removeInstructionAST * p = dynamic_cast <const GGS_removeInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_removeInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_removeInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_removeInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_incrementInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_incrementInstructionAST::
cPtr_incrementInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_incrementInstructionAST * GGS_incrementInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_incrementInstructionAST) ;
    return (cPtr_incrementInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_incrementInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_incrementInstructionAST * ptr = dynamic_cast <const cPtr_incrementInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_incrementInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@incrementInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_incrementInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_incrementInstructionAST (& typeid (cPtr_incrementInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_incrementInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__incrementInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_incrementInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_incrementInstructionAST (mStartLocation, mReceiverName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_incrementInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_incrementInstructionAST ("incrementInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_incrementInstructionAST::
GGS_incrementInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionAST::
GGS_incrementInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_incrementInstructionAST GGS_incrementInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_incrementInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_incrementInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_incrementInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_incrementInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionAST GGS_incrementInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_incrementInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_incrementInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_incrementInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_incrementInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_incrementInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_incrementInstructionAST::actualTypeName (void) const {
  return "incrementInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__incrementInstructionAST ("incrementInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_incrementInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_incrementInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_incrementInstructionAST * p = NULL ;
    macroMyNew (p, GGS_incrementInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_incrementInstructionAST GGS_incrementInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_incrementInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_incrementInstructionAST * p = dynamic_cast <const GGS_incrementInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_incrementInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_incrementInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_incrementInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_decrementInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_decrementInstructionAST::
cPtr_decrementInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mReceiverName (argument_1),
mStructAttributeList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_decrementInstructionAST * GGS_decrementInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_decrementInstructionAST) ;
    return (cPtr_decrementInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_decrementInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_decrementInstructionAST * ptr = dynamic_cast <const cPtr_decrementInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mReceiverName.operator_isEqual (ptr->mReceiverName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_decrementInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@decrementInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mReceiverName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_decrementInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_decrementInstructionAST (& typeid (cPtr_decrementInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_decrementInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__decrementInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_decrementInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_decrementInstructionAST (mStartLocation, mReceiverName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_decrementInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_decrementInstructionAST ("decrementInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_decrementInstructionAST::
GGS_decrementInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionAST::
GGS_decrementInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_decrementInstructionAST GGS_decrementInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_decrementInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_decrementInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_decrementInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_decrementInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionAST GGS_decrementInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_decrementInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_decrementInstructionAST::
reader_mReceiverName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionAST *) mPointer)->mReceiverName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_decrementInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_decrementInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_decrementInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_decrementInstructionAST::actualTypeName (void) const {
  return "decrementInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__decrementInstructionAST ("decrementInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_decrementInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_decrementInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_decrementInstructionAST * p = NULL ;
    macroMyNew (p, GGS_decrementInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_decrementInstructionAST GGS_decrementInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_decrementInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_decrementInstructionAST * p = dynamic_cast <const GGS_decrementInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_decrementInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_decrementInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_decrementInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_loopInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_loopInstructionAST::
cPtr_loopInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2,
                                const GGS_semanticExpressionAST & argument_3,
                                const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mVariantExpression (argument_1),
mFirstInstructions (argument_2),
mLoopExpression (argument_3),
mSecondInstructions (argument_4) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_loopInstructionAST * GGS_loopInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_loopInstructionAST) ;
    return (cPtr_loopInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_loopInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_loopInstructionAST * ptr = dynamic_cast <const cPtr_loopInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mVariantExpression.operator_isEqual (ptr->mVariantExpression).boolValue ()
         && mFirstInstructions.operator_isEqual (ptr->mFirstInstructions).boolValue ()
         && mLoopExpression.operator_isEqual (ptr->mLoopExpression).boolValue ()
         && mSecondInstructions.operator_isEqual (ptr->mSecondInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_loopInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@loopInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mVariantExpression.reader_description (inIndentation + 1)
           << mFirstInstructions.reader_description (inIndentation + 1)
           << mLoopExpression.reader_description (inIndentation + 1)
           << mSecondInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_loopInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_loopInstructionAST (& typeid (cPtr_loopInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_loopInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__loopInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_loopInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_loopInstructionAST (mStartLocation, mVariantExpression, mFirstInstructions, mLoopExpression, mSecondInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_loopInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_loopInstructionAST ("loopInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_loopInstructionAST::
GGS_loopInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionAST::
GGS_loopInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_loopInstructionAST GGS_loopInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_loopInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_loopInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_loopInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_loopInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_loopInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionAST GGS_loopInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_semanticInstructionListAST & argument_2,
                 const GGS_semanticExpressionAST & argument_3,
                 const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_loopInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_loopInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_loopInstructionAST::
reader_mVariantExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mVariantExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_loopInstructionAST::
reader_mFirstInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mFirstInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_loopInstructionAST::
reader_mLoopExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mLoopExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_loopInstructionAST::
reader_mSecondInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_loopInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_loopInstructionAST *) mPointer)->mSecondInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_loopInstructionAST::actualTypeName (void) const {
  return "loopInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__loopInstructionAST ("loopInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_loopInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_loopInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_loopInstructionAST * p = NULL ;
    macroMyNew (p, GGS_loopInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_loopInstructionAST GGS_loopInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_loopInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_loopInstructionAST * p = dynamic_cast <const GGS_loopInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_loopInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_loopInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_loopInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_messageInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_messageInstructionAST::
cPtr_messageInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_messageInstructionAST * GGS_messageInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_messageInstructionAST) ;
    return (cPtr_messageInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_messageInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_messageInstructionAST * ptr = dynamic_cast <const cPtr_messageInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_messageInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@messageInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_messageInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_messageInstructionAST (& typeid (cPtr_messageInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_messageInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__messageInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_messageInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_messageInstructionAST (mStartLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_messageInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_messageInstructionAST ("messageInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_messageInstructionAST::
GGS_messageInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionAST::
GGS_messageInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_messageInstructionAST GGS_messageInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_messageInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_messageInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_messageInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_messageInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_messageInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionAST GGS_messageInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_messageInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_messageInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_messageInstructionAST::
reader_mExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_messageInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_messageInstructionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_messageInstructionAST::actualTypeName (void) const {
  return "messageInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__messageInstructionAST ("messageInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_messageInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_messageInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_messageInstructionAST * p = NULL ;
    macroMyNew (p, GGS_messageInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_messageInstructionAST GGS_messageInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_messageInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_messageInstructionAST * p = dynamic_cast <const GGS_messageInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_messageInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_messageInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_messageInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Element of list '@logListAST'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_logListAST::
elementOf_GGS_logListAST (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mLogMessage (argument_0),
mLogExpression (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_logListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_logListAST * ptr = dynamic_cast <const elementOf_GGS_logListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLogMessage.operator_isEqual (ptr->mLogMessage).boolValue ()
         && mLogExpression.operator_isEqual (ptr->mLogExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_logListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLogMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLogExpression.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@logListAST'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_logListAST ("logListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_logListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpressionAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_semanticExpressionAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_logListAST GGS_logListAST::
operator_concat (const GGS_logListAST & inOperand) const {
  GGS_logListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
dotAssign_operation (const GGS_logListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_logListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mLogMessage ;
          GGS_semanticExpressionAST  p_1 = p->mLogExpression ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_semanticExpressionAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mLogMessage,
                                ptr->mLogExpression
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_logListAST  GGS_logListAST::
constructor_emptyList (void) {
  GGS_logListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListAST  GGS_logListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_semanticExpressionAST & argument_1) {
  GGS_logListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
internalSubListWithRange (GGS_logListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mLogMessage, ptr->mLogExpression) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_logListAST GGS_logListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_logListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListAST GGS_logListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_logListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_logListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@logListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_semanticExpressionAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_semanticExpressionAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_semanticExpressionAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_semanticExpressionAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mLogMessage ;
    _out_1 = ptr->mLogExpression ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_logListAST::
reader_mLogMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLogMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_logListAST::
reader_mLogExpressionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mLogExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_setMLogMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLogMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_logListAST::
modifier_setMLogExpressionAtIndex (C_Compiler & inLexique,
                              const GGS_semanticExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mLogExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_logListAST::cEnumerator::_mLogMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLogMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticExpressionAST  & GGS_logListAST::cEnumerator::_mLogExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mLogExpression ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_logListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_logListAST * p = NULL ;
    macroMyNew (p, GGS_logListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListAST GGS_logListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_logListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_logListAST * p = dynamic_cast <const GGS_logListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_logListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_logListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_logListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_logInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_logInstructionAST::
cPtr_logInstructionAST (const GGS_location & argument_0,
                                const GGS_logListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mLogList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_logInstructionAST * GGS_logInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_logInstructionAST) ;
    return (cPtr_logInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_logInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_logInstructionAST * ptr = dynamic_cast <const cPtr_logInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mLogList.operator_isEqual (ptr->mLogList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_logInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@logInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mLogList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_logInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_logInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_logInstructionAST (& typeid (cPtr_logInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_logInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__logInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_logInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_logInstructionAST (mStartLocation, mLogList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_logInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_logInstructionAST ("logInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_logInstructionAST::
GGS_logInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionAST::
GGS_logInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_logInstructionAST GGS_logInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_logInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_logInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_logInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_logInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_logInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionAST GGS_logInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_logListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_logInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_logInstructionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logListAST  GGS_logInstructionAST::
reader_mLogList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_logListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_logInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_logInstructionAST *) mPointer)->mLogList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_logInstructionAST::actualTypeName (void) const {
  return "logInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__logInstructionAST ("logInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_logInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_logInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_logInstructionAST * p = NULL ;
    macroMyNew (p, GGS_logInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_logInstructionAST GGS_logInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_logInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_logInstructionAST * p = dynamic_cast <const GGS_logInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_logInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_logInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_logInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_grammarInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_grammarInstructionAST::
cPtr_grammarInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_semanticExpressionAST & argument_3,
                                const GGS_bool& argument_4,
                                const GGS_actualParameterListAST & argument_5
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mGrammarComponentName (argument_1),
mLabelName (argument_2),
mSourceExpression (argument_3),
mSourceExpressionIsFile (argument_4),
mActualParameterList (argument_5) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_grammarInstructionAST * GGS_grammarInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_grammarInstructionAST) ;
    return (cPtr_grammarInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_grammarInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_grammarInstructionAST * ptr = dynamic_cast <const cPtr_grammarInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mGrammarComponentName.operator_isEqual (ptr->mGrammarComponentName).boolValue ()
         && mLabelName.operator_isEqual (ptr->mLabelName).boolValue ()
         && mSourceExpression.operator_isEqual (ptr->mSourceExpression).boolValue ()
         && mSourceExpressionIsFile.operator_isEqual (ptr->mSourceExpressionIsFile).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_grammarInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@grammarInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mGrammarComponentName.reader_description (inIndentation + 1)
           << mLabelName.reader_description (inIndentation + 1)
           << mSourceExpression.reader_description (inIndentation + 1)
           << mSourceExpressionIsFile.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_grammarInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_grammarInstructionAST (& typeid (cPtr_grammarInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_grammarInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__grammarInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_grammarInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_grammarInstructionAST (mStartLocation, mGrammarComponentName, mLabelName, mSourceExpression, mSourceExpressionIsFile, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_grammarInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarInstructionAST ("grammarInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_grammarInstructionAST::
GGS_grammarInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionAST::
GGS_grammarInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_grammarInstructionAST GGS_grammarInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_grammarInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_grammarInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_grammarInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_grammarInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionAST GGS_grammarInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_semanticExpressionAST & argument_3,
                 const GGS_bool& argument_4,
                 const GGS_actualParameterListAST & argument_5
                                COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_grammarInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstructionAST::
reader_mGrammarComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mGrammarComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_grammarInstructionAST::
reader_mLabelName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mLabelName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_grammarInstructionAST::
reader_mSourceExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mSourceExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarInstructionAST::
reader_mSourceExpressionIsFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mSourceExpressionIsFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_grammarInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_grammarInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_grammarInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_grammarInstructionAST::actualTypeName (void) const {
  return "grammarInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__grammarInstructionAST ("grammarInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_grammarInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_grammarInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarInstructionAST * p = NULL ;
    macroMyNew (p, GGS_grammarInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarInstructionAST GGS_grammarInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarInstructionAST * p = dynamic_cast <const GGS_grammarInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_withInstructionAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_withInstructionAST::
cPtr_withInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_lstring & argument_4,
                                const GGS_semanticExpressionAST & argument_5,
                                const GGS_semanticInstructionListAST & argument_6,
                                const GGS_semanticInstructionListAST & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mPrefix (argument_1),
mTargetObjectName (argument_2),
mStructAttributeList (argument_3),
mSearchMethodName (argument_4),
mKeyExpression (argument_5),
mDoBranchInstructions (argument_6),
mElseBranchInstructions (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_withInstructionAST * GGS_withInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_withInstructionAST) ;
    return (cPtr_withInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_withInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_withInstructionAST * ptr = dynamic_cast <const cPtr_withInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue ()
         && mTargetObjectName.operator_isEqual (ptr->mTargetObjectName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue ()
         && mSearchMethodName.operator_isEqual (ptr->mSearchMethodName).boolValue ()
         && mKeyExpression.operator_isEqual (ptr->mKeyExpression).boolValue ()
         && mDoBranchInstructions.operator_isEqual (ptr->mDoBranchInstructions).boolValue ()
         && mElseBranchInstructions.operator_isEqual (ptr->mElseBranchInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_withInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@withInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mPrefix.reader_description (inIndentation + 1)
           << mTargetObjectName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1)
           << mSearchMethodName.reader_description (inIndentation + 1)
           << mKeyExpression.reader_description (inIndentation + 1)
           << mDoBranchInstructions.reader_description (inIndentation + 1)
           << mElseBranchInstructions.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_withInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_withInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_withInstructionAST (& typeid (cPtr_withInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_withInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__withInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_withInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_withInstructionAST (mStartLocation, mPrefix, mTargetObjectName, mStructAttributeList, mSearchMethodName, mKeyExpression, mDoBranchInstructions, mElseBranchInstructions COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_withInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_withInstructionAST ("withInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_withInstructionAST::
GGS_withInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_withInstructionAST::
GGS_withInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_withInstructionAST GGS_withInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_withInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_withInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_withInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_withInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_withInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withInstructionAST GGS_withInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_lstring & argument_4,
                 const GGS_semanticExpressionAST & argument_5,
                 const GGS_semanticInstructionListAST & argument_6,
                 const GGS_semanticInstructionListAST & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_withInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_withInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstructionAST::
reader_mPrefix (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionAST *) mPointer)->mPrefix ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstructionAST::
reader_mTargetObjectName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionAST *) mPointer)->mTargetObjectName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_withInstructionAST::
reader_mStructAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_withInstructionAST::
reader_mSearchMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionAST *) mPointer)->mSearchMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_withInstructionAST::
reader_mKeyExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionAST *) mPointer)->mKeyExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_withInstructionAST::
reader_mDoBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionAST *) mPointer)->mDoBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_withInstructionAST::
reader_mElseBranchInstructions (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_withInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_withInstructionAST *) mPointer)->mElseBranchInstructions ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_withInstructionAST::actualTypeName (void) const {
  return "withInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__withInstructionAST ("withInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_withInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_withInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_withInstructionAST * p = NULL ;
    macroMyNew (p, GGS_withInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_withInstructionAST GGS_withInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_withInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_withInstructionAST * p = dynamic_cast <const GGS_withInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_withInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_withInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_withInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@switchBranchesAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_switchBranchesAST::
elementOf_GGS_switchBranchesAST (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSwitchConstantList (argument_0),
mInstructions (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_switchBranchesAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_switchBranchesAST * ptr = dynamic_cast <const elementOf_GGS_switchBranchesAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchConstantList.operator_isEqual (ptr->mSwitchConstantList).boolValue ()
         && mInstructions.operator_isEqual (ptr->mInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_switchBranchesAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSwitchConstantList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructions.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@switchBranchesAST'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_switchBranchesAST ("switchBranchesAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_semanticInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
addAssign_operation (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST GGS_switchBranchesAST::
operator_concat (const GGS_switchBranchesAST & inOperand) const {
  GGS_switchBranchesAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
dotAssign_operation (const GGS_switchBranchesAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_switchBranchesAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mSwitchConstantList ;
          GGS_semanticInstructionListAST  p_1 = p->mInstructions ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_semanticInstructionListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSwitchConstantList,
                                ptr->mInstructions
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST  GGS_switchBranchesAST::
constructor_emptyList (void) {
  GGS_switchBranchesAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST  GGS_switchBranchesAST::
constructor_listWithValue (const GGS_lstringlist & argument_0,
                                const GGS_semanticInstructionListAST & argument_1) {
  GGS_switchBranchesAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
internalSubListWithRange (GGS_switchBranchesAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSwitchConstantList, ptr->mInstructions) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST GGS_switchBranchesAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranchesAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST GGS_switchBranchesAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_switchBranchesAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_switchBranchesAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@switchBranchesAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
method_first (C_Compiler & inLexique,
              GGS_lstringlist & _out_0,
              GGS_semanticInstructionListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
method_last (C_Compiler & inLexique,
             GGS_lstringlist & _out_0,
             GGS_semanticInstructionListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstringlist & _out_0,
                 GGS_semanticInstructionListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstringlist & _out_0,
                GGS_semanticInstructionListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSwitchConstantList ;
    _out_1 = ptr->mInstructions ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_switchBranchesAST::
reader_mSwitchConstantListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSwitchConstantList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_switchBranchesAST::
reader_mInstructionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_setMSwitchConstantListAtIndex (C_Compiler & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSwitchConstantList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_switchBranchesAST::
modifier_setMInstructionsAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_switchBranchesAST::cEnumerator::_mSwitchConstantList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSwitchConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_switchBranchesAST::cEnumerator::_mInstructions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructions ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_switchBranchesAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_switchBranchesAST * p = NULL ;
    macroMyNew (p, GGS_switchBranchesAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST GGS_switchBranchesAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_switchBranchesAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_switchBranchesAST * p = dynamic_cast <const GGS_switchBranchesAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_switchBranchesAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_switchBranchesAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_switchBranchesAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_switchInstructionAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_switchInstructionAST::
cPtr_switchInstructionAST (const GGS_location & argument_0,
                                const GGS_semanticExpressionAST & argument_1,
                                const GGS_switchBranchesAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mSwitchExpression (argument_1),
mBranches (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_switchInstructionAST * GGS_switchInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_switchInstructionAST) ;
    return (cPtr_switchInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_switchInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_switchInstructionAST * ptr = dynamic_cast <const cPtr_switchInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mBranches.operator_isEqual (ptr->mBranches).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_switchInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@switchInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mSwitchExpression.reader_description (inIndentation + 1)
           << mBranches.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_switchInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_switchInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_switchInstructionAST (& typeid (cPtr_switchInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_switchInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__switchInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_switchInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_switchInstructionAST (mStartLocation, mSwitchExpression, mBranches COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_switchInstructionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_switchInstructionAST ("switchInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_switchInstructionAST::
GGS_switchInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionAST::
GGS_switchInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_switchInstructionAST GGS_switchInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_switchInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_switchInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_switchInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_switchInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_switchInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionAST GGS_switchInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_semanticExpressionAST & argument_1,
                 const GGS_switchBranchesAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_switchInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_switchInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticExpressionAST  GGS_switchInstructionAST::
reader_mSwitchExpression (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionAST *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchBranchesAST  GGS_switchInstructionAST::
reader_mBranches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_switchBranchesAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_switchInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_switchInstructionAST *) mPointer)->mBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_switchInstructionAST::actualTypeName (void) const {
  return "switchInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__switchInstructionAST ("switchInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_switchInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_switchInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_switchInstructionAST * p = NULL ;
    macroMyNew (p, GGS_switchInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_switchInstructionAST GGS_switchInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_switchInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_switchInstructionAST * p = dynamic_cast <const GGS_switchInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_switchInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_switchInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_switchInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeMethodInstructionAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeMethodInstructionAST::
cPtr_typeMethodInstructionAST (const GGS_location & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_actualParameterListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticInstructionAST (argument_0 COMMA_THERE),
mTypeName (argument_1),
mMethodName (argument_2),
mActualParameterList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeMethodInstructionAST * GGS_typeMethodInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeMethodInstructionAST) ;
    return (cPtr_typeMethodInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeMethodInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeMethodInstructionAST * ptr = dynamic_cast <const cPtr_typeMethodInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStartLocation.operator_isEqual (ptr->mStartLocation).boolValue ()
         && mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mActualParameterList.operator_isEqual (ptr->mActualParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeMethodInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeMethodInstructionAST:"
           << mStartLocation.reader_description (inIndentation + 1)
           << mTypeName.reader_description (inIndentation + 1)
           << mMethodName.reader_description (inIndentation + 1)
           << mActualParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeMethodInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeMethodInstructionAST (& typeid (cPtr_typeMethodInstructionAST), & typeid (cPtr_semanticInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeMethodInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__typeMethodInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeMethodInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeMethodInstructionAST (mStartLocation, mTypeName, mMethodName, mActualParameterList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeMethodInstructionAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeMethodInstructionAST ("typeMethodInstructionAST", true, & kTypeDescriptor_GGS_semanticInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionAST::
GGS_typeMethodInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionAST::
GGS_typeMethodInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeMethodInstructionAST GGS_typeMethodInstructionAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeMethodInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_typeMethodInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeMethodInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeMethodInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionAST GGS_typeMethodInstructionAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_actualParameterListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_typeMethodInstructionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstructionAST::
reader_mTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeMethodInstructionAST::
reader_mMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionAST *) mPointer)->mMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_actualParameterListAST  GGS_typeMethodInstructionAST::
reader_mActualParameterList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_actualParameterListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeMethodInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeMethodInstructionAST *) mPointer)->mActualParameterList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeMethodInstructionAST::actualTypeName (void) const {
  return "typeMethodInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeMethodInstructionAST ("typeMethodInstructionAST", gClassInfoFor__semanticInstructionAST, & kTypeDescriptor_GGS_typeMethodInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeMethodInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeMethodInstructionAST * p = NULL ;
    macroMyNew (p, GGS_typeMethodInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeMethodInstructionAST GGS_typeMethodInstructionAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeMethodInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeMethodInstructionAST * p = dynamic_cast <const GGS_typeMethodInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeMethodInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeMethodInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeMethodInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@abstracMultiMethodListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstracMultiMethodListAST::
elementOf_GGS_abstracMultiMethodListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAbstractCategoryMethodName (argument_0),
mAbstractCategoryFormalParameterList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstracMultiMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstracMultiMethodListAST * ptr = dynamic_cast <const elementOf_GGS_abstracMultiMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAbstractCategoryMethodName.operator_isEqual (ptr->mAbstractCategoryMethodName).boolValue ()
         && mAbstractCategoryFormalParameterList.operator_isEqual (ptr->mAbstractCategoryFormalParameterList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstracMultiMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalParameterList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@abstracMultiMethodListAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstracMultiMethodListAST ("abstracMultiMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstracMultiMethodListAST::
operator_concat (const GGS_abstracMultiMethodListAST & inOperand) const {
  GGS_abstracMultiMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
dotAssign_operation (const GGS_abstracMultiMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstracMultiMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractCategoryMethodName ;
          GGS_formalParameterListAST  p_1 = p->mAbstractCategoryFormalParameterList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAbstractCategoryMethodName,
                                ptr->mAbstractCategoryFormalParameterList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST  GGS_abstracMultiMethodListAST::
constructor_emptyList (void) {
  GGS_abstracMultiMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST  GGS_abstracMultiMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1) {
  GGS_abstracMultiMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
internalSubListWithRange (GGS_abstracMultiMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAbstractCategoryMethodName, ptr->mAbstractCategoryFormalParameterList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstracMultiMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstracMultiMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstracMultiMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstracMultiMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryMethodName ;
    _out_1 = ptr->mAbstractCategoryFormalParameterList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstracMultiMethodListAST::
reader_mAbstractCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_abstracMultiMethodListAST::
reader_mAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_setMAbstractCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstracMultiMethodListAST::
modifier_setMAbstractCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstracMultiMethodListAST::cEnumerator::_mAbstractCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_abstracMultiMethodListAST::cEnumerator::_mAbstractCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstracMultiMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstracMultiMethodListAST * p = NULL ;
    macroMyNew (p, GGS_abstracMultiMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstracMultiMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstracMultiMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstracMultiMethodListAST * p = dynamic_cast <const GGS_abstracMultiMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstracMultiMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstracMultiMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstracMultiMethodListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiMethodListMapAST ("abstractMultiMethodListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstracMultiMethodListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractMultiMethodListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractMultiMethodListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractMultiMethodListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST GGS_abstractMultiMethodListMapAST::
constructor_emptyMap (void) {
  GGS_abstractMultiMethodListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMultiMethodListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@abstractMultiMethodListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST GGS_abstractMultiMethodListMapAST::
operator_concat (const GGS_abstractMultiMethodListMapAST & inOperand) const {
  GGS_abstractMultiMethodListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiMethodListMapAST::
dotAssign_operation (const GGS_abstractMultiMethodListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_abstracMultiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiMethodListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListAST & inAttribute1) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_abstracMultiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstracMultiMethodListAST GGS_abstractMultiMethodListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstracMultiMethodListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstracMultiMethodListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractMultiMethodListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractMultiMethodListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST::cEnumerator::
cEnumerator (const GGS_abstractMultiMethodListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstracMultiMethodListAST & GGS_abstractMultiMethodListMapAST::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiMethodListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiMethodListMapAST * p = NULL ;
    macroMyNew (p, GGS_abstractMultiMethodListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiMethodListMapAST GGS_abstractMultiMethodListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiMethodListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiMethodListMapAST * p = dynamic_cast <const GGS_abstractMultiMethodListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiMethodListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiMethodListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiMethodListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@multiMethodListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_multiMethodListAST::
elementOf_GGS_multiMethodListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mCategoryMethodName (argument_0),
mCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_multiMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_multiMethodListAST * ptr = dynamic_cast <const elementOf_GGS_multiMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryMethodName.operator_isEqual (ptr->mCategoryMethodName).boolValue ()
         && mCategoryFormalParameterList.operator_isEqual (ptr->mCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_multiMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryFormalParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@multiMethodListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiMethodListAST ("multiMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListAST::
operator_concat (const GGS_multiMethodListAST & inOperand) const {
  GGS_multiMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
dotAssign_operation (const GGS_multiMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_multiMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCategoryMethodName ;
          GGS_formalParameterListAST  p_1 = p->mCategoryFormalParameterList ;
          GGS_semanticInstructionListAST  p_2 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1,
                     const GGS_semanticInstructionListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCategoryMethodName,
                                ptr->mCategoryFormalParameterList,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST  GGS_multiMethodListAST::
constructor_emptyList (void) {
  GGS_multiMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST  GGS_multiMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  GGS_multiMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
internalSubListWithRange (GGS_multiMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCategoryMethodName, ptr->mCategoryFormalParameterList, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_multiMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_multiMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@multiMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1,
              GGS_semanticInstructionListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1,
             GGS_semanticInstructionListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1,
                 GGS_semanticInstructionListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1,
                GGS_semanticInstructionListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryMethodName ;
    _out_1 = ptr->mCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiMethodListAST::
reader_mCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_multiMethodListAST::
reader_mCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_multiMethodListAST::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_setMCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_setMCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListAST::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiMethodListAST::cEnumerator::_mCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_multiMethodListAST::cEnumerator::_mCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_multiMethodListAST::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiMethodListAST * p = NULL ;
    macroMyNew (p, GGS_multiMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiMethodListAST * p = dynamic_cast <const GGS_multiMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiMethodListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiMethodListMapAST ("multiMethodListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_multiMethodListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_multiMethodListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_multiMethodListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_multiMethodListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST GGS_multiMethodListMapAST::
constructor_emptyMap (void) {
  GGS_multiMethodListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiMethodListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@multiMethodListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST GGS_multiMethodListMapAST::
operator_concat (const GGS_multiMethodListMapAST & inOperand) const {
  GGS_multiMethodListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListMapAST::
dotAssign_operation (const GGS_multiMethodListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_multiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListAST & inAttribute1,
                      const GGS_semanticInstructionListAST & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_multiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodListAST GGS_multiMethodListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_multiMethodListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_multiMethodListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_multiMethodListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_multiMethodListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST::cEnumerator::
cEnumerator (const GGS_multiMethodListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_multiMethodListAST & GGS_multiMethodListMapAST::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiMethodListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiMethodListMapAST * p = NULL ;
    macroMyNew (p, GGS_multiMethodListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodListMapAST GGS_multiMethodListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiMethodListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiMethodListMapAST * p = dynamic_cast <const GGS_multiMethodListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiMethodListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiMethodListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiMethodListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridingMultiMethodListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingMultiMethodListAST::
elementOf_GGS_overridingMultiMethodListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mOverridingCategoryMethodName (argument_0),
mOverridingCategoryFormalParameterList (argument_1),
mRoutineInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingMultiMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingMultiMethodListAST * ptr = dynamic_cast <const elementOf_GGS_overridingMultiMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverridingCategoryMethodName.operator_isEqual (ptr->mOverridingCategoryMethodName).boolValue ()
         && mOverridingCategoryFormalParameterList.operator_isEqual (ptr->mOverridingCategoryFormalParameterList).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingMultiMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryFormalParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@overridingMultiMethodListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiMethodListAST ("overridingMultiMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListAST::
operator_concat (const GGS_overridingMultiMethodListAST & inOperand) const {
  GGS_overridingMultiMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
dotAssign_operation (const GGS_overridingMultiMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_overridingMultiMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingCategoryMethodName ;
          GGS_formalParameterListAST  p_1 = p->mOverridingCategoryFormalParameterList ;
          GGS_semanticInstructionListAST  p_2 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1,
                     const GGS_semanticInstructionListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOverridingCategoryMethodName,
                                ptr->mOverridingCategoryFormalParameterList,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST  GGS_overridingMultiMethodListAST::
constructor_emptyList (void) {
  GGS_overridingMultiMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST  GGS_overridingMultiMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  GGS_overridingMultiMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
internalSubListWithRange (GGS_overridingMultiMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverridingCategoryMethodName, ptr->mOverridingCategoryFormalParameterList, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingMultiMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@overridingMultiMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1,
              GGS_semanticInstructionListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1,
             GGS_semanticInstructionListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1,
                 GGS_semanticInstructionListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1,
                GGS_semanticInstructionListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryMethodName ;
    _out_1 = ptr->mOverridingCategoryFormalParameterList ;
    _out_2 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiMethodListAST::
reader_mOverridingCategoryMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_overridingMultiMethodListAST::
reader_mOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryFormalParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_overridingMultiMethodListAST::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_setMOverridingCategoryMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_setMOverridingCategoryFormalParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryFormalParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListAST::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiMethodListAST::cEnumerator::_mOverridingCategoryMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_overridingMultiMethodListAST::cEnumerator::_mOverridingCategoryFormalParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryFormalParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_overridingMultiMethodListAST::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiMethodListAST * p = NULL ;
    macroMyNew (p, GGS_overridingMultiMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiMethodListAST * p = dynamic_cast <const GGS_overridingMultiMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiMethodListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiMethodListMapAST ("overridingMultiMethodListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingMultiMethodListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingMultiMethodListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingMultiMethodListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingMultiMethodListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST GGS_overridingMultiMethodListMapAST::
constructor_emptyMap (void) {
  GGS_overridingMultiMethodListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingMultiMethodListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@overridingMultiMethodListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST GGS_overridingMultiMethodListMapAST::
operator_concat (const GGS_overridingMultiMethodListMapAST & inOperand) const {
  GGS_overridingMultiMethodListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListMapAST::
dotAssign_operation (const GGS_overridingMultiMethodListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_overridingMultiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiMethodListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalParameterListAST & inAttribute1,
                      const GGS_semanticInstructionListAST & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_overridingMultiMethodListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListAST GGS_overridingMultiMethodListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingMultiMethodListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingMultiMethodListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingMultiMethodListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingMultiMethodListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST::cEnumerator::
cEnumerator (const GGS_overridingMultiMethodListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingMultiMethodListAST & GGS_overridingMultiMethodListMapAST::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiMethodListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiMethodListMapAST * p = NULL ;
    macroMyNew (p, GGS_overridingMultiMethodListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiMethodListMapAST GGS_overridingMultiMethodListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiMethodListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiMethodListMapAST * p = dynamic_cast <const GGS_overridingMultiMethodListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiMethodListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiMethodListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiMethodListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@abstractMultiReaderListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMultiReaderListAST::
elementOf_GGS_abstractMultiReaderListAST (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAbstractCategoryReaderName (argument_0),
mAbstractCategoryFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMultiReaderListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMultiReaderListAST * ptr = dynamic_cast <const elementOf_GGS_abstractMultiReaderListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAbstractCategoryReaderName.operator_isEqual (ptr->mAbstractCategoryReaderName).boolValue ()
         && mAbstractCategoryFormalInputParameterList.operator_isEqual (ptr->mAbstractCategoryFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMultiReaderListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAbstractCategoryFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@abstractMultiReaderListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiReaderListAST ("abstractMultiReaderListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListAST::
operator_concat (const GGS_abstractMultiReaderListAST & inOperand) const {
  GGS_abstractMultiReaderListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
dotAssign_operation (const GGS_abstractMultiReaderListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstractMultiReaderListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAbstractCategoryReaderName ;
          GGS_formalInputParameterListAST  p_1 = p->mAbstractCategoryFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListAST & argument_1,
                     const GGS_lstring & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAbstractCategoryReaderName,
                                ptr->mAbstractCategoryFormalInputParameterList,
                                ptr->mReturnedTypeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST  GGS_abstractMultiReaderListAST::
constructor_emptyList (void) {
  GGS_abstractMultiReaderListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST  GGS_abstractMultiReaderListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2) {
  GGS_abstractMultiReaderListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
internalSubListWithRange (GGS_abstractMultiReaderListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAbstractCategoryReaderName, ptr->mAbstractCategoryFormalInputParameterList, ptr->mReturnedTypeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMultiReaderListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstractMultiReaderListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListAST & _out_1,
              GGS_lstring & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListAST & _out_1,
             GGS_lstring & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListAST & _out_1,
                 GGS_lstring & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListAST & _out_1,
                GGS_lstring & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAbstractCategoryReaderName ;
    _out_1 = ptr->mAbstractCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMultiReaderListAST::
reader_mAbstractCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_abstractMultiReaderListAST::
reader_mAbstractCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAbstractCategoryFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMultiReaderListAST::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_setMAbstractCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_setMAbstractCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAbstractCategoryFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListAST::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMultiReaderListAST::cEnumerator::_mAbstractCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_abstractMultiReaderListAST::cEnumerator::_mAbstractCategoryFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAbstractCategoryFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMultiReaderListAST::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiReaderListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiReaderListAST * p = NULL ;
    macroMyNew (p, GGS_abstractMultiReaderListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiReaderListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiReaderListAST * p = dynamic_cast <const GGS_abstractMultiReaderListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiReaderListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiReaderListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiReaderListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMultiReaderListMapAST ("abstractMultiReaderListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_abstractMultiReaderListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_abstractMultiReaderListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_abstractMultiReaderListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_abstractMultiReaderListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST GGS_abstractMultiReaderListMapAST::
constructor_emptyMap (void) {
  GGS_abstractMultiReaderListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_abstractMultiReaderListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@abstractMultiReaderListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST GGS_abstractMultiReaderListMapAST::
operator_concat (const GGS_abstractMultiReaderListMapAST & inOperand) const {
  GGS_abstractMultiReaderListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListMapAST::
dotAssign_operation (const GGS_abstractMultiReaderListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_abstractMultiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMultiReaderListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListAST & inAttribute1,
                      const GGS_lstring & inAttribute2) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_abstractMultiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListAST GGS_abstractMultiReaderListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMultiReaderListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_abstractMultiReaderListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_abstractMultiReaderListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_abstractMultiReaderListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST::cEnumerator::
cEnumerator (const GGS_abstractMultiReaderListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_abstractMultiReaderListAST & GGS_abstractMultiReaderListMapAST::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMultiReaderListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMultiReaderListMapAST * p = NULL ;
    macroMyNew (p, GGS_abstractMultiReaderListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMultiReaderListMapAST GGS_abstractMultiReaderListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMultiReaderListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMultiReaderListMapAST * p = dynamic_cast <const GGS_abstractMultiReaderListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMultiReaderListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMultiReaderListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMultiReaderListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@multiReaderListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_multiReaderListAST::
elementOf_GGS_multiReaderListAST (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mCategoryReaderName (argument_0),
mReaderCategoryFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2),
mReturnedVariableName (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_multiReaderListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_multiReaderListAST * ptr = dynamic_cast <const elementOf_GGS_multiReaderListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mCategoryReaderName.operator_isEqual (ptr->mCategoryReaderName).boolValue ()
         && mReaderCategoryFormalInputParameterList.operator_isEqual (ptr->mReaderCategoryFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue ()
         && mReturnedVariableName.operator_isEqual (ptr->mReturnedVariableName).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_multiReaderListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mCategoryReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReaderCategoryFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@multiReaderListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiReaderListAST ("multiReaderListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListAST::
operator_concat (const GGS_multiReaderListAST & inOperand) const {
  GGS_multiReaderListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
dotAssign_operation (const GGS_multiReaderListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_multiReaderListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mCategoryReaderName ;
          GGS_formalInputParameterListAST  p_1 = p->mReaderCategoryFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_semanticInstructionListAST  p_4 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListAST & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_semanticInstructionListAST & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mCategoryReaderName,
                                ptr->mReaderCategoryFormalInputParameterList,
                                ptr->mReturnedTypeName,
                                ptr->mReturnedVariableName,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST  GGS_multiReaderListAST::
constructor_emptyList (void) {
  GGS_multiReaderListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST  GGS_multiReaderListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  GGS_multiReaderListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
internalSubListWithRange (GGS_multiReaderListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mCategoryReaderName, ptr->mReaderCategoryFormalInputParameterList, ptr->mReturnedTypeName, ptr->mReturnedVariableName, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_multiReaderListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_multiReaderListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiReaderListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@multiReaderListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListAST & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_semanticInstructionListAST & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListAST & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_semanticInstructionListAST & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListAST & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_semanticInstructionListAST & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListAST & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_semanticInstructionListAST & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mCategoryReaderName ;
    _out_1 = ptr->mReaderCategoryFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListAST::
reader_mCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_multiReaderListAST::
reader_mReaderCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReaderCategoryFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListAST::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_multiReaderListAST::
reader_mReturnedVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_multiReaderListAST::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMReaderCategoryFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReaderCategoryFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMReturnedVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListAST::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListAST::cEnumerator::_mCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_multiReaderListAST::cEnumerator::_mReaderCategoryFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReaderCategoryFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListAST::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_multiReaderListAST::cEnumerator::_mReturnedVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedVariableName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_multiReaderListAST::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiReaderListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiReaderListAST * p = NULL ;
    macroMyNew (p, GGS_multiReaderListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiReaderListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiReaderListAST * p = dynamic_cast <const GGS_multiReaderListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiReaderListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiReaderListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiReaderListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiReaderListMapAST ("multiReaderListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_multiReaderListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_multiReaderListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_multiReaderListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_multiReaderListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST GGS_multiReaderListMapAST::
constructor_emptyMap (void) {
  GGS_multiReaderListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_multiReaderListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@multiReaderListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST GGS_multiReaderListMapAST::
operator_concat (const GGS_multiReaderListMapAST & inOperand) const {
  GGS_multiReaderListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListMapAST::
dotAssign_operation (const GGS_multiReaderListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_multiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_multiReaderListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListAST & inAttribute1,
                      const GGS_lstring & inAttribute2,
                      const GGS_lstring & inAttribute3,
                      const GGS_semanticInstructionListAST & inAttribute4) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt () && inAttribute3.isBuilt () && inAttribute4.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_multiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2, inAttribute3, inAttribute4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiReaderListAST GGS_multiReaderListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_multiReaderListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_multiReaderListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_multiReaderListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_multiReaderListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST::cEnumerator::
cEnumerator (const GGS_multiReaderListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_multiReaderListAST & GGS_multiReaderListMapAST::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiReaderListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiReaderListMapAST * p = NULL ;
    macroMyNew (p, GGS_multiReaderListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiReaderListMapAST GGS_multiReaderListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiReaderListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiReaderListMapAST * p = dynamic_cast <const GGS_multiReaderListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiReaderListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiReaderListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiReaderListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@overridingMultiReaderListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridingMultiReaderListAST::
elementOf_GGS_overridingMultiReaderListAST (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mOverridingCategoryReaderName (argument_0),
mOverridingReaderFormalInputParameterList (argument_1),
mReturnedTypeName (argument_2),
mReturnedVariableName (argument_3),
mRoutineInstructionList (argument_4) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridingMultiReaderListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridingMultiReaderListAST * ptr = dynamic_cast <const elementOf_GGS_overridingMultiReaderListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOverridingCategoryReaderName.operator_isEqual (ptr->mOverridingCategoryReaderName).boolValue ()
         && mOverridingReaderFormalInputParameterList.operator_isEqual (ptr->mOverridingReaderFormalInputParameterList).boolValue ()
         && mReturnedTypeName.operator_isEqual (ptr->mReturnedTypeName).boolValue ()
         && mReturnedVariableName.operator_isEqual (ptr->mReturnedVariableName).boolValue ()
         && mRoutineInstructionList.operator_isEqual (ptr->mRoutineInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridingMultiReaderListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingCategoryReaderName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mOverridingReaderFormalInputParameterList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mReturnedVariableName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mRoutineInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@overridingMultiReaderListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiReaderListAST ("overridingMultiReaderListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalInputParameterListAST & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3,
                    const GGS_semanticInstructionListAST & argument_4
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()&& argument_4.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListAST::
operator_concat (const GGS_overridingMultiReaderListAST & inOperand) const {
  GGS_overridingMultiReaderListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
dotAssign_operation (const GGS_overridingMultiReaderListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_overridingMultiReaderListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mOverridingCategoryReaderName ;
          GGS_formalInputParameterListAST  p_1 = p->mOverridingReaderFormalInputParameterList ;
          GGS_lstring  p_2 = p->mReturnedTypeName ;
          GGS_lstring  p_3 = p->mReturnedVariableName ;
          GGS_semanticInstructionListAST  p_4 = p->mRoutineInstructionList ;
          internalAppendValues (p_0, p_1, p_2, p_3, p_4 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalInputParameterListAST & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3,
                     const GGS_semanticInstructionListAST & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mOverridingCategoryReaderName,
                                ptr->mOverridingReaderFormalInputParameterList,
                                ptr->mReturnedTypeName,
                                ptr->mReturnedVariableName,
                                ptr->mRoutineInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST  GGS_overridingMultiReaderListAST::
constructor_emptyList (void) {
  GGS_overridingMultiReaderListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST  GGS_overridingMultiReaderListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalInputParameterListAST & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3,
                                const GGS_semanticInstructionListAST & argument_4) {
  GGS_overridingMultiReaderListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
internalSubListWithRange (GGS_overridingMultiReaderListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mOverridingCategoryReaderName, ptr->mOverridingReaderFormalInputParameterList, ptr->mReturnedTypeName, ptr->mReturnedVariableName, ptr->mRoutineInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridingMultiReaderListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@overridingMultiReaderListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalInputParameterListAST & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3,
              GGS_semanticInstructionListAST & _out_4
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalInputParameterListAST & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3,
             GGS_semanticInstructionListAST & _out_4
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalInputParameterListAST & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3,
                 GGS_semanticInstructionListAST & _out_4
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalInputParameterListAST & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3,
                GGS_semanticInstructionListAST & _out_4
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mOverridingCategoryReaderName ;
    _out_1 = ptr->mOverridingReaderFormalInputParameterList ;
    _out_2 = ptr->mReturnedTypeName ;
    _out_3 = ptr->mReturnedVariableName ;
    _out_4 = ptr->mRoutineInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
    _out_4.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListAST::
reader_mOverridingCategoryReaderNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingCategoryReaderName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_overridingMultiReaderListAST::
reader_mOverridingReaderFormalInputParameterListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mOverridingReaderFormalInputParameterList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListAST::
reader_mReturnedTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridingMultiReaderListAST::
reader_mReturnedVariableNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mReturnedVariableName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_overridingMultiReaderListAST::
reader_mRoutineInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mRoutineInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMOverridingCategoryReaderNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingCategoryReaderName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMOverridingReaderFormalInputParameterListAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mOverridingReaderFormalInputParameterList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMReturnedTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMReturnedVariableNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mReturnedVariableName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListAST::
modifier_setMRoutineInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mRoutineInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListAST::cEnumerator::_mOverridingCategoryReaderName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingCategoryReaderName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_overridingMultiReaderListAST::cEnumerator::_mOverridingReaderFormalInputParameterList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mOverridingReaderFormalInputParameterList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListAST::cEnumerator::_mReturnedTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridingMultiReaderListAST::cEnumerator::_mReturnedVariableName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mReturnedVariableName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_overridingMultiReaderListAST::cEnumerator::_mRoutineInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mRoutineInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiReaderListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiReaderListAST * p = NULL ;
    macroMyNew (p, GGS_overridingMultiReaderListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiReaderListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiReaderListAST * p = dynamic_cast <const GGS_overridingMultiReaderListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiReaderListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiReaderListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiReaderListAST ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridingMultiReaderListMapAST ("overridingMultiReaderListMapAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST::cElement::cElement (LOCATION_ARGS) :
cPtrListMapObject (THERE),
mListObject (GGS_overridingMultiReaderListAST::constructor_emptyList ()) {
}

//---------------------------------------------------------------------------*

cPtrObject * GGS_overridingMultiReaderListMapAST::cElement::cloneObject (LOCATION_ARGS) {
  cElement * result = NULL ;
  macroMyNew (result, cElement (THERE)) ;
  result->mListObject = mListObject ;
  return result ;
}

//---------------------------------------------------------------------------*

bool GGS_overridingMultiReaderListMapAST::cElement::isEqual (const cPtrListMapObject * inOperand) const {
  const GGS_bool equal = mListObject.operator_isEqual (((cElement *) inOperand)->mListObject) ;
  return equal.boolValue () ;
}

//---------------------------------------------------------------------------*

C_String GGS_overridingMultiReaderListMapAST::cElement::
performDescription (const PMSInt32 inIndentation) const {
  const GGS_string s = mListObject.reader_description (inIndentation) ;
  return s.string () ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST GGS_overridingMultiReaderListMapAST::
constructor_emptyMap (void) {
  GGS_overridingMultiReaderListMapAST result ;
  result.alloc (HERE) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_overridingMultiReaderListMapAST::
_typeNameForDescriptionReader (void) const {
  return "@overridingMultiReaderListMapAST" ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST GGS_overridingMultiReaderListMapAST::
operator_concat (const GGS_overridingMultiReaderListMapAST & inOperand) const {
  GGS_overridingMultiReaderListMapAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListMapAST::
dotAssign_operation (const GGS_overridingMultiReaderListMapAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count (HERE) == 0) {
      * this = inOperand ;
    }else if (inOperand.count (HERE) > 0) {
      cPtrDictionary * dictPtr = macroPtr (inOperand, cPtrDictionary)  ;
      cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
      const PMSInt32 objectCount = dictPtr->count () ;
      for (PMSInt32 i=0 ; i<objectCount ; i++) {
        const GGS_string key = nodeSortedArray [i].key () ;
        const PM_C_Object object = nodeSortedArray [i].mObject ;
        cElement * elementPtr = macroPtr (object, cElement) ;
        bool wasInserted = false ;
        cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (key, wasInserted) ;
        if (wasInserted) {
           cElement * p = NULL ;
           macroMyNew (p, cElement (HERE)) ;
           nodePtr->mObject.setPointer (p) ;
        }
        GGS_overridingMultiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
        listPtr.dotAssign_operation (elementPtr->mListObject) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridingMultiReaderListMapAST::
addAssign_operation (const GGS_string & inKey,
                      const GGS_lstring & inAttribute0,
                      const GGS_formalInputParameterListAST & inAttribute1,
                      const GGS_lstring & inAttribute2,
                      const GGS_lstring & inAttribute3,
                      const GGS_semanticInstructionListAST & inAttribute4) {
  if (isBuilt () && inKey.isBuilt () && inAttribute0.isBuilt () && inAttribute1.isBuilt () && inAttribute2.isBuilt () && inAttribute3.isBuilt () && inAttribute4.isBuilt ()) {
    bool wasInserted = false ;
    cPtrDictionaryNode * nodePtr = findOrAddNodeForKey (inKey, wasInserted) ;
    MF_Assert (nodePtr != NULL, "NULL pointer (was inserted %d)", wasInserted, 0) ;
    if (wasInserted) {
       cElement * p = NULL ;
       macroMyNew (p, cElement (HERE)) ;
       nodePtr->mObject.setPointer (p) ;
    }
    GGS_overridingMultiReaderListAST & listPtr = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    listPtr.addAssign_operation (inAttribute0, inAttribute1, inAttribute2, inAttribute3, inAttribute4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListAST GGS_overridingMultiReaderListMapAST::
reader_listForKey (C_Compiler & /* inLexique */,
                   const GGS_string & inKey
                   COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridingMultiReaderListAST result ;
  if (isBuilt () && inKey.isBuilt ()) {
    cPtrDictionaryNode * nodePtr = dictionaryNodeForKey (inKey.string ()) ; 
    if (nodePtr == NULL) {
      result = GGS_overridingMultiReaderListAST::constructor_emptyList () ;
    }else{
      result = macroPtr (nodePtr->mObject, cElement)->mListObject ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringset GGS_overridingMultiReaderListMapAST::
reader_allKeys (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringset result ;
  result.setPointer (_pointer ()) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist GGS_overridingMultiReaderListMapAST::
reader_keyList (C_Compiler & /* inLexique */
                COMMA_UNUSED_LOCATION_ARGS) const {

  GGS_stringlist result ;
  if (isBuilt ()) {
    result = GGS_stringlist::constructor_emptyList () ;
    cPtrDictionary * dictPtr = macroPtr (*this, cPtrDictionary)  ;
    cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
    const PMSInt32 objectCount = dictPtr->count () ;
    for (PMSInt32 i=0 ; i<objectCount ; i++) {
      const GGS_string key = nodeSortedArray [i].key () ;
      result.addAssign_operation (key) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST::cEnumerator::
cEnumerator (const GGS_overridingMultiReaderListMapAST & inListMap,
             const bool inAscending) :
cAbstractDictionaryEnumerator (inListMap, inAscending) {
}

//---------------------------------------------------------------------------*

const GGS_overridingMultiReaderListAST & GGS_overridingMultiReaderListMapAST::cEnumerator::
_object (LOCATION_ARGS) const {
  cPtrDictionary * dictPtr = macroPtr (mEnumeratedDictionary, cPtrDictionary)  ;
  MF_AssertThere (currentIndex () >= 0, "Access with negative index %d", currentIndex (), 0) ;
  MF_AssertThere (currentIndex () < dictPtr->count (), "Access with index %d >= count %d", currentIndex (), dictPtr->count ()) ;
  cPtrDictionaryNode * nodeSortedArray = dictPtr->nodeSortedArray () ;
  PM_C_Object listObject = nodeSortedArray [currentIndex ()].mObject ;
  cElement * objectPtr = macroPtr (listObject, cElement) ;
  return objectPtr->mListObject ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridingMultiReaderListMapAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridingMultiReaderListMapAST * p = NULL ;
    macroMyNew (p, GGS_overridingMultiReaderListMapAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridingMultiReaderListMapAST GGS_overridingMultiReaderListMapAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridingMultiReaderListMapAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridingMultiReaderListMapAST * p = dynamic_cast <const GGS_overridingMultiReaderListMapAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridingMultiReaderListMapAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridingMultiReaderListMapAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridingMultiReaderListMapAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of 'semanticDeclarationStructAST' struct           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticDeclarationStructAST ("semanticDeclarationStructAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST::GGS_semanticDeclarationStructAST (void) :
mSemanticDeclarationList (),
mAbstractCategoryMethodListMap (),
mCategoryMethodListMap (),
mOverridingCategoryMethodListMap (),
mAbstractCategoryReaderListMap (),
mCategoryReaderListMap (),
mOverridingCategoryReaderListMap () {
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST::~GGS_semanticDeclarationStructAST (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticDeclarationStructAST::drop (void) {
  mSemanticDeclarationList.drop () ;
  mAbstractCategoryMethodListMap.drop () ;
  mCategoryMethodListMap.drop () ;
  mOverridingCategoryMethodListMap.drop () ;
  mAbstractCategoryReaderListMap.drop () ;
  mCategoryReaderListMap.drop () ;
  mOverridingCategoryReaderListMap.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticDeclarationStructAST::isBuilt (void) const {
  return mSemanticDeclarationList.isBuilt ()
    && mAbstractCategoryMethodListMap.isBuilt ()
    && mCategoryMethodListMap.isBuilt ()
    && mOverridingCategoryMethodListMap.isBuilt ()
    && mAbstractCategoryReaderListMap.isBuilt ()
    && mCategoryReaderListMap.isBuilt ()
    && mOverridingCategoryReaderListMap.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStructAST::
operator_isEqual (const GGS_semanticDeclarationStructAST & inOperand) const {
  return mSemanticDeclarationList.operator_isEqual (inOperand.mSemanticDeclarationList)
    .operator_and (mAbstractCategoryMethodListMap.operator_isEqual (inOperand.mAbstractCategoryMethodListMap))
    .operator_and (mCategoryMethodListMap.operator_isEqual (inOperand.mCategoryMethodListMap))
    .operator_and (mOverridingCategoryMethodListMap.operator_isEqual (inOperand.mOverridingCategoryMethodListMap))
    .operator_and (mAbstractCategoryReaderListMap.operator_isEqual (inOperand.mAbstractCategoryReaderListMap))
    .operator_and (mCategoryReaderListMap.operator_isEqual (inOperand.mCategoryReaderListMap))
    .operator_and (mOverridingCategoryReaderListMap.operator_isEqual (inOperand.mOverridingCategoryReaderListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticDeclarationStructAST::
operator_isNotEqual (const GGS_semanticDeclarationStructAST & inOperand) const {
  return mSemanticDeclarationList.operator_isNotEqual (inOperand.mSemanticDeclarationList)
    .operator_or (mAbstractCategoryMethodListMap.operator_isNotEqual (inOperand.mAbstractCategoryMethodListMap))
    .operator_or (mCategoryMethodListMap.operator_isNotEqual (inOperand.mCategoryMethodListMap))
    .operator_or (mOverridingCategoryMethodListMap.operator_isNotEqual (inOperand.mOverridingCategoryMethodListMap))
    .operator_or (mAbstractCategoryReaderListMap.operator_isNotEqual (inOperand.mAbstractCategoryReaderListMap))
    .operator_or (mCategoryReaderListMap.operator_isNotEqual (inOperand.mCategoryReaderListMap))
    .operator_or (mOverridingCategoryReaderListMap.operator_isNotEqual (inOperand.mOverridingCategoryReaderListMap)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST GGS_semanticDeclarationStructAST::
constructor_new (const GGS_semanticDeclarationListAST & argument_0,
                 const GGS_abstractMultiMethodListMapAST& argument_1,
                 const GGS_multiMethodListMapAST& argument_2,
                 const GGS_overridingMultiMethodListMapAST& argument_3,
                 const GGS_abstractMultiReaderListMapAST& argument_4,
                 const GGS_multiReaderListMapAST& argument_5,
                 const GGS_overridingMultiReaderListMapAST& argument_6) {
  GGS_semanticDeclarationStructAST result ;
  result.mSemanticDeclarationList = argument_0 ;
  result.mAbstractCategoryMethodListMap = argument_1 ;
  result.mCategoryMethodListMap = argument_2 ;
  result.mOverridingCategoryMethodListMap = argument_3 ;
  result.mAbstractCategoryReaderListMap = argument_4 ;
  result.mCategoryReaderListMap = argument_5 ;
  result.mOverridingCategoryReaderListMap = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticDeclarationStructAST::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticDeclarationStructAST" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mSemanticDeclarationList " ;
    _s << mSemanticDeclarationList.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryMethodListMap " ;
    _s << mAbstractCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryMethodListMap " ;
    _s << mCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryMethodListMap " ;
    _s << mOverridingCategoryMethodListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mAbstractCategoryReaderListMap " ;
    _s << mAbstractCategoryReaderListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mCategoryReaderListMap " ;
    _s << mCategoryReaderListMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOverridingCategoryReaderListMap " ;
    _s << mOverridingCategoryReaderListMap.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticDeclarationStructAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticDeclarationStructAST * p = NULL ;
    macroMyNew (p, GGS_semanticDeclarationStructAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST GGS_semanticDeclarationStructAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticDeclarationStructAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticDeclarationStructAST * p = dynamic_cast <const GGS_semanticDeclarationStructAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticDeclarationStructAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticDeclarationStructAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticDeclarationStructAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@attributeInCollectionListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_attributeInCollectionListAST::
elementOf_GGS_attributeInCollectionListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_attributeInCollectionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_attributeInCollectionListAST * ptr = dynamic_cast <const elementOf_GGS_attributeInCollectionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mAttributeTypeName.operator_isEqual (ptr->mAttributeTypeName).boolValue ()
         && mAttributeName.operator_isEqual (ptr->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_attributeInCollectionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@attributeInCollectionListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_attributeInCollectionListAST ("attributeInCollectionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST GGS_attributeInCollectionListAST::
operator_concat (const GGS_attributeInCollectionListAST & inOperand) const {
  GGS_attributeInCollectionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
dotAssign_operation (const GGS_attributeInCollectionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_attributeInCollectionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mAttributeTypeName,
                                ptr->mAttributeName
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_attributeInCollectionListAST::
constructor_emptyList (void) {
  GGS_attributeInCollectionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_attributeInCollectionListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_attributeInCollectionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
internalSubListWithRange (GGS_attributeInCollectionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mAttributeTypeName, ptr->mAttributeName) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST GGS_attributeInCollectionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST GGS_attributeInCollectionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_attributeInCollectionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@attributeInCollectionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mAttributeTypeName ;
    _out_1 = ptr->mAttributeName ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollectionListAST::
reader_mAttributeTypeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeTypeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_attributeInCollectionListAST::
reader_mAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_setMAttributeTypeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeTypeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_attributeInCollectionListAST::
modifier_setMAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_attributeInCollectionListAST::cEnumerator::_mAttributeTypeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_attributeInCollectionListAST::cEnumerator::_mAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAttributeName ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_attributeInCollectionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_attributeInCollectionListAST * p = NULL ;
    macroMyNew (p, GGS_attributeInCollectionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST GGS_attributeInCollectionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_attributeInCollectionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_attributeInCollectionListAST * p = dynamic_cast <const GGS_attributeInCollectionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_attributeInCollectionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_attributeInCollectionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_attributeInCollectionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_listmapDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listmapDeclarationAST::
cPtr_listmapDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mListmapTypeName (argument_0),
mAssociatedListTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listmapDeclarationAST * GGS_listmapDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listmapDeclarationAST) ;
    return (cPtr_listmapDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listmapDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listmapDeclarationAST * ptr = dynamic_cast <const cPtr_listmapDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListmapTypeName.operator_isEqual (ptr->mListmapTypeName).boolValue ()
         && mAssociatedListTypeName.operator_isEqual (ptr->mAssociatedListTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listmapDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listmapDeclarationAST:"
           << mListmapTypeName.reader_description (inIndentation + 1)
           << mAssociatedListTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listmapDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listmapDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listmapDeclarationAST (& typeid (cPtr_listmapDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listmapDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__listmapDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listmapDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listmapDeclarationAST (mListmapTypeName, mAssociatedListTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_listmapDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listmapDeclarationAST ("listmapDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_listmapDeclarationAST::
GGS_listmapDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationAST::
GGS_listmapDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listmapDeclarationAST GGS_listmapDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listmapDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_listmapDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listmapDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listmapDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationAST GGS_listmapDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_listmapDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listmapDeclarationAST::
reader_mListmapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapDeclarationAST *) mPointer)->mListmapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listmapDeclarationAST::
reader_mAssociatedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listmapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listmapDeclarationAST *) mPointer)->mAssociatedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listmapDeclarationAST::actualTypeName (void) const {
  return "listmapDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listmapDeclarationAST ("listmapDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_listmapDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listmapDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listmapDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_listmapDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listmapDeclarationAST GGS_listmapDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listmapDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listmapDeclarationAST * p = dynamic_cast <const GGS_listmapDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listmapDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listmapDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listmapDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Element of list '@mapMethodListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_mapMethodListAST::
elementOf_GGS_mapMethodListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMethodName (argument_0),
mAlternateMethodName (argument_1),
mErrorMessage (argument_2),
mShadowErrorMessage (argument_3) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_mapMethodListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_mapMethodListAST * ptr = dynamic_cast <const elementOf_GGS_mapMethodListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mAlternateMethodName.operator_isEqual (ptr->mAlternateMethodName).boolValue ()
         && mErrorMessage.operator_isEqual (ptr->mErrorMessage).boolValue ()
         && mShadowErrorMessage.operator_isEqual (ptr->mShadowErrorMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_mapMethodListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAlternateMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessage.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mShadowErrorMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         List '@mapMethodListAST'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapMethodListAST ("mapMethodListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstring & argument_3
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()&& argument_3.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST GGS_mapMethodListAST::
operator_concat (const GGS_mapMethodListAST & inOperand) const {
  GGS_mapMethodListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
dotAssign_operation (const GGS_mapMethodListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_mapMethodListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_lstring  p_1 = p->mAlternateMethodName ;
          GGS_lstring  p_2 = p->mErrorMessage ;
          GGS_lstring  p_3 = p->mShadowErrorMessage ;
          internalAppendValues (p_0, p_1, p_2, p_3 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstring & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mAlternateMethodName,
                                ptr->mErrorMessage,
                                ptr->mShadowErrorMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST  GGS_mapMethodListAST::
constructor_emptyList (void) {
  GGS_mapMethodListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST  GGS_mapMethodListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstring & argument_3) {
  GGS_mapMethodListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
internalSubListWithRange (GGS_mapMethodListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mAlternateMethodName, ptr->mErrorMessage, ptr->mShadowErrorMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST GGS_mapMethodListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_mapMethodListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST GGS_mapMethodListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_mapMethodListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_mapMethodListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@mapMethodListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_lstring & _out_2,
              GGS_lstring & _out_3
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mAlternateMethodName ;
    _out_2 = ptr->mErrorMessage ;
    _out_3 = ptr->mShadowErrorMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_lstring & _out_2,
             GGS_lstring & _out_3
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mAlternateMethodName ;
    _out_2 = ptr->mErrorMessage ;
    _out_3 = ptr->mShadowErrorMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstring & _out_3
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mAlternateMethodName ;
    _out_2 = ptr->mErrorMessage ;
    _out_3 = ptr->mShadowErrorMessage ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_lstring & _out_2,
                GGS_lstring & _out_3
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mAlternateMethodName ;
    _out_2 = ptr->mErrorMessage ;
    _out_3 = ptr->mShadowErrorMessage ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
    _out_3.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodListAST::
reader_mAlternateMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAlternateMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodListAST::
reader_mErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapMethodListAST::
reader_mShadowErrorMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mShadowErrorMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
modifier_setMAlternateMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAlternateMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
modifier_setMErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_mapMethodListAST::
modifier_setMShadowErrorMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mShadowErrorMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodListAST::cEnumerator::_mAlternateMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAlternateMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodListAST::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_mapMethodListAST::cEnumerator::_mShadowErrorMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mShadowErrorMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_mapMethodListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapMethodListAST * p = NULL ;
    macroMyNew (p, GGS_mapMethodListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST GGS_mapMethodListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapMethodListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapMethodListAST * p = dynamic_cast <const GGS_mapMethodListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapMethodListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapMethodListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapMethodListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'cPtr_mapDeclarationAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapDeclarationAST::
cPtr_mapDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_attributeInCollectionListAST & argument_3,
                                const GGS_mapMethodListAST & argument_4,
                                const GGS_mapMethodListAST & argument_5,
                                const GGS_mapMethodListAST & argument_6
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mMapTypeName (argument_0),
mAssociatedEnumTypeName (argument_1),
mAssociatedTerminaisonMethodName (argument_2),
mAttributeList (argument_3),
mInsertMethodList (argument_4),
mSearchMethodList (argument_5),
mRemoveMethodList (argument_6) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapDeclarationAST * GGS_mapDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapDeclarationAST) ;
    return (cPtr_mapDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapDeclarationAST * ptr = dynamic_cast <const cPtr_mapDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapTypeName.operator_isEqual (ptr->mMapTypeName).boolValue ()
         && mAssociatedEnumTypeName.operator_isEqual (ptr->mAssociatedEnumTypeName).boolValue ()
         && mAssociatedTerminaisonMethodName.operator_isEqual (ptr->mAssociatedTerminaisonMethodName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mInsertMethodList.operator_isEqual (ptr->mInsertMethodList).boolValue ()
         && mSearchMethodList.operator_isEqual (ptr->mSearchMethodList).boolValue ()
         && mRemoveMethodList.operator_isEqual (ptr->mRemoveMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapDeclarationAST:"
           << mMapTypeName.reader_description (inIndentation + 1)
           << mAssociatedEnumTypeName.reader_description (inIndentation + 1)
           << mAssociatedTerminaisonMethodName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mInsertMethodList.reader_description (inIndentation + 1)
           << mSearchMethodList.reader_description (inIndentation + 1)
           << mRemoveMethodList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapDeclarationAST (& typeid (cPtr_mapDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__mapDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapDeclarationAST (mMapTypeName, mAssociatedEnumTypeName, mAssociatedTerminaisonMethodName, mAttributeList, mInsertMethodList, mSearchMethodList, mRemoveMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   GALGAS class 'GGS_mapDeclarationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapDeclarationAST ("mapDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_mapDeclarationAST::
GGS_mapDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationAST::
GGS_mapDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapDeclarationAST GGS_mapDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_mapDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationAST GGS_mapDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_attributeInCollectionListAST & argument_3,
                 const GGS_mapMethodListAST & argument_4,
                 const GGS_mapMethodListAST & argument_5,
                 const GGS_mapMethodListAST & argument_6
                                COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_mapDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclarationAST::
reader_mMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclarationAST::
reader_mAssociatedEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mAssociatedEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapDeclarationAST::
reader_mAssociatedTerminaisonMethodName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mAssociatedTerminaisonMethodName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_mapDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST  GGS_mapDeclarationAST::
reader_mInsertMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mInsertMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST  GGS_mapDeclarationAST::
reader_mSearchMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mSearchMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapMethodListAST  GGS_mapDeclarationAST::
reader_mRemoveMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_mapMethodListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapDeclarationAST *) mPointer)->mRemoveMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapDeclarationAST::actualTypeName (void) const {
  return "mapDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapDeclarationAST ("mapDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_mapDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_mapDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapDeclarationAST GGS_mapDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapDeclarationAST * p = dynamic_cast <const GGS_mapDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_mapindexDeclarationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_mapindexDeclarationAST::
cPtr_mapindexDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mMapIndexTypeName (argument_0),
mAssociatedMapTypeName (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_mapindexDeclarationAST * GGS_mapindexDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_mapindexDeclarationAST) ;
    return (cPtr_mapindexDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_mapindexDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_mapindexDeclarationAST * ptr = dynamic_cast <const cPtr_mapindexDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMapIndexTypeName.operator_isEqual (ptr->mMapIndexTypeName).boolValue ()
         && mAssociatedMapTypeName.operator_isEqual (ptr->mAssociatedMapTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_mapindexDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@mapindexDeclarationAST:"
           << mMapIndexTypeName.reader_description (inIndentation + 1)
           << mAssociatedMapTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_mapindexDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_mapindexDeclarationAST (& typeid (cPtr_mapindexDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_mapindexDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__mapindexDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_mapindexDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_mapindexDeclarationAST (mMapIndexTypeName, mAssociatedMapTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_mapindexDeclarationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_mapindexDeclarationAST ("mapindexDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_mapindexDeclarationAST::
GGS_mapindexDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_mapindexDeclarationAST::
GGS_mapindexDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_mapindexDeclarationAST GGS_mapindexDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_mapindexDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_mapindexDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_mapindexDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_mapindexDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexDeclarationAST GGS_mapindexDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_mapindexDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclarationAST::
reader_mMapIndexTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclarationAST *) mPointer)->mMapIndexTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_mapindexDeclarationAST::
reader_mAssociatedMapTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_mapindexDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_mapindexDeclarationAST *) mPointer)->mAssociatedMapTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_mapindexDeclarationAST::actualTypeName (void) const {
  return "mapindexDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__mapindexDeclarationAST ("mapindexDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_mapindexDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_mapindexDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_mapindexDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_mapindexDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_mapindexDeclarationAST GGS_mapindexDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_mapindexDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_mapindexDeclarationAST * p = dynamic_cast <const GGS_mapindexDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_mapindexDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_mapindexDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_mapindexDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@abstractMethodDefinitionListAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_abstractMethodDefinitionListAST::
elementOf_GGS_abstractMethodDefinitionListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_abstractMethodDefinitionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_abstractMethodDefinitionListAST * ptr = dynamic_cast <const elementOf_GGS_abstractMethodDefinitionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_abstractMethodDefinitionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@abstractMethodDefinitionListAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_abstractMethodDefinitionListAST ("abstractMethodDefinitionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST GGS_abstractMethodDefinitionListAST::
operator_concat (const GGS_abstractMethodDefinitionListAST & inOperand) const {
  GGS_abstractMethodDefinitionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
dotAssign_operation (const GGS_abstractMethodDefinitionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_abstractMethodDefinitionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterListAST  p_1 = p->mSignature ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mSignature
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST  GGS_abstractMethodDefinitionListAST::
constructor_emptyList (void) {
  GGS_abstractMethodDefinitionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST  GGS_abstractMethodDefinitionListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1) {
  GGS_abstractMethodDefinitionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
internalSubListWithRange (GGS_abstractMethodDefinitionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mSignature) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST GGS_abstractMethodDefinitionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST GGS_abstractMethodDefinitionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_abstractMethodDefinitionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@abstractMethodDefinitionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_abstractMethodDefinitionListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_abstractMethodDefinitionListAST::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_abstractMethodDefinitionListAST::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_abstractMethodDefinitionListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_abstractMethodDefinitionListAST::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_abstractMethodDefinitionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_abstractMethodDefinitionListAST * p = NULL ;
    macroMyNew (p, GGS_abstractMethodDefinitionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST GGS_abstractMethodDefinitionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_abstractMethodDefinitionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_abstractMethodDefinitionListAST * p = dynamic_cast <const GGS_abstractMethodDefinitionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_abstractMethodDefinitionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_abstractMethodDefinitionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_abstractMethodDefinitionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Element of list '@overridenMethodDefinitionListAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_overridenMethodDefinitionListAST::
elementOf_GGS_overridenMethodDefinitionListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_overridenMethodDefinitionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_overridenMethodDefinitionListAST * ptr = dynamic_cast <const elementOf_GGS_overridenMethodDefinitionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_overridenMethodDefinitionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@overridenMethodDefinitionListAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_overridenMethodDefinitionListAST ("overridenMethodDefinitionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListAST GGS_overridenMethodDefinitionListAST::
operator_concat (const GGS_overridenMethodDefinitionListAST & inOperand) const {
  GGS_overridenMethodDefinitionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
dotAssign_operation (const GGS_overridenMethodDefinitionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_overridenMethodDefinitionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterListAST  p_1 = p->mSignature ;
          GGS_semanticInstructionListAST  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1,
                     const GGS_semanticInstructionListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mSignature,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListAST  GGS_overridenMethodDefinitionListAST::
constructor_emptyList (void) {
  GGS_overridenMethodDefinitionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListAST  GGS_overridenMethodDefinitionListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  GGS_overridenMethodDefinitionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
internalSubListWithRange (GGS_overridenMethodDefinitionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mSignature, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListAST GGS_overridenMethodDefinitionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListAST GGS_overridenMethodDefinitionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_overridenMethodDefinitionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@overridenMethodDefinitionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1,
              GGS_semanticInstructionListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1,
             GGS_semanticInstructionListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1,
                 GGS_semanticInstructionListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1,
                GGS_semanticInstructionListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_overridenMethodDefinitionListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_overridenMethodDefinitionListAST::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_overridenMethodDefinitionListAST::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_overridenMethodDefinitionListAST::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_overridenMethodDefinitionListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_overridenMethodDefinitionListAST::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_overridenMethodDefinitionListAST::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_overridenMethodDefinitionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_overridenMethodDefinitionListAST * p = NULL ;
    macroMyNew (p, GGS_overridenMethodDefinitionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListAST GGS_overridenMethodDefinitionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_overridenMethodDefinitionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_overridenMethodDefinitionListAST * p = dynamic_cast <const GGS_overridenMethodDefinitionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_overridenMethodDefinitionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_overridenMethodDefinitionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_overridenMethodDefinitionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@methodDefinitionListAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_methodDefinitionListAST::
elementOf_GGS_methodDefinitionListAST (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mMethodName (argument_0),
mSignature (argument_1),
mInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_methodDefinitionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_methodDefinitionListAST * ptr = dynamic_cast <const elementOf_GGS_methodDefinitionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mMethodName.operator_isEqual (ptr->mMethodName).boolValue ()
         && mSignature.operator_isEqual (ptr->mSignature).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_methodDefinitionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMethodName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSignature.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@methodDefinitionListAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_methodDefinitionListAST ("methodDefinitionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_formalParameterListAST & argument_1,
                    const GGS_semanticInstructionListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST GGS_methodDefinitionListAST::
operator_concat (const GGS_methodDefinitionListAST & inOperand) const {
  GGS_methodDefinitionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
dotAssign_operation (const GGS_methodDefinitionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_methodDefinitionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMethodName ;
          GGS_formalParameterListAST  p_1 = p->mSignature ;
          GGS_semanticInstructionListAST  p_2 = p->mInstructionList ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_formalParameterListAST & argument_1,
                     const GGS_semanticInstructionListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mMethodName,
                                ptr->mSignature,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST  GGS_methodDefinitionListAST::
constructor_emptyList (void) {
  GGS_methodDefinitionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST  GGS_methodDefinitionListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_formalParameterListAST & argument_1,
                                const GGS_semanticInstructionListAST & argument_2) {
  GGS_methodDefinitionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
internalSubListWithRange (GGS_methodDefinitionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mMethodName, ptr->mSignature, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST GGS_methodDefinitionListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST GGS_methodDefinitionListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_methodDefinitionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_methodDefinitionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@methodDefinitionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_formalParameterListAST & _out_1,
              GGS_semanticInstructionListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_formalParameterListAST & _out_1,
             GGS_semanticInstructionListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_formalParameterListAST & _out_1,
                 GGS_semanticInstructionListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_formalParameterListAST & _out_1,
                GGS_semanticInstructionListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mMethodName ;
    _out_1 = ptr->mSignature ;
    _out_2 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_methodDefinitionListAST::
reader_mMethodNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMethodName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalParameterListAST  GGS_methodDefinitionListAST::
reader_mSignatureAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSignature ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticInstructionListAST  GGS_methodDefinitionListAST::
reader_mInstructionListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_semanticInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_setMMethodNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMethodName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_setMSignatureAtIndex (C_Compiler & inLexique,
                              const GGS_formalParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSignature = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_methodDefinitionListAST::
modifier_setMInstructionListAtIndex (C_Compiler & inLexique,
                              const GGS_semanticInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_methodDefinitionListAST::cEnumerator::_mMethodName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMethodName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_methodDefinitionListAST::cEnumerator::_mSignature (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticInstructionListAST  & GGS_methodDefinitionListAST::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_methodDefinitionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_methodDefinitionListAST * p = NULL ;
    macroMyNew (p, GGS_methodDefinitionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST GGS_methodDefinitionListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_methodDefinitionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_methodDefinitionListAST * p = dynamic_cast <const GGS_methodDefinitionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_methodDefinitionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_methodDefinitionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_methodDefinitionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_classDeclarationAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_classDeclarationAST::
cPtr_classDeclarationAST (const GGS_bool& argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_attributeInCollectionListAST & argument_4,
                                const GGS_abstractMethodDefinitionListAST & argument_5,
                                const GGS_overridenMethodDefinitionListAST & argument_6,
                                const GGS_methodDefinitionListAST & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mIsAbstract (argument_0),
mClassTypeName (argument_1),
mSuperClassName (argument_2),
mClassFeatureList (argument_3),
mAttributeList (argument_4),
mAbstractMethodList (argument_5),
mOverridenMethodList (argument_6),
mMethodList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_classDeclarationAST * GGS_classDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_classDeclarationAST) ;
    return (cPtr_classDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_classDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_classDeclarationAST * ptr = dynamic_cast <const cPtr_classDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAbstract.operator_isEqual (ptr->mIsAbstract).boolValue ()
         && mClassTypeName.operator_isEqual (ptr->mClassTypeName).boolValue ()
         && mSuperClassName.operator_isEqual (ptr->mSuperClassName).boolValue ()
         && mClassFeatureList.operator_isEqual (ptr->mClassFeatureList).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mAbstractMethodList.operator_isEqual (ptr->mAbstractMethodList).boolValue ()
         && mOverridenMethodList.operator_isEqual (ptr->mOverridenMethodList).boolValue ()
         && mMethodList.operator_isEqual (ptr->mMethodList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_classDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@classDeclarationAST:"
           << mIsAbstract.reader_description (inIndentation + 1)
           << mClassTypeName.reader_description (inIndentation + 1)
           << mSuperClassName.reader_description (inIndentation + 1)
           << mClassFeatureList.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mAbstractMethodList.reader_description (inIndentation + 1)
           << mOverridenMethodList.reader_description (inIndentation + 1)
           << mMethodList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_classDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_classDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_classDeclarationAST (& typeid (cPtr_classDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_classDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__classDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_classDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_classDeclarationAST (mIsAbstract, mClassTypeName, mSuperClassName, mClassFeatureList, mAttributeList, mAbstractMethodList, mOverridenMethodList, mMethodList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_classDeclarationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_classDeclarationAST ("classDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_classDeclarationAST::
GGS_classDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationAST::
GGS_classDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_classDeclarationAST GGS_classDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_classDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_classDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_classDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_classDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_classDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationAST GGS_classDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_attributeInCollectionListAST & argument_4,
                 const GGS_abstractMethodDefinitionListAST & argument_5,
                 const GGS_overridenMethodDefinitionListAST & argument_6,
                 const GGS_methodDefinitionListAST & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_classDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_classDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_classDeclarationAST::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclarationAST::
reader_mClassTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mClassTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_classDeclarationAST::
reader_mSuperClassName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mSuperClassName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_classDeclarationAST::
reader_mClassFeatureList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mClassFeatureList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_classDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_abstractMethodDefinitionListAST  GGS_classDeclarationAST::
reader_mAbstractMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_abstractMethodDefinitionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mAbstractMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_overridenMethodDefinitionListAST  GGS_classDeclarationAST::
reader_mOverridenMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_overridenMethodDefinitionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mOverridenMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_methodDefinitionListAST  GGS_classDeclarationAST::
reader_mMethodList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_methodDefinitionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_classDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_classDeclarationAST *) mPointer)->mMethodList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_classDeclarationAST::actualTypeName (void) const {
  return "classDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__classDeclarationAST ("classDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_classDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_classDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_classDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_classDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_classDeclarationAST GGS_classDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_classDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_classDeclarationAST * p = dynamic_cast <const GGS_classDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_classDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_classDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_classDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_listDeclarationAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_listDeclarationAST::
cPtr_listDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mListTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_listDeclarationAST * GGS_listDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_listDeclarationAST) ;
    return (cPtr_listDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_listDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_listDeclarationAST * ptr = dynamic_cast <const cPtr_listDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mListTypeName.operator_isEqual (ptr->mListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_listDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@listDeclarationAST:"
           << mListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_listDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_listDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_listDeclarationAST (& typeid (cPtr_listDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_listDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__listDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_listDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_listDeclarationAST (mListTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_listDeclarationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_listDeclarationAST ("listDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_listDeclarationAST::
GGS_listDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationAST::
GGS_listDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_listDeclarationAST GGS_listDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_listDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_listDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_listDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_listDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_listDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationAST GGS_listDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_listDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_listDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_listDeclarationAST::
reader_mListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclarationAST *) mPointer)->mListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_listDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_listDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_listDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_listDeclarationAST::actualTypeName (void) const {
  return "listDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__listDeclarationAST ("listDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_listDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_listDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_listDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_listDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_listDeclarationAST GGS_listDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_listDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_listDeclarationAST * p = dynamic_cast <const GGS_listDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_listDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_listDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_listDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_structDeclarationAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_structDeclarationAST::
cPtr_structDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mStructTypeName (argument_0),
mAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_structDeclarationAST * GGS_structDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_structDeclarationAST) ;
    return (cPtr_structDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_structDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_structDeclarationAST * ptr = dynamic_cast <const cPtr_structDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStructTypeName.operator_isEqual (ptr->mStructTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_structDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@structDeclarationAST:"
           << mStructTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_structDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_structDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_structDeclarationAST (& typeid (cPtr_structDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_structDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__structDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_structDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_structDeclarationAST (mStructTypeName, mAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_structDeclarationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_structDeclarationAST ("structDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_structDeclarationAST::
GGS_structDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationAST::
GGS_structDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_structDeclarationAST GGS_structDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_structDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_structDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_structDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_structDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_structDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationAST GGS_structDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_structDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_structDeclarationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_structDeclarationAST::
reader_mStructTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclarationAST *) mPointer)->mStructTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_structDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_structDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_structDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_structDeclarationAST::actualTypeName (void) const {
  return "structDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__structDeclarationAST ("structDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_structDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_structDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_structDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_structDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_structDeclarationAST GGS_structDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_structDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_structDeclarationAST * p = dynamic_cast <const GGS_structDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_structDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_structDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_structDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@sortedListSortDescriptorListAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_sortedListSortDescriptorListAST::
elementOf_GGS_sortedListSortDescriptorListAST (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mSortedAttributeName (argument_0),
mAscending (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_sortedListSortDescriptorListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_sortedListSortDescriptorListAST * ptr = dynamic_cast <const elementOf_GGS_sortedListSortDescriptorListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSortedAttributeName.operator_isEqual (ptr->mSortedAttributeName).boolValue ()
         && mAscending.operator_isEqual (ptr->mAscending).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_sortedListSortDescriptorListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSortedAttributeName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAscending.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 List '@sortedListSortDescriptorListAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedListSortDescriptorListAST ("sortedListSortDescriptorListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_bool& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST GGS_sortedListSortDescriptorListAST::
operator_concat (const GGS_sortedListSortDescriptorListAST & inOperand) const {
  GGS_sortedListSortDescriptorListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
dotAssign_operation (const GGS_sortedListSortDescriptorListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_sortedListSortDescriptorListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mSortedAttributeName ;
          GGS_bool p_1 = p->mAscending ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_bool& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mSortedAttributeName,
                                ptr->mAscending
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST  GGS_sortedListSortDescriptorListAST::
constructor_emptyList (void) {
  GGS_sortedListSortDescriptorListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST  GGS_sortedListSortDescriptorListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_bool& argument_1) {
  GGS_sortedListSortDescriptorListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
internalSubListWithRange (GGS_sortedListSortDescriptorListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mSortedAttributeName, ptr->mAscending) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST GGS_sortedListSortDescriptorListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST GGS_sortedListSortDescriptorListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_sortedListSortDescriptorListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@sortedListSortDescriptorListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_bool& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_bool& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_bool& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_bool& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mSortedAttributeName ;
    _out_1 = ptr->mAscending ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListSortDescriptorListAST::
reader_mSortedAttributeNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mSortedAttributeName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_sortedListSortDescriptorListAST::
reader_mAscendingAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_bool result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mAscending ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_setMSortedAttributeNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mSortedAttributeName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_sortedListSortDescriptorListAST::
modifier_setMAscendingAtIndex (C_Compiler & inLexique,
                              const GGS_bool & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mAscending = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_sortedListSortDescriptorListAST::cEnumerator::_mSortedAttributeName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSortedAttributeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_sortedListSortDescriptorListAST::cEnumerator::_mAscending (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mAscending ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_sortedListSortDescriptorListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedListSortDescriptorListAST * p = NULL ;
    macroMyNew (p, GGS_sortedListSortDescriptorListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST GGS_sortedListSortDescriptorListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedListSortDescriptorListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedListSortDescriptorListAST * p = dynamic_cast <const GGS_sortedListSortDescriptorListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedListSortDescriptorListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedListSortDescriptorListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedListSortDescriptorListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_sortedListDeclarationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_sortedListDeclarationAST::
cPtr_sortedListDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_attributeInCollectionListAST & argument_1,
                                const GGS_sortedListSortDescriptorListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mSortedListTypeName (argument_0),
mAttributeList (argument_1),
mSortDescriptorList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_sortedListDeclarationAST * GGS_sortedListDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_sortedListDeclarationAST) ;
    return (cPtr_sortedListDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_sortedListDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_sortedListDeclarationAST * ptr = dynamic_cast <const cPtr_sortedListDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSortedListTypeName.operator_isEqual (ptr->mSortedListTypeName).boolValue ()
         && mAttributeList.operator_isEqual (ptr->mAttributeList).boolValue ()
         && mSortDescriptorList.operator_isEqual (ptr->mSortDescriptorList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_sortedListDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@sortedListDeclarationAST:"
           << mSortedListTypeName.reader_description (inIndentation + 1)
           << mAttributeList.reader_description (inIndentation + 1)
           << mSortDescriptorList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_sortedListDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_sortedListDeclarationAST (& typeid (cPtr_sortedListDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_sortedListDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__sortedListDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_sortedListDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_sortedListDeclarationAST (mSortedListTypeName, mAttributeList, mSortDescriptorList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_sortedListDeclarationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_sortedListDeclarationAST ("sortedListDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationAST::
GGS_sortedListDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationAST::
GGS_sortedListDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_sortedListDeclarationAST GGS_sortedListDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_sortedListDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_sortedListDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_sortedListDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_sortedListDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationAST GGS_sortedListDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_attributeInCollectionListAST & argument_1,
                 const GGS_sortedListSortDescriptorListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_sortedListDeclarationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_sortedListDeclarationAST::
reader_mSortedListTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationAST *) mPointer)->mSortedListTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_attributeInCollectionListAST  GGS_sortedListDeclarationAST::
reader_mAttributeList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_attributeInCollectionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationAST *) mPointer)->mAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListSortDescriptorListAST  GGS_sortedListDeclarationAST::
reader_mSortDescriptorList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_sortedListSortDescriptorListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_sortedListDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_sortedListDeclarationAST *) mPointer)->mSortDescriptorList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_sortedListDeclarationAST::actualTypeName (void) const {
  return "sortedListDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__sortedListDeclarationAST ("sortedListDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_sortedListDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_sortedListDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_sortedListDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_sortedListDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_sortedListDeclarationAST GGS_sortedListDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_sortedListDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_sortedListDeclarationAST * p = dynamic_cast <const GGS_sortedListDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_sortedListDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_sortedListDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_sortedListDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@enumMessageAssociationListAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageAssociationListAST::
elementOf_GGS_enumMessageAssociationListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mConstantName (argument_0),
mMessage (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageAssociationListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageAssociationListAST * ptr = dynamic_cast <const elementOf_GGS_enumMessageAssociationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantName.operator_isEqual (ptr->mConstantName).boolValue ()
         && mMessage.operator_isEqual (ptr->mMessage).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageAssociationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessage.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@enumMessageAssociationListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageAssociationListAST ("enumMessageAssociationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST GGS_enumMessageAssociationListAST::
operator_concat (const GGS_enumMessageAssociationListAST & inOperand) const {
  GGS_enumMessageAssociationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
dotAssign_operation (const GGS_enumMessageAssociationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageAssociationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mConstantName ;
          GGS_lstring  p_1 = p->mMessage ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantName,
                                ptr->mMessage
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST  GGS_enumMessageAssociationListAST::
constructor_emptyList (void) {
  GGS_enumMessageAssociationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST  GGS_enumMessageAssociationListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_enumMessageAssociationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
internalSubListWithRange (GGS_enumMessageAssociationListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mConstantName, ptr->mMessage) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST GGS_enumMessageAssociationListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST GGS_enumMessageAssociationListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageAssociationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageAssociationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantName ;
    _out_1 = ptr->mMessage ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationListAST::
reader_mConstantNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageAssociationListAST::
reader_mMessageAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessage ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_setMConstantNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageAssociationListAST::
modifier_setMMessageAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessage = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageAssociationListAST::cEnumerator::_mConstantName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageAssociationListAST::cEnumerator::_mMessage (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageAssociationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageAssociationListAST * p = NULL ;
    macroMyNew (p, GGS_enumMessageAssociationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST GGS_enumMessageAssociationListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageAssociationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageAssociationListAST * p = dynamic_cast <const GGS_enumMessageAssociationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageAssociationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageAssociationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageAssociationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@enumMessageListAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_enumMessageListAST::
elementOf_GGS_enumMessageListAST (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mEnumMessageName (argument_0),
mMessageAssociationList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_enumMessageListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_enumMessageListAST * ptr = dynamic_cast <const elementOf_GGS_enumMessageListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumMessageName.operator_isEqual (ptr->mEnumMessageName).boolValue ()
         && mMessageAssociationList.operator_isEqual (ptr->mMessageAssociationList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_enumMessageListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEnumMessageName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMessageAssociationList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@enumMessageListAST'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumMessageListAST ("enumMessageListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_enumMessageAssociationListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST GGS_enumMessageListAST::
operator_concat (const GGS_enumMessageListAST & inOperand) const {
  GGS_enumMessageListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
dotAssign_operation (const GGS_enumMessageListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_enumMessageListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEnumMessageName ;
          GGS_enumMessageAssociationListAST  p_1 = p->mMessageAssociationList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_enumMessageAssociationListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mEnumMessageName,
                                ptr->mMessageAssociationList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST  GGS_enumMessageListAST::
constructor_emptyList (void) {
  GGS_enumMessageListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST  GGS_enumMessageListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_enumMessageAssociationListAST & argument_1) {
  GGS_enumMessageListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
internalSubListWithRange (GGS_enumMessageListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mEnumMessageName, ptr->mMessageAssociationList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST GGS_enumMessageListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST GGS_enumMessageListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_enumMessageListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_enumMessageListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@enumMessageListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_enumMessageAssociationListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_enumMessageAssociationListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_enumMessageAssociationListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_enumMessageAssociationListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mEnumMessageName ;
    _out_1 = ptr->mMessageAssociationList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumMessageListAST::
reader_mEnumMessageNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEnumMessageName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageAssociationListAST  GGS_enumMessageListAST::
reader_mMessageAssociationListAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_enumMessageAssociationListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mMessageAssociationList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_setMEnumMessageNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEnumMessageName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_enumMessageListAST::
modifier_setMMessageAssociationListAtIndex (C_Compiler & inLexique,
                              const GGS_enumMessageAssociationListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mMessageAssociationList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_enumMessageListAST::cEnumerator::_mEnumMessageName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEnumMessageName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_enumMessageAssociationListAST  & GGS_enumMessageListAST::cEnumerator::_mMessageAssociationList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mMessageAssociationList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_enumMessageListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumMessageListAST * p = NULL ;
    macroMyNew (p, GGS_enumMessageListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST GGS_enumMessageListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumMessageListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumMessageListAST * p = dynamic_cast <const GGS_enumMessageListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumMessageListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumMessageListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumMessageListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_enumDeclarationAST'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_enumDeclarationAST::
cPtr_enumDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_enumMessageListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mEnumTypeName (argument_0),
mConstantList (argument_1),
mEnumMessageList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_enumDeclarationAST * GGS_enumDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_enumDeclarationAST) ;
    return (cPtr_enumDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_enumDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_enumDeclarationAST * ptr = dynamic_cast <const cPtr_enumDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mEnumTypeName.operator_isEqual (ptr->mEnumTypeName).boolValue ()
         && mConstantList.operator_isEqual (ptr->mConstantList).boolValue ()
         && mEnumMessageList.operator_isEqual (ptr->mEnumMessageList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_enumDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@enumDeclarationAST:"
           << mEnumTypeName.reader_description (inIndentation + 1)
           << mConstantList.reader_description (inIndentation + 1)
           << mEnumMessageList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_enumDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_enumDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_enumDeclarationAST (& typeid (cPtr_enumDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_enumDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__enumDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_enumDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_enumDeclarationAST (mEnumTypeName, mConstantList, mEnumMessageList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_enumDeclarationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_enumDeclarationAST ("enumDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_enumDeclarationAST::
GGS_enumDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationAST::
GGS_enumDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_enumDeclarationAST GGS_enumDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_enumDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_enumDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_enumDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_enumDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationAST GGS_enumDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_enumMessageListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_enumDeclarationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_enumDeclarationAST::
reader_mEnumTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationAST *) mPointer)->mEnumTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_enumDeclarationAST::
reader_mConstantList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationAST *) mPointer)->mConstantList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumMessageListAST  GGS_enumDeclarationAST::
reader_mEnumMessageList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_enumMessageListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_enumDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_enumDeclarationAST *) mPointer)->mEnumMessageList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_enumDeclarationAST::actualTypeName (void) const {
  return "enumDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__enumDeclarationAST ("enumDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_enumDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_enumDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_enumDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_enumDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_enumDeclarationAST GGS_enumDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_enumDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_enumDeclarationAST * p = dynamic_cast <const GGS_enumDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_enumDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_enumDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_enumDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@filewrapperTemplateListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateListAST::
elementOf_GGS_filewrapperTemplateListAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListAST & argument_2
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mFilewrapperTemplateName (argument_0),
mFilewrapperTemplatePath (argument_1),
mFilewrapperTemplateFormalInputParameters (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_filewrapperTemplateListAST * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperTemplateName.operator_isEqual (ptr->mFilewrapperTemplateName).boolValue ()
         && mFilewrapperTemplatePath.operator_isEqual (ptr->mFilewrapperTemplatePath).boolValue ()
         && mFilewrapperTemplateFormalInputParameters.operator_isEqual (ptr->mFilewrapperTemplateFormalInputParameters).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplatePath.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mFilewrapperTemplateFormalInputParameters.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@filewrapperTemplateListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateListAST ("filewrapperTemplateListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_formalInputParameterListAST & argument_2
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListAST & argument_2) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()&& argument_2.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST GGS_filewrapperTemplateListAST::
operator_concat (const GGS_filewrapperTemplateListAST & inOperand) const {
  GGS_filewrapperTemplateListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
dotAssign_operation (const GGS_filewrapperTemplateListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_filewrapperTemplateListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mFilewrapperTemplateName ;
          GGS_lstring  p_1 = p->mFilewrapperTemplatePath ;
          GGS_formalInputParameterListAST  p_2 = p->mFilewrapperTemplateFormalInputParameters ;
          internalAppendValues (p_0, p_1, p_2 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_formalInputParameterListAST & argument_2
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1,
                                argument_2
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mFilewrapperTemplateName,
                                ptr->mFilewrapperTemplatePath,
                                ptr->mFilewrapperTemplateFormalInputParameters
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST  GGS_filewrapperTemplateListAST::
constructor_emptyList (void) {
  GGS_filewrapperTemplateListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST  GGS_filewrapperTemplateListAST::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_formalInputParameterListAST & argument_2) {
  GGS_filewrapperTemplateListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
internalSubListWithRange (GGS_filewrapperTemplateListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mFilewrapperTemplateName, ptr->mFilewrapperTemplatePath, ptr->mFilewrapperTemplateFormalInputParameters) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST GGS_filewrapperTemplateListAST::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST GGS_filewrapperTemplateListAST::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@filewrapperTemplateListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_formalInputParameterListAST & _out_2
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_formalInputParameterListAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_formalInputParameterListAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_formalInputParameterListAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mFilewrapperTemplateName ;
    _out_1 = ptr->mFilewrapperTemplatePath ;
    _out_2 = ptr->mFilewrapperTemplateFormalInputParameters ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateListAST::
reader_mFilewrapperTemplateNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperTemplateListAST::
reader_mFilewrapperTemplatePathAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplatePath ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_formalInputParameterListAST  GGS_filewrapperTemplateListAST::
reader_mFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_formalInputParameterListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mFilewrapperTemplateFormalInputParameters ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_setMFilewrapperTemplateNameAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_setMFilewrapperTemplatePathAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplatePath = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateListAST::
modifier_setMFilewrapperTemplateFormalInputParametersAtIndex (C_Compiler & inLexique,
                              const GGS_formalInputParameterListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mFilewrapperTemplateFormalInputParameters = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateListAST::cEnumerator::_mFilewrapperTemplateName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplateName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateListAST::cEnumerator::_mFilewrapperTemplatePath (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplatePath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_filewrapperTemplateListAST::cEnumerator::_mFilewrapperTemplateFormalInputParameters (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mFilewrapperTemplateFormalInputParameters ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateListAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST GGS_filewrapperTemplateListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateListAST * p = dynamic_cast <const GGS_filewrapperTemplateListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_filewrapperDeclarationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_filewrapperDeclarationAST::
cPtr_filewrapperDeclarationAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstringlist & argument_2,
                                const GGS_filewrapperTemplateListAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_semanticDeclarationAST (THERE),
mFilewrapperName (argument_0),
mFilewrapperPath (argument_1),
mFilewrapperExtensionList (argument_2),
mFilewrapperTemplateList (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_filewrapperDeclarationAST * GGS_filewrapperDeclarationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_filewrapperDeclarationAST) ;
    return (cPtr_filewrapperDeclarationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_filewrapperDeclarationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_filewrapperDeclarationAST * ptr = dynamic_cast <const cPtr_filewrapperDeclarationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFilewrapperName.operator_isEqual (ptr->mFilewrapperName).boolValue ()
         && mFilewrapperPath.operator_isEqual (ptr->mFilewrapperPath).boolValue ()
         && mFilewrapperExtensionList.operator_isEqual (ptr->mFilewrapperExtensionList).boolValue ()
         && mFilewrapperTemplateList.operator_isEqual (ptr->mFilewrapperTemplateList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_filewrapperDeclarationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@filewrapperDeclarationAST:"
           << mFilewrapperName.reader_description (inIndentation + 1)
           << mFilewrapperPath.reader_description (inIndentation + 1)
           << mFilewrapperExtensionList.reader_description (inIndentation + 1)
           << mFilewrapperTemplateList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclarationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_filewrapperDeclarationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_filewrapperDeclarationAST (& typeid (cPtr_filewrapperDeclarationAST), & typeid (cPtr_semanticDeclarationAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_filewrapperDeclarationAST::galgasRTTI (void) const {
  return & gClassInfoFor__filewrapperDeclarationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_filewrapperDeclarationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_filewrapperDeclarationAST (mFilewrapperName, mFilewrapperPath, mFilewrapperExtensionList, mFilewrapperTemplateList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_filewrapperDeclarationAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperDeclarationAST ("filewrapperDeclarationAST", true, & kTypeDescriptor_GGS_semanticDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationAST::
GGS_filewrapperDeclarationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationAST::
GGS_filewrapperDeclarationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_filewrapperDeclarationAST GGS_filewrapperDeclarationAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_filewrapperDeclarationAST *> (inPointer) != NULL)
      : (typeid (cPtr_filewrapperDeclarationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_filewrapperDeclarationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_filewrapperDeclarationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationAST GGS_filewrapperDeclarationAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstringlist & argument_2,
                 const GGS_filewrapperTemplateListAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationAST result ;
  macroMyNew (result.mPointer, cPtr_filewrapperDeclarationAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclarationAST::
reader_mFilewrapperName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationAST *) mPointer)->mFilewrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_filewrapperDeclarationAST::
reader_mFilewrapperPath (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationAST *) mPointer)->mFilewrapperPath ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_filewrapperDeclarationAST::
reader_mFilewrapperExtensionList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationAST *) mPointer)->mFilewrapperExtensionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateListAST  GGS_filewrapperDeclarationAST::
reader_mFilewrapperTemplateList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_filewrapperDeclarationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_filewrapperDeclarationAST *) mPointer)->mFilewrapperTemplateList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_filewrapperDeclarationAST::actualTypeName (void) const {
  return "filewrapperDeclarationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__filewrapperDeclarationAST ("filewrapperDeclarationAST", gClassInfoFor__semanticDeclarationAST, & kTypeDescriptor_GGS_filewrapperDeclarationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperDeclarationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperDeclarationAST * p = NULL ;
    macroMyNew (p, GGS_filewrapperDeclarationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperDeclarationAST GGS_filewrapperDeclarationAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperDeclarationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperDeclarationAST * p = dynamic_cast <const GGS_filewrapperDeclarationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperDeclarationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperDeclarationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperDeclarationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_semanticsComponentAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_semanticsComponentAST::
cPtr_semanticsComponentAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_semanticDeclarationStructAST& argument_2,
                                const GGS_location & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE),
mSemanticsComponentName (argument_0),
mImportedComponentFileNameList (argument_1),
mSemanticDeclarations (argument_2),
mEndOfSourceFile (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_semanticsComponentAST * GGS_semanticsComponentAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_semanticsComponentAST) ;
    return (cPtr_semanticsComponentAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_semanticsComponentAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_semanticsComponentAST * ptr = dynamic_cast <const cPtr_semanticsComponentAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSemanticsComponentName.operator_isEqual (ptr->mSemanticsComponentName).boolValue ()
         && mImportedComponentFileNameList.operator_isEqual (ptr->mImportedComponentFileNameList).boolValue ()
         && mSemanticDeclarations.operator_isEqual (ptr->mSemanticDeclarations).boolValue ()
         && mEndOfSourceFile.operator_isEqual (ptr->mEndOfSourceFile).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_semanticsComponentAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@semanticsComponentAST:"
           << mSemanticsComponentName.reader_description (inIndentation + 1)
           << mImportedComponentFileNameList.reader_description (inIndentation + 1)
           << mSemanticDeclarations.reader_description (inIndentation + 1)
           << mEndOfSourceFile.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_semanticsComponentAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_semanticsComponentAST (& typeid (cPtr_semanticsComponentAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_semanticsComponentAST::galgasRTTI (void) const {
  return & gClassInfoFor__semanticsComponentAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_semanticsComponentAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_semanticsComponentAST (mSemanticsComponentName, mImportedComponentFileNameList, mSemanticDeclarations, mEndOfSourceFile COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_semanticsComponentAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticsComponentAST ("semanticsComponentAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticsComponentAST::
GGS_semanticsComponentAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentAST::
GGS_semanticsComponentAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_semanticsComponentAST GGS_semanticsComponentAST::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_semanticsComponentAST *> (inPointer) != NULL)
      : (typeid (cPtr_semanticsComponentAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_semanticsComponentAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_semanticsComponentAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentAST GGS_semanticsComponentAST::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_semanticDeclarationStructAST& argument_2,
                 const GGS_location & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentAST result ;
  macroMyNew (result.mPointer, cPtr_semanticsComponentAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_semanticsComponentAST::
reader_mSemanticsComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentAST *) mPointer)->mSemanticsComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_semanticsComponentAST::
reader_mImportedComponentFileNameList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentAST *) mPointer)->mImportedComponentFileNameList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticDeclarationStructAST GGS_semanticsComponentAST::
reader_mSemanticDeclarations (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_semanticDeclarationStructAST  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentAST *) mPointer)->mSemanticDeclarations ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_semanticsComponentAST::
reader_mEndOfSourceFile (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_semanticsComponentAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_semanticsComponentAST *) mPointer)->mEndOfSourceFile ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_semanticsComponentAST::actualTypeName (void) const {
  return "semanticsComponentAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_semanticsComponentAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__semanticsComponentAST ("semanticsComponentAST", & kTypeDescriptor_GGS_semanticsComponentAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_semanticsComponentAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticsComponentAST * p = NULL ;
    macroMyNew (p, GGS_semanticsComponentAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticsComponentAST GGS_semanticsComponentAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticsComponentAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticsComponentAST * p = dynamic_cast <const GGS_semanticsComponentAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticsComponentAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticsComponentAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticsComponentAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticsTypesForAST (void) {
  macroReleaseObject (gSingleton_selfInExpressionAST) ;
  macroReleaseObject (gSingleton_hereExpressionAST) ;
  macroReleaseObject (gSingleton_trueExpressionAST) ;
  macroReleaseObject (gSingleton_falseExpressionAST) ;
  macroReleaseObject (gSingleton_inputJokerActualParameterAST) ;
  macroReleaseObject (gSingleton_foreachInstructionJokerAST) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsTypesForAST (NULL, epilogueRoutineFor_semanticsTypesForAST) ;

//---------------------------------------------------------------------------*

