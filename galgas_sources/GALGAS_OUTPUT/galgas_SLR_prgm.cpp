//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'galgas_SLR_prgm.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                     october 28th, 2006, at 11h42'5"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1

#include "bdd/C_BDD.h"
#include "project_creation.h"

//--- END OF USER ZONE 1

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include "utilities/F_DisplayException.h"
#include "utilities/MF_MemoryControl.h"
#include "time/C_Timer.h"
#include "generic_arraies/TC_UniqueArray.h"
#include "command_line_interface/F_Analyze_CLI_Options.h"
#include "command_line_interface/mainForLIBPM.h"
#include "utilities/MF_MemoryControl.h"

#ifdef TARGET_API_MAC_CARBON
  #include <SIOUX.H>
#endif

#ifdef COMPILE_FOR_WIN32
  #ifdef __MWERKS__
    #include <WINSIOUX.H>
  #endif
#endif

//---------------------------------------------------------------------------*

#include "galgas_SLR_prgm.h"

//---------------------------------------------------------------------------*
//                                                                           *
//                C_options_for_galgas_SLR_prgm  CONSTRUCTOR                 *
//                                                                           *
//---------------------------------------------------------------------------*

C_options_for_galgas_SLR_prgm::
C_options_for_galgas_SLR_prgm (const bool inAcceptsDebugOption)
:mBuiltinOptions (inAcceptsDebugOption) {
  add (& mBuiltinOptions) ;
  add (& mGalgasOptions) ;
  add (& mOptions_galgas_cli_options) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          C O N S T R U C T O R                            *
//                                                                           *
//---------------------------------------------------------------------------*


grammar_galgas_SLR_prgm::
grammar_galgas_SLR_prgm (const C_galgas_io_parameters & inIOparameters COMMA_LOCATION_ARGS) :
_mScannerPtr (NULL), mTerminalIO (inIOparameters) {
  macroMyNew (_mScannerPtr, galgas_scanner (& mTerminalIO COMMA_THERE)) ;
  C_GGS_Object::attachPointer (_mScannerPtr COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           D E S T R U C T O R                             *
//                                                                           *
//---------------------------------------------------------------------------*


grammar_galgas_SLR_prgm::
~grammar_galgas_SLR_prgm (void) {
  macroDetachPointer (_mScannerPtr, galgas_scanner) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       D O    C O M P I L A T I O N                        *
//                                                                           *
//---------------------------------------------------------------------------*

void grammar_galgas_SLR_prgm::
doCompilation (const C_String & inSourceFileName_,
               const bool inVerboseOptionOn,
               sint16 & returnCode) {
  C_Timer timer ;
  try{
    /* if (mTerminalIO.versionModeOn ()) {
      co << "Reading '" << inSourceFileName_ << "'\n" ;
    } */
    _mScannerPtr->resetAndLoadSourceFromFile (inSourceFileName_) ;
    _beforeParsing () ;
    if (! mLexiqueMapForUse._isBuilt ()) {
      C_String message ;
      message << "the '"
                 "mLexiqueMapForUse"
                 "' program parameter has not been initialized" ;
      throw C_Exception (message.cString (), 0, 0 COMMA_HERE) ;
    }
    if (! mSemanticsComponentsMap._isBuilt ()) {
      C_String message ;
      message << "the '"
                 "mSemanticsComponentsMap"
                 "' program parameter has not been initialized" ;
      throw C_Exception (message.cString (), 0, 0 COMMA_HERE) ;
    }
    if (! mSyntaxComponentsMap._isBuilt ()) {
      C_String message ;
      message << "the '"
                 "mSyntaxComponentsMap"
                 "' program parameter has not been initialized" ;
      throw C_Exception (message.cString (), 0, 0 COMMA_HERE) ;
    }
    if (! mGrammarsComponentsMap._isBuilt ()) {
      C_String message ;
      message << "the '"
                 "mGrammarsComponentsMap"
                 "' program parameter has not been initialized" ;
      throw C_Exception (message.cString (), 0, 0 COMMA_HERE) ;
    }
    if (! mOptionComponentsMap._isBuilt ()) {
      C_String message ;
      message << "the '"
                 "mOptionComponentsMap"
                 "' program parameter has not been initialized" ;
      throw C_Exception (message.cString (), 0, 0 COMMA_HERE) ;
    }
    if (! mMetamodelComponentMap._isBuilt ()) {
      C_String message ;
      message << "the '"
                 "mMetamodelComponentMap"
                 "' program parameter has not been initialized" ;
      throw C_Exception (message.cString (), 0, 0 COMMA_HERE) ;
    }
    if (! mConstraintComponentMap._isBuilt ()) {
      C_String message ;
      message << "the '"
                 "mConstraintComponentMap"
                 "' program parameter has not been initialized" ;
      throw C_Exception (message.cString (), 0, 0 COMMA_HERE) ;
    }
    galgas_SLR_grammar grammar_ ;
    grammar_.startParsing_ (*_mScannerPtr,
                                mLexiqueMapForUse,
                                mSemanticsComponentsMap,
                                mSyntaxComponentsMap,
                                mGrammarsComponentsMap,
                                mOptionComponentsMap,
                                mMetamodelComponentMap,
                                mConstraintComponentMap) ;
    if (mTerminalIO.getErrorTotalCount () == 0) {
      _afterParsing (inVerboseOptionOn) ;
    }
    if (inVerboseOptionOn || ((mTerminalIO.getErrorTotalCount () + mTerminalIO.getWarningsCount ()) > 0)) {
      co << "Analysis of '" << _mScannerPtr->sourceFileName ().lastPathComponent () << "' completed. " ;
    }
    switch (mTerminalIO.getErrorTotalCount ()) {
    case 0 :
      if (inVerboseOptionOn) {
        co << "No error, " ;
      }
      break ;
    case 1 :
      co << "1 error, " ;
      returnCode = 1 ; // Error code
      break ;
    default :
      co << mTerminalIO.getErrorTotalCount () << " errors, " ;
      returnCode = 1 ; // Error code
      break ;
    }
    switch (mTerminalIO.getWarningsCount ()) {
    case 0 :
      if (inVerboseOptionOn) {
        co << "no warning" ;
      }
      break ;
    case 1 :
      co << "1 warning" ;
      break ;
    default :
      co << mTerminalIO.getWarningsCount () << " warnings" ;
      break ;
    }
    timer.stopTimer () ;
    if (inVerboseOptionOn || ((mTerminalIO.getErrorTotalCount () + mTerminalIO.getWarningsCount ()) > 0)) {
      co << " (" << timer << ").\n" ;
    }
  }catch (const C_TextReadException & inFileReadError) {
    co << "Error: " << inFileReadError.what () << "\n" ; // Error when reading source file
    returnCode = 1 ;
  }
}

//---------------------------------------------------------------------------*

int mainForLIBPM  (const int argc, const char * argv []) {
  bool verboseOptionOn = true ;
  sint16 returnCode = 0 ; // No error
  {
  //--- Input/output parameters
    C_options_for_galgas_SLR_prgm options (false) ;
    C_galgas_io_parameters IOparameters  (& options) ;
    #ifndef DO_NOT_GENERATE_CHECKINGS
      IOparameters.mCompilerVersion = "version GALGAS_BETA_VERSION (SLR grammar)" " [debug]" ;
    #else
      IOparameters.mCompilerVersion = "version GALGAS_BETA_VERSION (SLR grammar)" ;
    #endif
    IOparameters.mMaxErrorsCount = 100 ;
    IOparameters.mMaxWarningsCount = 100 ;
    const char * extensions [] = {"ggs", NULL} ;
    const char * helpMessages [] = {"a GALGAS source file", NULL} ;
    TC_UniqueArray <C_String> sourceFilesArray ;
  //--- Analyze Command Line Options
    F_Analyze_CLI_Options (argc, argv,
                           "version GALGAS_BETA_VERSION (SLR grammar)",
                           options,
                           sourceFilesArray,
                           extensions,
                           helpMessages,
                           IOparameters.mCocoaOutput) ;
  //--- Ask Save On Close ? (Carbon and Windows SIOUX Only)
    #ifdef SIOUX_IS_IMPLEMENTED
      SIOUXSettings.asktosaveonclose = options.boolOptionValueFromKeys ("generic_cli_options",
                                                                        ASK_TO_SAVE_ON_CLOSE,
                                                                        false) ;
    #endif
  //--- Enable 64 bit alloc debug ? Only if compiled in 64 bit and in debug mode
    #ifndef DO_NOT_GENERATE_CHECKINGS
      #ifdef __LP64__
        if (options.boolOptionValueFromKeys ("generic_cli_options",
                                             "enable_allocation_debugging",
                                             false)) {
          enableAllocDebugFor64BitTool () ;
        }
      #endif
    #endif
    try{
      verboseOptionOn = options.boolOptionValueFromKeys ("generic_galgas_cli_options",
                                                         "verbose_output",
                                                         false) ;
      galgas_SLR_prgm_prologue (options) ;
      for (sint32 i=0 ; i<sourceFilesArray.count () ; i++) {
        const C_String fileExtension = sourceFilesArray (i COMMA_HERE).pathExtension () ;
        sint16 r = 0 ;
        if (fileExtension.compare ("ggs") == 0) {
          grammar_galgas_SLR_prgm * compiler = NULL ;
          macroMyNew (compiler, grammar_galgas_SLR_prgm (IOparameters COMMA_HERE)) ;
          compiler->_prologue () ;
          compiler->doCompilation (sourceFilesArray (i COMMA_HERE), verboseOptionOn, r) ;
          compiler->_epilogue () ;
          macroMyDelete (compiler, grammar_galgas_SLR_prgm) ;
        }else{
          printf ("*** Error: unhandled extension for file '%s' ***\n", sourceFilesArray (i COMMA_HERE).cString ()) ;
          r = 1 ;
        }
        if (r != 0) {
          returnCode = r ;
        }
      }
      galgas_SLR_prgm_epilogue (options) ;
    }catch (const M_STD_NAMESPACE exception & e) {
      F_default_display_exception (e) ;
      returnCode = 1 ; // Error code
    }catch (...) {
      F_default_display_unknown_exception () ;
      returnCode = 2 ; // Error code
    }
  }
  #ifndef DO_NOT_GENERATE_CHECKINGS
    C_GGS_Object::checkAllObjectsHaveBeenReleased () ;
  #endif
  if (verboseOptionOn) {
    #ifndef DO_NOT_GENERATE_CHECKINGS
      const uint64 maxUsedMemorySize = getMaxUsedMemorySize () ;
      const uint64 oneMegaByte = 1 << 20 ;
      const uint64 megaBytes = maxUsedMemorySize / oneMegaByte ;
      const uint64 fraction = ((maxUsedMemorySize % oneMegaByte) * 1000) / oneMegaByte ;
      co << getCreatedDynamicObjectsTotalCount ()
         << " C++ objects have been created ("
         << megaBytes << "." << widthWithZeroFill (3) << fraction
         << " MB).\n" ;
      deactivateMemoryControl () ;
      if ((getAllocationBalance () != 0) && (returnCode == 0)) {
        display_pointers () ;
      }
    #endif
  }
  return returnCode ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    P R O L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

void galgas_SLR_prgm_prologue (const C_options_for_galgas_SLR_prgm & inOptions) {
  const C_String libpmLocation = inOptions.stringOptionValueFromKeys ("galgas_cli_options", "libpm", NULL) ;
//--- Classic Project Creation
  const C_String stringForClassicProjectCreation = inOptions.stringOptionValueFromKeys ("galgas_cli_options", "create_project", NULL) ;
  if (stringForClassicProjectCreation.length () > 0) {
    createProject (stringForClassicProjectCreation, libpmLocation, kClassicProject) ;
  }
//--- MDA Project Creation
  const C_String stringForMDAProjectCreation = inOptions.stringOptionValueFromKeys ("galgas_cli_options", "create_mda_project", NULL) ;
  if (stringForMDAProjectCreation.length () > 0) {
    createProject (stringForMDAProjectCreation, libpmLocation, kMDAproject) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     P R O G R A M    E P I L O G U E                      *
//                                                                           *
//---------------------------------------------------------------------------*

void galgas_SLR_prgm_epilogue (const C_options_for_galgas_SLR_prgm & /* inOptions */) {
// ADD YOUR CODE HERE
}

//---------------------------------------------------------------------------*

void grammar_galgas_SLR_prgm::_beforeParsing (void) {
  mLexiqueMapForUse = GGS_M_lexiqueComponents::constructor_emptyMap (*_mScannerPtr COMMA_HERE) ;
  mSemanticsComponentsMap = GGS_M_semanticsComponents::constructor_emptyMap (*_mScannerPtr COMMA_HERE) ;
  mSyntaxComponentsMap = GGS_M_syntaxComponents::constructor_emptyMap (*_mScannerPtr COMMA_HERE) ;
  mGrammarsComponentsMap = GGS_M_grammarComponents::constructor_emptyMap (*_mScannerPtr COMMA_HERE) ;
  mOptionComponentsMap = GGS_M_optionComponents::constructor_emptyMap (*_mScannerPtr COMMA_HERE) ;
  mMetamodelComponentMap = GGS_M_metamodelsComponents::constructor_emptyMap (*_mScannerPtr COMMA_HERE) ;
  mConstraintComponentMap = GGS_M_constraintComponents::constructor_emptyMap (*_mScannerPtr COMMA_HERE) ;
  mTerminalIO.mFileGenerationStartDir = _mScannerPtr->sourceFileName ().stringByDeletingLastPathComponent ().stringByAppendingPathComponent ("GALGAS_OUTPUT") ;
  const bool ok = mTerminalIO.mFileGenerationStartDir.makeDirectoryIfDoesNotExists () ;
  if (! ok) {
    C_String errorMessage ;
    errorMessage << "cannot create directory '" << mTerminalIO.mFileGenerationStartDir << "'" ;
    _mScannerPtr->galgas_IO_Ptr ()->printFileErrorMessage (_mScannerPtr->sourceFileName (), errorMessage.cString () COMMA_HERE) ;
  }
}

//--------------------------------------------------------------------------*

void grammar_galgas_SLR_prgm::_afterParsing (const bool inVerboseOptionOn) {
  if (_mScannerPtr->boolOptionValueFromKeys ("galgas_cli_options", "warningsAsError", true) &&
     (_mScannerPtr->totalErrorCount () == 0) &&
     (_mScannerPtr->totalWarningCount () > 0)) {
    C_String message ;
    message << "warnings are treated as errors" ;
    _mScannerPtr->onTheFlySemanticError (message COMMA_HERE) ;
  }
  C_BDD::markAndSweepUnusedNodes () ;
  if (inVerboseOptionOn) {
    co << _mScannerPtr->checkedLineCount () << " checked line"
       << ((_mScannerPtr->checkedLineCount () > 1) ? "s" : "")
       << ", " << _mScannerPtr->preservedLineCount ()
       << " preserved line"
       << ((_mScannerPtr->preservedLineCount () > 1) ? "s" : "")
       << ", "
       << _mScannerPtr->generatedLineCount ()
       << " generated line"
       << ((_mScannerPtr->generatedLineCount () > 1) ? "s" : "")
       << " for "
       << _mScannerPtr->generatedFileCount ()
       << " file"
       << ((_mScannerPtr->generatedFileCount () > 1) ? "s" : "")
       << ".\n" ;
  }
}

//---------------------------------------------------------------------------*

//--- END OF USER ZONE 2


