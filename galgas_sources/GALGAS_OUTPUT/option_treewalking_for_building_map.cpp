//---------------------------------------------------------------------------*
//                                                                           *
//              File 'option_treewalking_for_building_map.cpp'               *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      march 19th, 2007, at 11h49'58"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//#define TRACE_TREE_WALKING

//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "option_treewalking_for_building_map.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "option_treewalking_for_building_map.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                Treewalking routine prototype declaration                  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_optionComponentRoot (C_Compiler & _inLexique,
                                const cPtr_optionComponentRoot * _currentObject,
                                GGS_commandLineOptionMap  & var_cas_outBoolOptionMap,
                                GGS_commandLineOptionMap  & var_cas_outUIntOptionMap,
                                GGS_commandLineOptionMap  & var_cas_outStringOptionMap) ;

static void
_treewalking_routine_commandLineOption (C_Compiler & _inLexique,
                                const cPtr_commandLineOption * _currentObject,
                                GGS_stringset  & var_cas_ioOptionNameSet,
                                GGS_commandLineOptionMap  & var_cas_ioBoolOptionMap,
                                GGS_commandLineOptionMap  & var_cas_ioUIntOptionMap,
                                GGS_commandLineOptionMap  & var_cas_ioStringOptionMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                   Treewalking routine type declaration                    *
//                                                                           *
//---------------------------------------------------------------------------*

typedef void
_treewalking_routine_optionComponentRoot_type (C_Compiler & _inLexique,
                                const cPtr_optionComponentRoot * _currentObject,
                                GGS_commandLineOptionMap  & var_cas_outBoolOptionMap,
                                GGS_commandLineOptionMap  & var_cas_outUIntOptionMap,
                                GGS_commandLineOptionMap  & var_cas_outStringOptionMap) ;

typedef void
_treewalking_routine_commandLineOption_type (C_Compiler & _inLexique,
                                const cPtr_commandLineOption * _currentObject,
                                GGS_stringset  & var_cas_ioOptionNameSet,
                                GGS_commandLineOptionMap  & var_cas_ioBoolOptionMap,
                                GGS_commandLineOptionMap  & var_cas_ioUIntOptionMap,
                                GGS_commandLineOptionMap  & var_cas_ioStringOptionMap) ;

//---------------------------------------------------------------------------*
//                                                                           *
//                            Dispatcher tables                              *
//                                                                           *
//---------------------------------------------------------------------------*

static const uint32 _kSize_option_metamodel = 2 ;

static void * _kDispatcherFor_option_metamodel [_kSize_option_metamodel] = {
  (void *) _treewalking_routine_optionComponentRoot, // #0 @optionComponentRoot, defined in 'option_metamodel' metamodel
  (void *) _treewalking_routine_commandLineOption, // #1 @commandLineOption, defined in 'option_metamodel' metamodel
} ;

//---------------------------------------------------------------------------*

static C_TreewalkingDispacher _gDispatcherTable ;

//---------------------------------------------------------------------------*
//                                                                           *
//         'optionComponentRoot' treewalking routine implementation          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_optionComponentRoot (C_Compiler & _inLexique,
                                const cPtr_optionComponentRoot * _currentObject,
                                GGS_commandLineOptionMap  & var_cas_outBoolOptionMap,
                                GGS_commandLineOptionMap  & var_cas_outUIntOptionMap,
                                GGS_commandLineOptionMap  & var_cas_outStringOptionMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @optionComponentRoot\n") ; fflush (stdout) ;
  #endif
  var_cas_outBoolOptionMap = GGS_commandLineOptionMap::constructor_emptyMap (_inLexique COMMA_HERE) ;
  var_cas_outUIntOptionMap = GGS_commandLineOptionMap::constructor_emptyMap (_inLexique COMMA_HERE) ;
  var_cas_outStringOptionMap = GGS_commandLineOptionMap::constructor_emptyMap (_inLexique COMMA_HERE) ;
  GGS_stringset  var_cas_optionNameSet ;
  var_cas_optionNameSet = GGS_stringset::constructor_emptySet (_inLexique COMMA_HERE) ;
  macroValidPointer (_currentObject) ;
  { GGS_commandLineOptionList::element_type * _ptr = _currentObject->mOptions.firstObject () ;
    while (_ptr != NULL) {
      _treewalking_routine_commandLineOption_type * _f = (_treewalking_routine_commandLineOption_type *) _gDispatcherTable.entry (_ptr COMMA_HERE) ;
      (* _f) (_inLexique, _ptr, var_cas_optionNameSet, var_cas_outBoolOptionMap, var_cas_outUIntOptionMap, var_cas_outStringOptionMap) ;
      _ptr = _ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          'commandLineOption' treewalking routine implementation           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
_treewalking_routine_commandLineOption (C_Compiler & _inLexique,
                                const cPtr_commandLineOption * _currentObject,
                                GGS_stringset  & var_cas_ioOptionNameSet,
                                GGS_commandLineOptionMap  & var_cas_ioBoolOptionMap,
                                GGS_commandLineOptionMap  & var_cas_ioUIntOptionMap,
                                GGS_commandLineOptionMap  & var_cas_ioStringOptionMap) {
  #ifdef TRACE_TREE_WALKING
    printf ("TREE WALKING @commandLineOption\n") ; fflush (stdout) ;
  #endif
  if ((var_cas_ioOptionNameSet.reader_hasKey (_inLexique, _currentObject->mOptionInternalName.reader_string (_inLexique SOURCE_FILE_AT_LINE (50)) SOURCE_FILE_AT_LINE (50))).isBuiltAndTrue ()) {
    _currentObject->mOptionInternalName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, ((((GGS_string (true, "the '")) + (_currentObject->mOptionInternalName.reader_string (_inLexique SOURCE_FILE_AT_LINE (51))))) + (GGS_string (true, "' command line option has been already declared"))) SOURCE_FILE_AT_LINE (52)) ;
  }else if (((_currentObject->mOptionTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (52))) == (GGS_string (true, "bool"))).isBuiltAndTrue ()) {
    var_cas_ioBoolOptionMap.modifier_insertKey (_inLexique, _currentObject->mOptionInternalName, _currentObject->mOptionInvocationLetter, _currentObject->mOptionInvocationString, _currentObject->mOptionComment SOURCE_FILE_AT_LINE (53)) ;
  }else if (((_currentObject->mOptionTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (59))) == (GGS_string (true, "uint"))).isBuiltAndTrue ()) {
    var_cas_ioUIntOptionMap.modifier_insertKey (_inLexique, _currentObject->mOptionInternalName, _currentObject->mOptionInvocationLetter, _currentObject->mOptionInvocationString, _currentObject->mOptionComment SOURCE_FILE_AT_LINE (60)) ;
  }else if (((_currentObject->mOptionTypeName.reader_string (_inLexique SOURCE_FILE_AT_LINE (66))) == (GGS_string (true, "string"))).isBuiltAndTrue ()) {
    var_cas_ioStringOptionMap.modifier_insertKey (_inLexique, _currentObject->mOptionInternalName, _currentObject->mOptionInvocationLetter, _currentObject->mOptionInvocationString, _currentObject->mOptionComment SOURCE_FILE_AT_LINE (67)) ;
  }else{
    _currentObject->mOptionTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "only the @bool, @uint or @string types are allowed here") SOURCE_FILE_AT_LINE (75)) ;
  }
  var_cas_ioOptionNameSet._addAssign_operation (_currentObject->mOptionInternalName.reader_string (_inLexique SOURCE_FILE_AT_LINE (76))) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          Build Dispatcher Tree                            *
//                                                                           *
//---------------------------------------------------------------------------*

static void _build_dispacher_tree (void) {
  _gDispatcherTable.enterTable (_metamodel_index_for_option_metamodel (),
                                _kSize_option_metamodel,
                                _kDispatcherFor_option_metamodel
                                COMMA_HERE) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                               Root routine                                *
//                                                                           *
//---------------------------------------------------------------------------*

void
_walk_throught_option_treewalking_for_building_map (C_Compiler & _inLexique,
                                const GGS_optionComponentRoot & _rootObject,
                                GGS_commandLineOptionMap  & var_cas_outBoolOptionMap,
                                GGS_commandLineOptionMap  & var_cas_outUIntOptionMap,
                                GGS_commandLineOptionMap  & var_cas_outStringOptionMap) {
  if (_rootObject._isBuilt ()) {
    if (! _gDispatcherTable.isInited ()) {
      _build_dispacher_tree () ;
    }
    _treewalking_routine_optionComponentRoot_type * _f = (_treewalking_routine_optionComponentRoot_type *) _gDispatcherTable.entry (_rootObject.getPtr () COMMA_HERE) ;
    (* _f) (_inLexique, _rootObject.getPtr (), var_cas_outBoolOptionMap, var_cas_outUIntOptionMap, var_cas_outStringOptionMap) ;
  }else{
    var_cas_outBoolOptionMap._drop_operation () ;
    var_cas_outUIntOptionMap._drop_operation () ;
    var_cas_outStringOptionMap._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

