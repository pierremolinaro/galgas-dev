//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'metamodel_metamodel.cpp'                       *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                      march 28th, 2007, at 18h39'51"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

#include "metamodel_metamodel.h"
#include "utilities/MF_MemoryControl.h"

//---------------------------------------------------------------------------*

#include <typeinfo>

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "metamodel_metamodel.gMetamodel", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                           Metamodel Management                            *
//                                                                           *
//---------------------------------------------------------------------------*

static C_MetamodelManager gMetamodelManager ;

//---------------------------------------------------------------------------*

uint32 _metamodel_index_for_metamodel_metamodel (void) {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@metamodelComponentRootList'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelComponentRoot::
cPtr_metamodelComponentRoot (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_metamodelEntityList & argument_4
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mMetamodelComponentName (argument_0),
mSuperMetamodels (argument_1),
mMetamodelRootEntityName (argument_2),
mMetamodelImportedComponents (argument_3),
mMetamodelEntities (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_metamodelComponentRoot::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_metamodelComponentRoot * _p = dynamic_cast <const cPtr_metamodelComponentRoot *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mMetamodelComponentName._operator_isEqual (_p->mMetamodelComponentName).boolValue ()
         && mSuperMetamodels._operator_isEqual (_p->mSuperMetamodels).boolValue ()
         && mMetamodelRootEntityName._operator_isEqual (_p->mMetamodelRootEntityName).boolValue ()
         && mMetamodelImportedComponents._operator_isEqual (_p->mMetamodelImportedComponents).boolValue ()
         && mMetamodelEntities._operator_isEqual (_p->mMetamodelEntities).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelComponentRoot::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @metamodelComponentRoot" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelComponentName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSuperMetamodels.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelRootEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelImportedComponents.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMetamodelEntities.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_metamodelComponentRoot::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_metamodelComponentRoot::_metamodelClassID (void) const {
  return 0 ;
}

//---------------------------------------------------------------------------*

cPtr_metamodelComponentRoot * cPtr_metamodelComponentRoot::
_cloneObject (void) const {
  cPtr_metamodelComponentRoot * _p = NULL ;
  macroMyNew (_p, cPtr_metamodelComponentRoot (mMetamodelComponentName, mSuperMetamodels, mMetamodelRootEntityName, mMetamodelImportedComponents, mMetamodelEntities COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@metamodelComponentRootList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelComponentRootList::GGS_metamodelComponentRootList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_metamodelComponentRootList::
GGS_metamodelComponentRootList (const GGS_metamodelComponentRootList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelComponentRootList::
_operator_isEqual (const GGS_metamodelComponentRootList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelComponentRootList::
_operator_isNotEqual (const GGS_metamodelComponentRootList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_metamodelEntityList & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstringlist & argument_1,
                    const GGS_lstring & argument_2,
                    const GGS_lstringlist & argument_3,
                    const GGS_metamodelEntityList & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1,
                                const GGS_lstring & argument_2,
                                const GGS_lstringlist & argument_3,
                                const GGS_metamodelEntityList & argument_4) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelComponentRootList GGS_metamodelComponentRootList::
_operator_concat (const GGS_metamodelComponentRootList & inOperand) const {
  GGS_metamodelComponentRootList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_metamodelComponentRoot * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mMetamodelComponentName ;
          GGS_lstringlist  p_1 = p->mSuperMetamodels ;
          GGS_lstring  p_2 = p->mMetamodelRootEntityName ;
          GGS_lstringlist  p_3 = p->mMetamodelImportedComponents ;
          GGS_metamodelEntityList  p_4 = p->mMetamodelEntities ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstringlist & argument_1,
                     const GGS_lstring & argument_2,
                     const GGS_lstringlist & argument_3,
                     const GGS_metamodelEntityList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mMetamodelComponentName,
                                _p->mSuperMetamodels,
                                _p->mMetamodelRootEntityName,
                                _p->mMetamodelImportedComponents,
                                _p->mMetamodelEntities) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelComponentRootList  GGS_metamodelComponentRootList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelComponentRootList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelComponentRootList  GGS_metamodelComponentRootList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstringlist & argument_1,
                           const GGS_lstring & argument_2,
                           const GGS_lstringlist & argument_3,
                           const GGS_metamodelEntityList & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelComponentRootList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelComponentRootList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@metamodelComponentRootList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
_addModel (const GGS_metamodelComponentRoot & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstringlist & _out_1,
              GGS_lstring & _out_2,
              GGS_lstringlist & _out_3,
              GGS_metamodelEntityList & _out_4
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelComponentName ;
    _out_1 = _p->mSuperMetamodels ;
    _out_2 = _p->mMetamodelRootEntityName ;
    _out_3 = _p->mMetamodelImportedComponents ;
    _out_4 = _p->mMetamodelEntities ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstringlist & _out_1,
             GGS_lstring & _out_2,
             GGS_lstringlist & _out_3,
             GGS_metamodelEntityList & _out_4
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelComponentName ;
    _out_1 = _p->mSuperMetamodels ;
    _out_2 = _p->mMetamodelRootEntityName ;
    _out_3 = _p->mMetamodelImportedComponents ;
    _out_4 = _p->mMetamodelEntities ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstringlist & _out_1,
                 GGS_lstring & _out_2,
                 GGS_lstringlist & _out_3,
                 GGS_metamodelEntityList & _out_4
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelComponentName ;
    _out_1 = _p->mSuperMetamodels ;
    _out_2 = _p->mMetamodelRootEntityName ;
    _out_3 = _p->mMetamodelImportedComponents ;
    _out_4 = _p->mMetamodelEntities ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRootList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstringlist & _out_1,
                GGS_lstring & _out_2,
                GGS_lstringlist & _out_3,
                GGS_metamodelEntityList & _out_4
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mMetamodelComponentName ;
    _out_1 = _p->mSuperMetamodels ;
    _out_2 = _p->mMetamodelRootEntityName ;
    _out_3 = _p->mMetamodelImportedComponents ;
    _out_4 = _p->mMetamodelEntities ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_metamodelComponentRoot'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelComponentRoot::
GGS_metamodelComponentRoot (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelComponentRoot::
GGS_metamodelComponentRoot (const GGS_metamodelComponentRoot & inOperand) {
  mPointer = (cPtr_metamodelComponentRoot *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelComponentRoot::
~GGS_metamodelComponentRoot (void) {
  macroDetachPointer (mPointer, cPtr_metamodelComponentRoot) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRoot::
operator = (const GGS_metamodelComponentRoot & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelComponentRoot GGS_metamodelComponentRoot::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1,
                 const GGS_lstring & argument_2,
                 const GGS_lstringlist & argument_3,
                 const GGS_metamodelEntityList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_metamodelComponentRoot result ;
  macroMyNew (result.mPointer, cPtr_metamodelComponentRoot (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelComponentRoot::
reader_mMetamodelComponentName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mMetamodelComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_metamodelComponentRoot::
reader_mSuperMetamodels (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mSuperMetamodels ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelComponentRoot::
reader_mMetamodelRootEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mMetamodelRootEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_metamodelComponentRoot::
reader_mMetamodelImportedComponents (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mMetamodelImportedComponents ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelEntityList  GGS_metamodelComponentRoot::
reader_mMetamodelEntities (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelEntityList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mMetamodelEntities ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelComponentRoot::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_metamodelComponentRoot) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelComponentRoot::
_operator_isEqual (const GGS_metamodelComponentRoot & inOperand) const {
  bool built = _isBuilt () && inOperand._isBuilt () ;
  bool equal = mPointer == inOperand.mPointer ;
  if (built && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (built, equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelComponentRoot::
_operator_isNotEqual (const GGS_metamodelComponentRoot & inOperand) const {
  bool built = _isBuilt () && inOperand._isBuilt () ;
  bool equal = mPointer == inOperand.mPointer ;
  if (built && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (built, ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelComponentRoot::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelComponentRoot " ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelComponentRoot * GGS_metamodelComponentRoot::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@metamodelEntityList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelEntity::
cPtr_metamodelEntity (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_metamodelAttributeList & argument_3,
                                const GGS_metamodelMultipleReferenceList & argument_4
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mEntityName (argument_0),
mSuperEntityName (argument_1),
mIsAbstract (argument_2),
mAttributes (argument_3),
mMultipleReferences (argument_4) {
}

//---------------------------------------------------------------------------*

bool cPtr_metamodelEntity::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_metamodelEntity * _p = dynamic_cast <const cPtr_metamodelEntity *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mEntityName._operator_isEqual (_p->mEntityName).boolValue ()
         && mSuperEntityName._operator_isEqual (_p->mSuperEntityName).boolValue ()
         && mIsAbstract._operator_isEqual (_p->mIsAbstract).boolValue ()
         && mAttributes._operator_isEqual (_p->mAttributes).boolValue ()
         && mMultipleReferences._operator_isEqual (_p->mMultipleReferences).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelEntity::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @metamodelEntity" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSuperEntityName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mIsAbstract.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributes.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mMultipleReferences.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_metamodelEntity::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_metamodelEntity::_metamodelClassID (void) const {
  return 1 ;
}

//---------------------------------------------------------------------------*

cPtr_metamodelEntity * cPtr_metamodelEntity::
_cloneObject (void) const {
  cPtr_metamodelEntity * _p = NULL ;
  macroMyNew (_p, cPtr_metamodelEntity (mEntityName, mSuperEntityName, mIsAbstract, mAttributes, mMultipleReferences COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       List '@metamodelEntityList'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelEntityList::GGS_metamodelEntityList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_metamodelEntityList::
GGS_metamodelEntityList (const GGS_metamodelEntityList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelEntityList::
_operator_isEqual (const GGS_metamodelEntityList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelEntityList::
_operator_isNotEqual (const GGS_metamodelEntityList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_metamodelAttributeList & argument_3,
                    const GGS_metamodelMultipleReferenceList & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_bool& argument_2,
                    const GGS_metamodelAttributeList & argument_3,
                    const GGS_metamodelMultipleReferenceList & argument_4) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_bool& argument_2,
                                const GGS_metamodelAttributeList & argument_3,
                                const GGS_metamodelMultipleReferenceList & argument_4) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelEntityList GGS_metamodelEntityList::
_operator_concat (const GGS_metamodelEntityList & inOperand) const {
  GGS_metamodelEntityList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_metamodelEntity * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mEntityName ;
          GGS_lstring  p_1 = p->mSuperEntityName ;
          GGS_bool p_2 = p->mIsAbstract ;
          GGS_metamodelAttributeList  p_3 = p->mAttributes ;
          GGS_metamodelMultipleReferenceList  p_4 = p->mMultipleReferences ;
          result._internalAppendValues (p_0, p_1, p_2, p_3, p_4) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_bool& argument_2,
                     const GGS_metamodelAttributeList & argument_3,
                     const GGS_metamodelMultipleReferenceList & argument_4
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mEntityName,
                                _p->mSuperEntityName,
                                _p->mIsAbstract,
                                _p->mAttributes,
                                _p->mMultipleReferences) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelEntityList  GGS_metamodelEntityList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelEntityList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelEntityList  GGS_metamodelEntityList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_bool& argument_2,
                           const GGS_metamodelAttributeList & argument_3,
                           const GGS_metamodelMultipleReferenceList & argument_4
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelEntityList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3, argument_4) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelEntityList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@metamodelEntityList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
_addModel (const GGS_metamodelEntity & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_bool& _out_2,
              GGS_metamodelAttributeList & _out_3,
              GGS_metamodelMultipleReferenceList & _out_4
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityName ;
    _out_1 = _p->mSuperEntityName ;
    _out_2 = _p->mIsAbstract ;
    _out_3 = _p->mAttributes ;
    _out_4 = _p->mMultipleReferences ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_bool& _out_2,
             GGS_metamodelAttributeList & _out_3,
             GGS_metamodelMultipleReferenceList & _out_4
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityName ;
    _out_1 = _p->mSuperEntityName ;
    _out_2 = _p->mIsAbstract ;
    _out_3 = _p->mAttributes ;
    _out_4 = _p->mMultipleReferences ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_bool& _out_2,
                 GGS_metamodelAttributeList & _out_3,
                 GGS_metamodelMultipleReferenceList & _out_4
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityName ;
    _out_1 = _p->mSuperEntityName ;
    _out_2 = _p->mIsAbstract ;
    _out_3 = _p->mAttributes ;
    _out_4 = _p->mMultipleReferences ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntityList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_bool& _out_2,
                GGS_metamodelAttributeList & _out_3,
                GGS_metamodelMultipleReferenceList & _out_4
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mEntityName ;
    _out_1 = _p->mSuperEntityName ;
    _out_2 = _p->mIsAbstract ;
    _out_3 = _p->mAttributes ;
    _out_4 = _p->mMultipleReferences ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
    _out_4._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    GALGAS class 'GGS_metamodelEntity'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelEntity::
GGS_metamodelEntity (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelEntity::
GGS_metamodelEntity (const GGS_metamodelEntity & inOperand) {
  mPointer = (cPtr_metamodelEntity *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelEntity::
~GGS_metamodelEntity (void) {
  macroDetachPointer (mPointer, cPtr_metamodelEntity) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntity::
operator = (const GGS_metamodelEntity & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelEntity GGS_metamodelEntity::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_bool& argument_2,
                 const GGS_metamodelAttributeList & argument_3,
                 const GGS_metamodelMultipleReferenceList & argument_4
                                COMMA_LOCATION_ARGS) {
  GGS_metamodelEntity result ;
  macroMyNew (result.mPointer, cPtr_metamodelEntity (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelEntity::
reader_mEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelEntity::
reader_mSuperEntityName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mSuperEntityName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelEntity::
reader_mIsAbstract (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mIsAbstract ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelAttributeList  GGS_metamodelEntity::
reader_mAttributes (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelAttributeList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mAttributes ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceList  GGS_metamodelEntity::
reader_mMultipleReferences (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_metamodelMultipleReferenceList   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mMultipleReferences ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelEntity::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_metamodelEntity) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelEntity::
_operator_isEqual (const GGS_metamodelEntity & inOperand) const {
  bool built = _isBuilt () && inOperand._isBuilt () ;
  bool equal = mPointer == inOperand.mPointer ;
  if (built && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (built, equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelEntity::
_operator_isNotEqual (const GGS_metamodelEntity & inOperand) const {
  bool built = _isBuilt () && inOperand._isBuilt () ;
  bool equal = mPointer == inOperand.mPointer ;
  if (built && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (built, ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelEntity::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelEntity " ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelEntity * GGS_metamodelEntity::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@metamodelAttributeList'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelAttribute::
cPtr_metamodelAttribute (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_metamodelAttribute::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_metamodelAttribute * _p = dynamic_cast <const cPtr_metamodelAttribute *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeName._operator_isEqual (_p->mAttributeTypeName).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelAttribute::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @metamodelAttribute" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_metamodelAttribute::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_metamodelAttribute::_metamodelClassID (void) const {
  return 2 ;
}

//---------------------------------------------------------------------------*

cPtr_metamodelAttribute * cPtr_metamodelAttribute::
_cloneObject (void) const {
  cPtr_metamodelAttribute * _p = NULL ;
  macroMyNew (_p, cPtr_metamodelAttribute (mAttributeTypeName, mAttributeName COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      List '@metamodelAttributeList'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelAttributeList::GGS_metamodelAttributeList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_metamodelAttributeList::
GGS_metamodelAttributeList (const GGS_metamodelAttributeList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelAttributeList::
_operator_isEqual (const GGS_metamodelAttributeList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelAttributeList::
_operator_isNotEqual (const GGS_metamodelAttributeList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelAttributeList GGS_metamodelAttributeList::
_operator_concat (const GGS_metamodelAttributeList & inOperand) const {
  GGS_metamodelAttributeList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_metamodelAttribute * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeName,
                                _p->mAttributeName) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelAttributeList  GGS_metamodelAttributeList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelAttributeList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelAttributeList  GGS_metamodelAttributeList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelAttributeList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelAttributeList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@metamodelAttributeList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
_addModel (const GGS_metamodelAttribute & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttributeList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_metamodelAttribute'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelAttribute::
GGS_metamodelAttribute (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelAttribute::
GGS_metamodelAttribute (const GGS_metamodelAttribute & inOperand) {
  mPointer = (cPtr_metamodelAttribute *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelAttribute::
~GGS_metamodelAttribute (void) {
  macroDetachPointer (mPointer, cPtr_metamodelAttribute) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttribute::
operator = (const GGS_metamodelAttribute & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelAttribute GGS_metamodelAttribute::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_metamodelAttribute result ;
  macroMyNew (result.mPointer, cPtr_metamodelAttribute (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelAttribute::
reader_mAttributeTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mAttributeTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelAttribute::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelAttribute::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_metamodelAttribute) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelAttribute::
_operator_isEqual (const GGS_metamodelAttribute & inOperand) const {
  bool built = _isBuilt () && inOperand._isBuilt () ;
  bool equal = mPointer == inOperand.mPointer ;
  if (built && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (built, equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelAttribute::
_operator_isNotEqual (const GGS_metamodelAttribute & inOperand) const {
  bool built = _isBuilt () && inOperand._isBuilt () ;
  bool equal = mPointer == inOperand.mPointer ;
  if (built && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (built, ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelAttribute::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelAttribute " ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelAttribute * GGS_metamodelAttribute::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//            Element of list '@metamodelMultipleReferenceList'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_metamodelMultipleReference::
cPtr_metamodelMultipleReference (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) :
C_GGS_MetamodelEntity (THERE),
mAttributeTypeName (argument_0),
mAttributeName (argument_1),
mLowerBound (argument_2),
mUpperBound (argument_3) {
}

//---------------------------------------------------------------------------*

bool cPtr_metamodelMultipleReference::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const cPtr_metamodelMultipleReference * _p = dynamic_cast <const cPtr_metamodelMultipleReference *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = mAttributeTypeName._operator_isEqual (_p->mAttributeTypeName).boolValue ()
         && mAttributeName._operator_isEqual (_p->mAttributeName).boolValue ()
         && mLowerBound._operator_isEqual (_p->mLowerBound).boolValue ()
         && mUpperBound._operator_isEqual (_p->mUpperBound).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_metamodelMultipleReference::
appendForDescription (C_Compiler & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "-> instance of @metamodelMultipleReference" ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeTypeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mAttributeName.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mLowerBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mUpperBound.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_metamodelMultipleReference::_metamodelIndex (void) const {
  return gMetamodelManager.mMetamodelIndex ;
}

//---------------------------------------------------------------------------*

uint32 cPtr_metamodelMultipleReference::_metamodelClassID (void) const {
  return 3 ;
}

//---------------------------------------------------------------------------*

cPtr_metamodelMultipleReference * cPtr_metamodelMultipleReference::
_cloneObject (void) const {
  cPtr_metamodelMultipleReference * _p = NULL ;
  macroMyNew (_p, cPtr_metamodelMultipleReference (mAttributeTypeName, mAttributeName, mLowerBound, mUpperBound COMMA_HERE)) ;
  return _p ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@metamodelMultipleReferenceList'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceList::GGS_metamodelMultipleReferenceList (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceList::
GGS_metamodelMultipleReferenceList (const GGS_metamodelMultipleReferenceList & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelMultipleReferenceList::
_operator_isEqual (const GGS_metamodelMultipleReferenceList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelMultipleReferenceList::
_operator_isNotEqual (const GGS_metamodelMultipleReferenceList & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_uint & argument_2,
                    const GGS_uint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1,
                    const GGS_uint & argument_2,
                    const GGS_uint & argument_3) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1,
                                argument_2,
                                argument_3
                                COMMA_HERE)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_uint & argument_2,
                                const GGS_uint & argument_3) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceList GGS_metamodelMultipleReferenceList::
_operator_concat (const GGS_metamodelMultipleReferenceList & inOperand) const {
  GGS_metamodelMultipleReferenceList result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        cPtr_metamodelMultipleReference * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->mAttributeTypeName ;
          GGS_lstring  p_1 = p->mAttributeName ;
          GGS_uint  p_2 = p->mLowerBound ;
          GGS_uint  p_3 = p->mUpperBound ;
          result._internalAppendValues (p_0, p_1, p_2, p_3) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1,
                     const GGS_uint & argument_2,
                     const GGS_uint & argument_3
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1,
                                argument_2,
                                argument_3) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mAttributeTypeName,
                                _p->mAttributeName,
                                _p->mLowerBound,
                                _p->mUpperBound) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceList  GGS_metamodelMultipleReferenceList::
constructor_emptyList (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelMultipleReferenceList result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReferenceList  GGS_metamodelMultipleReferenceList::
constructor_listWithValue (C_Compiler & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1,
                           const GGS_uint & argument_2,
                           const GGS_uint & argument_3
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_metamodelMultipleReferenceList result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1, argument_2, argument_3) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelMultipleReferenceList::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@metamodelMultipleReferenceList", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
_addModel (const GGS_metamodelMultipleReference & inOperand) {
  if (_isBuilt () && inOperand._isBuilt ()) {
    _insulateList () ;
    _internalAppendItem (inOperand (HERE)->_cloneObject ()) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
method_first (C_Compiler & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1,
              GGS_uint & _out_2,
              GGS_uint & _out_3
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _out_2 = _p->mLowerBound ;
    _out_3 = _p->mUpperBound ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
method_last (C_Compiler & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1,
             GGS_uint & _out_2,
             GGS_uint & _out_3
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _out_2 = _p->mLowerBound ;
    _out_3 = _p->mUpperBound ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
modifier_popFirst (C_Compiler & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1,
                 GGS_uint & _out_2,
                 GGS_uint & _out_3
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _out_2 = _p->mLowerBound ;
    _out_3 = _p->mUpperBound ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReferenceList::
modifier_popLast (C_Compiler & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1,
                GGS_uint & _out_2,
                GGS_uint & _out_3
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mAttributeTypeName ;
    _out_1 = _p->mAttributeName ;
    _out_2 = _p->mLowerBound ;
    _out_3 = _p->mUpperBound ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
    _out_2._drop_operation () ;
    _out_3._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_metamodelMultipleReference'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_metamodelMultipleReference::
GGS_metamodelMultipleReference (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReference::
GGS_metamodelMultipleReference (const GGS_metamodelMultipleReference & inOperand) {
  mPointer = (cPtr_metamodelMultipleReference *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReference::
~GGS_metamodelMultipleReference (void) {
  macroDetachPointer (mPointer, cPtr_metamodelMultipleReference) ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReference::
operator = (const GGS_metamodelMultipleReference & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_metamodelMultipleReference GGS_metamodelMultipleReference::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_uint & argument_2,
                 const GGS_uint & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_metamodelMultipleReference result ;
  macroMyNew (result.mPointer, cPtr_metamodelMultipleReference (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelMultipleReference::
reader_mAttributeTypeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mAttributeTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_metamodelMultipleReference::
reader_mAttributeName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mAttributeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_metamodelMultipleReference::
reader_mLowerBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mLowerBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_metamodelMultipleReference::
reader_mUpperBound (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->mUpperBound ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_metamodelMultipleReference::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_metamodelMultipleReference) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelMultipleReference::
_operator_isEqual (const GGS_metamodelMultipleReference & inOperand) const {
  bool built = _isBuilt () && inOperand._isBuilt () ;
  bool equal = mPointer == inOperand.mPointer ;
  if (built && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (built, equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_metamodelMultipleReference::
_operator_isNotEqual (const GGS_metamodelMultipleReference & inOperand) const {
  bool built = _isBuilt () && inOperand._isBuilt () ;
  bool equal = mPointer == inOperand.mPointer ;
  if (built && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (built, ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_metamodelMultipleReference::
reader_description (C_Compiler & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @metamodelMultipleReference " ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_metamodelMultipleReference * GGS_metamodelMultipleReference::operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    return mPointer ;
  }
#endif

