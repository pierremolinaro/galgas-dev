//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'semanticContext.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 18th, 2010, at 16h14'10"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticContext.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticContext.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//         Implementation of routine "appendPredefinedListTypeAST"           *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_appendPredefinedListTypeAST (C_Compiler & inLexique,
                                GGS_semanticDeclarationListAST  & var_cas_ioDeclarationListASTs,
                                const GGS_string  var_cas_inElementTypeName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_appendPredefinedListTypeAST at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_attributeInCollectionListAST  var_cas_attributeList = GGS_attributeInCollectionListAST ::constructor_emptyList () ;
  var_cas_attributeList.addAssign_operation (GGS_lstring ::constructor_new (inLexique, var_cas_inElementTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (41)), GGS_lstring ::constructor_new (inLexique, GGS_string ("mValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (42))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_listDeclarationAST ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, (var_cas_inElementTypeName).operator_concat (GGS_string ("list")), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (45)), var_cas_attributeList COMMA_SOURCE_FILE_AT_LINE (44))) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_appendPredefinedListTypeAST\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "appendStructASTForTypeWithLocation"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_appendStructASTForTypeWithLocation (C_Compiler & inLexique,
                                GGS_semanticDeclarationListAST  & var_cas_ioDeclarationListASTs,
                                const GGS_string  var_cas_inElementTypeName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_appendStructASTForTypeWithLocation at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_attributeInCollectionListAST  var_cas_attributeList = GGS_attributeInCollectionListAST ::constructor_emptyList () ;
  var_cas_attributeList.addAssign_operation (GGS_lstring ::constructor_new (inLexique, var_cas_inElementTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (57)), GGS_lstring ::constructor_new (inLexique, var_cas_inElementTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (57))) ;
  var_cas_attributeList.addAssign_operation (GGS_lstring ::constructor_new (inLexique, GGS_string ("location"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (58)), GGS_lstring ::constructor_new (inLexique, GGS_string ("location"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (58))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_structDeclarationAST ::constructor_new (inLexique, GGS_lstring ::constructor_new (inLexique, (GGS_string ("l")).operator_concat (var_cas_inElementTypeName), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (60)), var_cas_attributeList COMMA_SOURCE_FILE_AT_LINE (59))) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_appendStructASTForTypeWithLocation\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of routine "appendPredefinedTypesASTs"            *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_appendPredefinedTypesASTs (C_Compiler & inLexique,
                                GGS_semanticDeclarationListAST  & var_cas_ioDeclarationListASTs COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_appendPredefinedTypesASTs at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("root"), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (70))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("enumerable"), GGS_string ("root") COMMA_SOURCE_FILE_AT_LINE (71))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("class"), GGS_string ("root") COMMA_SOURCE_FILE_AT_LINE (72))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("struct"), GGS_string ("root") COMMA_SOURCE_FILE_AT_LINE (73))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("enum"), GGS_string ("root") COMMA_SOURCE_FILE_AT_LINE (74))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("list"), GGS_string ("enumerable") COMMA_SOURCE_FILE_AT_LINE (75))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("sortedlist"), GGS_string ("enumerable") COMMA_SOURCE_FILE_AT_LINE (76))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("map"), GGS_string ("enumerable") COMMA_SOURCE_FILE_AT_LINE (78))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_genericTypeTypeAST ::constructor_new (inLexique, GGS_string ("listmap"), GGS_string ("enumerable") COMMA_SOURCE_FILE_AT_LINE (79))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_boolPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("bool") COMMA_SOURCE_FILE_AT_LINE (81))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_uintPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("uint") COMMA_SOURCE_FILE_AT_LINE (82))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_uint64PredefinedTypeAST ::constructor_new (inLexique, GGS_string ("uint64") COMMA_SOURCE_FILE_AT_LINE (83))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_sintPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("sint") COMMA_SOURCE_FILE_AT_LINE (84))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_sint64PredefinedTypeAST ::constructor_new (inLexique, GGS_string ("sint64") COMMA_SOURCE_FILE_AT_LINE (85))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_charPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("char") COMMA_SOURCE_FILE_AT_LINE (86))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_doublePredefinedTypeAST ::constructor_new (inLexique, GGS_string ("double") COMMA_SOURCE_FILE_AT_LINE (87))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_stringPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("string") COMMA_SOURCE_FILE_AT_LINE (88))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_locationPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("location") COMMA_SOURCE_FILE_AT_LINE (89))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_stringsetPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("stringset") COMMA_SOURCE_FILE_AT_LINE (90))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_objectPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("object") COMMA_SOURCE_FILE_AT_LINE (91))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_functionPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("function") COMMA_SOURCE_FILE_AT_LINE (92))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_typePredefinedTypeAST ::constructor_new (inLexique, GGS_string ("type") COMMA_SOURCE_FILE_AT_LINE (93))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_binarysetPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("binaryset") COMMA_SOURCE_FILE_AT_LINE (94))) ;
  var_cas_ioDeclarationListASTs.addAssign_operation (GGS_dataPredefinedTypeAST ::constructor_new (inLexique, GGS_string ("data") COMMA_SOURCE_FILE_AT_LINE (95))) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("luint") COMMA_SOURCE_FILE_AT_LINE (97)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("uint") COMMA_SOURCE_FILE_AT_LINE (98)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("uint64") COMMA_SOURCE_FILE_AT_LINE (99)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("object") COMMA_SOURCE_FILE_AT_LINE (102)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("function") COMMA_SOURCE_FILE_AT_LINE (103)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("string") COMMA_SOURCE_FILE_AT_LINE (104)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("lstring") COMMA_SOURCE_FILE_AT_LINE (105)) ;
  ::routine_appendPredefinedListTypeAST (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("type") COMMA_SOURCE_FILE_AT_LINE (106)) ;
  ::routine_appendStructASTForTypeWithLocation (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("bool") COMMA_SOURCE_FILE_AT_LINE (108)) ;
  ::routine_appendStructASTForTypeWithLocation (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("uint") COMMA_SOURCE_FILE_AT_LINE (109)) ;
  ::routine_appendStructASTForTypeWithLocation (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("uint64") COMMA_SOURCE_FILE_AT_LINE (110)) ;
  ::routine_appendStructASTForTypeWithLocation (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("sint") COMMA_SOURCE_FILE_AT_LINE (111)) ;
  ::routine_appendStructASTForTypeWithLocation (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("sint64") COMMA_SOURCE_FILE_AT_LINE (112)) ;
  ::routine_appendStructASTForTypeWithLocation (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("char") COMMA_SOURCE_FILE_AT_LINE (113)) ;
  ::routine_appendStructASTForTypeWithLocation (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("double") COMMA_SOURCE_FILE_AT_LINE (114)) ;
  ::routine_appendStructASTForTypeWithLocation (inLexique,  var_cas_ioDeclarationListASTs,  GGS_string ("string") COMMA_SOURCE_FILE_AT_LINE (115)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_appendPredefinedTypesASTs\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_routineMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineMap::e_routineMap (void) :
mRoutineSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@routineMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineMap ("routineMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_routineMap::
elementOf_GGS_routineMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_routineMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRoutineSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineMap * ptr = dynamic_cast <const elementOf_GGS_routineMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRoutineSignature.operator_isEqual (ptr->mInfo.mRoutineSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isNotEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_formalParameterSignature & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_routineMap info  ;
    info.mRoutineSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_routineMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @routineMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_routineMap::cEnumerator::_mRoutineSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRoutineSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_routineMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineMap * p = NULL ;
    macroMyNew (p, GGS_routineMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineMap * p = dynamic_cast <const GGS_routineMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_functionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_functionMap::e_functionMap (void) :
mFunctionSignature (),
mResultTypeIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@functionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionMap ("functionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_functionMap::
elementOf_GGS_functionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_functionMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_functionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFunctionSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mResultTypeIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_functionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_functionMap * ptr = dynamic_cast <const elementOf_GGS_functionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFunctionSignature.operator_isEqual (ptr->mInfo.mFunctionSignature)).boolValue ()
           && (mInfo.mResultTypeIndex.operator_isEqual (ptr->mInfo.mResultTypeIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_functionMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_functionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isNotEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_unifiedTypeMapIndex & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_functionMap info  ;
    info.mFunctionSignature = inParameter0 ;
    info.mResultTypeIndex = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_unifiedTypeMapIndex   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFunctionSignature ;
    outParameter1 = node->mInfo.mResultTypeIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_unifiedTypeMapIndex   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_unifiedTypeMapIndex & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_functionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_functionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @functionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_functionMap::cEnumerator::_mFunctionSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFunctionSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndex  & GGS_functionMap::cEnumerator::_mResultTypeIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mResultTypeIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_functionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionMap * p = NULL ;
    macroMyNew (p, GGS_functionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionMap * p = dynamic_cast <const GGS_functionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_filewrapperTemplateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperTemplateMap::e_filewrapperTemplateMap (void) :
mTemplateSignature (),
mFilewrapperTemplatePath () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@filewrapperTemplateMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateMap ("filewrapperTemplateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateMap::
elementOf_GGS_filewrapperTemplateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperTemplateMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTemplateSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplatePath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperTemplateMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mTemplateSignature.operator_isEqual (ptr->mInfo.mTemplateSignature)).boolValue ()
           && (mInfo.mFilewrapperTemplatePath.operator_isEqual (ptr->mInfo.mFilewrapperTemplatePath)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperTemplateMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperTemplateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isNotEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_unifiedTypeMapIndexList & inParameter0,
                const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_filewrapperTemplateMap info  ;
    info.mTemplateSignature = inParameter0 ;
    info.mFilewrapperTemplatePath = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapIndexList   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mTemplateSignature ;
    outParameter1 = node->mInfo.mFilewrapperTemplatePath ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapIndexList   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapIndexList & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperTemplateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperTemplateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapIndexList  & GGS_filewrapperTemplateMap::cEnumerator::_mTemplateSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTemplateSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateMap::cEnumerator::_mFilewrapperTemplatePath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplatePath ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateMap * p = dynamic_cast <const GGS_filewrapperTemplateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_filewrapperMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperMap::e_filewrapperMap (void) :
mFilewrapperPath (),
mFilewrapperExtensionList (),
mFilewrapperTemplateMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@filewrapperMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperMap ("filewrapperMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperMap::
elementOf_GGS_filewrapperMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperPath.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperExtensionList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplateMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFilewrapperPath.operator_isEqual (ptr->mInfo.mFilewrapperPath)).boolValue ()
           && (mInfo.mFilewrapperExtensionList.operator_isEqual (ptr->mInfo.mFilewrapperExtensionList)).boolValue ()
           && (mInfo.mFilewrapperTemplateMap.operator_isEqual (ptr->mInfo.mFilewrapperTemplateMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isNotEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                const GGS_lstringlist & inParameter1,
                const GGS_filewrapperTemplateMap & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_filewrapperMap info  ;
    info.mFilewrapperPath = inParameter0 ;
    info.mFilewrapperExtensionList = inParameter1 ;
    info.mFilewrapperTemplateMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstringlist   & outParameter1,
               GGS_filewrapperTemplateMap   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    outParameter0 = node->mInfo.mFilewrapperPath ;
    outParameter1 = node->mInfo.mFilewrapperExtensionList ;
    outParameter2 = node->mInfo.mFilewrapperTemplateMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstringlist   & outParameter1,
                                GGS_filewrapperTemplateMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstringlist & inParameter1,
                                const GGS_filewrapperTemplateMap & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperMap::cEnumerator::_mFilewrapperPath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperPath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_filewrapperMap::cEnumerator::_mFilewrapperExtensionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperExtensionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_filewrapperTemplateMap  & GGS_filewrapperMap::cEnumerator::_mFilewrapperTemplateMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperMap * p = dynamic_cast <const GGS_filewrapperMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticContext ("semanticContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
mTypeMap (),
mRoutineMap (),
mFunctionMap (),
mFilewrapperMap (),
mOrderedSemanticDeclarationListAST () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::drop (void) {
  mTypeMap.drop () ;
  mRoutineMap.drop () ;
  mFunctionMap.drop () ;
  mFilewrapperMap.drop () ;
  mOrderedSemanticDeclarationListAST.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::isBuilt (void) const {
  return mTypeMap.isBuilt ()
    && mRoutineMap.isBuilt ()
    && mFunctionMap.isBuilt ()
    && mFilewrapperMap.isBuilt ()
    && mOrderedSemanticDeclarationListAST.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isEqual (inOperand.mTypeMap)
    .operator_and (mRoutineMap.operator_isEqual (inOperand.mRoutineMap))
    .operator_and (mFunctionMap.operator_isEqual (inOperand.mFunctionMap))
    .operator_and (mFilewrapperMap.operator_isEqual (inOperand.mFilewrapperMap))
    .operator_and (mOrderedSemanticDeclarationListAST.operator_isEqual (inOperand.mOrderedSemanticDeclarationListAST)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isNotEqual (inOperand.mTypeMap)
    .operator_or (mRoutineMap.operator_isNotEqual (inOperand.mRoutineMap))
    .operator_or (mFunctionMap.operator_isNotEqual (inOperand.mFunctionMap))
    .operator_or (mFilewrapperMap.operator_isNotEqual (inOperand.mFilewrapperMap))
    .operator_or (mOrderedSemanticDeclarationListAST.operator_isNotEqual (inOperand.mOrderedSemanticDeclarationListAST)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (const GGS_unifiedTypeMap & argument_0,
                 const GGS_routineMap & argument_1,
                 const GGS_functionMap & argument_2,
                 const GGS_filewrapperMap & argument_3,
                 const GGS_semanticDeclarationListAST & argument_4) {
  GGS_semanticContext result ;
  result.mTypeMap = argument_0 ;
  result.mRoutineMap = argument_1 ;
  result.mFunctionMap = argument_2 ;
  result.mFilewrapperMap = argument_3 ;
  result.mOrderedSemanticDeclarationListAST = argument_4 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mTypeMap " ;
    _s << mTypeMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineMap " ;
    _s << mRoutineMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFunctionMap " ;
    _s << mFunctionMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFilewrapperMap " ;
    _s << mFilewrapperMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOrderedSemanticDeclarationListAST " ;
    _s << mOrderedSemanticDeclarationListAST.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticContext * p = NULL ;
    macroMyNew (p, GGS_semanticContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticContext * p = dynamic_cast <const GGS_semanticContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticContext ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@collectedTypeMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMap ("collectedTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_collectedTypeMap::
elementOf_GGS_collectedTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_collectedTypeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_collectedTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_collectedTypeMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_collectedTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_collectedTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isNotEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
insertElement (C_Compiler & inLexique,
                const utf32 * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_collectedTypeMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
searchElement (C_Compiler & inLexique,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                  kSearchMessage_searchKey,
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 kInsertMessage_insertKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_collectedTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_collectedTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @collectedTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMap * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMap * p = dynamic_cast <const GGS_collectedTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    map index '@collectedTypeMapIndex'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMapIndex ("collectedTypeMapIndex", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::
constructor_null (C_Compiler & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMapIndex::
operator_isEqual (const GGS_collectedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMapIndex::
operator_isNotEqual (const GGS_collectedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState)) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMapIndex::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapindex @collectedTypeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMapIndex::
class_method_makeRegularIndex (C_Compiler & /* inLexique*/ ,
                               const GGS_lstring & inKey,
                               GGS_collectedTypeMap & ioMap,
                               GGS_collectedTypeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::constructor_searchKey (C_Compiler & inLexique,
              const GGS_collectedTypeMap & inMap,
              const GGS_lstring & inKey
              COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  result.mState = kRegular ;
  result.mKey = inKey ;
  inMap.searchIndex (inLexique, inKey, GGS_collectedTypeMap::kSearchMessage_searchKey, result.mIndex COMMA_THERE) ;
  if (result.mIndex.retrieve () == NULL) {
    result.drop () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMapIndex::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMapIndex * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMapIndex (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMapIndex * p = dynamic_cast <const GGS_collectedTypeMapIndex *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMapIndex, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMapIndex::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMapIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "collectAttributeTypes"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_collectAttributeTypes (C_Compiler & inLexique,
                                const GGS_attributeInCollectionListAST   var_cas_inAttributeList,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_collectAttributeTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_attributeInCollectionListAST::cEnumerator enumerator_10330 (var_cas_inAttributeList, true) ;
    const GGS_attributeInCollectionListAST::cElement * operand_10330 = NULL ;
    while (((operand_10330 = enumerator_10330.nextObject ()))) {
      macroValidPointer (operand_10330) ;
      GGS_collectedTypeMapIndex  automatic_var_10423_0 ;
      GGS_collectedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_10330->mAttributeTypeName, var_cas_ioCollectedTypeMap, automatic_var_10423_0 COMMA_SOURCE_FILE_AT_LINE (202)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_collectAttributeTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@semanticDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__collectType (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_10578,
                                GGS_collectedTypeMap  & /* var_cas_ioCollectedTypeMap */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10578 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@semanticDeclarationAST.collectType'   *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__collectType> gDispatchTableForMethod__semanticDeclarationAST__collectType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__collectType (typeCategoryMethod__semanticDeclarationAST__collectType inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__collectType.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__collectType
findCategoryMethod__semanticDeclarationAST__collectType (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__collectType result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__collectType.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__collectType (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__collectType (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__collectType.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@genericTypeTypeAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__genericTypeTypeAST__collectType (C_Compiler & inLexique,
                                const cPtr_genericTypeTypeAST * operand_10769,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10769 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_10769->mTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (218)) COMMA_SOURCE_FILE_AT_LINE (218)) ;
    const GGS_bool cond_11029 = (operand_10769->mSuperTypeName).operator_isNotEqual (GGS_string ("")) ;
    if (cond_11029.isBuiltAndTrue ()) {
      GGS_collectedTypeMapIndex  automatic_var_11021_0 ;
      GGS_collectedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, operand_10769->mSuperTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (220)), var_cas_ioCollectedTypeMap, automatic_var_11021_0 COMMA_SOURCE_FILE_AT_LINE (220)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@predefinedTypeAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__collectType (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_11174,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11174 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_11174->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (229)) COMMA_SOURCE_FILE_AT_LINE (229)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@mapDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_11437,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11437 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_11437->mMapTypeName COMMA_SOURCE_FILE_AT_LINE (237)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_11437->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (238)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@mapindexDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapindexDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_mapindexDeclarationAST * operand_11739,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11739 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_11739->mMapIndexTypeName COMMA_SOURCE_FILE_AT_LINE (246)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@enumDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_11979,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11979 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_11979->mEnumTypeName COMMA_SOURCE_FILE_AT_LINE (254)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@sortedListDeclarationAST.collectType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_12221,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12221 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_12221->mSortedListTypeName COMMA_SOURCE_FILE_AT_LINE (262)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_12221->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (263)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@structDeclarationAST.collectType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_12528,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12528 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_12528->mStructTypeName COMMA_SOURCE_FILE_AT_LINE (271)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_12528->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (272)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listDeclarationAST.collectType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_12829,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12829 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_12829->mListTypeName COMMA_SOURCE_FILE_AT_LINE (280)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_12829->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (281)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@classDeclarationAST.collectType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_13129,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13129 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_13129->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (289)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_13129->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (290)) ;
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_13318 (operand_13129->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_13318 = NULL ;
      while (((operand_13318 = enumerator_13318.nextObject ()))) {
        macroValidPointer (operand_13318) ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_13344 (operand_13318->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_13344 = NULL ;
          while (((operand_13344 = enumerator_13344.nextObject ()))) {
            macroValidPointer (operand_13344) ;
            GGS_collectedTypeMapIndex  automatic_var_13445_0 ;
            GGS_collectedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_13344->mFormalParameterTypeName, var_cas_ioCollectedTypeMap, automatic_var_13445_0 COMMA_SOURCE_FILE_AT_LINE (293)) ;
          }
        }
      }
    }
    {
      GGS_overridenMethodDefinitionListAST::cEnumerator enumerator_13512 (operand_13129->mOverridenMethodList, true) ;
      const GGS_overridenMethodDefinitionListAST::cElement * operand_13512 = NULL ;
      while (((operand_13512 = enumerator_13512.nextObject ()))) {
        macroValidPointer (operand_13512) ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_13538 (operand_13512->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_13538 = NULL ;
          while (((operand_13538 = enumerator_13538.nextObject ()))) {
            macroValidPointer (operand_13538) ;
            GGS_collectedTypeMapIndex  automatic_var_13639_0 ;
            GGS_collectedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_13538->mFormalParameterTypeName, var_cas_ioCollectedTypeMap, automatic_var_13639_0 COMMA_SOURCE_FILE_AT_LINE (298)) ;
          }
        }
      }
    }
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_13697 (operand_13129->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_13697 = NULL ;
      while (((operand_13697 = enumerator_13697.nextObject ()))) {
        macroValidPointer (operand_13697) ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_13723 (operand_13697->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_13723 = NULL ;
          while (((operand_13723 = enumerator_13723.nextObject ()))) {
            macroValidPointer (operand_13723) ;
            GGS_collectedTypeMapIndex  automatic_var_13824_0 ;
            GGS_collectedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_13723->mFormalParameterTypeName, var_cas_ioCollectedTypeMap, automatic_var_13824_0 COMMA_SOURCE_FILE_AT_LINE (303)) ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@listmapDeclarationAST.collectType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__collectType (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_14004,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14004 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_14004->mListmapTypeName COMMA_SOURCE_FILE_AT_LINE (313)) ;
    GGS_collectedTypeMapIndex  automatic_var_14195_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_14004->mAssociatedListTypeName, var_cas_ioCollectedTypeMap, automatic_var_14195_0 COMMA_SOURCE_FILE_AT_LINE (314)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Virtual Table for category method '@semanticDeclarationAST.enterType'    *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterType> gDispatchTableForMethod__semanticDeclarationAST__enterType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterType (typeCategoryMethod__semanticDeclarationAST__enterType inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterType.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterType
findCategoryMethod__semanticDeclarationAST__enterType (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterType result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterType.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__enterType (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__enterType (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__enterType.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@predefinedTypeAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_14825,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14825 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    GGS_predefinedTypeAST  var_cas_t = operand_14825 ;
    const GGS_predefinedTypeAST  temp_15105 = var_cas_t ;
    if (temp_15105.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getConstructorMap method = findCategoryMethod__predefinedTypeAST__getConstructorMap (temp_15105.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15105 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (338)) ;
      }
    }
    const GGS_predefinedTypeAST  temp_15172 = var_cas_t ;
    if (temp_15172.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getReaderMap method = findCategoryMethod__predefinedTypeAST__getReaderMap (temp_15172.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15172 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (339)) ;
      }
    }
    const GGS_predefinedTypeAST  temp_15236 = var_cas_t ;
    if (temp_15236.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getModifierMap method = findCategoryMethod__predefinedTypeAST__getModifierMap (temp_15236.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15236 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (340)) ;
      }
    }
    const GGS_predefinedTypeAST  temp_15308 = var_cas_t ;
    if (temp_15308.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap method = findCategoryMethod__predefinedTypeAST__getInstanceMethodMap (temp_15308.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15308 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_instanceMethodMap COMMA_SOURCE_FILE_AT_LINE (341)) ;
      }
    }
    const GGS_predefinedTypeAST  temp_15383 = var_cas_t ;
    if (temp_15383.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getClassMethodMap method = findCategoryMethod__predefinedTypeAST__getClassMethodMap (temp_15383.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15383 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_classMethodMap COMMA_SOURCE_FILE_AT_LINE (342)) ;
      }
    }
    GGS_unifiedTypeMapIndexList  var_cas_addAssignArgumentList ;
    const GGS_predefinedTypeAST  temp_15513 = var_cas_t ;
    if (temp_15513.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList method = findCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (temp_15513.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15513 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_addAssignArgumentList COMMA_SOURCE_FILE_AT_LINE (344)) ;
      }
    }
    GGS_unifiedTypeMapIndexList  var_cas_minusAssignArgumentList ;
    const GGS_predefinedTypeAST  temp_15654 = var_cas_t ;
    if (temp_15654.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList method = findCategoryMethod__predefinedTypeAST__getMinusAssignArgumentList (temp_15654.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15654 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_minusAssignArgumentList COMMA_SOURCE_FILE_AT_LINE (346)) ;
      }
    }
    GGS_enumerationDescriptorList  var_cas_enumerationList ;
    const GGS_predefinedTypeAST  temp_15783 = var_cas_t ;
    if (temp_15783.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getEnumerationList method = findCategoryMethod__predefinedTypeAST__getEnumerationList (temp_15783.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15783 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_enumerationList COMMA_SOURCE_FILE_AT_LINE (348)) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    const GGS_predefinedTypeAST  temp_15891 = var_cas_t ;
    if (temp_15891.isBuilt ()) {
      typeCategoryMethod__predefinedTypeAST__getSuperType method = findCategoryMethod__predefinedTypeAST__getSuperType (temp_15891.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, temp_15891 (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (350)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_14825->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (352)), GGS_bool (true), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_primitiveType (inLexique COMMA_SOURCE_FILE_AT_LINE (355)), GGS_typedAttributeList ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, var_cas_classMethodMap, var_cas_enumerationList, (findCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (var_cas_t (HERE)->galgasRTTI ()) (inLexique, var_cas_t.getPtr () COMMA_SOURCE_FILE_AT_LINE (364))), var_cas_addAssignArgumentList, var_cas_minusAssignArgumentList, (findCategoryReader__predefinedTypeAST__getNativeAttributeList (var_cas_t (HERE)->galgasRTTI ()) (inLexique, var_cas_t.getPtr () COMMA_SOURCE_FILE_AT_LINE (367))) COMMA_SOURCE_FILE_AT_LINE (351)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@genericTypeTypeAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__genericTypeTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_genericTypeTypeAST * operand_16569,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16569 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    const GGS_bool cond_16933 = (operand_16569->mSuperTypeName).operator_isEqual (GGS_string ("")) ;
    if (cond_16933.isBuiltAndTrue ()) {
      var_cas_superTypeIndex = GGS_unifiedTypeMapIndex ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (382)) ;
    }else if (cond_16933.isBuiltAndFalse ()) {
      GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, operand_16569->mSuperTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (384)), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (384)) ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (387)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (389)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (392)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (394)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_16569->mTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (397)), GGS_bool (false), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (400)), GGS_typedAttributeList ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (407)), GGS_enumerationDescriptorList ::constructor_emptyList (), GGS_uint (0U), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (396)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@mapDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_18097,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_18097 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (421)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (422)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (423)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (424)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndex  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (428)), var_cas_ioSemanticContext.mTypeMap, var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (428)) ;
    GGS_unifiedTypeMapIndex  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (431)), var_cas_ioSemanticContext.mTypeMap, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (431)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentMapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_18097->mMapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (434)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyMap"),  operand_18097->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (436)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (436)) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (438)) ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_insertMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (442))) ;
    GGS_formalParameterSignature  var_cas_removeMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (444))) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_19659 (operand_18097->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_19659 = NULL ;
      while (((operand_19659 = enumerator_19659.nextObject ()))) {
        macroValidPointer (operand_19659) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_19659->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (447)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_19659->mAttributeName) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_19659->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (449))) ;
        var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (450))) ;
        var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (451))) ;
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_20254 (operand_18097->mInsertMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_20254 = NULL ;
      while (((operand_20254 = enumerator_20254.nextObject ()))) {
        macroValidPointer (operand_20254) ;
        const GGS_bool cond_20409 = var_cas_modifierMap.reader_hasKey (operand_20254->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (455))) ;
        if (cond_20409.isBuiltAndTrue ()) {
          operand_20254->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_20254->mMethodName)).operator_concat (GGS_string ("' insert method is already declared")) COMMA_SOURCE_FILE_AT_LINE (457)) ;
        }else if (cond_20409.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_20254->mMethodName, var_cas_insertMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (458)) ;
        }
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_20617 (operand_18097->mRemoveMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_20617 = NULL ;
      while (((operand_20617 = enumerator_20617.nextObject ()))) {
        macroValidPointer (operand_20617) ;
        const GGS_bool cond_20808 = var_cas_modifierMap.reader_hasKey (operand_20617->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (467))) ;
        if (cond_20808.isBuiltAndTrue ()) {
          operand_20617->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_20617->mMethodName)).operator_concat (GGS_string ("' method is already declared as an insert modifier or a remove modifier")) COMMA_SOURCE_FILE_AT_LINE (469)) ;
        }else if (cond_20808.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_20617->mMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (470)) ;
        }
      }
    }
    {
      GGS_mapMethodListAST::cEnumerator enumerator_21014 (operand_18097->mSearchMethodList, true) ;
      const GGS_mapMethodListAST::cElement * operand_21014 = NULL ;
      while (((operand_21014 = enumerator_21014.nextObject ()))) {
        macroValidPointer (operand_21014) ;
        var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, operand_21014->mMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (479)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_21213 (operand_18097->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_21213 = NULL ;
      while (((operand_21213 = enumerator_21213.nextObject ()))) {
        macroValidPointer (operand_21213) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_21213->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (487))).operator_concat (GGS_string ("ForKey")), operand_21213->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (487)) COMMA_SOURCE_FILE_AT_LINE (487)) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_21213->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (489)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, GGS_unifiedTypeMapIndexList ::constructor_listWithValue (var_cas_stringTypeIndex), GGS_bool (true), var_cas_attributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (495)), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (490)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_21778 (operand_18097->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_21778 = NULL ;
      while (((operand_21778 = enumerator_21778.nextObject ()))) {
        macroValidPointer (operand_21778) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_21778->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("ForKey")), operand_21778->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (501)) COMMA_SOURCE_FILE_AT_LINE (501)) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_21778->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (503)) ;
        GGS_formalParameterSignature  var_cas_accessorFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (505))) ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (506))) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, var_cas_accessorFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (507)) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("map"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (515)), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (515)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_18097->mMapTypeName, GGS_bool (true), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_mapType (inLexique COMMA_SOURCE_FILE_AT_LINE (520)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (527)), var_cas_enumerationDescriptor, GGS_uint (0U), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (516)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@mapindexDeclarationAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapindexDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_mapindexDeclarationAST * operand_23283,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_23283 != NULL) {
    GGS_typedAttributeList  var_cas_mapTypedAttributeList ;
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_bool automatic_var_23586_0 ;
    GGS_unifiedTypeMapIndex  automatic_var_23586_1 ;
    GGS_typedAttributeList  automatic_var_23586_2 ;
    GGS_constructorMap  automatic_var_23586_3 ;
    GGS_readerMap  automatic_var_23586_4 ;
    GGS_modifierMap  automatic_var_23586_5 ;
    GGS_instanceMethodMap  automatic_var_23586_6 ;
    GGS_classMethodMap  automatic_var_23586_7 ;
    GGS_enumerationDescriptorList  automatic_var_23586_8 ;
    GGS_uint  automatic_var_23586_9 ;
    GGS_unifiedTypeMapIndexList  automatic_var_23586_10 ;
    GGS_unifiedTypeMapIndexList  automatic_var_23586_11 ;
    GGS_nativeAttributeList  automatic_var_23586_12 ;
    const GGS_unifiedTypeMap  temp_23485 = var_cas_ioSemanticContext.reader_mTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (544)) ;
    if (temp_23485.isBuilt ()) {
      temp_23485 (HERE)->method_searchKey (inLexique, operand_23283->mAssociatedMapTypeName, automatic_var_23586_0, automatic_var_23586_1, var_cas_typeKindEnum, automatic_var_23586_2, var_cas_mapTypedAttributeList, automatic_var_23586_3, automatic_var_23586_4, automatic_var_23586_5, automatic_var_23586_6, automatic_var_23586_7, automatic_var_23586_8, automatic_var_23586_9, automatic_var_23586_10, automatic_var_23586_11, automatic_var_23586_12 COMMA_SOURCE_FILE_AT_LINE (544)) ;
    }
    const GGS_bool cond_23803 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_mapType (inLexique COMMA_SOURCE_FILE_AT_LINE (552))) ;
    if (cond_23803.isBuiltAndTrue ()) {
      operand_23283->mAssociatedMapTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the @")).operator_concat (operand_23283->mAssociatedMapTypeName)).operator_concat (GGS_string (" should be a map type")) COMMA_SOURCE_FILE_AT_LINE (554)) ;
      var_cas_mapTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (557)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (558)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (559)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (560)) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (561)) ;
    GGS_unifiedTypeMapIndex  var_cas_associatedMapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_23283->mAssociatedMapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_associatedMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (564)) ;
    GGS_unifiedTypeMapIndex  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (567)), var_cas_ioSemanticContext.mTypeMap, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (567)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("lstring"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (570)), var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (570)) ;
    GGS_unifiedTypeMapIndex  var_cas_mapTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_23283->mMapIndexTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_mapTypeIndex COMMA_SOURCE_FILE_AT_LINE (573)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_argList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (576))) ;
    var_cas_argList.addAssign_operation (var_cas_associatedMapTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentInOut (inLexique COMMA_SOURCE_FILE_AT_LINE (577))) ;
    var_cas_argList.addAssign_operation (var_cas_currentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (578))) ;
    var_cas_classMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("makeRegularIndex"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (580)), var_cas_argList, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (579)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("null"),  operand_23283->mMapIndexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (585)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (585)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isSolved"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (587)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isNull"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (588)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_25682 (var_cas_mapTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_25682 = NULL ;
      while (((operand_25682 = enumerator_25682.nextObject ()))) {
        macroValidPointer (operand_25682) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_25682->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (591))).operator_concat (GGS_string ("ForKey")), operand_25682->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (591)) COMMA_SOURCE_FILE_AT_LINE (591)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_bool (true), operand_25682->mAttributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (597)), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (592)) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("root"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (604)), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (604)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_23283->mMapIndexTypeName, GGS_bool (true), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_SOURCE_FILE_AT_LINE (609)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_mapTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (616)), GGS_enumerationDescriptorList ::constructor_emptyList (), GGS_uint (0U), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (605)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@enumDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_26840,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_26840 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (631)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (632)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (633)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (634)) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (635)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_26840->mEnumTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (638)) ;
    {
      GGS_lstringlist::cEnumerator enumerator_27325 (operand_26840->mConstantList, true) ;
      const GGS_lstringlist::cElement * operand_27325 = NULL ;
      while (((operand_27325 = enumerator_27325.nextObject ()))) {
        macroValidPointer (operand_27325) ;
        ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  operand_27325->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (641)),  operand_26840->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (641)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (641)) ;
      }
    }
    {
      GGS_enumMessageListAST::cEnumerator enumerator_27517 (operand_26840->mEnumMessageList, true) ;
      const GGS_enumMessageListAST::cElement * operand_27517 = NULL ;
      while (((operand_27517 = enumerator_27517.nextObject ()))) {
        macroValidPointer (operand_27517) ;
        ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  operand_27517->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (645)),  GGS_string ("string"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (645)) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("enum"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (650)), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (650)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_26840->mEnumTypeName, GGS_bool (true), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_SOURCE_FILE_AT_LINE (655)), GGS_typedAttributeList ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (662)), GGS_enumerationDescriptorList ::constructor_emptyList (), GGS_uint (0U), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (651)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@filewrapperDeclarationAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__filewrapperDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_filewrapperDeclarationAST * operand_28516,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_28516 != NULL) {
    GGS_filewrapperTemplateMap  var_cas_filewrapperTemplateMap = GGS_filewrapperTemplateMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (676)) ;
    {
      GGS_filewrapperTemplateListAST::cEnumerator enumerator_28654 (operand_28516->mFilewrapperTemplateList, true) ;
      const GGS_filewrapperTemplateListAST::cElement * operand_28654 = NULL ;
      while (((operand_28654 = enumerator_28654.nextObject ()))) {
        macroValidPointer (operand_28654) ;
        GGS_unifiedTypeMapIndexList  var_cas_templateSignature = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
        {
          GGS_formalInputParameterListAST::cEnumerator enumerator_28772 (operand_28654->mFilewrapperTemplateFormalInputParameters, true) ;
          const GGS_formalInputParameterListAST::cElement * operand_28772 = NULL ;
          while (((operand_28772 = enumerator_28772.nextObject ()))) {
            macroValidPointer (operand_28772) ;
            GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
            GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_28772->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (681)) ;
            var_cas_templateSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
          }
        }
        var_cas_filewrapperTemplateMap.modifier_insertKey (inLexique, operand_28654->mFilewrapperTemplateName, var_cas_templateSignature, operand_28654->mFilewrapperTemplatePath COMMA_SOURCE_FILE_AT_LINE (684)) ;
      }
    }
    var_cas_ioSemanticContext.mFilewrapperMap.modifier_insertKey (inLexique, operand_28516->mFilewrapperName, operand_28516->mFilewrapperPath, operand_28516->mFilewrapperExtensionList, var_cas_filewrapperTemplateMap COMMA_SOURCE_FILE_AT_LINE (690)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@sortedListDeclarationAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_29471,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_29471 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_uintType ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (704)), var_cas_ioSemanticContext.mTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (704)) ;
    GGS_unifiedTypeMapIndex  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_29471->mSortedListTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (707)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_30146 (operand_29471->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_30146 = NULL ;
      while (((operand_30146 = enumerator_30146.nextObject ()))) {
        macroValidPointer (operand_30146) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_30146->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (715)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_30146->mAttributeName) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_30146->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (717))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_modifierFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (719))) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (722)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptySortedList"),  operand_29471->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (723)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (723)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (725)) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (726)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (728)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popGreatest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (730)), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (729)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popSmallest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (735)), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (734)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (740)) ;
    var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("greatest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (742)), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (741)) ;
    var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("smallest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (747)), var_cas_modifierFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (746)) ;
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sortedlist"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (754)), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (754)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_29471->mSortedListTypeName, GGS_bool (true), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_sortedListType (inLexique COMMA_SOURCE_FILE_AT_LINE (759)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (766)), var_cas_enumerationDescriptor, GGS_uint (0U), var_cas_constructorAttributeTypeList, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (755)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@structDeclarationAST.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_32432,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_32432 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_structTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_32432->mStructTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (782)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (784)) ;
    GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_32859 (operand_32432->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_32859 = NULL ;
      while (((operand_32859 = enumerator_32859.nextObject ()))) {
        macroValidPointer (operand_32859) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_32859->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (789)) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_32859->mAttributeName) ;
      }
    }
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (794)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (793)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (800)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_33371 (operand_32432->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_33371 = NULL ;
      while (((operand_33371 = enumerator_33371.nextObject ()))) {
        macroValidPointer (operand_33371) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_33371->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (803)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, operand_33371->mAttributeName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_bool (false), var_cas_attributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (809)), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (804)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (814)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (816)) ;
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("struct"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (819)), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (819)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_32432->mStructTypeName, GGS_bool (true), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_structType (inLexique COMMA_SOURCE_FILE_AT_LINE (824)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (831)), GGS_enumerationDescriptorList ::constructor_emptyList (), ((function_generateVirtualDestructor (inLexique COMMA_SOURCE_FILE_AT_LINE (833))).operator_or (function_generateCppConstructorWithAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (834)))).operator_or (function_generateDescriptionReaderUtilityMethod (inLexique COMMA_SOURCE_FILE_AT_LINE (835))), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (820)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@listDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_34812,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_34812 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_34956 (operand_34812->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_34956 = NULL ;
      while (((operand_34956 = enumerator_34956.nextObject ()))) {
        macroValidPointer (operand_34956) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_34956->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (851)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_34956->mAttributeName) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_uintType ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (856)), var_cas_ioSemanticContext.mTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (856)) ;
    GGS_unifiedTypeMapIndex  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_34812->mListTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (859)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierOutputFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierInputFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_35877 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_35877 = NULL ;
      while (((operand_35877 = enumerator_35877.nextObject ()))) {
        macroValidPointer (operand_35877) ;
        var_cas_enumerationDescriptor.addAssign_operation (operand_35877->mAttributeTypeIndex, operand_35877->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (866))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (operand_35877->mAttributeTypeIndex) ;
        var_cas_modifierOutputFormalArgumentList.addAssign_operation (operand_35877->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (868))) ;
        var_cas_modifierInputFormalArgumentList.addAssign_operation (operand_35877->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (869))) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (872)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyList"),  operand_34812->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (873)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (873)) ;
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("listWithValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (875)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (874)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (881)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (882)) ;
    ::routine_enterBaseReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("subListFromIndex"),  GGS_string ("uint"),  operand_34812->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (883)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (883)) ;
    ::routine_enterBaseReaderWith2Arguments (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("subListWithRange"),  GGS_string ("uint"),  GGS_string ("uint"),  operand_34812->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (884)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (884)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_37047 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_37047 = NULL ;
      while (((operand_37047 = enumerator_37047.nextObject ()))) {
        macroValidPointer (operand_37047) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, (operand_37047->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (887))).operator_concat (GGS_string ("AtIndex")), operand_37047->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (887)) COMMA_SOURCE_FILE_AT_LINE (887)), GGS_unifiedTypeMapIndexList ::constructor_listWithValue (var_cas_uintType), GGS_bool (true), operand_37047->mAttributeTypeIndex, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (891)), GGS_string ("") COMMA_SOURCE_FILE_AT_LINE (886)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (896)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popFirst"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (898)), var_cas_modifierOutputFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (897)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popLast"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (903)), var_cas_modifierOutputFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (902)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("prependValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (908)), var_cas_modifierInputFormalArgumentList, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (907)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_37796 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_37796 = NULL ;
      while (((operand_37796 = enumerator_37796.nextObject ()))) {
        macroValidPointer (operand_37796) ;
        GGS_formalParameterSignature  var_cas_setterFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_setterFormalArgumentList.addAssign_operation (operand_37796->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (914))) ;
        var_cas_setterFormalArgumentList.addAssign_operation (var_cas_uintType, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (915))) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_37796->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("AtIndex")), operand_37796->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (917)) COMMA_SOURCE_FILE_AT_LINE (917)), var_cas_setterFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (916)) ;
      }
    }
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (923)) ;
    var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("first"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (925)), var_cas_modifierOutputFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (924)) ;
    var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("last"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (930)), var_cas_modifierOutputFormalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (929)) ;
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("list"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (937)), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (937)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_34812->mListTypeName, GGS_bool (true), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (942)), var_cas_typedAttributeList, GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (949)), var_cas_enumerationDescriptor, (((function_binaryConcatOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (951))).operator_or (function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (951)))).operator_or (function_dotAssignOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (951)))).operator_or (function_generateCppConstructorWithNativeAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (951))), var_cas_constructorAttributeTypeList, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (938)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@classDeclarationAST.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_39559,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_39559 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_uintType ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (964)), var_cas_ioSemanticContext.mTypeMap, var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (964)) ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    GGS_typedAttributeList  var_cas_inheritedTypedAttributeList ;
    GGS_unifiedTypeMapIndex  var_cas_superClassIndex ;
    const GGS_bool cond_40435 = (operand_39559->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (973))).operator_isEqual (GGS_string ("")) ;
    if (cond_40435.isBuiltAndTrue ()) {
      GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("class"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (974)), var_cas_ioSemanticContext.mTypeMap, var_cas_superClassIndex COMMA_SOURCE_FILE_AT_LINE (974)) ;
      var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (975)) ;
      var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (976)) ;
      var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (977)) ;
      var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (978)) ;
      var_cas_inheritedTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }else if (cond_40435.isBuiltAndFalse ()) {
      GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_39559->mSuperClassName, var_cas_ioSemanticContext.mTypeMap, var_cas_superClassIndex COMMA_SOURCE_FILE_AT_LINE (981)) ;
      GGS_typeKindEnum var_cas_typeKindEnum ;
      GGS_bool automatic_var_40827_0 ;
      GGS_unifiedTypeMapIndex  automatic_var_40827_1 ;
      GGS_typedAttributeList  automatic_var_40827_2 ;
      GGS_constructorMap  automatic_var_40827_3 ;
      GGS_enumerationDescriptorList  automatic_var_40827_4 ;
      GGS_uint  automatic_var_40827_5 ;
      GGS_unifiedTypeMapIndexList  automatic_var_40827_6 ;
      GGS_unifiedTypeMapIndexList  automatic_var_40827_7 ;
      GGS_nativeAttributeList  automatic_var_40827_8 ;
      const GGS_unifiedTypeMap  temp_40622 = var_cas_ioSemanticContext.reader_mTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (983)) ;
      if (temp_40622.isBuilt ()) {
        temp_40622 (HERE)->method_searchKey (inLexique, operand_39559->mSuperClassName, automatic_var_40827_0, automatic_var_40827_1, var_cas_typeKindEnum, automatic_var_40827_2, var_cas_inheritedTypedAttributeList, automatic_var_40827_3, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, var_cas_classMethodMap, automatic_var_40827_4, automatic_var_40827_5, automatic_var_40827_6, automatic_var_40827_7, automatic_var_40827_8 COMMA_SOURCE_FILE_AT_LINE (983)) ;
      }
      const GGS_bool cond_40977 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (996))) ;
      if (cond_40977.isBuiltAndTrue ()) {
        operand_39559->mSuperClassName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the @")).operator_concat (operand_39559->mSuperClassName)).operator_concat (GGS_string (" should be a class type")) COMMA_SOURCE_FILE_AT_LINE (998)) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_classIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_39559->mClassTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1002)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1004)) ;
    const GGS_bool cond_41860 = (operand_39559->mIsAbstract).operator_not () ;
    if (cond_41860.isBuiltAndTrue ()) {
      GGS_unifiedTypeMapIndexList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
      {
        GGS_typedAttributeList::cEnumerator enumerator_41357 (var_cas_inheritedTypedAttributeList, true) ;
        const GGS_typedAttributeList::cElement * operand_41357 = NULL ;
        while (((operand_41357 = enumerator_41357.nextObject ()))) {
          macroValidPointer (operand_41357) ;
          var_cas_constructorAttributeTypeList.addAssign_operation (operand_41357->mAttributeTypeIndex) ;
        }
      }
      {
        GGS_attributeInCollectionListAST::cEnumerator enumerator_41466 (operand_39559->mAttributeList, true) ;
        const GGS_attributeInCollectionListAST::cElement * operand_41466 = NULL ;
        while (((operand_41466 = enumerator_41466.nextObject ()))) {
          macroValidPointer (operand_41466) ;
          GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
          GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_41466->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1012)) ;
          var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        }
      }
      var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1016)), var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1015)) ;
    }
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_41915 (operand_39559->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_41915 = NULL ;
      while (((operand_41915 = enumerator_41915.nextObject ()))) {
        macroValidPointer (operand_41915) ;
        GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_42004 (operand_41915->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_42004 = NULL ;
          while (((operand_42004 = enumerator_42004.nextObject ()))) {
            macroValidPointer (operand_42004) ;
            GGS_unifiedTypeMapIndex  var_cas_typeIndex ;
            GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_42004->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1027)) ;
            var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_42004->mFormalParameterPassingMode) ;
          }
        }
        var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, operand_41915->mMethodName, var_cas_formalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1030)) ;
      }
    }
    {
      GGS_overridenMethodDefinitionListAST::cEnumerator enumerator_42402 (operand_39559->mOverridenMethodList, true) ;
      const GGS_overridenMethodDefinitionListAST::cElement * operand_42402 = NULL ;
      while (((operand_42402 = enumerator_42402.nextObject ()))) {
        macroValidPointer (operand_42402) ;
        GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_42491 (operand_42402->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_42491 = NULL ;
          while (((operand_42491 = enumerator_42491.nextObject ()))) {
            macroValidPointer (operand_42491) ;
            GGS_unifiedTypeMapIndex  var_cas_typeIndex ;
            GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_42491->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1040)) ;
            var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_42491->mFormalParameterPassingMode) ;
          }
        }
        var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, operand_42402->mMethodName, var_cas_formalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1043)) ;
      }
    }
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_42880 (operand_39559->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_42880 = NULL ;
      while (((operand_42880 = enumerator_42880.nextObject ()))) {
        macroValidPointer (operand_42880) ;
        GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_42969 (operand_42880->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_42969 = NULL ;
          while (((operand_42969 = enumerator_42969.nextObject ()))) {
            macroValidPointer (operand_42969) ;
            GGS_unifiedTypeMapIndex  var_cas_typeIndex ;
            GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_42969->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1053)) ;
            var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_42969->mFormalParameterPassingMode) ;
          }
        }
        var_cas_instanceMethodMap.modifier_insertOrReplace (inLexique, operand_42880->mMethodName, var_cas_formalArgumentList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1056)) ;
      }
    }
    GGS_typedAttributeList  var_cas_currentClassTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_allTypedAttributeList = var_cas_inheritedTypedAttributeList ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_43531 (operand_39559->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_43531 = NULL ;
      while (((operand_43531 = enumerator_43531.nextObject ()))) {
        macroValidPointer (operand_43531) ;
        GGS_unifiedTypeMapIndex  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_43531->mAttributeTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1067)) ;
        var_cas_currentClassTypedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_43531->mAttributeName) ;
        var_cas_allTypedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_43531->mAttributeName) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_39559->mClassTypeName, (operand_39559->mIsAbstract).operator_not (), var_cas_superClassIndex, GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1077)), var_cas_allTypedAttributeList, var_cas_currentClassTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1084)), GGS_enumerationDescriptorList ::constructor_emptyList (), GGS_uint (0U), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (1073)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@externRoutineDeclarationAST.enterType'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_externRoutineDeclarationAST * operand_44549,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_44549 != NULL) {
    GGS_formalParameterSignature  var_cas_routineSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_44736 (operand_44549->mFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_44736 = NULL ;
      while (((operand_44736 = enumerator_44736.nextObject ()))) {
        macroValidPointer (operand_44736) ;
        GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_44736->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1102)) ;
        var_cas_routineSignature.addAssign_operation (var_cas_parameterTypeIndex, operand_44736->mFormalParameterPassingMode) ;
      }
    }
    var_cas_ioSemanticContext.mRoutineMap.modifier_insertKey (inLexique, operand_44549->mRoutineName, var_cas_routineSignature COMMA_SOURCE_FILE_AT_LINE (1106)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@externFunctionDeclarationAST.enterType'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_externFunctionDeclarationAST * operand_45262,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_45262 != NULL) {
    GGS_unifiedTypeMapIndexList  var_cas_functionSignature = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_45450 (operand_45262->mFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_45450 = NULL ;
      while (((operand_45450 = enumerator_45450.nextObject ()))) {
        macroValidPointer (operand_45450) ;
        GGS_unifiedTypeMapIndex  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_45450->mFormalParameterTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1118)) ;
        var_cas_functionSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_45262->mResultTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1123)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_45262->mFunctionName, var_cas_functionSignature, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1125)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@lazyFunctionDeclarationAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lazyFunctionDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_lazyFunctionDeclarationAST * operand_46133,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_46133 != NULL) {
    GGS_unifiedTypeMapIndex  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_46133->mResultTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1135)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_46133->mFunctionName, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1137)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listmapDeclarationAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_46637,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_46637 != NULL) {
    GGS_typedAttributeList  var_cas_listTypedAttributeList ;
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_bool automatic_var_46944_0 ;
    GGS_unifiedTypeMapIndex  automatic_var_46944_1 ;
    GGS_typedAttributeList  automatic_var_46944_2 ;
    GGS_constructorMap  automatic_var_46944_3 ;
    GGS_readerMap  automatic_var_46944_4 ;
    GGS_modifierMap  automatic_var_46944_5 ;
    GGS_instanceMethodMap  automatic_var_46944_6 ;
    GGS_classMethodMap  automatic_var_46944_7 ;
    GGS_enumerationDescriptorList  automatic_var_46944_8 ;
    GGS_uint  automatic_var_46944_9 ;
    GGS_unifiedTypeMapIndexList  automatic_var_46944_10 ;
    GGS_unifiedTypeMapIndexList  automatic_var_46944_11 ;
    GGS_nativeAttributeList  automatic_var_46944_12 ;
    const GGS_unifiedTypeMap  temp_46841 = var_cas_ioSemanticContext.reader_mTypeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1148)) ;
    if (temp_46841.isBuilt ()) {
      temp_46841 (HERE)->method_searchKey (inLexique, operand_46637->mAssociatedListTypeName, automatic_var_46944_0, automatic_var_46944_1, var_cas_typeKindEnum, automatic_var_46944_2, var_cas_listTypedAttributeList, automatic_var_46944_3, automatic_var_46944_4, automatic_var_46944_5, automatic_var_46944_6, automatic_var_46944_7, automatic_var_46944_8, automatic_var_46944_9, automatic_var_46944_10, automatic_var_46944_11, automatic_var_46944_12 COMMA_SOURCE_FILE_AT_LINE (1148)) ;
    }
    const GGS_bool cond_47173 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (1156))) ;
    if (cond_47173.isBuiltAndTrue ()) {
      operand_46637->mAssociatedListTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '@")).operator_concat (operand_46637->mAssociatedListTypeName)).operator_concat (GGS_string ("' type should be a list type")) COMMA_SOURCE_FILE_AT_LINE (1158)) ;
      var_cas_listTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1161)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1162)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1163)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1164)) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1165)) ;
    GGS_unifiedTypeMapIndex  var_cas_associatedListTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_46637->mAssociatedListTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_associatedListTypeIndex COMMA_SOURCE_FILE_AT_LINE (1168)) ;
    GGS_unifiedTypeMapIndex  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, operand_46637->mListmapTypeName, var_cas_ioSemanticContext.mTypeMap, var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (1171)) ;
    GGS_unifiedTypeMapIndex  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1174)), var_cas_ioSemanticContext.mTypeMap, var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1174)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1176)) ;
    GGS_enumerationDescriptorList  var_cas_enumeratorDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_stringTypeIndex, GGS_string ("key")) ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_associatedListTypeIndex, GGS_string ("value")) ;
    GGS_unifiedTypeMapIndexList  var_cas_addAssignOperatorDescription = GGS_unifiedTypeMapIndexList ::constructor_emptyList () ;
    var_cas_addAssignOperatorDescription.addAssign_operation (var_cas_stringTypeIndex) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_48497 (var_cas_listTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_48497 = NULL ;
      while (((operand_48497 = enumerator_48497.nextObject ()))) {
        macroValidPointer (operand_48497) ;
        var_cas_addAssignOperatorDescription.addAssign_operation (operand_48497->mAttributeTypeIndex) ;
      }
    }
    GGS_unifiedTypeMapIndex  var_cas_superTypeIndex ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("listmap"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1189)), var_cas_ioSemanticContext.mTypeMap, var_cas_superTypeIndex COMMA_SOURCE_FILE_AT_LINE (1189)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_46637->mListmapTypeName, GGS_bool (true), var_cas_superTypeIndex, GGS_typeKindEnum::constructor_mapIndexType (inLexique COMMA_SOURCE_FILE_AT_LINE (1194)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_listTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1201)), var_cas_enumeratorDescriptor, GGS_uint (0U), var_cas_addAssignOperatorDescription, GGS_unifiedTypeMapIndexList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList () COMMA_SOURCE_FILE_AT_LINE (1190)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@partiallyOrderedSemanticDeclarationListAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
elementOf_GGS_partiallyOrderedSemanticDeclarationListAST (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticDeclarationAST & argument_2):
mDependanceString (argument_0),
mTypeString (argument_1),
mSemanticDeclaration (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDependanceString.operator_isEqual (ptr->mDependanceString).boolValue ()
         && mTypeString.operator_isEqual (ptr->mTypeString).boolValue ()
         && mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * operand = (const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST *) inOperand ;
  PMSInt32 result = mDependanceString.genericObjectCompare (operand->mDependanceString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDependanceString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Sorted list '@partiallyOrderedSemanticDeclarationListAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST ("partiallyOrderedSemanticDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST::GGS_partiallyOrderedSemanticDeclarationListAST (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST::
GGS_partiallyOrderedSemanticDeclarationListAST (const GGS_partiallyOrderedSemanticDeclarationListAST & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_partiallyOrderedSemanticDeclarationListAST::
operator_isEqual (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_partiallyOrderedSemanticDeclarationListAST::
operator_isNotEqual (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_semanticDeclarationAST & argument_2) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticDeclarationAST & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST GGS_partiallyOrderedSemanticDeclarationListAST::
operator_concat (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  GGS_partiallyOrderedSemanticDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
dotAssign_operation (const GGS_partiallyOrderedSemanticDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mDependanceString ;
          GGS_string p_1 = p->mTypeString ;
          GGS_semanticDeclarationAST  p_2 = p->mSemanticDeclaration ;
          internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mDependanceString,
                                ptr->mTypeString,
                                ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST  GGS_partiallyOrderedSemanticDeclarationListAST::
constructor_emptySortedList (void) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST  GGS_partiallyOrderedSemanticDeclarationListAST::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_string& argument_1,
                           const GGS_semanticDeclarationAST & argument_2) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_partiallyOrderedSemanticDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@partiallyOrderedSemanticDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
method_smallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_semanticDeclarationAST & _out_2
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
method_greatest (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_semanticDeclarationAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_semanticDeclarationAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_semanticDeclarationAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mDependanceString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDependanceString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mTypeString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationAST  & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_partiallyOrderedSemanticDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_partiallyOrderedSemanticDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_partiallyOrderedSemanticDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST GGS_partiallyOrderedSemanticDeclarationListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_partiallyOrderedSemanticDeclarationListAST * p = dynamic_cast <const GGS_partiallyOrderedSemanticDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_partiallyOrderedSemanticDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_49963,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & /* var_cas_ioPartiallyOrderedDeclarationList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_49963 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@semanticDeclarationAST.enterOrderedDeclaration'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration> gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration
findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@predefinedTypeAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_predefinedTypeAST * operand_50206,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_50206 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string ("root"), operand_50206->mPredefinedTypeName, operand_50206) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@stringsetPredefinedTypeAST.enterOrderedDeclaration'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__stringsetPredefinedTypeAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_stringsetPredefinedTypeAST * operand_50527,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_50527 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string ("enumerable"), operand_50527->mPredefinedTypeName, operand_50527) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@genericTypeTypeAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__genericTypeTypeAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_genericTypeTypeAST * operand_50846,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_50846 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_50846->mSuperTypeName, operand_50846->mTypeName, operand_50846) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@classDeclarationAST.enterOrderedDeclaration'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_51158,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_51158 != NULL) {
    const GGS_string var_cas_actualSuperTypeName = (((operand_51158->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1260))).operator_isEqual (GGS_string (""))).isBuiltAndTrue () ? (GGS_string ("class")) : (operand_51158->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1260)))) ;
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (var_cas_actualSuperTypeName, operand_51158->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1261)), operand_51158) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@listDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_51610,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_51610 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string ("list"), operand_51610->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1269)), operand_51610) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@structDeclarationAST.enterOrderedDeclaration'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_51928,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_51928 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string ("struct"), operand_51928->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1277)), operand_51928) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@enumDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_52248,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_52248 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string ("enum"), operand_52248->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1285)), operand_52248) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@sortedListDeclarationAST.enterOrderedDeclaration'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_52570,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_52570 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string ("sortedlist"), operand_52570->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1293)), operand_52570) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@listmapDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_52901,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_52901 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_52901->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1301)), operand_52901->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1301)), operand_52901) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@mapDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_53245,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_53245 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string ("map"), operand_53245->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1309)), operand_53245) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@mapindexDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapindexDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_mapindexDeclarationAST * operand_53563,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_53563 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_53563->mAssociatedMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1317)), operand_53563->mMapIndexTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1317)), operand_53563) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildSemanticContext"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSemanticContext (C_Compiler & inLexique,
                                const GGS_semanticDeclarationListAST   var_cas_inSemanticDeclarationList,
                                const GGS_location   var_cas_inEndOfSourceFile,
                                GGS_semanticContext & var_cas_outSemanticContext COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildSemanticContext at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_collectedTypeMap  var_cas_collectedTypeMap = GGS_collectedTypeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1332)) ;
  {
    GGS_semanticDeclarationListAST::cEnumerator enumerator_54470 (var_cas_inSemanticDeclarationList, true) ;
    const GGS_semanticDeclarationListAST::cElement * operand_54470 = NULL ;
    while (((operand_54470 = enumerator_54470.nextObject ()))) {
      macroValidPointer (operand_54470) ;
      const GGS_semanticDeclarationAST  temp_54511 = operand_54470->mSemanticDeclaration ;
      if (temp_54511.isBuilt ()) {
        typeCategoryMethod__semanticDeclarationAST__collectType method = findCategoryMethod__semanticDeclarationAST__collectType (temp_54511.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, temp_54511 (HERE), var_cas_collectedTypeMap COMMA_SOURCE_FILE_AT_LINE (1334)) ;
        }
      }
    }
  }
  GGS_stringlist  var_cas_undefinedClasses = var_cas_collectedTypeMap.reader_unsolvedIndexKeyStringList (inLexique COMMA_SOURCE_FILE_AT_LINE (1337)) ;
  const GGS_bool cond_54914 = (var_cas_undefinedClasses.reader_length ()).operator_isEqual (GGS_uint (1U)) ;
  if (cond_54914.isBuiltAndTrue ()) {
    GGS_string var_cas_errorMessage = GGS_string ("there is 1 undefined type:") ;
    {
      GGS_stringlist::cEnumerator enumerator_54798 (var_cas_undefinedClasses, true) ;
      const GGS_stringlist::cElement * operand_54798 = NULL ;
      while (((operand_54798 = enumerator_54798.nextObject ()))) {
        macroValidPointer (operand_54798) ;
        var_cas_errorMessage.appendCString ("\n"
          "-  @") ;
        var_cas_errorMessage.dotAssign_operation (operand_54798->mValue) ;
      }
    }
    var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (1344)) ;
  }else if (cond_54914.isBuiltAndFalse ()) {
    const GGS_bool cond_55194 = (var_cas_undefinedClasses.reader_length ()).operator_strictSup (GGS_uint (1U)) ;
    if (cond_55194.isBuiltAndTrue ()) {
      GGS_string var_cas_errorMessage = ((GGS_string ("there are ")).operator_concat (var_cas_undefinedClasses.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1345)))).operator_concat (GGS_string (" undefined types:")) ;
      {
        GGS_stringlist::cEnumerator enumerator_55080 (var_cas_undefinedClasses, true) ;
        const GGS_stringlist::cElement * operand_55080 = NULL ;
        while (((operand_55080 = enumerator_55080.nextObject ()))) {
          macroValidPointer (operand_55080) ;
          var_cas_errorMessage.appendCString ("\n"
            "-  @") ;
          var_cas_errorMessage.dotAssign_operation (operand_55080->mValue) ;
        }
      }
      var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (1350)) ;
    }
  }
  GGS_partiallyOrderedSemanticDeclarationListAST  var_cas_partiallyOrderedSemanticDeclarationListAST = GGS_partiallyOrderedSemanticDeclarationListAST ::constructor_emptySortedList () ;
  const GGS_bool cond_55694 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (1356))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_55694.isBuiltAndTrue ()) {
    {
      GGS_semanticDeclarationListAST::cEnumerator enumerator_55565 (var_cas_inSemanticDeclarationList, true) ;
      const GGS_semanticDeclarationListAST::cElement * operand_55565 = NULL ;
      while (((operand_55565 = enumerator_55565.nextObject ()))) {
        macroValidPointer (operand_55565) ;
        const GGS_semanticDeclarationAST  temp_55620 = operand_55565->mSemanticDeclaration ;
        if (temp_55620.isBuilt ()) {
          typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration method = findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (temp_55620.galgasObjectRunTimeInfo ()) ;
          if (method != NULL) {
            method (inLexique, temp_55620 (HERE), var_cas_partiallyOrderedSemanticDeclarationListAST COMMA_SOURCE_FILE_AT_LINE (1358)) ;
          }
        }
      }
    }
  }
  GGS_semanticDeclarationListAST  var_cas_orderedSemanticDeclarationListAST = GGS_semanticDeclarationListAST ::constructor_emptyList () ;
  GGS_stringset  var_cas_alreadyDefinedTypes = GGS_stringset ::constructor_emptySet () ;
  var_cas_alreadyDefinedTypes.addAssign_operation (GGS_string ("")) ;
  GGS_bool var_cas_progress = GGS_bool (true) ;
  GGS_uint _variant_56703 = var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length () ;
  GGS_bool _condition_56703 (_variant_56703.isBuilt (), true) ;
  while (_condition_56703.isBuiltAndTrue ()) {
    _condition_56703 = ((var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U))).operator_and (var_cas_progress) ;
    if (_condition_56703.isBuiltAndTrue ()) {
      if (_variant_56703.uintValue () == 0) {
        inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1381)) ;
        _condition_56703 = GGS_bool (false) ;
      }else{
        _variant_56703.decrement_operation (inLexique COMMA_HERE) ;
        var_cas_progress = GGS_bool (false) ;
        const GGS_partiallyOrderedSemanticDeclarationListAST  var_cas_r = var_cas_partiallyOrderedSemanticDeclarationListAST ;
        var_cas_partiallyOrderedSemanticDeclarationListAST = GGS_partiallyOrderedSemanticDeclarationListAST ::constructor_emptySortedList () ;
        {
          GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_56283 (var_cas_r, true) ;
          const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_56283 = NULL ;
          while (((operand_56283 = enumerator_56283.nextObject ()))) {
            macroValidPointer (operand_56283) ;
            const GGS_bool cond_56554 = var_cas_alreadyDefinedTypes.reader_hasKey (operand_56283->mDependanceString) ;
            if (cond_56554.isBuiltAndTrue ()) {
              var_cas_orderedSemanticDeclarationListAST.addAssign_operation (operand_56283->mSemanticDeclaration) ;
              var_cas_alreadyDefinedTypes.addAssign_operation (operand_56283->mTypeString) ;
              var_cas_progress = GGS_bool (true) ;
            }else if (cond_56554.isBuiltAndFalse ()) {
              var_cas_partiallyOrderedSemanticDeclarationListAST.addAssign_operation (operand_56283->mDependanceString, operand_56283->mTypeString, operand_56283->mSemanticDeclaration) ;
            }
          }
        }
      }
    }
  }
  const GGS_bool cond_57270 = (var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
  if (cond_57270.isBuiltAndTrue ()) {
    GGS_string var_cas_s = GGS_string ("inheritance circularities involving the ") ;
    {
      GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_56982 (var_cas_partiallyOrderedSemanticDeclarationListAST, true) ;
      const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_56982 = enumerator_56982.nextObject () ;
      if ((operand_56982 != NULL)) {
        bool _foreach_loop_56982 ;
        do{
          macroValidPointer (operand_56982) ;
          var_cas_s.appendCString ("@") ;
          var_cas_s.dotAssign_operation (operand_56982->mTypeString) ;
          operand_56982 = enumerator_56982.nextObject () ;
          _foreach_loop_56982 = ((operand_56982 != NULL)) ;
          if (_foreach_loop_56982) {
            var_cas_s.appendCString (", ") ;
          }
        }while (_foreach_loop_56982) ;
      }
    }
    var_cas_s.appendCString (" classes; detail:") ;
    {
      GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_57145 (var_cas_partiallyOrderedSemanticDeclarationListAST, true) ;
      const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_57145 = NULL ;
      while (((operand_57145 = enumerator_57145.nextObject ()))) {
        macroValidPointer (operand_57145) ;
        var_cas_s.appendCString ("\n"
          "  - @") ;
        var_cas_s.dotAssign_operation (operand_57145->mTypeString) ;
        var_cas_s.appendCString (" inherits from @") ;
        var_cas_s.dotAssign_operation (operand_57145->mDependanceString) ;
      }
    }
    GGS_location (inLexique).reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_s COMMA_SOURCE_FILE_AT_LINE (1395)) ;
  }
  var_cas_outSemanticContext = GGS_semanticContext::constructor_new (GGS_unifiedTypeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1398)), GGS_routineMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1399)), GGS_functionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1400)), GGS_filewrapperMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1401)), var_cas_orderedSemanticDeclarationListAST) ;
  const GGS_bool cond_57872 = (GGS_uint ::constructor_errorCount (inLexique COMMA_SOURCE_FILE_AT_LINE (1405))).operator_isEqual (GGS_uint (0U)) ;
  if (cond_57872.isBuiltAndTrue ()) {
    {
      GGS_semanticDeclarationListAST::cEnumerator enumerator_57710 (var_cas_orderedSemanticDeclarationListAST, true) ;
      const GGS_semanticDeclarationListAST::cElement * operand_57710 = NULL ;
      while (((operand_57710 = enumerator_57710.nextObject ()))) {
        macroValidPointer (operand_57710) ;
        const GGS_semanticDeclarationAST  temp_57751 = operand_57710->mSemanticDeclaration ;
        if (temp_57751.isBuilt ()) {
          typeCategoryMethod__semanticDeclarationAST__enterType method = findCategoryMethod__semanticDeclarationAST__enterType (temp_57751.galgasObjectRunTimeInfo ()) ;
          if (method != NULL) {
            method (inLexique, temp_57751 (HERE), var_cas_outSemanticContext COMMA_SOURCE_FILE_AT_LINE (1408)) ;
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildSemanticContext\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticContext (void) {
  enterCategoryMethod__semanticDeclarationAST__collectType (category_method__semanticDeclarationAST__collectType, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__genericTypeTypeAST__collectType, gClassInfoFor__genericTypeTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__predefinedTypeAST__collectType, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__mapDeclarationAST__collectType, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__mapindexDeclarationAST__collectType, gClassInfoFor__mapindexDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__enumDeclarationAST__collectType, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__sortedListDeclarationAST__collectType, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__structDeclarationAST__collectType, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__listDeclarationAST__collectType, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__classDeclarationAST__collectType, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectType ((typeCategoryMethod__semanticDeclarationAST__collectType) category_method__listmapDeclarationAST__collectType, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__predefinedTypeAST__enterType, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__genericTypeTypeAST__enterType, gClassInfoFor__genericTypeTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__mapDeclarationAST__enterType, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__mapindexDeclarationAST__enterType, gClassInfoFor__mapindexDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__enumDeclarationAST__enterType, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__filewrapperDeclarationAST__enterType, gClassInfoFor__filewrapperDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__sortedListDeclarationAST__enterType, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__structDeclarationAST__enterType, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__listDeclarationAST__enterType, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__classDeclarationAST__enterType, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__externRoutineDeclarationAST__enterType, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__externFunctionDeclarationAST__enterType, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__lazyFunctionDeclarationAST__enterType, gClassInfoFor__lazyFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__listmapDeclarationAST__enterType, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (category_method__semanticDeclarationAST__enterOrderedDeclaration, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__predefinedTypeAST__enterOrderedDeclaration, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__stringsetPredefinedTypeAST__enterOrderedDeclaration, gClassInfoFor__stringsetPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__genericTypeTypeAST__enterOrderedDeclaration, gClassInfoFor__genericTypeTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__classDeclarationAST__enterOrderedDeclaration, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__listDeclarationAST__enterOrderedDeclaration, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__structDeclarationAST__enterOrderedDeclaration, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__enumDeclarationAST__enterOrderedDeclaration, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__sortedListDeclarationAST__enterOrderedDeclaration, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__listmapDeclarationAST__enterOrderedDeclaration, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__mapDeclarationAST__enterOrderedDeclaration, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__mapindexDeclarationAST__enterOrderedDeclaration, gClassInfoFor__mapindexDeclarationAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticContext (void) {
  gDispatchTableForMethod__semanticDeclarationAST__collectType.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterType.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticContext (prologueRoutineFor_semanticContext, epilogueRoutineFor_semanticContext) ;

//---------------------------------------------------------------------------*

