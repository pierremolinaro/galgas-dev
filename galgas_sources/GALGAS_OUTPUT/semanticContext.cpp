//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'semanticContext.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                    september 24th, 2010, at 15h10'59"                     *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticContext.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticContext.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_grammarLabelMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_grammarLabelMap::e_grammarLabelMap (void) :
mLabelSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@grammarLabelMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarLabelMap ("grammarLabelMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_grammarLabelMap::
elementOf_GGS_grammarLabelMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_grammarLabelMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_grammarLabelMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLabelSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_grammarLabelMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_grammarLabelMap * ptr = dynamic_cast <const elementOf_GGS_grammarLabelMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mLabelSignature.operator_isEqual (ptr->mInfo.mLabelSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_grammarLabelMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_grammarLabelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_grammarLabelMap * info = (e_grammarLabelMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_grammarLabelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_grammarLabelMap * info = (e_grammarLabelMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_grammarLabelMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_grammarLabelMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarLabelMap::
operator_isEqual (const GGS_grammarLabelMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarLabelMap::
operator_isNotEqual (const GGS_grammarLabelMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_formalParameterSignature & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_grammarLabelMap info  ;
    info.mLabelSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mLabelSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_grammarLabelMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_grammarLabelMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_grammarLabelMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_grammarLabelMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_grammarLabelMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarLabelMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @grammarLabelMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_grammarLabelMap::cEnumerator::_mLabelSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLabelSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_grammarLabelMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarLabelMap * p = NULL ;
    macroMyNew (p, GGS_grammarLabelMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarLabelMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarLabelMap * p = dynamic_cast <const GGS_grammarLabelMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarLabelMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarLabelMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarLabelMap ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_formalParameterSignature & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_grammarLabelMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_grammarMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_grammarMap::e_grammarMap (void) :
mLabelMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@grammarMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarMap ("grammarMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_grammarMap::
elementOf_GGS_grammarMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_grammarMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_grammarMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLabelMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_grammarMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_grammarMap * ptr = dynamic_cast <const elementOf_GGS_grammarMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mLabelMap.operator_isEqual (ptr->mInfo.mLabelMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_grammarMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_grammarMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_grammarMap * info = (e_grammarMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_grammarMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_grammarMap * info = (e_grammarMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_grammarMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_grammarMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarMap::
operator_isEqual (const GGS_grammarMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarMap::
operator_isNotEqual (const GGS_grammarMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_grammarLabelMap & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_grammarMap info  ;
    info.mLabelMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_grammarLabelMap   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mLabelMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_grammarMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_grammarMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_grammarLabelMap   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_grammarMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_grammarMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_grammarLabelMap & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_grammarMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_grammarMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_grammarMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @grammarMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_grammarLabelMap  & GGS_grammarMap::cEnumerator::_mLabelMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLabelMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_grammarMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarMap * p = NULL ;
    macroMyNew (p, GGS_grammarMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarMap * p = dynamic_cast <const GGS_grammarMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarMap ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_grammarLabelMap & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_grammarMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_routineMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineMap::e_routineMap (void) :
mRoutineSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@routineMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineMap ("routineMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_routineMap::
elementOf_GGS_routineMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_routineMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRoutineSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineMap * ptr = dynamic_cast <const elementOf_GGS_routineMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRoutineSignature.operator_isEqual (ptr->mInfo.mRoutineSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isNotEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_formalParameterSignature & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_routineMap info  ;
    info.mRoutineSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_routineMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @routineMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_routineMap::cEnumerator::_mRoutineSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRoutineSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_routineMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineMap * p = NULL ;
    macroMyNew (p, GGS_routineMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineMap * p = dynamic_cast <const GGS_routineMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineMap ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_formalParameterSignature & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_routineMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_functionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_functionMap::e_functionMap (void) :
mFunctionSignature (),
mResultType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@functionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionMap ("functionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_functionMap::
elementOf_GGS_functionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_functionMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_functionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFunctionSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mResultType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_functionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_functionMap * ptr = dynamic_cast <const elementOf_GGS_functionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFunctionSignature.operator_isEqual (ptr->mInfo.mFunctionSignature)).boolValue ()
           && (mInfo.mResultType.operator_isEqual (ptr->mInfo.mResultType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_functionMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_functionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isNotEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxyList & inParameter0,
               const GGS_unifiedTypeMapProxy & inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_functionMap info  ;
    info.mFunctionSignature = inParameter0 ;
    info.mResultType = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxyList   & outParameter0,
               GGS_unifiedTypeMapProxy   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mFunctionSignature ;
    outParameter1 = node->mInfo.mResultType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxyList   & outParameter0,
                                GGS_unifiedTypeMapProxy   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxyList & inParameter0,
                                const GGS_unifiedTypeMapProxy & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_functionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_functionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @functionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxyList  & GGS_functionMap::cEnumerator::_mFunctionSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFunctionSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_functionMap::cEnumerator::_mResultType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mResultType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_functionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionMap * p = NULL ;
    macroMyNew (p, GGS_functionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionMap * p = dynamic_cast <const GGS_functionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionMap ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxyList & inValue0,
                                             const GGS_unifiedTypeMapProxy & inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_functionMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_filewrapperTemplateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperTemplateMap::e_filewrapperTemplateMap (void) :
mTemplateSignature (),
mFilewrapperTemplatePath () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@filewrapperTemplateMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateMap ("filewrapperTemplateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateMap::
elementOf_GGS_filewrapperTemplateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperTemplateMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTemplateSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplatePath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperTemplateMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mTemplateSignature.operator_isEqual (ptr->mInfo.mTemplateSignature)).boolValue ()
           && (mInfo.mFilewrapperTemplatePath.operator_isEqual (ptr->mInfo.mFilewrapperTemplatePath)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperTemplateMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperTemplateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isNotEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxyList & inParameter0,
               const GGS_lstring & inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_filewrapperTemplateMap info  ;
    info.mTemplateSignature = inParameter0 ;
    info.mFilewrapperTemplatePath = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxyList   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mTemplateSignature ;
    outParameter1 = node->mInfo.mFilewrapperTemplatePath ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxyList   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxyList & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperTemplateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperTemplateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxyList  & GGS_filewrapperTemplateMap::cEnumerator::_mTemplateSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTemplateSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateMap::cEnumerator::_mFilewrapperTemplatePath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplatePath ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateMap * p = dynamic_cast <const GGS_filewrapperTemplateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxyList & inValue0,
                                             const GGS_lstring & inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_filewrapperMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperMap::e_filewrapperMap (void) :
mFilewrapperPath (),
mFilewrapperExtensionList (),
mFilewrapperTemplateMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@filewrapperMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperMap ("filewrapperMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperMap::
elementOf_GGS_filewrapperMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperPath.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperExtensionList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplateMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFilewrapperPath.operator_isEqual (ptr->mInfo.mFilewrapperPath)).boolValue ()
           && (mInfo.mFilewrapperExtensionList.operator_isEqual (ptr->mInfo.mFilewrapperExtensionList)).boolValue ()
           && (mInfo.mFilewrapperTemplateMap.operator_isEqual (ptr->mInfo.mFilewrapperTemplateMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isNotEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
               const GGS_lstringlist & inParameter1,
               const GGS_filewrapperTemplateMap & inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_filewrapperMap info  ;
    info.mFilewrapperPath = inParameter0 ;
    info.mFilewrapperExtensionList = inParameter1 ;
    info.mFilewrapperTemplateMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstringlist   & outParameter1,
               GGS_filewrapperTemplateMap   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mFilewrapperPath ;
    outParameter1 = node->mInfo.mFilewrapperExtensionList ;
    outParameter2 = node->mInfo.mFilewrapperTemplateMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstringlist   & outParameter1,
                                GGS_filewrapperTemplateMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstringlist & inParameter1,
                                const GGS_filewrapperTemplateMap & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_filewrapperMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperMap::cEnumerator::_mFilewrapperPath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperPath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_filewrapperMap::cEnumerator::_mFilewrapperExtensionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperExtensionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_filewrapperTemplateMap  & GGS_filewrapperMap::cEnumerator::_mFilewrapperTemplateMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperMap * p = dynamic_cast <const GGS_filewrapperMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperMap ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_lstring & inValue0,
                                             const GGS_lstringlist & inValue1,
                                             const GGS_filewrapperTemplateMap & inValue2
                                             COMMA_LOCATION_ARGS) {
  GGS_filewrapperMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'e_optionComponentMapForSemanticAnalysis'               *
//                                                                           *
//---------------------------------------------------------------------------*

e_optionComponentMapForSemanticAnalysis::e_optionComponentMapForSemanticAnalysis (void) :
mBoolOptionMap (),
mUIntOptionMap (),
mStringOptionMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class map '@optionComponentMapForSemanticAnalysis'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionComponentMapForSemanticAnalysis ("optionComponentMapForSemanticAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_optionComponentMapForSemanticAnalysis::
elementOf_GGS_optionComponentMapForSemanticAnalysis (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_optionComponentMapForSemanticAnalysis & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_optionComponentMapForSemanticAnalysis::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mBoolOptionMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mUIntOptionMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStringOptionMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_optionComponentMapForSemanticAnalysis::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_optionComponentMapForSemanticAnalysis * ptr = dynamic_cast <const elementOf_GGS_optionComponentMapForSemanticAnalysis *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mBoolOptionMap.operator_isEqual (ptr->mInfo.mBoolOptionMap)).boolValue ()
           && (mInfo.mUIntOptionMap.operator_isEqual (ptr->mInfo.mUIntOptionMap)).boolValue ()
           && (mInfo.mStringOptionMap.operator_isEqual (ptr->mInfo.mStringOptionMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_optionComponentMapForSemanticAnalysis::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_optionComponentMapForSemanticAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_optionComponentMapForSemanticAnalysis * info = (e_optionComponentMapForSemanticAnalysis *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_optionComponentMapForSemanticAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_optionComponentMapForSemanticAnalysis * info = (e_optionComponentMapForSemanticAnalysis *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_optionComponentMapForSemanticAnalysis result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_optionComponentMapForSemanticAnalysis info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_optionComponentMapForSemanticAnalysis::
operator_isEqual (const GGS_optionComponentMapForSemanticAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_optionComponentMapForSemanticAnalysis::
operator_isNotEqual (const GGS_optionComponentMapForSemanticAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_commandLineOptionMap & inParameter0,
               const GGS_commandLineOptionMap & inParameter1,
               const GGS_commandLineOptionMap & inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_optionComponentMapForSemanticAnalysis info  ;
    info.mBoolOptionMap = inParameter0 ;
    info.mUIntOptionMap = inParameter1 ;
    info.mStringOptionMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_commandLineOptionMap   & outParameter0,
               GGS_commandLineOptionMap   & outParameter1,
               GGS_commandLineOptionMap   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mBoolOptionMap ;
    outParameter1 = node->mInfo.mUIntOptionMap ;
    outParameter2 = node->mInfo.mStringOptionMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_optionComponentMapForSemanticAnalysis::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_commandLineOptionMap   & outParameter0,
                                GGS_commandLineOptionMap   & outParameter1,
                                GGS_commandLineOptionMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_optionComponentMapForSemanticAnalysis::kInsertMessage_insertKey [] = {
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('f'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (':'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_commandLineOptionMap & inParameter0,
                                const GGS_commandLineOptionMap & inParameter1,
                                const GGS_commandLineOptionMap & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_optionComponentMapForSemanticAnalysis & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_optionComponentMapForSemanticAnalysis result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_optionComponentMapForSemanticAnalysis result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionComponentMapForSemanticAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @optionComponentMapForSemanticAnalysis " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_commandLineOptionMap  & GGS_optionComponentMapForSemanticAnalysis::cEnumerator::_mBoolOptionMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mBoolOptionMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_commandLineOptionMap  & GGS_optionComponentMapForSemanticAnalysis::cEnumerator::_mUIntOptionMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mUIntOptionMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_commandLineOptionMap  & GGS_optionComponentMapForSemanticAnalysis::cEnumerator::_mStringOptionMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStringOptionMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_optionComponentMapForSemanticAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionComponentMapForSemanticAnalysis * p = NULL ;
    macroMyNew (p, GGS_optionComponentMapForSemanticAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionComponentMapForSemanticAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionComponentMapForSemanticAnalysis * p = dynamic_cast <const GGS_optionComponentMapForSemanticAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionComponentMapForSemanticAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionComponentMapForSemanticAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionComponentMapForSemanticAnalysis ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_commandLineOptionMap & inValue0,
                                             const GGS_commandLineOptionMap & inValue1,
                                             const GGS_commandLineOptionMap & inValue2
                                             COMMA_LOCATION_ARGS) {
  GGS_optionComponentMapForSemanticAnalysis result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticContext ("semanticContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
mTypeMap (),
mRoutineMap (),
mFunctionMap (),
mFilewrapperMap (),
mGrammarMap (),
mOptionComponentMapForSemanticAnalysis () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::drop (void) {
  mTypeMap.drop () ;
  mRoutineMap.drop () ;
  mFunctionMap.drop () ;
  mFilewrapperMap.drop () ;
  mGrammarMap.drop () ;
  mOptionComponentMapForSemanticAnalysis.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::isBuilt (void) const {
  return mTypeMap.isBuilt ()
    && mRoutineMap.isBuilt ()
    && mFunctionMap.isBuilt ()
    && mFilewrapperMap.isBuilt ()
    && mGrammarMap.isBuilt ()
    && mOptionComponentMapForSemanticAnalysis.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isEqual (inOperand.mTypeMap)
    .operator_and (mRoutineMap.operator_isEqual (inOperand.mRoutineMap))
    .operator_and (mFunctionMap.operator_isEqual (inOperand.mFunctionMap))
    .operator_and (mFilewrapperMap.operator_isEqual (inOperand.mFilewrapperMap))
    .operator_and (mGrammarMap.operator_isEqual (inOperand.mGrammarMap))
    .operator_and (mOptionComponentMapForSemanticAnalysis.operator_isEqual (inOperand.mOptionComponentMapForSemanticAnalysis)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return mTypeMap.operator_isNotEqual (inOperand.mTypeMap)
    .operator_or (mRoutineMap.operator_isNotEqual (inOperand.mRoutineMap))
    .operator_or (mFunctionMap.operator_isNotEqual (inOperand.mFunctionMap))
    .operator_or (mFilewrapperMap.operator_isNotEqual (inOperand.mFilewrapperMap))
    .operator_or (mGrammarMap.operator_isNotEqual (inOperand.mGrammarMap))
    .operator_or (mOptionComponentMapForSemanticAnalysis.operator_isNotEqual (inOperand.mOptionComponentMapForSemanticAnalysis)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (const GGS_unifiedTypeMap & argument_0,
                 const GGS_routineMap & argument_1,
                 const GGS_functionMap & argument_2,
                 const GGS_filewrapperMap & argument_3,
                 const GGS_grammarMap & argument_4,
                 const GGS_optionComponentMapForSemanticAnalysis & argument_5) {
  GGS_semanticContext result ;
  result.mTypeMap = argument_0 ;
  result.mRoutineMap = argument_1 ;
  result.mFunctionMap = argument_2 ;
  result.mFilewrapperMap = argument_3 ;
  result.mGrammarMap = argument_4 ;
  result.mOptionComponentMapForSemanticAnalysis = argument_5 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mTypeMap " ;
    _s << mTypeMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineMap " ;
    _s << mRoutineMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFunctionMap " ;
    _s << mFunctionMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFilewrapperMap " ;
    _s << mFilewrapperMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mGrammarMap " ;
    _s << mGrammarMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOptionComponentMapForSemanticAnalysis " ;
    _s << mOptionComponentMapForSemanticAnalysis.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticContext * p = NULL ;
    macroMyNew (p, GGS_semanticContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticContext * p = dynamic_cast <const GGS_semanticContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticContext ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@collectedTypeMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMap ("collectedTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_collectedTypeMap::
elementOf_GGS_collectedTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_collectedTypeMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_collectedTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_collectedTypeMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_collectedTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_collectedTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isNotEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_collectedTypeMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_collectedTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_collectedTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @collectedTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMap * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMap * p = dynamic_cast <const GGS_collectedTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMap ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    map index '@collectedTypeMapIndex'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMapIndex ("collectedTypeMapIndex", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::
constructor_null (C_Compiler & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMapIndex::
operator_isEqual (const GGS_collectedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState) && (mIndex.retrieve () == inOperand.mIndex.retrieve ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMapIndex::
operator_isNotEqual (const GGS_collectedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState) || (mIndex.retrieve () != inOperand.mIndex.retrieve ())) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMapIndex::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapproxy @collectedTypeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\", " ;
    if (mIndex.retrieve () == NULL) {
      s << "deleted" ;
    }else if (mIndex.retrieve ()->mIsDefined) {
      s << "defined" ;
    }else{
      s << "unsolved" ;
    }
    s << ")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMapIndex::
class_method_makeRegularProxy (C_Compiler & /* inLexique*/ ,
                               GGS_collectedTypeMap & ioMap,
                               const GGS_string & inKey,
                               GGS_collectedTypeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::constructor_searchKey (C_Compiler & inLexique,
              const GGS_collectedTypeMap & inMap,
              const GGS_lstring & inKey
              COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  result.mState = kRegular ;
  result.mKey = inKey.ggs_string () ;
  inMap.searchIndex (inLexique, inKey, GGS_collectedTypeMap::kSearchMessage_searchKey, result.mIndex COMMA_THERE) ;
  if (result.mIndex.retrieve () == NULL) {
    result.drop () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMapIndex::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMapIndex * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMapIndex (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMapIndex * p = dynamic_cast <const GGS_collectedTypeMapIndex *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMapIndex, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMapIndex::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMapIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_multiMethodMapForType'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_multiMethodMapForType::e_multiMethodMapForType (void) :
mFormalParameterList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@multiMethodMapForType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiMethodMapForType ("multiMethodMapForType", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_multiMethodMapForType::
elementOf_GGS_multiMethodMapForType (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_multiMethodMapForType & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_multiMethodMapForType::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_multiMethodMapForType::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_multiMethodMapForType * ptr = dynamic_cast <const elementOf_GGS_multiMethodMapForType *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFormalParameterList.operator_isEqual (ptr->mInfo.mFormalParameterList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_multiMethodMapForType::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_multiMethodMapForType *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_multiMethodMapForType * info = (e_multiMethodMapForType *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForType::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_multiMethodMapForType *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_multiMethodMapForType * info = (e_multiMethodMapForType *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForType GGS_multiMethodMapForType::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_multiMethodMapForType result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForType::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_multiMethodMapForType info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_multiMethodMapForType::
operator_isEqual (const GGS_multiMethodMapForType & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_multiMethodMapForType::
operator_isNotEqual (const GGS_multiMethodMapForType & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForType::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForType::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_formalParameterListAST & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_multiMethodMapForType info  ;
    info.mFormalParameterList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForType::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterListAST   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mFormalParameterList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForType GGS_multiMethodMapForType::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_multiMethodMapForType & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_multiMethodMapForType result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForType GGS_multiMethodMapForType::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_multiMethodMapForType result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiMethodMapForType::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @multiMethodMapForType " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_multiMethodMapForType::cEnumerator::_mFormalParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalParameterList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiMethodMapForType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiMethodMapForType * p = NULL ;
    macroMyNew (p, GGS_multiMethodMapForType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForType GGS_multiMethodMapForType::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiMethodMapForType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiMethodMapForType * p = dynamic_cast <const GGS_multiMethodMapForType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiMethodMapForType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiMethodMapForType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiMethodMapForType ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForType::modifier_insertOrReplace (C_Compiler & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterListAST &  inParameter0 COMMA_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()) {
    insulateMap (THERE) ;
    e_multiMethodMapForType info ;
    info.mFormalParameterList =  inParameter0 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForType GGS_multiMethodMapForType::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_formalParameterListAST & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_multiMethodMapForType result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'e_multiMethodMapForBuildingContext'                 *
//                                                                           *
//---------------------------------------------------------------------------*

e_multiMethodMapForBuildingContext::e_multiMethodMapForBuildingContext (void) :
mMultiMethodMapForType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class map '@multiMethodMapForBuildingContext'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_multiMethodMapForBuildingContext ("multiMethodMapForBuildingContext", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_multiMethodMapForBuildingContext::
elementOf_GGS_multiMethodMapForBuildingContext (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_multiMethodMapForBuildingContext & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_multiMethodMapForBuildingContext::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMultiMethodMapForType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_multiMethodMapForBuildingContext::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_multiMethodMapForBuildingContext * ptr = dynamic_cast <const elementOf_GGS_multiMethodMapForBuildingContext *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMultiMethodMapForType.operator_isEqual (ptr->mInfo.mMultiMethodMapForType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_multiMethodMapForBuildingContext::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_multiMethodMapForBuildingContext *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_multiMethodMapForBuildingContext * info = (e_multiMethodMapForBuildingContext *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForBuildingContext::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_multiMethodMapForBuildingContext *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_multiMethodMapForBuildingContext * info = (e_multiMethodMapForBuildingContext *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForBuildingContext GGS_multiMethodMapForBuildingContext::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_multiMethodMapForBuildingContext result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForBuildingContext::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_multiMethodMapForBuildingContext info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_multiMethodMapForBuildingContext::
operator_isEqual (const GGS_multiMethodMapForBuildingContext & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_multiMethodMapForBuildingContext::
operator_isNotEqual (const GGS_multiMethodMapForBuildingContext & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForBuildingContext::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForBuildingContext::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_multiMethodMapForType & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_multiMethodMapForBuildingContext info  ;
    info.mMultiMethodMapForType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForBuildingContext::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_multiMethodMapForType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mMultiMethodMapForType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_multiMethodMapForBuildingContext::kSearchMessage_searchKey [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForBuildingContext::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_multiMethodMapForType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_multiMethodMapForBuildingContext::kInsertMessage_insertKey [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_multiMethodMapForBuildingContext::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_multiMethodMapForType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForBuildingContext GGS_multiMethodMapForBuildingContext::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_multiMethodMapForBuildingContext & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_multiMethodMapForBuildingContext result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForBuildingContext GGS_multiMethodMapForBuildingContext::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_multiMethodMapForBuildingContext result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_multiMethodMapForBuildingContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @multiMethodMapForBuildingContext " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_multiMethodMapForType  & GGS_multiMethodMapForBuildingContext::cEnumerator::_mMultiMethodMapForType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMultiMethodMapForType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_multiMethodMapForBuildingContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_multiMethodMapForBuildingContext * p = NULL ;
    macroMyNew (p, GGS_multiMethodMapForBuildingContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForBuildingContext GGS_multiMethodMapForBuildingContext::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_multiMethodMapForBuildingContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_multiMethodMapForBuildingContext * p = dynamic_cast <const GGS_multiMethodMapForBuildingContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_multiMethodMapForBuildingContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_multiMethodMapForBuildingContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_multiMethodMapForBuildingContext ;
}

//---------------------------------------------------------------------------*

GGS_multiMethodMapForBuildingContext GGS_multiMethodMapForBuildingContext::constructor_mapWithKeyAndValue (C_Compiler & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_multiMethodMapForType & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_multiMethodMapForBuildingContext result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "collectAttributeTypes"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_collectAttributeTypes (C_Compiler & inLexique,
                                const GGS_attributeInCollectionListAST   var_cas_inAttributeList,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_collectAttributeTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_attributeInCollectionListAST::cEnumerator enumerator_8240 (var_cas_inAttributeList, true) ;
    const GGS_attributeInCollectionListAST::cElement * operand_8240 = NULL ;
    while (((operand_8240 = enumerator_8240.nextObject ()))) {
      macroValidPointer (operand_8240) ;
      GGS_collectedTypeMapIndex  automatic_var_8342_0 ;
      GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_8240->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (169)), automatic_var_8342_0 COMMA_SOURCE_FILE_AT_LINE (169)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_collectAttributeTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@semanticDeclarationAST.collectTypes'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__collectTypes (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_8498,
                                GGS_collectedTypeMap  & /* var_cas_ioCollectedTypeMap */,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8498 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@semanticDeclarationAST.collectTypes'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__collectTypes> gDispatchTableForMethod__semanticDeclarationAST__collectTypes ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__collectTypes (typeCategoryMethod__semanticDeclarationAST__collectTypes inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__collectTypes.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__collectTypes
findCategoryMethod__semanticDeclarationAST__collectTypes (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__collectTypes result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__collectTypes.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__collectTypes (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (NULL == result) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__collectTypes (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__collectTypes.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@genericTypeTypeAST.collectTypes'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__genericTypeTypeAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_genericTypeTypeAST * operand_8770,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8770 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_8770->mTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (187)) COMMA_SOURCE_FILE_AT_LINE (187)) ;
    const GGS_bool cond_9088 = (operand_8770->mSuperTypeName).operator_isNotEqual (GGS_string ("")) ;
    if (cond_9088.isBuiltAndTrue ()) {
      GGS_collectedTypeMapIndex  automatic_var_9080_0 ;
      GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_8770->mSuperTypeName, automatic_var_9080_0 COMMA_SOURCE_FILE_AT_LINE (189)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@abstracMultiMethodAST.collectTypes'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstracMultiMethodAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_abstracMultiMethodAST * operand_9238,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & var_cas_ioMultiMethodMapForBuildingContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_9238 != NULL) {
    {
      GGS_formalParameterListAST::cEnumerator enumerator_9431 (operand_9238->mAbstractMultiMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_9431 = NULL ;
      while (((operand_9431 = enumerator_9431.nextObject ()))) {
        macroValidPointer (operand_9431) ;
        GGS_collectedTypeMapIndex  automatic_var_9538_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_9431->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (201)), automatic_var_9538_0 COMMA_SOURCE_FILE_AT_LINE (201)) ;
      }
    }
    const GGS_bool cond_9763 = (var_cas_ioMultiMethodMapForBuildingContext.reader_hasKey (operand_9238->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (204)))).operator_not () ;
    if (cond_9763.isBuiltAndTrue ()) {
      var_cas_ioMultiMethodMapForBuildingContext.modifier_insertKey (inLexique, operand_9238->mTypeName, GGS_multiMethodMapForType ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (207)) COMMA_SOURCE_FILE_AT_LINE (205)) ;
    }
    elementOf_GGS_multiMethodMapForBuildingContext * operand_9812 = (elementOf_GGS_multiMethodMapForBuildingContext *) var_cas_ioMultiMethodMapForBuildingContext.searchForWithInstruction (inLexique, operand_9238->mTypeName, GGS_multiMethodMapForBuildingContext::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (210)) ;
    if (NULL != operand_9812) {
      operand_9812->mInfo.mMultiMethodMapForType.modifier_insertOrReplace (inLexique, operand_9238->mAbstractMultiMethodName, operand_9238->mAbstractMultiMethodFormalParameterList COMMA_SOURCE_FILE_AT_LINE (211)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@multiMethodAST.collectTypes'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__multiMethodAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_multiMethodAST * operand_10120,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & var_cas_ioMultiMethodMapForBuildingContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10120 != NULL) {
    {
      GGS_formalParameterListAST::cEnumerator enumerator_10305 (operand_10120->mMultiMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_10305 = NULL ;
      while (((operand_10305 = enumerator_10305.nextObject ()))) {
        macroValidPointer (operand_10305) ;
        GGS_collectedTypeMapIndex  automatic_var_10412_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_10305->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (226)), automatic_var_10412_0 COMMA_SOURCE_FILE_AT_LINE (226)) ;
      }
    }
    const GGS_bool cond_10637 = (var_cas_ioMultiMethodMapForBuildingContext.reader_hasKey (operand_10120->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (229)))).operator_not () ;
    if (cond_10637.isBuiltAndTrue ()) {
      var_cas_ioMultiMethodMapForBuildingContext.modifier_insertKey (inLexique, operand_10120->mTypeName, GGS_multiMethodMapForType ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (232)) COMMA_SOURCE_FILE_AT_LINE (230)) ;
    }
    elementOf_GGS_multiMethodMapForBuildingContext * operand_10686 = (elementOf_GGS_multiMethodMapForBuildingContext *) var_cas_ioMultiMethodMapForBuildingContext.searchForWithInstruction (inLexique, operand_10120->mTypeName, GGS_multiMethodMapForBuildingContext::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (235)) ;
    if (NULL != operand_10686) {
      operand_10686->mInfo.mMultiMethodMapForType.modifier_insertOrReplace (inLexique, operand_10120->mMultiMethodName, operand_10120->mMultiMethodFormalParameterList COMMA_SOURCE_FILE_AT_LINE (236)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@overridingMultiMethodAST.collectTypes'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingMultiMethodAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_overridingMultiMethodAST * operand_10988,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10988 != NULL) {
    {
      GGS_formalParameterListAST::cEnumerator enumerator_11190 (operand_10988->mOverridingMultiMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_11190 = NULL ;
      while (((operand_11190 = enumerator_11190.nextObject ()))) {
        macroValidPointer (operand_11190) ;
        GGS_collectedTypeMapIndex  automatic_var_11297_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_11190->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (251)), automatic_var_11297_0 COMMA_SOURCE_FILE_AT_LINE (251)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@abstractMultiReaderAST.collectTypes'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractMultiReaderAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_abstractMultiReaderAST * operand_11461,
                                GGS_collectedTypeMap  & /* var_cas_ioCollectedTypeMap */,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11461 != NULL) {
    operand_11461->mAbstractMultiReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("@abstractMultiReaderAST collectTypes\n") COMMA_SOURCE_FILE_AT_LINE (262)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@multiReaderAST.collectTypes'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__multiReaderAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_multiReaderAST * operand_11807,
                                GGS_collectedTypeMap  & /* var_cas_ioCollectedTypeMap */,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11807 != NULL) {
    operand_11807->mMultiReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("@multiReaderAST collectTypes\n") COMMA_SOURCE_FILE_AT_LINE (271)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@overridingMultiReaderAST.collectTypes'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingMultiReaderAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_overridingMultiReaderAST * operand_12147,
                                GGS_collectedTypeMap  & /* var_cas_ioCollectedTypeMap */,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12147 != NULL) {
    operand_12147->mOverridingMultiReaderName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("@overridingMultiReaderAST collectTypes\n") COMMA_SOURCE_FILE_AT_LINE (280)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@objectPredefinedTypeAST.collectTypes'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__objectPredefinedTypeAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_objectPredefinedTypeAST * operand_12506,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12506 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("object"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (288)) COMMA_SOURCE_FILE_AT_LINE (288)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@predefinedTypeAST.collectTypes'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_12839,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12839 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_12839->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (297)) COMMA_SOURCE_FILE_AT_LINE (297)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@mapDeclarationAST.collectTypes'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_13183,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13183 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_13183->mMapTypeName COMMA_SOURCE_FILE_AT_LINE (306)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_13183->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (307)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@mapProxyDeclarationAST.collectTypes'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_13566,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13566 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_13566->mMapProxyTypeName COMMA_SOURCE_FILE_AT_LINE (316)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@enumDeclarationAST.collectTypes'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_13887,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13887 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_13887->mEnumTypeName COMMA_SOURCE_FILE_AT_LINE (325)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@sortedListDeclarationAST.collectTypes'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_14210,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14210 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_14210->mSortedListTypeName COMMA_SOURCE_FILE_AT_LINE (334)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_14210->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (335)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@structDeclarationAST.collectTypes'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_14598,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14598 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_14598->mStructTypeName COMMA_SOURCE_FILE_AT_LINE (344)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_14598->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (345)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listDeclarationAST.collectTypes'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_14980,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14980 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_14980->mListTypeName COMMA_SOURCE_FILE_AT_LINE (354)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_14980->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (355)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@classDeclarationAST.collectTypes'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_15361,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15361 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_15361->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (364)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_15361->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (365)) ;
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_15630 (operand_15361->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_15630 = NULL ;
      while (((operand_15630 = enumerator_15630.nextObject ()))) {
        macroValidPointer (operand_15630) ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_15656 (operand_15630->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_15656 = NULL ;
          while (((operand_15656 = enumerator_15656.nextObject ()))) {
            macroValidPointer (operand_15656) ;
            GGS_collectedTypeMapIndex  automatic_var_15765_0 ;
            GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_15656->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (368)), automatic_var_15765_0 COMMA_SOURCE_FILE_AT_LINE (368)) ;
          }
        }
      }
    }
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_15823 (operand_15361->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_15823 = NULL ;
      while (((operand_15823 = enumerator_15823.nextObject ()))) {
        macroValidPointer (operand_15823) ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_15849 (operand_15823->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_15849 = NULL ;
          while (((operand_15849 = enumerator_15849.nextObject ()))) {
            macroValidPointer (operand_15849) ;
            GGS_collectedTypeMapIndex  automatic_var_15958_0 ;
            GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_15849->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (373)), automatic_var_15958_0 COMMA_SOURCE_FILE_AT_LINE (373)) ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@listmapDeclarationAST.collectTypes'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__collectTypes (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_16139,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_multiMethodMapForBuildingContext  & /* var_cas_ioMultiMethodMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16139 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_16139->mListmapTypeName COMMA_SOURCE_FILE_AT_LINE (384)) ;
    GGS_collectedTypeMapIndex  automatic_var_16419_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_16139->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (385)), automatic_var_16419_0 COMMA_SOURCE_FILE_AT_LINE (385)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Virtual Table for category method '@semanticDeclarationAST.enterType'    *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterType> gDispatchTableForMethod__semanticDeclarationAST__enterType ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterType (typeCategoryMethod__semanticDeclarationAST__enterType inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterType.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterType
findCategoryMethod__semanticDeclarationAST__enterType (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterType result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterType.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__enterType (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (NULL == result) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__enterType (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__enterType.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@predefinedTypeAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_predefinedTypeAST * operand_17129,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17129 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    GGS_predefinedTypeAST  var_cas_t = operand_17129 ;
    { typeCategoryMethod__predefinedTypeAST__getConstructorMap method = findCategoryMethod__predefinedTypeAST__getConstructorMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (412)) ;
      }
    }
    { typeCategoryMethod__predefinedTypeAST__getReaderMap method = findCategoryMethod__predefinedTypeAST__getReaderMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (413)) ;
      }
    }
    { typeCategoryMethod__predefinedTypeAST__getModifierMap method = findCategoryMethod__predefinedTypeAST__getModifierMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (414)) ;
      }
    }
    { typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap method = findCategoryMethod__predefinedTypeAST__getInstanceMethodMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_instanceMethodMap COMMA_SOURCE_FILE_AT_LINE (415)) ;
      }
    }
    { typeCategoryMethod__predefinedTypeAST__getClassMethodMap method = findCategoryMethod__predefinedTypeAST__getClassMethodMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_classMethodMap COMMA_SOURCE_FILE_AT_LINE (416)) ;
      }
    }
    GGS_unifiedTypeMapProxyList  var_cas_addAssignArgumentList ;
    { typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList method = findCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_addAssignArgumentList COMMA_SOURCE_FILE_AT_LINE (418)) ;
      }
    }
    GGS_enumerationDescriptorList  var_cas_enumerationList ;
    { typeCategoryMethod__predefinedTypeAST__getEnumerationList method = findCategoryMethod__predefinedTypeAST__getEnumerationList (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_enumerationList COMMA_SOURCE_FILE_AT_LINE (420)) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_selfTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_17129->mPredefinedTypeName, var_cas_selfTypeProxy COMMA_SOURCE_FILE_AT_LINE (422)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_17129->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (424)), GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (426)), GGS_typeKindEnum::constructor_predefinedType (inLexique COMMA_SOURCE_FILE_AT_LINE (427)), GGS_typedAttributeList ::constructor_listWithValue (var_cas_selfTypeProxy, GGS_lstring ::constructor_new (inLexique, operand_17129->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (428))), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (429)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, var_cas_classMethodMap, var_cas_enumerationList, (findCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (var_cas_t (HERE)->galgasRTTI ()) (inLexique, var_cas_t.getPtr () COMMA_SOURCE_FILE_AT_LINE (437))), var_cas_addAssignArgumentList, (findCategoryReader__predefinedTypeAST__getNativeAttributeList (var_cas_t (HERE)->galgasRTTI ()) (inLexique, var_cas_t.getPtr () COMMA_SOURCE_FILE_AT_LINE (439))), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (445)) COMMA_SOURCE_FILE_AT_LINE (423)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@genericTypeTypeAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__genericTypeTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_genericTypeTypeAST * operand_19184,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_19184 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_superTypeProxy ;
    const GGS_bool cond_19504 = (operand_19184->mSuperTypeName).operator_isEqual (GGS_string ("")) ;
    if (cond_19504.isBuiltAndTrue ()) {
      var_cas_superTypeProxy = GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (459)) ;
    }else if (cond_19504.isBuiltAndFalse ()) {
      GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_19184->mSuperTypeName, var_cas_superTypeProxy COMMA_SOURCE_FILE_AT_LINE (461)) ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (464)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (466)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (468)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (470)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_19184->mTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (473)), GGS_bool (false), var_cas_superTypeProxy, GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (476)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (478)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (484)), GGS_enumerationDescriptorList ::constructor_emptyList (), GGS_uint (0U), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (494)) COMMA_SOURCE_FILE_AT_LINE (472)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@objectPredefinedTypeAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__objectPredefinedTypeAST__enterType (C_Compiler & inLexique,
                                const cPtr_objectPredefinedTypeAST * operand_20746,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_20746 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (505)) ;
    GGS_readerMap  var_cas_readerMap ;
    ::routine_commonReaderMapForAllTypes (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (508)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (510)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (512)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("object"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (515)), GGS_bool (false), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (517)), GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (518)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (520)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (526)), GGS_enumerationDescriptorList ::constructor_emptyList (), GGS_uint (0U), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (536)) COMMA_SOURCE_FILE_AT_LINE (514)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@mapDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_22057,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22057 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("string"), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (548)) ;
    GGS_unifiedTypeMapProxy  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("lstring"), var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (551)) ;
    GGS_unifiedTypeMapProxy  var_cas_currentMapTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_22057->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (554)), var_cas_currentMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (554)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (556)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (557)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (558)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (559)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_listWithValue (var_cas_lstringTypeIndex, GGS_string ("lkey")) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyMap"),  operand_22057->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (562)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (562)) ;
    ::routine_enterConstructorWithArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("mapWithMapToOverride"),  operand_22057->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (563)),  operand_22057->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (563)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (563)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("allKeys"),  GGS_string ("stringset"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (565)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("allKeyList"),  GGS_string ("lstringlist"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (566)) ;
    ::routine_enterInheritedReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("hasKey"),  GGS_string ("string"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (567)) ;
    ::routine_enterInheritedReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("locationForKey"),  GGS_string ("string"),  GGS_string ("location"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (568)) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("overriddenMap"),  operand_22057->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (569)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (569)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (570)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("unsolvedProxyCount"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (571)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("unsolvedProxyKeyList"),  GGS_string ("stringlist"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (572)) ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_insertMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (576))) ;
    GGS_formalParameterSignature  var_cas_removeMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (578))) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_24701 (operand_22057->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_24701 = NULL ;
      while (((operand_24701 = enumerator_24701.nextObject ()))) {
        macroValidPointer (operand_24701) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_24701->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (581)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (581)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_24701->mAttributeName) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_24701->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (583))) ;
        var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (584))) ;
        var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (585))) ;
      }
    }
    {
      GGS_insertMethodListAST::cEnumerator enumerator_25305 (operand_22057->mInsertMethodList, true) ;
      const GGS_insertMethodListAST::cElement * operand_25305 = NULL ;
      while (((operand_25305 = enumerator_25305.nextObject ()))) {
        macroValidPointer (operand_25305) ;
        const GGS_bool cond_25460 = var_cas_modifierMap.reader_hasKey (operand_25305->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (589))) ;
        if (cond_25460.isBuiltAndTrue ()) {
          operand_25305->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_25305->mMethodName)).operator_concat (GGS_string ("' insert method is already declared")) COMMA_SOURCE_FILE_AT_LINE (591)) ;
        }else if (cond_25460.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_25305->mMethodName, var_cas_insertMethodFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (596)) COMMA_SOURCE_FILE_AT_LINE (592)) ;
        }
      }
    }
    {
      GGS_mapRemoveMethodListAST::cEnumerator enumerator_25704 (operand_22057->mRemoveMethodList, true) ;
      const GGS_mapRemoveMethodListAST::cElement * operand_25704 = NULL ;
      while (((operand_25704 = enumerator_25704.nextObject ()))) {
        macroValidPointer (operand_25704) ;
        const GGS_bool cond_25895 = var_cas_modifierMap.reader_hasKey (operand_25704->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (602))) ;
        if (cond_25895.isBuiltAndTrue ()) {
          operand_25704->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_25704->mMethodName)).operator_concat (GGS_string ("' method is already declared as an insert modifier or a remove modifier")) COMMA_SOURCE_FILE_AT_LINE (604)) ;
        }else if (cond_25895.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_25704->mMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (609)) COMMA_SOURCE_FILE_AT_LINE (605)) ;
        }
      }
    }
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_26137 (operand_22057->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_26137 = NULL ;
      while (((operand_26137 = enumerator_26137.nextObject ()))) {
        macroValidPointer (operand_26137) ;
        var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_26137->mMethodName, GGS_bool (false), var_cas_removeMethodFormalArgumentList, operand_26137->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (619)), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (621)) COMMA_SOURCE_FILE_AT_LINE (615)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_26427 (operand_22057->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_26427 = NULL ;
      while (((operand_26427 = enumerator_26427.nextObject ()))) {
        macroValidPointer (operand_26427) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_26427->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (626))).operator_concat (GGS_string ("ForKey")), operand_26427->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (626)) COMMA_SOURCE_FILE_AT_LINE (626)) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_26427->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (628)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (628)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_listWithValue (var_cas_stringTypeIndex), GGS_bool (true), var_cas_attributeTypeIndex, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (635)) COMMA_SOURCE_FILE_AT_LINE (629)) ;
      }
    }
    const GGS_bool cond_27370 = (operand_22057->mInsertOrReplaceDeclarationListAST.reader_length ()).operator_supOrEqual (GGS_uint (1U)) ;
    if (cond_27370.isBuiltAndTrue ()) {
      GGS_location  var_cas_insertOrReplaceLocation ;
      if (operand_22057->mInsertOrReplaceDeclarationListAST.isBuilt ()) {
        operand_22057->mInsertOrReplaceDeclarationListAST (HERE)->method_first (inLexique, var_cas_insertOrReplaceLocation COMMA_SOURCE_FILE_AT_LINE (641)) ;
      }
      var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("insertOrReplace"), var_cas_insertOrReplaceLocation COMMA_SOURCE_FILE_AT_LINE (643)), var_cas_insertMethodFormalArgumentList, GGS_bool (false), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (646)) COMMA_SOURCE_FILE_AT_LINE (642)) ;
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_27455 (operand_22057->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_27455 = NULL ;
      while (((operand_27455 = enumerator_27455.nextObject ()))) {
        macroValidPointer (operand_27455) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_27455->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("ForKey")), operand_27455->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (651)) COMMA_SOURCE_FILE_AT_LINE (651)) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_27455->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (653)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (653)) ;
        GGS_formalParameterSignature  var_cas_accessorFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (655))) ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (656))) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, var_cas_accessorFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (661)) COMMA_SOURCE_FILE_AT_LINE (657)) ;
      }
    }
    GGS_withAccessorMap  var_cas_withAccessorMap = GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (665)) ;
    var_cas_withAccessorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("hasKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (666)), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (666)) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_28398 (operand_22057->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_28398 = NULL ;
      while (((operand_28398 = enumerator_28398.nextObject ()))) {
        macroValidPointer (operand_28398) ;
        var_cas_withAccessorMap.modifier_insertKey (inLexique, operand_28398->mMethodName, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (668)) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_superTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("map"), var_cas_superTypeProxy COMMA_SOURCE_FILE_AT_LINE (675)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_22057->mMapTypeName, GGS_bool (true), var_cas_superTypeProxy, GGS_typeKindEnum::constructor_mapType (inLexique COMMA_SOURCE_FILE_AT_LINE (680)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (682)), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (688)), var_cas_enumerationDescriptor, (function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (690))).operator_or (function_generateCppConstructorWithNativeAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (690))), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), operand_22057->mSearchMethodList, GGS_mapSearchMethodListAST ::constructor_emptyList (), var_cas_withAccessorMap COMMA_SOURCE_FILE_AT_LINE (676)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@mapProxyDeclarationAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_29518,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_29518 != NULL) {
    GGS_typedAttributeList  var_cas_mapTypedAttributeList ;
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_mapSearchMethodListAST  var_cas_searchMethodList ;
    GGS_bool automatic_var_30027_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_30027_1 ;
    GGS_typedAttributeList  automatic_var_30027_2 ;
    GGS_attributeMap  automatic_var_30027_3 ;
    GGS_constructorMap  automatic_var_30027_4 ;
    GGS_readerMap  automatic_var_30027_5 ;
    GGS_modifierMap  automatic_var_30027_6 ;
    GGS_instanceMethodMap  automatic_var_30027_7 ;
    GGS_classMethodMap  automatic_var_30027_8 ;
    GGS_enumerationDescriptorList  automatic_var_30027_9 ;
    GGS_uint  automatic_var_30027_10 ;
    GGS_unifiedTypeMapProxyList  automatic_var_30027_11 ;
    GGS_nativeAttributeList  automatic_var_30027_12 ;
    GGS_stringset  automatic_var_30027_13 ;
    GGS_lstringlist  automatic_var_30027_14 ;
    GGS_typedAttributeList  automatic_var_30027_15 ;
    GGS_mapSearchMethodListAST  automatic_var_30027_16 ;
    GGS_withAccessorMap  automatic_var_30027_17 ;
    if (var_cas_ioSemanticContext.mTypeMap.isBuilt ()) {
      var_cas_ioSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_29518->mAssociatedMapTypeName, automatic_var_30027_0, automatic_var_30027_1, var_cas_typeKindEnum, automatic_var_30027_2, automatic_var_30027_3, var_cas_mapTypedAttributeList, automatic_var_30027_4, automatic_var_30027_5, automatic_var_30027_6, automatic_var_30027_7, automatic_var_30027_8, automatic_var_30027_9, automatic_var_30027_10, automatic_var_30027_11, automatic_var_30027_12, automatic_var_30027_13, automatic_var_30027_14, automatic_var_30027_15, var_cas_searchMethodList, automatic_var_30027_16, automatic_var_30027_17 COMMA_SOURCE_FILE_AT_LINE (713)) ;
    }
    const GGS_bool cond_30244 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_mapType (inLexique COMMA_SOURCE_FILE_AT_LINE (723))) ;
    if (cond_30244.isBuiltAndTrue ()) {
      operand_29518->mAssociatedMapTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the @")).operator_concat (operand_29518->mAssociatedMapTypeName)).operator_concat (GGS_string (" should be a map type")) COMMA_SOURCE_FILE_AT_LINE (725)) ;
      var_cas_mapTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (728)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (729)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (730)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (731)) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (732)) ;
    GGS_unifiedTypeMapProxy  var_cas_associatedMapTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_29518->mAssociatedMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (735)), var_cas_associatedMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (735)) ;
    GGS_unifiedTypeMapProxy  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("string"), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (738)) ;
    GGS_unifiedTypeMapProxy  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("lstring"), var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (741)) ;
    GGS_unifiedTypeMapProxy  var_cas_mapProxyTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_29518->mMapProxyTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (744)), var_cas_mapProxyTypeProxy COMMA_SOURCE_FILE_AT_LINE (744)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_argList.addAssign_operation (var_cas_associatedMapTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentInOut (inLexique COMMA_SOURCE_FILE_AT_LINE (747))) ;
    var_cas_argList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (748))) ;
    var_cas_argList.addAssign_operation (var_cas_mapProxyTypeProxy, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (749))) ;
    var_cas_classMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("makeRegularProxy"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (751)), var_cas_argList, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (750)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("null"),  operand_29518->mMapProxyTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (756)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (756)) ;
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_associatedMapTypeIndex) ;
    var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_lstringTypeIndex) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_32044 (var_cas_searchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_32044 = NULL ;
      while (((operand_32044 = enumerator_32044.nextObject ()))) {
        macroValidPointer (operand_32044) ;
        var_cas_constructorMap.modifier_insertKey (inLexique, operand_32044->mMethodName, var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_mapProxyTypeProxy COMMA_SOURCE_FILE_AT_LINE (762)) ;
      }
    }
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isSolved"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (770)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isNull"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (771)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isRegular"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (772)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("lkey"),  GGS_string ("lstring"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (773)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("key"),  GGS_string ("string"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (774)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("identifierRepresentation"),  GGS_string ("string"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (775)) ;
    const GGS_readerMap  var_cas_inheritedReaderMap = var_cas_readerMap ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_33010 (var_cas_mapTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_33010 = NULL ;
      while (((operand_33010 = enumerator_33010.nextObject ()))) {
        macroValidPointer (operand_33010) ;
        const GGS_bool cond_33417 = var_cas_inheritedReaderMap.reader_hasKey (operand_33010->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (779))) ;
        if (cond_33417.isBuiltAndTrue ()) {
          GGS_string var_cas_s = GGS_string ("") ;
          {
            GGS_stringset::cEnumerator enumerator_33118 (var_cas_inheritedReaderMap.reader_allKeys (inLexique COMMA_SOURCE_FILE_AT_LINE (781)), true) ;
            if (enumerator_33118 .hasCurrentObject ()) {
              bool _foreach_loop_33118 ;
              do{
                var_cas_s.appendCString ("'") ;
                var_cas_s.dotAssign_operation (enumerator_33118._key (HERE)) ;
                var_cas_s.appendCString ("'") ;
                enumerator_33118.next () ;
                _foreach_loop_33118 = (enumerator_33118 .hasCurrentObject ()) ;
                if (_foreach_loop_33118) {
                  var_cas_s.appendCString (", ") ;
                }
              }while (_foreach_loop_33118) ;
            }
          }
          operand_33010->mAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the map has a associated map proxy, which has predefined readers: ")).operator_concat (var_cas_s)).operator_concat (GGS_string ("; you cannot use theses names for naming an attribute of this map")) COMMA_SOURCE_FILE_AT_LINE (787)) ;
        }else if (cond_33417.isBuiltAndFalse ()) {
          var_cas_readerMap.modifier_insertKey (inLexique, operand_33010->mAttributeName, GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_bool (true), operand_33010->mAttributeTypeIndex, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (794)) COMMA_SOURCE_FILE_AT_LINE (788)) ;
        }
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_superTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("mapproxy"), var_cas_superTypeProxy COMMA_SOURCE_FILE_AT_LINE (800)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_29518->mMapProxyTypeName, GGS_bool (true), var_cas_superTypeProxy, GGS_typeKindEnum::constructor_mapProxyType (inLexique COMMA_SOURCE_FILE_AT_LINE (805)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (807)), var_cas_mapTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, var_cas_classMethodMap, GGS_enumerationDescriptorList ::constructor_emptyList (), (function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (815))).operator_or (function_generateCppConstructorWithNativeAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (815))), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), var_cas_searchMethodList, GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (823)) COMMA_SOURCE_FILE_AT_LINE (801)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@enumDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_34721,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_34721 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (835)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (836)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (837)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (838)) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (839)) ;
    GGS_unifiedTypeMapProxy  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_34721->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (842)), var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (842)) ;
    GGS_stringset  var_cas_constantSet = GGS_stringset ::constructor_emptySet () ;
    {
      GGS_lstringlist::cEnumerator enumerator_35380 (operand_34721->mConstantList, true) ;
      const GGS_lstringlist::cElement * operand_35380 = NULL ;
      while (((operand_35380 = enumerator_35380.nextObject ()))) {
        macroValidPointer (operand_35380) ;
        var_cas_constantSet.addAssign_operation (operand_35380->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (846))) ;
        ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  operand_35380->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (847)),  operand_34721->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (847)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (847)) ;
      }
    }
    {
      GGS_enumMessageListAST::cEnumerator enumerator_35610 (operand_34721->mEnumMessageList, true) ;
      const GGS_enumMessageListAST::cElement * operand_35610 = NULL ;
      while (((operand_35610 = enumerator_35610.nextObject ()))) {
        macroValidPointer (operand_35610) ;
        ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  operand_35610->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (851)),  GGS_string ("string"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (851)) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_superTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("enum"), var_cas_superTypeProxy COMMA_SOURCE_FILE_AT_LINE (856)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_34721->mEnumTypeName, GGS_bool (true), var_cas_superTypeProxy, GGS_typeKindEnum::constructor_enumType (inLexique COMMA_SOURCE_FILE_AT_LINE (861)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (863)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (869)), GGS_enumerationDescriptorList ::constructor_emptyList (), (function_generateDescriptionReaderUtilityMethod (inLexique COMMA_SOURCE_FILE_AT_LINE (871))).operator_or (function_isComparable (inLexique COMMA_SOURCE_FILE_AT_LINE (871))), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList (), var_cas_constantSet, operand_34721->mConstantList, GGS_typedAttributeList ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (879)) COMMA_SOURCE_FILE_AT_LINE (857)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@filewrapperDeclarationAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__filewrapperDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_filewrapperDeclarationAST * operand_36817,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_36817 != NULL) {
    GGS_filewrapperTemplateMap  var_cas_filewrapperTemplateMap = GGS_filewrapperTemplateMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (890)) ;
    {
      GGS_filewrapperTemplateListAST::cEnumerator enumerator_37089 (operand_36817->mFilewrapperTemplateList, true) ;
      const GGS_filewrapperTemplateListAST::cElement * operand_37089 = NULL ;
      while (((operand_37089 = enumerator_37089.nextObject ()))) {
        macroValidPointer (operand_37089) ;
        GGS_unifiedTypeMapProxyList  var_cas_templateSignature = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
        {
          GGS_formalInputParameterListAST::cEnumerator enumerator_37207 (operand_37089->mFilewrapperTemplateFormalInputParameters, true) ;
          const GGS_formalInputParameterListAST::cElement * operand_37207 = NULL ;
          while (((operand_37207 = enumerator_37207.nextObject ()))) {
            macroValidPointer (operand_37207) ;
            GGS_unifiedTypeMapProxy  var_cas_parameterTypeIndex ;
            GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_37207->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (895)), var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (895)) ;
            var_cas_templateSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
          }
        }
        var_cas_filewrapperTemplateMap.modifier_insertKey (inLexique, operand_37089->mFilewrapperTemplateName, var_cas_templateSignature, operand_37089->mFilewrapperTemplatePath COMMA_SOURCE_FILE_AT_LINE (898)) ;
      }
    }
    var_cas_ioSemanticContext.mFilewrapperMap.modifier_insertKey (inLexique, operand_36817->mFilewrapperName, operand_36817->mFilewrapperPath, operand_36817->mFilewrapperExtensionList, var_cas_filewrapperTemplateMap COMMA_SOURCE_FILE_AT_LINE (904)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@listDeclarationAST.enterType'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_37908,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_37908 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_38179 (operand_37908->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_38179 = NULL ;
      while (((operand_38179 = enumerator_38179.nextObject ()))) {
        macroValidPointer (operand_38179) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_38179->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (923)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (923)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_38179->mAttributeName) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_uintType ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("uint"), var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (928)) ;
    GGS_unifiedTypeMapProxy  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_37908->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (931)), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (931)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierOutputFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierInputFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_39096 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_39096 = NULL ;
      while (((operand_39096 = enumerator_39096.nextObject ()))) {
        macroValidPointer (operand_39096) ;
        var_cas_enumerationDescriptor.addAssign_operation (operand_39096->mAttributeTypeIndex, operand_39096->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (938))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (operand_39096->mAttributeTypeIndex) ;
        var_cas_modifierOutputFormalArgumentList.addAssign_operation (operand_39096->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (940))) ;
        var_cas_modifierInputFormalArgumentList.addAssign_operation (operand_39096->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (941))) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (944)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyList"),  operand_37908->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (945)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (945)) ;
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("listWithValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (947)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (946)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (953)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (954)) ;
    ::routine_enterBaseReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("subListFromIndex"),  GGS_string ("uint"),  operand_37908->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (955)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (955)) ;
    ::routine_enterBaseReaderWith2Arguments (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("subListWithRange"),  GGS_string ("uint"),  GGS_string ("uint"),  operand_37908->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (956)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (956)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_40266 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_40266 = NULL ;
      while (((operand_40266 = enumerator_40266.nextObject ()))) {
        macroValidPointer (operand_40266) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, (operand_40266->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (959))).operator_concat (GGS_string ("AtIndex")), operand_40266->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (959)) COMMA_SOURCE_FILE_AT_LINE (959)), GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_listWithValue (var_cas_uintType), GGS_bool (true), operand_40266->mAttributeTypeIndex, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (964)) COMMA_SOURCE_FILE_AT_LINE (958)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (968)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popFirst"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (970)), var_cas_modifierOutputFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (973)) COMMA_SOURCE_FILE_AT_LINE (969)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popLast"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (976)), var_cas_modifierOutputFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (979)) COMMA_SOURCE_FILE_AT_LINE (975)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("prependValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (982)), var_cas_modifierInputFormalArgumentList, GGS_bool (false), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (985)) COMMA_SOURCE_FILE_AT_LINE (981)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_41134 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_41134 = NULL ;
      while (((operand_41134 = enumerator_41134.nextObject ()))) {
        macroValidPointer (operand_41134) ;
        GGS_formalParameterSignature  var_cas_setterFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_setterFormalArgumentList.addAssign_operation (operand_41134->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (989))) ;
        var_cas_setterFormalArgumentList.addAssign_operation (var_cas_uintType, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (990))) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_41134->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("AtIndex")), operand_41134->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (992)) COMMA_SOURCE_FILE_AT_LINE (992)), var_cas_setterFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (995)) COMMA_SOURCE_FILE_AT_LINE (991)) ;
      }
    }
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (999)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("first"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1001)), GGS_bool (false), var_cas_modifierOutputFormalArgumentList, GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1006)) COMMA_SOURCE_FILE_AT_LINE (1000)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("last"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1009)), GGS_bool (false), var_cas_modifierOutputFormalArgumentList, GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1014)) COMMA_SOURCE_FILE_AT_LINE (1008)) ;
    GGS_unifiedTypeMapProxy  var_cas_superTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("list"), var_cas_superTypeProxy COMMA_SOURCE_FILE_AT_LINE (1018)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_37908->mListTypeName, GGS_bool (true), var_cas_superTypeProxy, GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (1023)), var_cas_typedAttributeList, GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1025)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1031)), var_cas_enumerationDescriptor, (((function_binaryConcatOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1033))).operator_or (function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (1033)))).operator_or (function_dotAssignOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1033)))).operator_or (function_generateCppConstructorWithNativeAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1033))), var_cas_constructorAttributeTypeList, GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1041)) COMMA_SOURCE_FILE_AT_LINE (1019)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@sortedListDeclarationAST.enterType'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_43224,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_43224 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_uintType ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("uint"), var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1053)) ;
    GGS_unifiedTypeMapProxy  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_43224->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1056)), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1056)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_44018 (operand_43224->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_44018 = NULL ;
      while (((operand_44018 = enumerator_44018.nextObject ()))) {
        macroValidPointer (operand_44018) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_44018->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1064)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1064)) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_44018->mAttributeName) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_44018->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1066))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_modifierFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (1068))) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1071)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptySortedList"),  operand_43224->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1072)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1072)) ;
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sortedListWithValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1074)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1073)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1080)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1081)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1083)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popGreatest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1085)), var_cas_modifierFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1088)) COMMA_SOURCE_FILE_AT_LINE (1084)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popSmallest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1091)), var_cas_modifierFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1094)) COMMA_SOURCE_FILE_AT_LINE (1090)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1097)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("greatest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1099)), GGS_bool (false), var_cas_modifierFormalArgumentList, GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1104)) COMMA_SOURCE_FILE_AT_LINE (1098)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("smallest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1107)), GGS_bool (false), var_cas_modifierFormalArgumentList, GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1112)) COMMA_SOURCE_FILE_AT_LINE (1106)) ;
    GGS_unifiedTypeMapProxy  var_cas_superTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("sortedlist"), var_cas_superTypeProxy COMMA_SOURCE_FILE_AT_LINE (1116)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_43224->mSortedListTypeName, GGS_bool (true), var_cas_superTypeProxy, GGS_typeKindEnum::constructor_sortedListType (inLexique COMMA_SOURCE_FILE_AT_LINE (1121)), var_cas_typedAttributeList, GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1123)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1129)), var_cas_enumerationDescriptor, ((((function_binaryConcatOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1131))).operator_or (function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (1131)))).operator_or (function_dotAssignOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1131)))).operator_or (function_generateCppConstructorWithNativeAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1132)))).operator_or (function_generateSortedListComparisonMethod (inLexique COMMA_SOURCE_FILE_AT_LINE (1132))), var_cas_constructorAttributeTypeList, GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1140)) COMMA_SOURCE_FILE_AT_LINE (1117)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@structDeclarationAST.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_46989,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_46989 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_structTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_46989->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1153)), var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (1153)) ;
    GGS_attributeMap  var_cas_attributeMap = GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1155)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1156)) ;
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_47614 (operand_46989->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_47614 = NULL ;
      while (((operand_47614 = enumerator_47614.nextObject ()))) {
        macroValidPointer (operand_47614) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_47614->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1161)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1161)) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_47614->mAttributeName) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_47614->mAttributeName, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1164)) ;
      }
    }
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1167)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (1166)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1173)) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_48204 (operand_46989->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_48204 = NULL ;
      while (((operand_48204 = enumerator_48204.nextObject ()))) {
        macroValidPointer (operand_48204) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_48204->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1176)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1176)) ;
        ::routine_enterBaseFinalReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  operand_48204->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1180)),  operand_48204->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1181)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1177)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1186)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1188)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_46989->mStructTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1193)), GGS_typeKindEnum::constructor_structType (inLexique COMMA_SOURCE_FILE_AT_LINE (1194)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_attributeMap, var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1202)), GGS_enumerationDescriptorList ::constructor_emptyList (), (((function_generateVirtualDestructor (inLexique COMMA_SOURCE_FILE_AT_LINE (1204))).operator_or (function_generateCppConstructorWithCurrentAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1205)))).operator_or (function_generateDescriptionReaderUtilityMethod (inLexique COMMA_SOURCE_FILE_AT_LINE (1206)))).operator_or (function_autoBoxing (inLexique COMMA_SOURCE_FILE_AT_LINE (1206))), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), var_cas_typedAttributeList, GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1214)) COMMA_SOURCE_FILE_AT_LINE (1190)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@classDeclarationAST.enterType'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_49691,
                                const GGS_multiMethodMapForBuildingContext   var_cas_inMultiMethodMapForBuildingContext,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_49691 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_uintType ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("uint"), var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1226)) ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_inheritedInstanceMethodMap ;
    GGS_typedAttributeList  var_cas_inheritedTypedAttributeList ;
    GGS_attributeMap  var_cas_attributeMap = GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1232)) ;
    GGS_unifiedTypeMapProxy  var_cas_superClassIndex ;
    const GGS_bool cond_50616 = (operand_49691->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1235))).operator_isEqual (GGS_string ("")) ;
    if (cond_50616.isBuiltAndTrue ()) {
      var_cas_superClassIndex = GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1236)) ;
      var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1237)) ;
      var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1238)) ;
      var_cas_inheritedInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1239)) ;
      var_cas_inheritedTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
      var_cas_attributeMap = GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1241)) ;
    }else if (cond_50616.isBuiltAndFalse ()) {
      GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_49691->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1243)), var_cas_superClassIndex COMMA_SOURCE_FILE_AT_LINE (1243)) ;
      GGS_typeKindEnum var_cas_typeKindEnum ;
      GGS_readerMap  var_cas_inheritedReaderMap ;
      GGS_modifierMap  var_cas_inheritedModifierMap ;
      GGS_bool automatic_var_51110_0 ;
      GGS_unifiedTypeMapProxy  automatic_var_51110_1 ;
      GGS_typedAttributeList  automatic_var_51110_2 ;
      GGS_constructorMap  automatic_var_51110_3 ;
      GGS_classMethodMap  automatic_var_51110_4 ;
      GGS_enumerationDescriptorList  automatic_var_51110_5 ;
      GGS_uint  automatic_var_51110_6 ;
      GGS_unifiedTypeMapProxyList  automatic_var_51110_7 ;
      GGS_nativeAttributeList  automatic_var_51110_8 ;
      GGS_stringset  automatic_var_51110_9 ;
      GGS_lstringlist  automatic_var_51110_10 ;
      GGS_typedAttributeList  automatic_var_51110_11 ;
      GGS_mapSearchMethodListAST  automatic_var_51110_12 ;
      GGS_mapSearchMethodListAST  automatic_var_51110_13 ;
      GGS_withAccessorMap  automatic_var_51110_14 ;
      if (var_cas_ioSemanticContext.mTypeMap.isBuilt ()) {
        var_cas_ioSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_49691->mSuperClassName, automatic_var_51110_0, automatic_var_51110_1, var_cas_typeKindEnum, var_cas_inheritedTypedAttributeList, var_cas_attributeMap, automatic_var_51110_2, automatic_var_51110_3, var_cas_inheritedReaderMap, var_cas_inheritedModifierMap, var_cas_inheritedInstanceMethodMap, automatic_var_51110_4, automatic_var_51110_5, automatic_var_51110_6, automatic_var_51110_7, automatic_var_51110_8, automatic_var_51110_9, automatic_var_51110_10, automatic_var_51110_11, automatic_var_51110_12, automatic_var_51110_13, automatic_var_51110_14 COMMA_SOURCE_FILE_AT_LINE (1247)) ;
      }
      const GGS_bool cond_51267 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1260))) ;
      if (cond_51267.isBuiltAndTrue ()) {
        operand_49691->mSuperClassName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the @")).operator_concat (operand_49691->mSuperClassName)).operator_concat (GGS_string (" should be a class type")) COMMA_SOURCE_FILE_AT_LINE (1262)) ;
      }
      var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1264)) ;
      var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1274)) ;
      {
        GGS_readerMap::cEnumerator enumerator_51677 (var_cas_inheritedReaderMap, true) ;
        const GGS_readerMap::cElement * operand_51677 = NULL ;
        while (((operand_51677 = enumerator_51677.nextObject ()))) {
          macroValidPointer (operand_51677) ;
          var_cas_readerMap.modifier_insertKey (inLexique, operand_51677->mKey, operand_51677->mInfo.mIsCategory, operand_51677->mInfo.mArgumentTypeList, operand_51677->mInfo.mHasCompilerArgument, operand_51677->mInfo.mReturnedType, GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1282)) COMMA_SOURCE_FILE_AT_LINE (1276)) ;
        }
      }
    }
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_52067 (var_cas_inheritedTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_52067 = NULL ;
      while (((operand_52067 = enumerator_52067.nextObject ()))) {
        macroValidPointer (operand_52067) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (operand_52067->mAttributeTypeIndex) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_52170 (operand_49691->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_52170 = NULL ;
      while (((operand_52170 = enumerator_52170.nextObject ()))) {
        macroValidPointer (operand_52170) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_52170->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1293)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1293)) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_52170->mAttributeName, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1295)) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_classIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_49691->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1299)), var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1299)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1301)) ;
    const GGS_bool cond_52896 = (operand_49691->mIsAbstract).operator_not () ;
    if (cond_52896.isBuiltAndTrue ()) {
      var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1304)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1303)) ;
    }
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1311)) ;
    {
      GGS_instanceMethodMap::cEnumerator enumerator_53027 (var_cas_inheritedInstanceMethodMap, true) ;
      const GGS_instanceMethodMap::cElement * operand_53027 = NULL ;
      while (((operand_53027 = enumerator_53027.nextObject ()))) {
        macroValidPointer (operand_53027) ;
        var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_53027->mKey, GGS_bool (false), operand_53027->mInfo.mParameterList, operand_53027->mInfo.mDeclarationLocation, operand_53027->mInfo.mHasCompilerArgument, GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1319)) COMMA_SOURCE_FILE_AT_LINE (1313)) ;
      }
    }
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_53323 (operand_49691->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_53323 = NULL ;
      while (((operand_53323 = enumerator_53323.nextObject ()))) {
        macroValidPointer (operand_53323) ;
        GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_53412 (operand_53323->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_53412 = NULL ;
          while (((operand_53412 = enumerator_53412.nextObject ()))) {
            macroValidPointer (operand_53412) ;
            GGS_unifiedTypeMapProxy  var_cas_typeIndex ;
            GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_53412->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1327)), var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1327)) ;
            var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_53412->mFormalArgumentPassingMode) ;
          }
        }
        elementOf_GGS_instanceMethodMap * operand_53693 = (elementOf_GGS_instanceMethodMap *) var_cas_instanceMethodMap.searchForReadWriteWithInstruction (operand_53323->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1330))) ;
        if (NULL != operand_53693) {
          operand_53693->mInfo.mQualifier = GGS_methodQualifier::constructor_isOverridingAbstract (inLexique COMMA_SOURCE_FILE_AT_LINE (1331)) ;
        }else{
          var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_53323->mMethodName, GGS_bool (false), var_cas_formalArgumentList, operand_53323->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1337)), GGS_bool (true), GGS_methodQualifier::constructor_isAbstract (inLexique COMMA_SOURCE_FILE_AT_LINE (1339)) COMMA_SOURCE_FILE_AT_LINE (1333)) ;
        }
      }
    }
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_54110 (operand_49691->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_54110 = NULL ;
      while (((operand_54110 = enumerator_54110.nextObject ()))) {
        macroValidPointer (operand_54110) ;
        GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_54199 (operand_54110->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_54199 = NULL ;
          while (((operand_54199 = enumerator_54199.nextObject ()))) {
            macroValidPointer (operand_54199) ;
            GGS_unifiedTypeMapProxy  var_cas_typeIndex ;
            GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_54199->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1348)), var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1348)) ;
            var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_54199->mFormalArgumentPassingMode) ;
          }
        }
        elementOf_GGS_instanceMethodMap * operand_54480 = (elementOf_GGS_instanceMethodMap *) var_cas_instanceMethodMap.searchForReadWriteWithInstruction (operand_54110->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1351))) ;
        if (NULL != operand_54480) {
          operand_54480->mInfo.mQualifier = GGS_methodQualifier::constructor_isOverriding (inLexique COMMA_SOURCE_FILE_AT_LINE (1352)) ;
        }else{
          var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_54110->mMethodName, GGS_bool (false), var_cas_formalArgumentList, operand_54110->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1358)), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1360)) COMMA_SOURCE_FILE_AT_LINE (1354)) ;
        }
      }
    }
    const GGS_bool cond_55696 = var_cas_inMultiMethodMapForBuildingContext.reader_hasKey (operand_49691->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1365))) ;
    if (cond_55696.isBuiltAndTrue ()) {
      GGS_multiMethodMapForType  var_cas_multiMethodMapForType ;
      if (var_cas_inMultiMethodMapForBuildingContext.isBuilt ()) {
        var_cas_inMultiMethodMapForBuildingContext (HERE)->method_searchKey (inLexique, operand_49691->mClassTypeName, var_cas_multiMethodMapForType COMMA_SOURCE_FILE_AT_LINE (1367)) ;
      }
      {
        GGS_multiMethodMapForType::cEnumerator enumerator_55115 (var_cas_multiMethodMapForType, true) ;
        const GGS_multiMethodMapForType::cElement * operand_55115 = NULL ;
        while (((operand_55115 = enumerator_55115.nextObject ()))) {
          macroValidPointer (operand_55115) ;
          GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
          {
            GGS_formalParameterListAST::cEnumerator enumerator_55218 (operand_55115->mInfo.mFormalParameterList, true) ;
            const GGS_formalParameterListAST::cElement * operand_55218 = NULL ;
            while (((operand_55218 = enumerator_55218.nextObject ()))) {
              macroValidPointer (operand_55218) ;
              GGS_unifiedTypeMapProxy  var_cas_typeIndex ;
              GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_55218->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1372)), var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1372)) ;
              var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_55218->mFormalArgumentPassingMode) ;
            }
          }
          var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_55115->mKey, GGS_bool (true), var_cas_formalArgumentList, operand_55115->mKey.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1379)), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1381)) COMMA_SOURCE_FILE_AT_LINE (1375)) ;
        }
      }
    }
    GGS_typedAttributeList  var_cas_currentClassTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_allTypedAttributeList = var_cas_inheritedTypedAttributeList ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_55896 (operand_49691->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_55896 = NULL ;
      while (((operand_55896 = enumerator_55896.nextObject ()))) {
        macroValidPointer (operand_55896) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_55896->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1390)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1390)) ;
        var_cas_currentClassTypedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_55896->mAttributeName) ;
        var_cas_allTypedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_55896->mAttributeName) ;
        var_cas_readerMap.modifier_insertKey (inLexique, operand_55896->mAttributeName, GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_bool (false), var_cas_attributeTypeIndex, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1399)) COMMA_SOURCE_FILE_AT_LINE (1393)) ;
      }
    }
    const GGS_bool cond_56930 = (operand_49691->mIsAbstract).operator_not () ;
    if (cond_56930.isBuiltAndTrue ()) {
      {
        GGS_typedAttributeList::cEnumerator enumerator_56581 (var_cas_allTypedAttributeList, true) ;
        const GGS_typedAttributeList::cElement * operand_56581 = NULL ;
        while (((operand_56581 = enumerator_56581.nextObject ()))) {
          macroValidPointer (operand_56581) ;
          var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, (GGS_string ("set")).operator_concat (operand_56581->mAttributeName.ggs_string ().reader_stringByCapitalizingFirstCharacter ()), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1406)), GGS_formalParameterSignature ::constructor_listWithValue (operand_56581->mAttributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1407))), GGS_bool (false), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1409)) COMMA_SOURCE_FILE_AT_LINE (1405)) ;
        }
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_49691->mClassTypeName, (operand_49691->mIsAbstract).operator_not (), var_cas_superClassIndex, GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1418)), var_cas_allTypedAttributeList, var_cas_attributeMap, var_cas_currentClassTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1426)), GGS_enumerationDescriptorList ::constructor_emptyList (), ((function_generateCppConstructorWithAllAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1428))).operator_or (function_generateVirtualDestructor (inLexique COMMA_SOURCE_FILE_AT_LINE (1428)))).operator_or (((operand_49691->mIsAbstract).isBuiltAndTrue () ? (GGS_uint (0U)) : (function_generateDescriptionReaderUtilityMethod (inLexique COMMA_SOURCE_FILE_AT_LINE (1428))))), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), var_cas_currentClassTypedAttributeList, GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1436)) COMMA_SOURCE_FILE_AT_LINE (1414)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@externRoutineDeclarationAST.enterType'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_externRoutineDeclarationAST * operand_57941,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_57941 != NULL) {
    GGS_formalParameterSignature  var_cas_routineSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_58207 (operand_57941->mFormalArgumentList, true) ;
      const GGS_formalParameterListAST::cElement * operand_58207 = NULL ;
      while (((operand_58207 = enumerator_58207.nextObject ()))) {
        macroValidPointer (operand_58207) ;
        GGS_unifiedTypeMapProxy  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_58207->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1450)), var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1450)) ;
        var_cas_routineSignature.addAssign_operation (var_cas_parameterTypeIndex, operand_58207->mFormalArgumentPassingMode) ;
      }
    }
    var_cas_ioSemanticContext.mRoutineMap.modifier_insertKey (inLexique, operand_57941->mRoutineName, var_cas_routineSignature COMMA_SOURCE_FILE_AT_LINE (1454)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@externFunctionDeclarationAST.enterType'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_externFunctionDeclarationAST * operand_58740,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_58740 != NULL) {
    GGS_unifiedTypeMapProxyList  var_cas_functionSignature = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_59007 (operand_58740->mFormalArgumentList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_59007 = NULL ;
      while (((operand_59007 = enumerator_59007.nextObject ()))) {
        macroValidPointer (operand_59007) ;
        GGS_unifiedTypeMapProxy  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_59007->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1467)), var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1467)) ;
        var_cas_functionSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_58740->mResultTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1472)), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1472)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_58740->mFunctionName, var_cas_functionSignature, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1474)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@onceFunctionDeclarationAST.enterType'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__onceFunctionDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_onceFunctionDeclarationAST * operand_59707,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_59707 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_59707->mResultTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1485)), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1485)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_59707->mFunctionName, GGS_unifiedTypeMapProxyList ::constructor_emptyList (), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (1487)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listmapDeclarationAST.enterType'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterType (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_60300,
                                const GGS_multiMethodMapForBuildingContext   /* var_cas_inMultiMethodMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_60300 != NULL) {
    GGS_typedAttributeList  var_cas_listTypedAttributeList ;
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_bool automatic_var_60765_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_60765_1 ;
    GGS_attributeMap  automatic_var_60765_2 ;
    GGS_typedAttributeList  automatic_var_60765_3 ;
    GGS_constructorMap  automatic_var_60765_4 ;
    GGS_readerMap  automatic_var_60765_5 ;
    GGS_modifierMap  automatic_var_60765_6 ;
    GGS_instanceMethodMap  automatic_var_60765_7 ;
    GGS_classMethodMap  automatic_var_60765_8 ;
    GGS_enumerationDescriptorList  automatic_var_60765_9 ;
    GGS_uint  automatic_var_60765_10 ;
    GGS_unifiedTypeMapProxyList  automatic_var_60765_11 ;
    GGS_nativeAttributeList  automatic_var_60765_12 ;
    GGS_stringset  automatic_var_60765_13 ;
    GGS_lstringlist  automatic_var_60765_14 ;
    GGS_typedAttributeList  automatic_var_60765_15 ;
    GGS_mapSearchMethodListAST  automatic_var_60765_16 ;
    GGS_mapSearchMethodListAST  automatic_var_60765_17 ;
    GGS_withAccessorMap  automatic_var_60765_18 ;
    if (var_cas_ioSemanticContext.mTypeMap.isBuilt ()) {
      var_cas_ioSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_60300->mAssociatedListTypeName, automatic_var_60765_0, automatic_var_60765_1, var_cas_typeKindEnum, var_cas_listTypedAttributeList, automatic_var_60765_2, automatic_var_60765_3, automatic_var_60765_4, automatic_var_60765_5, automatic_var_60765_6, automatic_var_60765_7, automatic_var_60765_8, automatic_var_60765_9, automatic_var_60765_10, automatic_var_60765_11, automatic_var_60765_12, automatic_var_60765_13, automatic_var_60765_14, automatic_var_60765_15, automatic_var_60765_16, automatic_var_60765_17, automatic_var_60765_18 COMMA_SOURCE_FILE_AT_LINE (1500)) ;
    }
    const GGS_bool cond_60994 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (1507))) ;
    if (cond_60994.isBuiltAndTrue ()) {
      operand_60300->mAssociatedListTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '@")).operator_concat (operand_60300->mAssociatedListTypeName)).operator_concat (GGS_string ("' type should be a list type")) COMMA_SOURCE_FILE_AT_LINE (1509)) ;
      var_cas_listTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1512)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1513)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1514)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1515)) ;
    GGS_unifiedTypeMapProxy  var_cas_associatedListTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_60300->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1518)), var_cas_associatedListTypeIndex COMMA_SOURCE_FILE_AT_LINE (1518)) ;
    GGS_unifiedTypeMapProxy  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_60300->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1521)), var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (1521)) ;
    GGS_unifiedTypeMapProxy  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("string"), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1524)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1526)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("allKeys"),  GGS_string ("stringset"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1527)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("keyList"),  GGS_string ("stringlist"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1528)) ;
    ::routine_enterBaseReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("listForKey"),  GGS_string ("string"),  operand_60300->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1529)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1529)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyMap"),  operand_60300->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1531)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1531)) ;
    GGS_enumerationDescriptorList  var_cas_enumeratorDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_stringTypeIndex, GGS_string ("key")) ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_associatedListTypeIndex, GGS_string ("mList")) ;
    GGS_unifiedTypeMapProxyList  var_cas_addAssignOperatorDescription = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    var_cas_addAssignOperatorDescription.addAssign_operation (var_cas_stringTypeIndex) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_62781 (var_cas_listTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_62781 = NULL ;
      while (((operand_62781 = enumerator_62781.nextObject ()))) {
        macroValidPointer (operand_62781) ;
        var_cas_addAssignOperatorDescription.addAssign_operation (operand_62781->mAttributeTypeIndex) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_superTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("listmap"), var_cas_superTypeProxy COMMA_SOURCE_FILE_AT_LINE (1544)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_60300->mListmapTypeName, GGS_bool (true), var_cas_superTypeProxy, GGS_typeKindEnum::constructor_listMapType (inLexique COMMA_SOURCE_FILE_AT_LINE (1549)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1551)), var_cas_listTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1557)), var_cas_enumeratorDescriptor, (((function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (1559))).operator_or (function_generateCppConstructorWithNativeAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (1559)))).operator_or (function_binaryConcatOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1559)))).operator_or (function_dotAssignOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1559))), var_cas_addAssignOperatorDescription, GGS_nativeAttributeList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_typedAttributeList ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1567)) COMMA_SOURCE_FILE_AT_LINE (1545)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@partiallyOrderedSemanticDeclarationListAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
elementOf_GGS_partiallyOrderedSemanticDeclarationListAST (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticDeclarationAST & argument_2):
mDependanceString (argument_0),
mTypeString (argument_1),
mSemanticDeclaration (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDependanceString.operator_isEqual (ptr->mDependanceString).boolValue ()
         && mTypeString.operator_isEqual (ptr->mTypeString).boolValue ()
         && mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * operand = (const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST *) inOperand ;
  PMSInt32 result = mDependanceString.genericObjectCompare (operand->mDependanceString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDependanceString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Sorted list '@partiallyOrderedSemanticDeclarationListAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST ("partiallyOrderedSemanticDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST::GGS_partiallyOrderedSemanticDeclarationListAST (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST::
GGS_partiallyOrderedSemanticDeclarationListAST (const GGS_partiallyOrderedSemanticDeclarationListAST & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_partiallyOrderedSemanticDeclarationListAST::
operator_isEqual (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_partiallyOrderedSemanticDeclarationListAST::
operator_isNotEqual (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_semanticDeclarationAST & argument_2) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticDeclarationAST & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST GGS_partiallyOrderedSemanticDeclarationListAST::
operator_concat (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  GGS_partiallyOrderedSemanticDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
dotAssign_operation (const GGS_partiallyOrderedSemanticDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mDependanceString ;
          GGS_string p_1 = p->mTypeString ;
          GGS_semanticDeclarationAST  p_2 = p->mSemanticDeclaration ;
          internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mDependanceString,
                                ptr->mTypeString,
                                ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST  GGS_partiallyOrderedSemanticDeclarationListAST::
constructor_emptySortedList (void) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST  GGS_partiallyOrderedSemanticDeclarationListAST::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_string& argument_1,
                           const GGS_semanticDeclarationAST & argument_2) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_partiallyOrderedSemanticDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@partiallyOrderedSemanticDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
method_smallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_semanticDeclarationAST & _out_2
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
method_greatest (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_semanticDeclarationAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
modifier_popSmallest (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_semanticDeclarationAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
modifier_popGreatest (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_semanticDeclarationAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mDependanceString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDependanceString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mTypeString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationAST  & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_partiallyOrderedSemanticDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_partiallyOrderedSemanticDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_partiallyOrderedSemanticDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST GGS_partiallyOrderedSemanticDeclarationListAST::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_partiallyOrderedSemanticDeclarationListAST * p = dynamic_cast <const GGS_partiallyOrderedSemanticDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_partiallyOrderedSemanticDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_semanticDeclarationAST * operand_64551,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & /* var_cas_ioPartiallyOrderedDeclarationList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_64551 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@semanticDeclarationAST.enterOrderedDeclaration'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration> gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration
findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.count ()) {
    result = gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (NULL == result) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (superClassPtr) ;
      gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@predefinedTypeAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_predefinedTypeAST * operand_64794,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_64794 != NULL) {
    GGS_predefinedTypeAST  var_cas_t = operand_64794 ;
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_64794->mPredefinedTypeName, operand_64794) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@objectPredefinedTypeAST.enterOrderedDeclaration'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__objectPredefinedTypeAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_objectPredefinedTypeAST * operand_65159,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_65159 != NULL) {
    GGS_objectPredefinedTypeAST  var_cas_t = operand_65159 ;
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), GGS_string ("object"), operand_65159) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@stringsetPredefinedTypeAST.enterOrderedDeclaration'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__stringsetPredefinedTypeAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_stringsetPredefinedTypeAST * operand_65522,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_65522 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_65522->mPredefinedTypeName, operand_65522) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@genericTypeTypeAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__genericTypeTypeAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_genericTypeTypeAST * operand_65831,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_65831 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_65831->mSuperTypeName, operand_65831->mTypeName, operand_65831) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@classDeclarationAST.enterOrderedDeclaration'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_classDeclarationAST * operand_66143,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_66143 != NULL) {
    const GGS_string var_cas_actualSuperTypeName = operand_66143->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1631)) ;
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (var_cas_actualSuperTypeName, operand_66143->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1632)), operand_66143) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@listDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_listDeclarationAST * operand_66539,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_66539 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_66539->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1640)), operand_66539) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@structDeclarationAST.enterOrderedDeclaration'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_structDeclarationAST * operand_66853,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_66853 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_66853->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1648)), operand_66853) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@enumDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_enumDeclarationAST * operand_67167,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_67167 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_67167->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1656)), operand_67167) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@sortedListDeclarationAST.enterOrderedDeclaration'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_67485,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_67485 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_67485->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1664)), operand_67485) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@listmapDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_listmapDeclarationAST * operand_67806,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_67806 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_67806->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1672)), operand_67806->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1672)), operand_67806) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@mapDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_mapDeclarationAST * operand_68150,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_68150 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_68150->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1680)), operand_68150) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@mapProxyDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__enterOrderedDeclaration (C_Compiler & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_68465,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_68465 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_68465->mAssociatedMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1688)), operand_68465->mMapProxyTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1688)), operand_68465) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Category method '@externFunctionDeclarationAST.enterOrderedDeclaration'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_externFunctionDeclarationAST * operand_68820,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_68820 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), GGS_string (""), operand_68820) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@externRoutineDeclarationAST.enterOrderedDeclaration'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__enterOrderedDeclaration (C_Compiler &,
                                const cPtr_externRoutineDeclarationAST * operand_69121,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_69121 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), GGS_string (""), operand_69121) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildSemanticContext"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSemanticContext (C_Compiler & inLexique,
                                const GGS_semanticDeclarationListAST   var_cas_inSemanticDeclarationList,
                                const GGS_location   var_cas_inEndOfSourceFile,
                                GGS_semanticContext & var_cas_outSemanticContext
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildSemanticContext at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_collectedTypeMap  var_cas_collectedTypeMap = GGS_collectedTypeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1719)) ;
  GGS_multiMethodMapForBuildingContext  var_cas_multiMethodMapForBuildingContext = GGS_multiMethodMapForBuildingContext ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1720)) ;
  {
    GGS_semanticDeclarationListAST::cEnumerator enumerator_70057 (var_cas_inSemanticDeclarationList, true) ;
    const GGS_semanticDeclarationListAST::cElement * operand_70057 = NULL ;
    while (((operand_70057 = enumerator_70057.nextObject ()))) {
      macroValidPointer (operand_70057) ;
      { typeCategoryMethod__semanticDeclarationAST__collectTypes method = findCategoryMethod__semanticDeclarationAST__collectTypes (operand_70057->mSemanticDeclaration.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_70057->mSemanticDeclaration (HERE), var_cas_collectedTypeMap, var_cas_multiMethodMapForBuildingContext COMMA_SOURCE_FILE_AT_LINE (1722)) ;
        }
      }
    }
  }
  GGS_stringlist  var_cas_undefinedClasses = var_cas_collectedTypeMap.reader_unsolvedProxyKeyList (inLexique COMMA_SOURCE_FILE_AT_LINE (1728)) ;
  const GGS_bool cond_70569 = (var_cas_undefinedClasses.reader_length ()).operator_isEqual (GGS_uint (1U)) ;
  if (cond_70569.isBuiltAndTrue ()) {
    GGS_string var_cas_errorMessage = GGS_string ("there is 1 undefined type:") ;
    {
      GGS_stringlist::cEnumerator enumerator_70432 (var_cas_undefinedClasses, true) ;
      const GGS_stringlist::cElement * operand_70432 = NULL ;
      while (((operand_70432 = enumerator_70432.nextObject ()))) {
        macroValidPointer (operand_70432) ;
        var_cas_errorMessage.appendCString ("\n"
          "-  @") ;
        var_cas_errorMessage.dotAssign_operation (operand_70432->mValue) ;
      }
    }
    var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (1735)) ;
    var_cas_outSemanticContext.drop () ;
  }else if (cond_70569.isBuiltAndFalse ()) {
    const GGS_bool cond_70871 = (var_cas_undefinedClasses.reader_length ()).operator_strictSup (GGS_uint (1U)) ;
    if (cond_70871.isBuiltAndTrue ()) {
      GGS_string var_cas_errorMessage = ((GGS_string ("there are ")).operator_concat (var_cas_undefinedClasses.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1736)))).operator_concat (GGS_string (" undefined types:")) ;
      {
        GGS_stringlist::cEnumerator enumerator_70735 (var_cas_undefinedClasses, true) ;
        const GGS_stringlist::cElement * operand_70735 = NULL ;
        while (((operand_70735 = enumerator_70735.nextObject ()))) {
          macroValidPointer (operand_70735) ;
          var_cas_errorMessage.appendCString ("\n"
            "-  @") ;
          var_cas_errorMessage.dotAssign_operation (operand_70735->mValue) ;
        }
      }
      var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (1741)) ;
      var_cas_outSemanticContext.drop () ;
    }else if (cond_70871.isBuiltAndFalse ()) {
      GGS_partiallyOrderedSemanticDeclarationListAST  var_cas_partiallyOrderedSemanticDeclarationListAST = GGS_partiallyOrderedSemanticDeclarationListAST ::constructor_emptySortedList () ;
      {
        GGS_semanticDeclarationListAST::cEnumerator enumerator_71234 (var_cas_inSemanticDeclarationList, true) ;
        const GGS_semanticDeclarationListAST::cElement * operand_71234 = NULL ;
        while (((operand_71234 = enumerator_71234.nextObject ()))) {
          macroValidPointer (operand_71234) ;
          { typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration method = findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (operand_71234->mSemanticDeclaration.galgasObjectRunTimeInfo ()) ;
            if (method != NULL) {
              method (inLexique, operand_71234->mSemanticDeclaration (HERE), var_cas_partiallyOrderedSemanticDeclarationListAST COMMA_SOURCE_FILE_AT_LINE (1748)) ;
            }
          }
        }
      }
      GGS_semanticDeclarationListAST  var_cas_orderedSemanticDeclarationListAST = GGS_semanticDeclarationListAST ::constructor_emptyList () ;
      GGS_stringset  var_cas_alreadyDefinedTypes = GGS_stringset ::constructor_emptySet () ;
      var_cas_alreadyDefinedTypes.addAssign_operation (GGS_string ("")) ;
      GGS_bool var_cas_progress = GGS_bool (true) ;
      GGS_uint _variant_72348 = var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length () ;
      GGS_bool _condition_72348 (_variant_72348.isBuilt (), true) ;
      while (_condition_72348.isBuiltAndTrue ()) {
        _condition_72348 = ((var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U))).operator_and (var_cas_progress) ;
        if (_condition_72348.isBuiltAndTrue ()) {
          if (_variant_72348.uintValue () == 0) {
            inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (1769)) ;
            _condition_72348 = GGS_bool (false) ;
          }else{
            _variant_72348.decrement_operation (inLexique COMMA_HERE) ;
            var_cas_progress = GGS_bool (false) ;
            const GGS_partiallyOrderedSemanticDeclarationListAST  var_cas_r = var_cas_partiallyOrderedSemanticDeclarationListAST ;
            var_cas_partiallyOrderedSemanticDeclarationListAST = GGS_partiallyOrderedSemanticDeclarationListAST ::constructor_emptySortedList () ;
            {
              GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_71963 (var_cas_r, true) ;
              const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_71963 = NULL ;
              while (((operand_71963 = enumerator_71963.nextObject ()))) {
                macroValidPointer (operand_71963) ;
                const GGS_bool cond_72191 = var_cas_alreadyDefinedTypes.reader_hasKey (operand_71963->mDependanceString) ;
                if (cond_72191.isBuiltAndTrue ()) {
                  var_cas_orderedSemanticDeclarationListAST.addAssign_operation (operand_71963->mSemanticDeclaration) ;
                  var_cas_alreadyDefinedTypes.addAssign_operation (operand_71963->mTypeString) ;
                  var_cas_progress = GGS_bool (true) ;
                }else if (cond_72191.isBuiltAndFalse ()) {
                  var_cas_partiallyOrderedSemanticDeclarationListAST.addAssign_operation (operand_71963->mDependanceString, operand_71963->mTypeString, operand_71963->mSemanticDeclaration) ;
                }
              }
            }
          }
        }
      }
      const GGS_bool cond_72971 = (var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
      if (cond_72971.isBuiltAndTrue ()) {
        GGS_string var_cas_s = GGS_string ("inheritance circularities involving the ") ;
        {
          GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_72630 (var_cas_partiallyOrderedSemanticDeclarationListAST, true) ;
          const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_72630 = enumerator_72630.nextObject () ;
          if ((operand_72630 != NULL)) {
            bool _foreach_loop_72630 ;
            do{
              macroValidPointer (operand_72630) ;
              var_cas_s.appendCString ("@") ;
              var_cas_s.dotAssign_operation (operand_72630->mTypeString) ;
              operand_72630 = enumerator_72630.nextObject () ;
              _foreach_loop_72630 = ((operand_72630 != NULL)) ;
              if (_foreach_loop_72630) {
                var_cas_s.appendCString (", ") ;
              }
            }while (_foreach_loop_72630) ;
          }
        }
        var_cas_s.appendCString (" classes; detail:") ;
        {
          GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_72803 (var_cas_partiallyOrderedSemanticDeclarationListAST, true) ;
          const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_72803 = NULL ;
          while (((operand_72803 = enumerator_72803.nextObject ()))) {
            macroValidPointer (operand_72803) ;
            var_cas_s.appendCString ("\n"
              "  - @") ;
            var_cas_s.dotAssign_operation (operand_72803->mTypeString) ;
            var_cas_s.appendCString (" inherits from @") ;
            var_cas_s.dotAssign_operation (operand_72803->mDependanceString) ;
          }
        }
        var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_s COMMA_SOURCE_FILE_AT_LINE (1782)) ;
        var_cas_outSemanticContext.drop () ;
      }else if (cond_72971.isBuiltAndFalse ()) {
        var_cas_outSemanticContext = GGS_semanticContext::constructor_new (GGS_unifiedTypeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1785)), GGS_routineMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1786)), GGS_functionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1787)), GGS_filewrapperMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1788)), GGS_grammarMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1789)), GGS_optionComponentMapForSemanticAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1790))) ;
        {
          GGS_semanticDeclarationListAST::cEnumerator enumerator_73387 (var_cas_orderedSemanticDeclarationListAST, true) ;
          const GGS_semanticDeclarationListAST::cElement * operand_73387 = NULL ;
          while (((operand_73387 = enumerator_73387.nextObject ()))) {
            macroValidPointer (operand_73387) ;
            { typeCategoryMethod__semanticDeclarationAST__enterType method = findCategoryMethod__semanticDeclarationAST__enterType (operand_73387->mSemanticDeclaration.galgasObjectRunTimeInfo ()) ;
              if (method != NULL) {
                method (inLexique, operand_73387->mSemanticDeclaration (HERE), var_cas_multiMethodMapForBuildingContext, var_cas_outSemanticContext COMMA_SOURCE_FILE_AT_LINE (1794)) ;
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildSemanticContext\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticContext (void) {
  enterCategoryMethod__semanticDeclarationAST__collectTypes (category_method__semanticDeclarationAST__collectTypes, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__genericTypeTypeAST__collectTypes, gClassInfoFor__genericTypeTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__abstracMultiMethodAST__collectTypes, gClassInfoFor__abstracMultiMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__multiMethodAST__collectTypes, gClassInfoFor__multiMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__overridingMultiMethodAST__collectTypes, gClassInfoFor__overridingMultiMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__abstractMultiReaderAST__collectTypes, gClassInfoFor__abstractMultiReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__multiReaderAST__collectTypes, gClassInfoFor__multiReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__overridingMultiReaderAST__collectTypes, gClassInfoFor__overridingMultiReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__objectPredefinedTypeAST__collectTypes, gClassInfoFor__objectPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__predefinedTypeAST__collectTypes, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__mapDeclarationAST__collectTypes, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__mapProxyDeclarationAST__collectTypes, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__enumDeclarationAST__collectTypes, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__sortedListDeclarationAST__collectTypes, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__structDeclarationAST__collectTypes, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__listDeclarationAST__collectTypes, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__classDeclarationAST__collectTypes, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__listmapDeclarationAST__collectTypes, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__predefinedTypeAST__enterType, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__genericTypeTypeAST__enterType, gClassInfoFor__genericTypeTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__objectPredefinedTypeAST__enterType, gClassInfoFor__objectPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__mapDeclarationAST__enterType, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__mapProxyDeclarationAST__enterType, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__enumDeclarationAST__enterType, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__filewrapperDeclarationAST__enterType, gClassInfoFor__filewrapperDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__listDeclarationAST__enterType, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__sortedListDeclarationAST__enterType, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__structDeclarationAST__enterType, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__classDeclarationAST__enterType, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__externRoutineDeclarationAST__enterType, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__externFunctionDeclarationAST__enterType, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__onceFunctionDeclarationAST__enterType, gClassInfoFor__onceFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterType ((typeCategoryMethod__semanticDeclarationAST__enterType) category_method__listmapDeclarationAST__enterType, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (category_method__semanticDeclarationAST__enterOrderedDeclaration, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__predefinedTypeAST__enterOrderedDeclaration, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__objectPredefinedTypeAST__enterOrderedDeclaration, gClassInfoFor__objectPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__stringsetPredefinedTypeAST__enterOrderedDeclaration, gClassInfoFor__stringsetPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__genericTypeTypeAST__enterOrderedDeclaration, gClassInfoFor__genericTypeTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__classDeclarationAST__enterOrderedDeclaration, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__listDeclarationAST__enterOrderedDeclaration, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__structDeclarationAST__enterOrderedDeclaration, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__enumDeclarationAST__enterOrderedDeclaration, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__sortedListDeclarationAST__enterOrderedDeclaration, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__listmapDeclarationAST__enterOrderedDeclaration, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__mapDeclarationAST__enterOrderedDeclaration, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__mapProxyDeclarationAST__enterOrderedDeclaration, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__externFunctionDeclarationAST__enterOrderedDeclaration, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__externRoutineDeclarationAST__enterOrderedDeclaration, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticContext (void) {
  gDispatchTableForMethod__semanticDeclarationAST__collectTypes.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterType.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticContext (prologueRoutineFor_semanticContext, epilogueRoutineFor_semanticContext) ;

//---------------------------------------------------------------------------*

