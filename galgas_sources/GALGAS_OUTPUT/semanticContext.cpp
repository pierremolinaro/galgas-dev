//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'semanticContext.cpp'                         *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 14th, 2010, at 15h5'24"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "semanticContext.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticContext.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_grammarLabelMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_grammarLabelMap::e_grammarLabelMap (void) :
mLabelSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@grammarLabelMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarLabelMap ("grammarLabelMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_grammarLabelMap::
elementOf_GGS_grammarLabelMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_grammarLabelMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_grammarLabelMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLabelSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_grammarLabelMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_grammarLabelMap * ptr = dynamic_cast <const elementOf_GGS_grammarLabelMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mLabelSignature.operator_isEqual (ptr->mInfo.mLabelSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_grammarLabelMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_grammarLabelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_grammarLabelMap * info = (e_grammarLabelMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_grammarLabelMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_grammarLabelMap * info = (e_grammarLabelMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_grammarLabelMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_grammarLabelMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_grammarLabelMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarLabelMap::
operator_isEqual (const GGS_grammarLabelMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarLabelMap::
operator_isNotEqual (const GGS_grammarLabelMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_formalParameterSignature & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_grammarLabelMap info  ;
    info.mLabelSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mLabelSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_grammarLabelMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_grammarLabelMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_grammarLabelMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_grammarLabelMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_grammarLabelMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_grammarLabelMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarLabelMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @grammarLabelMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_grammarLabelMap::cEnumerator::_mLabelSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLabelSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_grammarLabelMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarLabelMap * p = NULL ;
    macroMyNew (p, GGS_grammarLabelMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarLabelMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarLabelMap * p = dynamic_cast <const GGS_grammarLabelMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarLabelMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarLabelMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarLabelMap ;
}

//---------------------------------------------------------------------------*

GGS_grammarLabelMap GGS_grammarLabelMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_formalParameterSignature & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_grammarLabelMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_grammarMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_grammarMap::e_grammarMap (void) :
mLabelMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@grammarMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_grammarMap ("grammarMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_grammarMap::
elementOf_GGS_grammarMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_grammarMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_grammarMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mLabelMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_grammarMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_grammarMap * ptr = dynamic_cast <const elementOf_GGS_grammarMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mLabelMap.operator_isEqual (ptr->mInfo.mLabelMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_grammarMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_grammarMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_grammarMap * info = (e_grammarMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_grammarMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_grammarMap * info = (e_grammarMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_grammarMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_grammarMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_grammarMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarMap::
operator_isEqual (const GGS_grammarMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_grammarMap::
operator_isNotEqual (const GGS_grammarMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_grammarLabelMap & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_grammarMap info  ;
    info.mLabelMap = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_grammarMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_grammarLabelMap   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mLabelMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_grammarMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_grammarMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_grammarLabelMap   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_grammarMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('g'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_grammarMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_grammarLabelMap & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_grammarMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_grammarMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_grammarMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_grammarMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @grammarMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_grammarLabelMap  & GGS_grammarMap::cEnumerator::_mLabelMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mLabelMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_grammarMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_grammarMap * p = NULL ;
    macroMyNew (p, GGS_grammarMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_grammarMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_grammarMap * p = dynamic_cast <const GGS_grammarMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_grammarMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_grammarMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_grammarMap ;
}

//---------------------------------------------------------------------------*

GGS_grammarMap GGS_grammarMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_grammarLabelMap & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_grammarMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class 'e_routineMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_routineMap::e_routineMap (void) :
mRoutineSignature () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@routineMap'                           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_routineMap ("routineMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_routineMap::
elementOf_GGS_routineMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_routineMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_routineMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRoutineSignature.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_routineMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_routineMap * ptr = dynamic_cast <const elementOf_GGS_routineMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRoutineSignature.operator_isEqual (ptr->mInfo.mRoutineSignature)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_routineMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_routineMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_routineMap * info = (e_routineMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_routineMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_routineMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_routineMap::
operator_isNotEqual (const GGS_routineMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_formalParameterSignature & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_routineMap info  ;
    info.mRoutineSignature = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_routineMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterSignature   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mRoutineSignature ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_formalParameterSignature   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_routineMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_routineMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterSignature & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_routineMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_routineMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_routineMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_routineMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @routineMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterSignature  & GGS_routineMap::cEnumerator::_mRoutineSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRoutineSignature ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_routineMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_routineMap * p = NULL ;
    macroMyNew (p, GGS_routineMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_routineMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_routineMap * p = dynamic_cast <const GGS_routineMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_routineMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_routineMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_routineMap ;
}

//---------------------------------------------------------------------------*

GGS_routineMap GGS_routineMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_formalParameterSignature & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_routineMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class 'e_functionMap'                            *
//                                                                           *
//---------------------------------------------------------------------------*

e_functionMap::e_functionMap (void) :
mFunctionSignature (),
mResultType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class map '@functionMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_functionMap ("functionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_functionMap::
elementOf_GGS_functionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_functionMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_functionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFunctionSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mResultType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_functionMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_functionMap * ptr = dynamic_cast <const elementOf_GGS_functionMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFunctionSignature.operator_isEqual (ptr->mInfo.mFunctionSignature)).boolValue ()
           && (mInfo.mResultType.operator_isEqual (ptr->mInfo.mResultType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_functionMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_functionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_functionMap * info = (e_functionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_functionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_functionMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_functionMap::
operator_isNotEqual (const GGS_functionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxyList & inParameter0,
               const GGS_unifiedTypeMapProxy & inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_functionMap info  ;
    info.mFunctionSignature = inParameter0 ;
    info.mResultType = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_functionMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxyList   & outParameter0,
               GGS_unifiedTypeMapProxy   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mFunctionSignature ;
    outParameter1 = node->mInfo.mResultType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxyList   & outParameter0,
                                GGS_unifiedTypeMapProxy   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_functionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('u'),
  TO_UNICODE ('n'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_functionMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxyList & inParameter0,
                                const GGS_unifiedTypeMapProxy & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_functionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_functionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_functionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_functionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @functionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxyList  & GGS_functionMap::cEnumerator::_mFunctionSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFunctionSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxy  & GGS_functionMap::cEnumerator::_mResultType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mResultType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_functionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_functionMap * p = NULL ;
    macroMyNew (p, GGS_functionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_functionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_functionMap * p = dynamic_cast <const GGS_functionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_functionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_functionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_functionMap ;
}

//---------------------------------------------------------------------------*

GGS_functionMap GGS_functionMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxyList & inValue0,
                                             const GGS_unifiedTypeMapProxy & inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_functionMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_wrapperFileMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_wrapperFileMap::e_wrapperFileMap (void) :
mAbsoluteFilePath (),
mWrapperDirectoryIndex (),
mWrapperFileIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@wrapperFileMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_wrapperFileMap ("wrapperFileMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_wrapperFileMap::
elementOf_GGS_wrapperFileMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_wrapperFileMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperFileMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAbsoluteFilePath.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mWrapperDirectoryIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mWrapperFileIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperFileMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_wrapperFileMap * ptr = dynamic_cast <const elementOf_GGS_wrapperFileMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAbsoluteFilePath.operator_isEqual (ptr->mInfo.mAbsoluteFilePath)).boolValue ()
           && (mInfo.mWrapperDirectoryIndex.operator_isEqual (ptr->mInfo.mWrapperDirectoryIndex)).boolValue ()
           && (mInfo.mWrapperFileIndex.operator_isEqual (ptr->mInfo.mWrapperFileIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_wrapperFileMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_wrapperFileMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_wrapperFileMap * info = (e_wrapperFileMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_wrapperFileMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_wrapperFileMap * info = (e_wrapperFileMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileMap GGS_wrapperFileMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperFileMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_wrapperFileMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_wrapperFileMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperFileMap::
operator_isEqual (const GGS_wrapperFileMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperFileMap::
operator_isNotEqual (const GGS_wrapperFileMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_string& inParameter0,
               const GGS_uint & inParameter1,
               const GGS_uint & inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_wrapperFileMap info  ;
    info.mAbsoluteFilePath = inParameter0 ;
    info.mWrapperDirectoryIndex = inParameter1 ;
    info.mWrapperFileIndex = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperFileMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_uint   & outParameter1,
               GGS_uint   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mAbsoluteFilePath ;
    outParameter1 = node->mInfo.mWrapperDirectoryIndex ;
    outParameter2 = node->mInfo.mWrapperFileIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_wrapperFileMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('I'),
  TO_UNICODE ('N'),
  TO_UNICODE ('T'),
  TO_UNICODE ('E'),
  TO_UNICODE ('R'),
  TO_UNICODE ('N'),
  TO_UNICODE ('A'),
  TO_UNICODE ('L'),
  TO_UNICODE (' '),
  TO_UNICODE ('E'),
  TO_UNICODE ('R'),
  TO_UNICODE ('R'),
  TO_UNICODE ('O'),
  TO_UNICODE ('R'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_wrapperFileMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0,
                                GGS_uint   & outParameter1,
                                GGS_uint   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_wrapperFileMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('I'),
  TO_UNICODE ('N'),
  TO_UNICODE ('T'),
  TO_UNICODE ('E'),
  TO_UNICODE ('R'),
  TO_UNICODE ('N'),
  TO_UNICODE ('A'),
  TO_UNICODE ('L'),
  TO_UNICODE (' '),
  TO_UNICODE ('E'),
  TO_UNICODE ('R'),
  TO_UNICODE ('R'),
  TO_UNICODE ('O'),
  TO_UNICODE ('R'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_wrapperFileMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_uint & inParameter1,
                                const GGS_uint & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileMap GGS_wrapperFileMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_wrapperFileMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperFileMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileMap GGS_wrapperFileMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperFileMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperFileMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @wrapperFileMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_wrapperFileMap::cEnumerator::_mAbsoluteFilePath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAbsoluteFilePath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperFileMap::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperFileMap::cEnumerator::_mWrapperFileIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperFileIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_wrapperFileMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_wrapperFileMap * p = NULL ;
    macroMyNew (p, GGS_wrapperFileMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileMap GGS_wrapperFileMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_wrapperFileMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_wrapperFileMap * p = dynamic_cast <const GGS_wrapperFileMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_wrapperFileMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_wrapperFileMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_wrapperFileMap ;
}

//---------------------------------------------------------------------------*

GGS_wrapperFileMap GGS_wrapperFileMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_string& inValue0,
                                             const GGS_uint & inValue1,
                                             const GGS_uint & inValue2
                                             COMMA_LOCATION_ARGS) {
  GGS_wrapperFileMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_wrapperDirectoryMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

e_wrapperDirectoryMap::e_wrapperDirectoryMap (void) :
mRegularFileMap (),
mDirectoryMap (),
mWrapperDirectoryIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@wrapperDirectoryMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_wrapperDirectoryMap ("wrapperDirectoryMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_wrapperDirectoryMap::
elementOf_GGS_wrapperDirectoryMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_wrapperDirectoryMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperDirectoryMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mRegularFileMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mDirectoryMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mWrapperDirectoryIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperDirectoryMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_wrapperDirectoryMap * ptr = dynamic_cast <const elementOf_GGS_wrapperDirectoryMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mRegularFileMap.operator_isEqual (ptr->mInfo.mRegularFileMap)).boolValue ()
           && (mInfo.mDirectoryMap.operator_isEqual (ptr->mInfo.mDirectoryMap)).boolValue ()
           && (mInfo.mWrapperDirectoryIndex.operator_isEqual (ptr->mInfo.mWrapperDirectoryIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_wrapperDirectoryMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_wrapperDirectoryMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_wrapperDirectoryMap * info = (e_wrapperDirectoryMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectoryMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_wrapperDirectoryMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_wrapperDirectoryMap * info = (e_wrapperDirectoryMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectoryMap GGS_wrapperDirectoryMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperDirectoryMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectoryMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_wrapperDirectoryMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectoryMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_wrapperDirectoryMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperDirectoryMap::
operator_isEqual (const GGS_wrapperDirectoryMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperDirectoryMap::
operator_isNotEqual (const GGS_wrapperDirectoryMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectoryMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectoryMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_wrapperFileMap & inParameter0,
               const GGS_wrapperDirectoryMap & inParameter1,
               const GGS_uint & inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_wrapperDirectoryMap info  ;
    info.mRegularFileMap = inParameter0 ;
    info.mDirectoryMap = inParameter1 ;
    info.mWrapperDirectoryIndex = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperDirectoryMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_wrapperFileMap   & outParameter0,
               GGS_wrapperDirectoryMap   & outParameter1,
               GGS_uint   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mRegularFileMap ;
    outParameter1 = node->mInfo.mDirectoryMap ;
    outParameter2 = node->mInfo.mWrapperDirectoryIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_wrapperDirectoryMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('I'),
  TO_UNICODE ('N'),
  TO_UNICODE ('T'),
  TO_UNICODE ('E'),
  TO_UNICODE ('R'),
  TO_UNICODE ('N'),
  TO_UNICODE ('A'),
  TO_UNICODE ('L'),
  TO_UNICODE (' '),
  TO_UNICODE ('E'),
  TO_UNICODE ('R'),
  TO_UNICODE ('R'),
  TO_UNICODE ('O'),
  TO_UNICODE ('R'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_wrapperDirectoryMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_wrapperFileMap   & outParameter0,
                                GGS_wrapperDirectoryMap   & outParameter1,
                                GGS_uint   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_wrapperDirectoryMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('I'),
  TO_UNICODE ('N'),
  TO_UNICODE ('T'),
  TO_UNICODE ('E'),
  TO_UNICODE ('R'),
  TO_UNICODE ('N'),
  TO_UNICODE ('A'),
  TO_UNICODE ('L'),
  TO_UNICODE (' '),
  TO_UNICODE ('E'),
  TO_UNICODE ('R'),
  TO_UNICODE ('R'),
  TO_UNICODE ('O'),
  TO_UNICODE ('R'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_wrapperDirectoryMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_wrapperFileMap & inParameter0,
                                const GGS_wrapperDirectoryMap & inParameter1,
                                const GGS_uint & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectoryMap GGS_wrapperDirectoryMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_wrapperDirectoryMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperDirectoryMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectoryMap GGS_wrapperDirectoryMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperDirectoryMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperDirectoryMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @wrapperDirectoryMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_wrapperFileMap  & GGS_wrapperDirectoryMap::cEnumerator::_mRegularFileMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mRegularFileMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_wrapperDirectoryMap  & GGS_wrapperDirectoryMap::cEnumerator::_mDirectoryMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mDirectoryMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_wrapperDirectoryMap::cEnumerator::_mWrapperDirectoryIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mWrapperDirectoryIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_wrapperDirectoryMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_wrapperDirectoryMap * p = NULL ;
    macroMyNew (p, GGS_wrapperDirectoryMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectoryMap GGS_wrapperDirectoryMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_wrapperDirectoryMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_wrapperDirectoryMap * p = dynamic_cast <const GGS_wrapperDirectoryMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_wrapperDirectoryMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_wrapperDirectoryMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_wrapperDirectoryMap ;
}

//---------------------------------------------------------------------------*

GGS_wrapperDirectoryMap GGS_wrapperDirectoryMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_wrapperFileMap & inValue0,
                                             const GGS_wrapperDirectoryMap & inValue1,
                                             const GGS_uint & inValue2
                                             COMMA_LOCATION_ARGS) {
  GGS_wrapperDirectoryMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_filewrapperTemplateMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperTemplateMap::e_filewrapperTemplateMap (void) :
mTemplateSignature (),
mFilewrapperTemplatePath () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@filewrapperTemplateMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperTemplateMap ("filewrapperTemplateMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperTemplateMap::
elementOf_GGS_filewrapperTemplateMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperTemplateMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperTemplateMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTemplateSignature.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplatePath.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperTemplateMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperTemplateMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperTemplateMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mTemplateSignature.operator_isEqual (ptr->mInfo.mTemplateSignature)).boolValue ()
           && (mInfo.mFilewrapperTemplatePath.operator_isEqual (ptr->mInfo.mFilewrapperTemplatePath)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperTemplateMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperTemplateMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperTemplateMap * info = (e_filewrapperTemplateMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperTemplateMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_filewrapperTemplateMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperTemplateMap::
operator_isNotEqual (const GGS_filewrapperTemplateMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_unifiedTypeMapProxyList & inParameter0,
               const GGS_lstring & inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_filewrapperTemplateMap info  ;
    info.mTemplateSignature = inParameter0 ;
    info.mFilewrapperTemplatePath = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_unifiedTypeMapProxyList   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mTemplateSignature ;
    outParameter1 = node->mInfo.mFilewrapperTemplatePath ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_unifiedTypeMapProxyList   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperTemplateMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperTemplateMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_unifiedTypeMapProxyList & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_filewrapperTemplateMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperTemplateMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperTemplateMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperTemplateMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_unifiedTypeMapProxyList  & GGS_filewrapperTemplateMap::cEnumerator::_mTemplateSignature (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTemplateSignature ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperTemplateMap::cEnumerator::_mFilewrapperTemplatePath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplatePath ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperTemplateMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperTemplateMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperTemplateMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperTemplateMap * p = dynamic_cast <const GGS_filewrapperTemplateMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperTemplateMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperTemplateMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperTemplateMap GGS_filewrapperTemplateMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_unifiedTypeMapProxyList & inValue0,
                                             const GGS_lstring & inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_filewrapperTemplateMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                         class 'e_filewrapperMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_filewrapperMap::e_filewrapperMap (void) :
mFilewrapperPath (),
mFilewrapperExtensionList (),
mFilewrapperFileMap (),
mFilewrapperDirectoryMap (),
mFilewrapperTemplateMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@filewrapperMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_filewrapperMap ("filewrapperMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_filewrapperMap::
elementOf_GGS_filewrapperMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_filewrapperMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_filewrapperMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperPath.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperExtensionList.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperFileMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperDirectoryMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFilewrapperTemplateMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_filewrapperMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_filewrapperMap * ptr = dynamic_cast <const elementOf_GGS_filewrapperMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFilewrapperPath.operator_isEqual (ptr->mInfo.mFilewrapperPath)).boolValue ()
           && (mInfo.mFilewrapperExtensionList.operator_isEqual (ptr->mInfo.mFilewrapperExtensionList)).boolValue ()
           && (mInfo.mFilewrapperFileMap.operator_isEqual (ptr->mInfo.mFilewrapperFileMap)).boolValue ()
           && (mInfo.mFilewrapperDirectoryMap.operator_isEqual (ptr->mInfo.mFilewrapperDirectoryMap)).boolValue ()
           && (mInfo.mFilewrapperTemplateMap.operator_isEqual (ptr->mInfo.mFilewrapperTemplateMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_filewrapperMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_filewrapperMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_filewrapperMap * info = (e_filewrapperMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_filewrapperMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_filewrapperMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_filewrapperMap::
operator_isNotEqual (const GGS_filewrapperMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
               const GGS_lstringlist & inParameter1,
               const GGS_wrapperFileMap & inParameter2,
               const GGS_wrapperDirectoryMap & inParameter3,
               const GGS_filewrapperTemplateMap & inParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inParameter4.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_filewrapperMap info  ;
    info.mFilewrapperPath = inParameter0 ;
    info.mFilewrapperExtensionList = inParameter1 ;
    info.mFilewrapperFileMap = inParameter2 ;
    info.mFilewrapperDirectoryMap = inParameter3 ;
    info.mFilewrapperTemplateMap = inParameter4 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstringlist   & outParameter1,
               GGS_wrapperFileMap   & outParameter2,
               GGS_wrapperDirectoryMap   & outParameter3,
               GGS_filewrapperTemplateMap   & outParameter4,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    outParameter4.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mFilewrapperPath ;
    outParameter1 = node->mInfo.mFilewrapperExtensionList ;
    outParameter2 = node->mInfo.mFilewrapperFileMap ;
    outParameter3 = node->mInfo.mFilewrapperDirectoryMap ;
    outParameter4 = node->mInfo.mFilewrapperTemplateMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstringlist   & outParameter1,
                                GGS_wrapperFileMap   & outParameter2,
                                GGS_wrapperDirectoryMap   & outParameter3,
                                GGS_filewrapperTemplateMap   & outParameter4 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 outParameter4,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_filewrapperMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('w'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_filewrapperMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstringlist & inParameter1,
                                const GGS_wrapperFileMap & inParameter2,
                                const GGS_wrapperDirectoryMap & inParameter3,
                                const GGS_filewrapperTemplateMap & inParameter4 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                 inParameter4,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_filewrapperMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_filewrapperMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_filewrapperMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_filewrapperMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @filewrapperMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_filewrapperMap::cEnumerator::_mFilewrapperPath (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperPath ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_filewrapperMap::cEnumerator::_mFilewrapperExtensionList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperExtensionList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_wrapperFileMap  & GGS_filewrapperMap::cEnumerator::_mFilewrapperFileMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperFileMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_wrapperDirectoryMap  & GGS_filewrapperMap::cEnumerator::_mFilewrapperDirectoryMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperDirectoryMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_filewrapperTemplateMap  & GGS_filewrapperMap::cEnumerator::_mFilewrapperTemplateMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFilewrapperTemplateMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_filewrapperMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_filewrapperMap * p = NULL ;
    macroMyNew (p, GGS_filewrapperMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_filewrapperMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_filewrapperMap * p = dynamic_cast <const GGS_filewrapperMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_filewrapperMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_filewrapperMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_filewrapperMap ;
}

//---------------------------------------------------------------------------*

GGS_filewrapperMap GGS_filewrapperMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_lstring & inValue0,
                                             const GGS_lstringlist & inValue1,
                                             const GGS_wrapperFileMap & inValue2,
                                             const GGS_wrapperDirectoryMap & inValue3,
                                             const GGS_filewrapperTemplateMap & inValue4
                                             COMMA_LOCATION_ARGS) {
  GGS_filewrapperMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        inValue3,
                        inValue4,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'e_optionComponentMapForSemanticAnalysis'               *
//                                                                           *
//---------------------------------------------------------------------------*

e_optionComponentMapForSemanticAnalysis::e_optionComponentMapForSemanticAnalysis (void) :
mBoolOptionMap (),
mUIntOptionMap (),
mStringOptionMap () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class map '@optionComponentMapForSemanticAnalysis'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_optionComponentMapForSemanticAnalysis ("optionComponentMapForSemanticAnalysis", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_optionComponentMapForSemanticAnalysis::
elementOf_GGS_optionComponentMapForSemanticAnalysis (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_optionComponentMapForSemanticAnalysis & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_optionComponentMapForSemanticAnalysis::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mBoolOptionMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mUIntOptionMap.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStringOptionMap.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_optionComponentMapForSemanticAnalysis::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_optionComponentMapForSemanticAnalysis * ptr = dynamic_cast <const elementOf_GGS_optionComponentMapForSemanticAnalysis *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mBoolOptionMap.operator_isEqual (ptr->mInfo.mBoolOptionMap)).boolValue ()
           && (mInfo.mUIntOptionMap.operator_isEqual (ptr->mInfo.mUIntOptionMap)).boolValue ()
           && (mInfo.mStringOptionMap.operator_isEqual (ptr->mInfo.mStringOptionMap)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_optionComponentMapForSemanticAnalysis::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_optionComponentMapForSemanticAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_optionComponentMapForSemanticAnalysis * info = (e_optionComponentMapForSemanticAnalysis *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_optionComponentMapForSemanticAnalysis *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_optionComponentMapForSemanticAnalysis * info = (e_optionComponentMapForSemanticAnalysis *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_optionComponentMapForSemanticAnalysis result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_optionComponentMapForSemanticAnalysis info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_optionComponentMapForSemanticAnalysis info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_optionComponentMapForSemanticAnalysis::
operator_isEqual (const GGS_optionComponentMapForSemanticAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_optionComponentMapForSemanticAnalysis::
operator_isNotEqual (const GGS_optionComponentMapForSemanticAnalysis & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_commandLineOptionMap & inParameter0,
               const GGS_commandLineOptionMap & inParameter1,
               const GGS_commandLineOptionMap & inParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_optionComponentMapForSemanticAnalysis info  ;
    info.mBoolOptionMap = inParameter0 ;
    info.mUIntOptionMap = inParameter1 ;
    info.mStringOptionMap = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_commandLineOptionMap   & outParameter0,
               GGS_commandLineOptionMap   & outParameter1,
               GGS_commandLineOptionMap   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mBoolOptionMap ;
    outParameter1 = node->mInfo.mUIntOptionMap ;
    outParameter2 = node->mInfo.mStringOptionMap ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_optionComponentMapForSemanticAnalysis::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_commandLineOptionMap   & outParameter0,
                                GGS_commandLineOptionMap   & outParameter1,
                                GGS_commandLineOptionMap   & outParameter2 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_optionComponentMapForSemanticAnalysis::kInsertMessage_insertKey [] = {
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('f'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('o'),
  TO_UNICODE ('p'),
  TO_UNICODE ('t'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('o'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (':'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_optionComponentMapForSemanticAnalysis::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_commandLineOptionMap & inParameter0,
                                const GGS_commandLineOptionMap & inParameter1,
                                const GGS_commandLineOptionMap & inParameter2 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_optionComponentMapForSemanticAnalysis & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_optionComponentMapForSemanticAnalysis result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_optionComponentMapForSemanticAnalysis result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_optionComponentMapForSemanticAnalysis::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @optionComponentMapForSemanticAnalysis " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_commandLineOptionMap  & GGS_optionComponentMapForSemanticAnalysis::cEnumerator::_mBoolOptionMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mBoolOptionMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_commandLineOptionMap  & GGS_optionComponentMapForSemanticAnalysis::cEnumerator::_mUIntOptionMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mUIntOptionMap ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_commandLineOptionMap  & GGS_optionComponentMapForSemanticAnalysis::cEnumerator::_mStringOptionMap (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStringOptionMap ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_optionComponentMapForSemanticAnalysis::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_optionComponentMapForSemanticAnalysis * p = NULL ;
    macroMyNew (p, GGS_optionComponentMapForSemanticAnalysis (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_optionComponentMapForSemanticAnalysis result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_optionComponentMapForSemanticAnalysis * p = dynamic_cast <const GGS_optionComponentMapForSemanticAnalysis *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_optionComponentMapForSemanticAnalysis, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_optionComponentMapForSemanticAnalysis::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_optionComponentMapForSemanticAnalysis ;
}

//---------------------------------------------------------------------------*

GGS_optionComponentMapForSemanticAnalysis GGS_optionComponentMapForSemanticAnalysis::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_commandLineOptionMap & inValue0,
                                             const GGS_commandLineOptionMap & inValue1,
                                             const GGS_commandLineOptionMap & inValue2
                                             COMMA_LOCATION_ARGS) {
  GGS_optionComponentMapForSemanticAnalysis result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        inValue2,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Implementation of 'semanticContext' struct                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_semanticContext ("semanticContext", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_semanticContext::GGS_semanticContext (void) :
mSourceFileAbsolutePath (),
mTypeMap (),
mRoutineMap (),
mFunctionMap (),
mFilewrapperMap (),
mGrammarMap (),
mOptionComponentMapForSemanticAnalysis () {
}

//---------------------------------------------------------------------------*

GGS_semanticContext::~GGS_semanticContext (void) {
}

//---------------------------------------------------------------------------*

void GGS_semanticContext::drop (void) {
  mSourceFileAbsolutePath.drop () ;
  mTypeMap.drop () ;
  mRoutineMap.drop () ;
  mFunctionMap.drop () ;
  mFilewrapperMap.drop () ;
  mGrammarMap.drop () ;
  mOptionComponentMapForSemanticAnalysis.drop () ;
}

//---------------------------------------------------------------------------*

bool GGS_semanticContext::isBuilt (void) const {
  return mSourceFileAbsolutePath.isBuilt ()
    && mTypeMap.isBuilt ()
    && mRoutineMap.isBuilt ()
    && mFunctionMap.isBuilt ()
    && mFilewrapperMap.isBuilt ()
    && mGrammarMap.isBuilt ()
    && mOptionComponentMapForSemanticAnalysis.isBuilt () ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isEqual (const GGS_semanticContext & inOperand) const {
  return mSourceFileAbsolutePath.operator_isEqual (inOperand.mSourceFileAbsolutePath)
    .operator_and (mTypeMap.operator_isEqual (inOperand.mTypeMap))
    .operator_and (mRoutineMap.operator_isEqual (inOperand.mRoutineMap))
    .operator_and (mFunctionMap.operator_isEqual (inOperand.mFunctionMap))
    .operator_and (mFilewrapperMap.operator_isEqual (inOperand.mFilewrapperMap))
    .operator_and (mGrammarMap.operator_isEqual (inOperand.mGrammarMap))
    .operator_and (mOptionComponentMapForSemanticAnalysis.operator_isEqual (inOperand.mOptionComponentMapForSemanticAnalysis)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_semanticContext::
operator_isNotEqual (const GGS_semanticContext & inOperand) const {
  return mSourceFileAbsolutePath.operator_isNotEqual (inOperand.mSourceFileAbsolutePath)
    .operator_or (mTypeMap.operator_isNotEqual (inOperand.mTypeMap))
    .operator_or (mRoutineMap.operator_isNotEqual (inOperand.mRoutineMap))
    .operator_or (mFunctionMap.operator_isNotEqual (inOperand.mFunctionMap))
    .operator_or (mFilewrapperMap.operator_isNotEqual (inOperand.mFilewrapperMap))
    .operator_or (mGrammarMap.operator_isNotEqual (inOperand.mGrammarMap))
    .operator_or (mOptionComponentMapForSemanticAnalysis.operator_isNotEqual (inOperand.mOptionComponentMapForSemanticAnalysis)) ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::
constructor_new (const GGS_string& argument_0,
                 const GGS_unifiedTypeMap & argument_1,
                 const GGS_routineMap & argument_2,
                 const GGS_functionMap & argument_3,
                 const GGS_filewrapperMap & argument_4,
                 const GGS_grammarMap & argument_5,
                 const GGS_optionComponentMapForSemanticAnalysis & argument_6) {
  GGS_semanticContext result ;
  result.mSourceFileAbsolutePath = argument_0 ;
  result.mTypeMap = argument_1 ;
  result.mRoutineMap = argument_2 ;
  result.mFunctionMap = argument_3 ;
  result.mFilewrapperMap = argument_4 ;
  result.mGrammarMap = argument_5 ;
  result.mOptionComponentMapForSemanticAnalysis = argument_6 ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_semanticContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String _s ;
  _s << "<struct @semanticContext" ;
  if (isBuilt ()) {
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mSourceFileAbsolutePath " ;
    _s << mSourceFileAbsolutePath.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mTypeMap " ;
    _s << mTypeMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mRoutineMap " ;
    _s << mRoutineMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFunctionMap " ;
    _s << mFunctionMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mFilewrapperMap " ;
    _s << mFilewrapperMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mGrammarMap " ;
    _s << mGrammarMap.reader_description (inIndentation + 1) ;
    _s << "\n" ;
    _s.writeStringMultiple ("| ", inIndentation + 1) ;
    _s << "mOptionComponentMapForSemanticAnalysis " ;
    _s << mOptionComponentMapForSemanticAnalysis.reader_description (inIndentation + 1) ;
  }else{
    _s << "not built" ;
  }
  _s << "\n" ;
  _s.writeStringMultiple ("| ", inIndentation) ;
  _s << ">" ;
  return GGS_string (true, _s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_semanticContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_semanticContext * p = NULL ;
    macroMyNew (p, GGS_semanticContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_semanticContext GGS_semanticContext::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_semanticContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_semanticContext * p = dynamic_cast <const GGS_semanticContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_semanticContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_semanticContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_semanticContext ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@collectedTypeMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMap ("collectedTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_collectedTypeMap::
elementOf_GGS_collectedTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_collectedTypeMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_collectedTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_collectedTypeMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_collectedTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_collectedTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_collectedTypeMap * info = (e_collectedTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_collectedTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_collectedTypeMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMap::
operator_isNotEqual (const GGS_collectedTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_collectedTypeMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_collectedTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('f'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_collectedTypeMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_collectedTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_collectedTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @collectedTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMap * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMap * p = dynamic_cast <const GGS_collectedTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMap ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMap GGS_collectedTypeMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    map index '@collectedTypeMapIndex'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_collectedTypeMapIndex ("collectedTypeMapIndex", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::
constructor_null (C_CompilerEx & /* inLexique */
                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  result.mState = kNull ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMapIndex::
operator_isEqual (const GGS_collectedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState == inOperand.mState) && (mIndex.retrieve () == inOperand.mIndex.retrieve ())) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_collectedTypeMapIndex::
operator_isNotEqual (const GGS_collectedTypeMapIndex & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (),
                   (mState != inOperand.mState) || (mIndex.retrieve () != inOperand.mIndex.retrieve ())) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_collectedTypeMapIndex::
reader_description (const PMSInt32 /* inIndentation */) const {
  C_String s ;
  s << "<mapproxy @collectedTypeMapIndex" ;
  switch (mState) {
  case kNotBuilt:
    break ;
    s << " (not built)" ;
  case kNull:
    s << ": null" ;
    break ;
  case kRegular:
    s << ": regular (\"" << mKey << "\", " ;
    if (mIndex.retrieve () == NULL) {
      s << "deleted" ;
    }else if (mIndex.retrieve ()->mIsDefined) {
      s << "defined" ;
    }else{
      s << "unsolved" ;
    }
    s << ")" ;
    break ;
  }
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

void GGS_collectedTypeMapIndex::
class_method_makeRegularProxy (C_CompilerEx & /* inLexique*/ ,
                               GGS_collectedTypeMap & ioMap,
                               const GGS_string & inKey,
                               GGS_collectedTypeMapIndex & outIndex
                               COMMA_UNUSED_LOCATION_ARGS) {
  outIndex.mState = kRegular ;
  outIndex.mKey = inKey ;
  ioMap.enterIndex (inKey, outIndex.mIndex) ;
  if (outIndex.mIndex.retrieve () == NULL) {
    outIndex.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::constructor_searchKey (C_CompilerEx & inLexique,
              const GGS_collectedTypeMap & inMap,
              const GGS_lstring & inKey
              COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  result.mState = kRegular ;
  result.mKey = inKey.ggs_string () ;
  inMap.searchIndex (inLexique, inKey, GGS_collectedTypeMap::kSearchMessage_searchKey, result.mIndex COMMA_THERE) ;
  if (result.mIndex.retrieve () == NULL) {
    result.drop () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_collectedTypeMapIndex::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_collectedTypeMapIndex * p = NULL ;
    macroMyNew (p, GGS_collectedTypeMapIndex (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_collectedTypeMapIndex GGS_collectedTypeMapIndex::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_collectedTypeMapIndex result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_collectedTypeMapIndex * p = dynamic_cast <const GGS_collectedTypeMapIndex *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_collectedTypeMapIndex, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_collectedTypeMapIndex::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_collectedTypeMapIndex ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_categoryMethodMapForType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_categoryMethodMapForType::e_categoryMethodMapForType (void) :
mFormalParameterList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@categoryMethodMapForType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryMethodMapForType ("categoryMethodMapForType", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_categoryMethodMapForType::
elementOf_GGS_categoryMethodMapForType (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_categoryMethodMapForType & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_categoryMethodMapForType::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_categoryMethodMapForType::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_categoryMethodMapForType * ptr = dynamic_cast <const elementOf_GGS_categoryMethodMapForType *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mFormalParameterList.operator_isEqual (ptr->mInfo.mFormalParameterList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_categoryMethodMapForType::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_categoryMethodMapForType *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_categoryMethodMapForType * info = (e_categoryMethodMapForType *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForType::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_categoryMethodMapForType *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_categoryMethodMapForType * info = (e_categoryMethodMapForType *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForType GGS_categoryMethodMapForType::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_categoryMethodMapForType result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForType::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_categoryMethodMapForType info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForType::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_categoryMethodMapForType info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodMapForType::
operator_isEqual (const GGS_categoryMethodMapForType & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodMapForType::
operator_isNotEqual (const GGS_categoryMethodMapForType & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForType::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForType::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_formalParameterListAST & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_categoryMethodMapForType info  ;
    info.mFormalParameterList = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForType::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_formalParameterListAST   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mFormalParameterList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForType GGS_categoryMethodMapForType::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_categoryMethodMapForType & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_categoryMethodMapForType result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForType GGS_categoryMethodMapForType::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_categoryMethodMapForType result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodMapForType::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @categoryMethodMapForType " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalParameterListAST  & GGS_categoryMethodMapForType::cEnumerator::_mFormalParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mFormalParameterList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_categoryMethodMapForType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryMethodMapForType * p = NULL ;
    macroMyNew (p, GGS_categoryMethodMapForType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForType GGS_categoryMethodMapForType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryMethodMapForType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryMethodMapForType * p = dynamic_cast <const GGS_categoryMethodMapForType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryMethodMapForType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryMethodMapForType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryMethodMapForType ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForType::modifier_insertOrReplace (C_CompilerEx & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_formalParameterListAST &  inParameter0 COMMA_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()) {
    insulateMap (THERE) ;
    e_categoryMethodMapForType info ;
    info.mFormalParameterList =  inParameter0 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForType GGS_categoryMethodMapForType::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_formalParameterListAST & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_categoryMethodMapForType result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'e_categoryMethodMapForBuildingContext'                *
//                                                                           *
//---------------------------------------------------------------------------*

e_categoryMethodMapForBuildingContext::e_categoryMethodMapForBuildingContext (void) :
mCategoryMethodMapForType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class map '@categoryMethodMapForBuildingContext'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryMethodMapForBuildingContext ("categoryMethodMapForBuildingContext", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_categoryMethodMapForBuildingContext::
elementOf_GGS_categoryMethodMapForBuildingContext (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_categoryMethodMapForBuildingContext & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_categoryMethodMapForBuildingContext::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCategoryMethodMapForType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_categoryMethodMapForBuildingContext::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_categoryMethodMapForBuildingContext * ptr = dynamic_cast <const elementOf_GGS_categoryMethodMapForBuildingContext *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mCategoryMethodMapForType.operator_isEqual (ptr->mInfo.mCategoryMethodMapForType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_categoryMethodMapForBuildingContext::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_categoryMethodMapForBuildingContext *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_categoryMethodMapForBuildingContext * info = (e_categoryMethodMapForBuildingContext *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForBuildingContext::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_categoryMethodMapForBuildingContext *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_categoryMethodMapForBuildingContext * info = (e_categoryMethodMapForBuildingContext *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForBuildingContext GGS_categoryMethodMapForBuildingContext::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_categoryMethodMapForBuildingContext result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForBuildingContext::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_categoryMethodMapForBuildingContext info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForBuildingContext::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_categoryMethodMapForBuildingContext info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodMapForBuildingContext::
operator_isEqual (const GGS_categoryMethodMapForBuildingContext & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryMethodMapForBuildingContext::
operator_isNotEqual (const GGS_categoryMethodMapForBuildingContext & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForBuildingContext::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForBuildingContext::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_categoryMethodMapForType & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_categoryMethodMapForBuildingContext info  ;
    info.mCategoryMethodMapForType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForBuildingContext::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_categoryMethodMapForType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mCategoryMethodMapForType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_categoryMethodMapForBuildingContext::kSearchMessage_searchKey [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForBuildingContext::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_categoryMethodMapForType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_categoryMethodMapForBuildingContext::kInsertMessage_insertKey [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_categoryMethodMapForBuildingContext::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_categoryMethodMapForType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForBuildingContext GGS_categoryMethodMapForBuildingContext::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_categoryMethodMapForBuildingContext & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_categoryMethodMapForBuildingContext result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForBuildingContext GGS_categoryMethodMapForBuildingContext::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_categoryMethodMapForBuildingContext result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryMethodMapForBuildingContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @categoryMethodMapForBuildingContext " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_categoryMethodMapForType  & GGS_categoryMethodMapForBuildingContext::cEnumerator::_mCategoryMethodMapForType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCategoryMethodMapForType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_categoryMethodMapForBuildingContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryMethodMapForBuildingContext * p = NULL ;
    macroMyNew (p, GGS_categoryMethodMapForBuildingContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForBuildingContext GGS_categoryMethodMapForBuildingContext::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryMethodMapForBuildingContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryMethodMapForBuildingContext * p = dynamic_cast <const GGS_categoryMethodMapForBuildingContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryMethodMapForBuildingContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryMethodMapForBuildingContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryMethodMapForBuildingContext ;
}

//---------------------------------------------------------------------------*

GGS_categoryMethodMapForBuildingContext GGS_categoryMethodMapForBuildingContext::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_categoryMethodMapForType & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_categoryMethodMapForBuildingContext result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_categoryReaderMapForType'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_categoryReaderMapForType::e_categoryReaderMapForType (void) :
mResultTypeName (),
mInputFormalParameterList () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@categoryReaderMapForType'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryReaderMapForType ("categoryReaderMapForType", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_categoryReaderMapForType::
elementOf_GGS_categoryReaderMapForType (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_categoryReaderMapForType & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_categoryReaderMapForType::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mResultTypeName.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mInputFormalParameterList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_categoryReaderMapForType::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_categoryReaderMapForType * ptr = dynamic_cast <const elementOf_GGS_categoryReaderMapForType *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mResultTypeName.operator_isEqual (ptr->mInfo.mResultTypeName)).boolValue ()
           && (mInfo.mInputFormalParameterList.operator_isEqual (ptr->mInfo.mInputFormalParameterList)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_categoryReaderMapForType::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_categoryReaderMapForType *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_categoryReaderMapForType * info = (e_categoryReaderMapForType *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForType::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_categoryReaderMapForType *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_categoryReaderMapForType * info = (e_categoryReaderMapForType *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForType GGS_categoryReaderMapForType::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_categoryReaderMapForType result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForType::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_categoryReaderMapForType info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForType::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_categoryReaderMapForType info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryReaderMapForType::
operator_isEqual (const GGS_categoryReaderMapForType & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryReaderMapForType::
operator_isNotEqual (const GGS_categoryReaderMapForType & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForType::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForType::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
               const GGS_formalInputParameterListAST & inParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_categoryReaderMapForType info  ;
    info.mResultTypeName = inParameter0 ;
    info.mInputFormalParameterList = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForType::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_formalInputParameterListAST   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mResultTypeName ;
    outParameter1 = node->mInfo.mInputFormalParameterList ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForType GGS_categoryReaderMapForType::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_categoryReaderMapForType & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_categoryReaderMapForType result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForType GGS_categoryReaderMapForType::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_categoryReaderMapForType result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryReaderMapForType::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @categoryReaderMapForType " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_categoryReaderMapForType::cEnumerator::_mResultTypeName (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mResultTypeName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_formalInputParameterListAST  & GGS_categoryReaderMapForType::cEnumerator::_mInputFormalParameterList (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mInputFormalParameterList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_categoryReaderMapForType::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryReaderMapForType * p = NULL ;
    macroMyNew (p, GGS_categoryReaderMapForType (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForType GGS_categoryReaderMapForType::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryReaderMapForType result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryReaderMapForType * p = dynamic_cast <const GGS_categoryReaderMapForType *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryReaderMapForType, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryReaderMapForType::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryReaderMapForType ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForType::modifier_insertOrReplace (C_CompilerEx & /* inLexique */,
                                const GGS_lstring & inKey,
                                const GGS_lstring &  inParameter0,
                                const GGS_formalInputParameterListAST &  inParameter1 COMMA_LOCATION_ARGS) {
  if (isBuilt () && inKey.isBuilt ()
  && inParameter0.isBuilt ()
  && inParameter1.isBuilt ()) {
    insulateMap (THERE) ;
    e_categoryReaderMapForType info ;
    info.mResultTypeName =  inParameter0 ;
    info.mInputFormalParameterList =  inParameter1 ;
    insertOrReplaceElement (inKey, (void *) & info) ;
  }
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForType GGS_categoryReaderMapForType::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_lstring & inValue0,
                                             const GGS_formalInputParameterListAST & inValue1
                                             COMMA_LOCATION_ARGS) {
  GGS_categoryReaderMapForType result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        inValue1,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'e_categoryReaderMapForBuildingContext'                *
//                                                                           *
//---------------------------------------------------------------------------*

e_categoryReaderMapForBuildingContext::e_categoryReaderMapForBuildingContext (void) :
mCategoryReaderMapForType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class map '@categoryReaderMapForBuildingContext'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_categoryReaderMapForBuildingContext ("categoryReaderMapForBuildingContext", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_categoryReaderMapForBuildingContext::
elementOf_GGS_categoryReaderMapForBuildingContext (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_categoryReaderMapForBuildingContext & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_categoryReaderMapForBuildingContext::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mCategoryReaderMapForType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_categoryReaderMapForBuildingContext::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_categoryReaderMapForBuildingContext * ptr = dynamic_cast <const elementOf_GGS_categoryReaderMapForBuildingContext *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mCategoryReaderMapForType.operator_isEqual (ptr->mInfo.mCategoryReaderMapForType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_categoryReaderMapForBuildingContext::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_categoryReaderMapForBuildingContext *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_categoryReaderMapForBuildingContext * info = (e_categoryReaderMapForBuildingContext *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForBuildingContext::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_categoryReaderMapForBuildingContext *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_categoryReaderMapForBuildingContext * info = (e_categoryReaderMapForBuildingContext *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForBuildingContext GGS_categoryReaderMapForBuildingContext::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_categoryReaderMapForBuildingContext result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForBuildingContext::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_categoryReaderMapForBuildingContext info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForBuildingContext::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_categoryReaderMapForBuildingContext info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryReaderMapForBuildingContext::
operator_isEqual (const GGS_categoryReaderMapForBuildingContext & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_categoryReaderMapForBuildingContext::
operator_isNotEqual (const GGS_categoryReaderMapForBuildingContext & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForBuildingContext::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForBuildingContext::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_categoryReaderMapForType & inParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_categoryReaderMapForBuildingContext info  ;
    info.mCategoryReaderMapForType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForBuildingContext::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_categoryReaderMapForType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mCategoryReaderMapForType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_categoryReaderMapForBuildingContext::kSearchMessage_searchKey [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForBuildingContext::
method_searchKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                GGS_categoryReaderMapForType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_categoryReaderMapForBuildingContext::kInsertMessage_insertKey [] = {
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_categoryReaderMapForBuildingContext::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_categoryReaderMapForType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForBuildingContext GGS_categoryReaderMapForBuildingContext::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_categoryReaderMapForBuildingContext & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_categoryReaderMapForBuildingContext result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForBuildingContext GGS_categoryReaderMapForBuildingContext::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_categoryReaderMapForBuildingContext result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_categoryReaderMapForBuildingContext::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @categoryReaderMapForBuildingContext " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_categoryReaderMapForType  & GGS_categoryReaderMapForBuildingContext::cEnumerator::_mCategoryReaderMapForType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mCategoryReaderMapForType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_categoryReaderMapForBuildingContext::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_categoryReaderMapForBuildingContext * p = NULL ;
    macroMyNew (p, GGS_categoryReaderMapForBuildingContext (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForBuildingContext GGS_categoryReaderMapForBuildingContext::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_categoryReaderMapForBuildingContext result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_categoryReaderMapForBuildingContext * p = dynamic_cast <const GGS_categoryReaderMapForBuildingContext *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_categoryReaderMapForBuildingContext, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_categoryReaderMapForBuildingContext::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_categoryReaderMapForBuildingContext ;
}

//---------------------------------------------------------------------------*

GGS_categoryReaderMapForBuildingContext GGS_categoryReaderMapForBuildingContext::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey,
                                             const GGS_categoryReaderMapForType & inValue0
                                             COMMA_LOCATION_ARGS) {
  GGS_categoryReaderMapForBuildingContext result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        inValue0,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Implementation of routine "collectAttributeTypes"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_collectAttributeTypes (C_CompilerEx & inLexique,
                                const GGS_attributeInCollectionListAST   var_cas_inAttributeList,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_collectAttributeTypes at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  {
    GGS_attributeInCollectionListAST::cEnumerator enumerator_10208 (var_cas_inAttributeList, true) ;
    const GGS_attributeInCollectionListAST::cElement * operand_10208 = NULL ;
    while (((operand_10208 = enumerator_10208.nextObject ()))) {
      macroValidPointer (operand_10208) ;
      GGS_collectedTypeMapIndex  automatic_var_10310_0 ;
      GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_10208->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (218)), automatic_var_10310_0 COMMA_SOURCE_FILE_AT_LINE (218)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_collectAttributeTypes\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@semanticDeclarationAST.display'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__display (C_CompilerEx &,
                                const cPtr_semanticDeclarationAST * operand_10773,
                                GGS_string & /* var_cas_ioString */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10773 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Virtual Table for category method '@semanticDeclarationAST.display'     *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__display> gDispatchTableForMethod__semanticDeclarationAST__display ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__display (typeCategoryMethod__semanticDeclarationAST__display inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__display.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__display
findCategoryMethod__semanticDeclarationAST__display (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__display result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__display.count ()) {
      result = gDispatchTableForMethod__semanticDeclarationAST__display (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__semanticDeclarationAST__display (superClassPtr) ;
        gDispatchTableForMethod__semanticDeclarationAST__display.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@abstractCategoryMethodAST.display'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryMethodAST__display (C_CompilerEx &,
                                const cPtr_abstractCategoryMethodAST * operand_10947,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_10947 != NULL) {
    var_cas_ioString.appendCString ("  - abstract category method @") ;
    var_cas_ioString.dotAssign_operation (operand_10947->mTypeName) ;
    var_cas_ioString.appendCString (" ") ;
    var_cas_ioString.dotAssign_operation (operand_10947->mAbstractCategoryMethodName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Category method '@categoryMethodAST.display'                *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryMethodAST__display (C_CompilerEx &,
                                const cPtr_categoryMethodAST * operand_11210,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11210 != NULL) {
    var_cas_ioString.appendCString ("  - category method @") ;
    var_cas_ioString.dotAssign_operation (operand_11210->mTypeName) ;
    var_cas_ioString.appendCString (" ") ;
    var_cas_ioString.dotAssign_operation (operand_11210->mCategoryMethodName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@overridingCategoryMethodAST.display'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryMethodAST__display (C_CompilerEx &,
                                const cPtr_overridingCategoryMethodAST * operand_11466,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11466 != NULL) {
    var_cas_ioString.appendCString ("  - overriding category method @") ;
    var_cas_ioString.dotAssign_operation (operand_11466->mTypeName) ;
    var_cas_ioString.appendCString (" ") ;
    var_cas_ioString.dotAssign_operation (operand_11466->mOverridingCategoryMethodName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@abstractCategoryReaderAST.display'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryReaderAST__display (C_CompilerEx &,
                                const cPtr_abstractCategoryReaderAST * operand_11741,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11741 != NULL) {
    var_cas_ioString.appendCString ("  - abstract category reader @") ;
    var_cas_ioString.dotAssign_operation (operand_11741->mTypeName) ;
    var_cas_ioString.appendCString (" ") ;
    var_cas_ioString.dotAssign_operation (operand_11741->mAbstractCategoryReaderName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Category method '@categoryReaderAST.display'                *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryReaderAST__display (C_CompilerEx &,
                                const cPtr_categoryReaderAST * operand_12004,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12004 != NULL) {
    var_cas_ioString.appendCString ("  - category reader @") ;
    var_cas_ioString.dotAssign_operation (operand_12004->mTypeName) ;
    var_cas_ioString.appendCString (" ") ;
    var_cas_ioString.dotAssign_operation (operand_12004->mCategoryReaderName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@overridingCategoryReaderAST.display'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryReaderAST__display (C_CompilerEx &,
                                const cPtr_overridingCategoryReaderAST * operand_12260,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12260 != NULL) {
    var_cas_ioString.appendCString ("  - overriding category reader @") ;
    var_cas_ioString.dotAssign_operation (operand_12260->mTypeName) ;
    var_cas_ioString.appendCString (" ") ;
    var_cas_ioString.dotAssign_operation (operand_12260->mOverridingCategoryReaderName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Category method '@predefinedTypeAST.display'                *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__display (C_CompilerEx &,
                                const cPtr_predefinedTypeAST * operand_12527,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12527 != NULL) {
    var_cas_ioString.appendCString ("  - predefined type @") ;
    var_cas_ioString.dotAssign_operation (operand_12527->mPredefinedTypeName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@uniqueMapDeclarationAST.display'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__uniqueMapDeclarationAST__display (C_CompilerEx &,
                                const cPtr_uniqueMapDeclarationAST * operand_12761,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12761 != NULL) {
    var_cas_ioString.appendCString ("  - unique map @") ;
    var_cas_ioString.dotAssign_operation (operand_12761->mMapTypeName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Category method '@mapDeclarationAST.display'                *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__display (C_CompilerEx &,
                                const cPtr_mapDeclarationAST * operand_12977,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12977 != NULL) {
    var_cas_ioString.appendCString ("  - map @") ;
    var_cas_ioString.dotAssign_operation (operand_12977->mMapTypeName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@mapProxyDeclarationAST.display'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__display (C_CompilerEx &,
                                const cPtr_mapProxyDeclarationAST * operand_13191,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13191 != NULL) {
    var_cas_ioString.appendCString ("  - map proxy @") ;
    var_cas_ioString.dotAssign_operation (operand_13191->mMapProxyTypeName) ;
    var_cas_ioString.appendCString ("(for map @") ;
    var_cas_ioString.dotAssign_operation (operand_13191->mAssociatedMapTypeName) ;
    var_cas_ioString.appendCString (")\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@enumDeclarationAST.display'                *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__display (C_CompilerEx &,
                                const cPtr_enumDeclarationAST * operand_13453,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13453 != NULL) {
    var_cas_ioString.appendCString ("  - enum @") ;
    var_cas_ioString.dotAssign_operation (operand_13453->mEnumTypeName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@sortedListDeclarationAST.display'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__display (C_CompilerEx &,
                                const cPtr_sortedListDeclarationAST * operand_13671,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13671 != NULL) {
    var_cas_ioString.appendCString ("  - sorted list @") ;
    var_cas_ioString.dotAssign_operation (operand_13671->mSortedListTypeName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@structDeclarationAST.display'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__display (C_CompilerEx &,
                                const cPtr_structDeclarationAST * operand_13898,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13898 != NULL) {
    var_cas_ioString.appendCString ("  - struct @") ;
    var_cas_ioString.dotAssign_operation (operand_13898->mStructTypeName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@listDeclarationAST.display'                *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__display (C_CompilerEx &,
                                const cPtr_listDeclarationAST * operand_14114,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14114 != NULL) {
    var_cas_ioString.appendCString ("  - list @") ;
    var_cas_ioString.dotAssign_operation (operand_14114->mListTypeName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Category method '@classDeclarationAST.display'               *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__display (C_CompilerEx & inLexique,
                                const cPtr_classDeclarationAST * operand_14327,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14327 != NULL) {
    var_cas_ioString.appendCString ("  - class @") ;
    var_cas_ioString.dotAssign_operation (operand_14327->mClassTypeName) ;
    const GGS_bool cond_14487 = (operand_14327->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (351))).operator_isNotEqual (GGS_string ("")) ;
    if (cond_14487.isBuiltAndTrue ()) {
      var_cas_ioString.appendCString (" : @") ;
      var_cas_ioString.dotAssign_operation (operand_14327->mSuperClassName) ;
    }
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Category method '@listmapDeclarationAST.display'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__display (C_CompilerEx &,
                                const cPtr_listmapDeclarationAST * operand_14653,
                                GGS_string & var_cas_ioString
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_14653 != NULL) {
    var_cas_ioString.appendCString ("  - listmap @") ;
    var_cas_ioString.dotAssign_operation (operand_14653->mListmapTypeName) ;
    var_cas_ioString.appendCString ("\n") ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@semanticDeclarationAST.collectTypes'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__collectTypes (C_CompilerEx &,
                                const cPtr_semanticDeclarationAST * operand_15183,
                                GGS_collectedTypeMap  & /* var_cas_ioCollectedTypeMap */,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15183 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Virtual Table for category method '@semanticDeclarationAST.collectTypes'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__collectTypes> gDispatchTableForMethod__semanticDeclarationAST__collectTypes ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__collectTypes (typeCategoryMethod__semanticDeclarationAST__collectTypes inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__collectTypes.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__collectTypes
findCategoryMethod__semanticDeclarationAST__collectTypes (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__collectTypes result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__collectTypes.count ()) {
      result = gDispatchTableForMethod__semanticDeclarationAST__collectTypes (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__semanticDeclarationAST__collectTypes (superClassPtr) ;
        gDispatchTableForMethod__semanticDeclarationAST__collectTypes.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@abstractCategoryMethodAST.collectTypes'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryMethodAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_abstractCategoryMethodAST * operand_15554,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & var_cas_ioCategoryMethodMapForBuildingContext,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15554 != NULL) {
    GGS_collectedTypeMapIndex  automatic_var_15850_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_15554->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (385)), automatic_var_15850_0 COMMA_SOURCE_FILE_AT_LINE (385)) ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_15932 (operand_15554->mAbstractCategoryMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_15932 = NULL ;
      while (((operand_15932 = enumerator_15932.nextObject ()))) {
        macroValidPointer (operand_15932) ;
        GGS_collectedTypeMapIndex  automatic_var_16039_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_15932->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (388)), automatic_var_16039_0 COMMA_SOURCE_FILE_AT_LINE (388)) ;
      }
    }
    const GGS_bool cond_16273 = (var_cas_ioCategoryMethodMapForBuildingContext.reader_hasKey (operand_15554->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (391)))).operator_not () ;
    if (cond_16273.isBuiltAndTrue ()) {
      var_cas_ioCategoryMethodMapForBuildingContext.modifier_insertKey (inLexique, operand_15554->mTypeName, GGS_categoryMethodMapForType ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (394)) COMMA_SOURCE_FILE_AT_LINE (392)) ;
    }
    elementOf_GGS_categoryMethodMapForBuildingContext * operand_16325 = (elementOf_GGS_categoryMethodMapForBuildingContext *) var_cas_ioCategoryMethodMapForBuildingContext.searchForWithInstruction (inLexique, operand_15554->mTypeName, GGS_categoryMethodMapForBuildingContext::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (397)) ;
    if (NULL != operand_16325) {
      operand_16325->mInfo.mCategoryMethodMapForType.modifier_insertOrReplace (inLexique, operand_15554->mAbstractCategoryMethodName, operand_15554->mAbstractCategoryMethodFormalParameterList COMMA_SOURCE_FILE_AT_LINE (398)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@categoryMethodAST.collectTypes'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryMethodAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_categoryMethodAST * operand_16645,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & var_cas_ioCategoryMethodMapForBuildingContext,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_16645 != NULL) {
    GGS_collectedTypeMapIndex  automatic_var_16941_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_16645->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (412)), automatic_var_16941_0 COMMA_SOURCE_FILE_AT_LINE (412)) ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_17015 (operand_16645->mCategoryMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_17015 = NULL ;
      while (((operand_17015 = enumerator_17015.nextObject ()))) {
        macroValidPointer (operand_17015) ;
        GGS_collectedTypeMapIndex  automatic_var_17122_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_17015->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (415)), automatic_var_17122_0 COMMA_SOURCE_FILE_AT_LINE (415)) ;
      }
    }
    const GGS_bool cond_17356 = (var_cas_ioCategoryMethodMapForBuildingContext.reader_hasKey (operand_16645->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (418)))).operator_not () ;
    if (cond_17356.isBuiltAndTrue ()) {
      var_cas_ioCategoryMethodMapForBuildingContext.modifier_insertKey (inLexique, operand_16645->mTypeName, GGS_categoryMethodMapForType ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (421)) COMMA_SOURCE_FILE_AT_LINE (419)) ;
    }
    elementOf_GGS_categoryMethodMapForBuildingContext * operand_17408 = (elementOf_GGS_categoryMethodMapForBuildingContext *) var_cas_ioCategoryMethodMapForBuildingContext.searchForWithInstruction (inLexique, operand_16645->mTypeName, GGS_categoryMethodMapForBuildingContext::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (424)) ;
    if (NULL != operand_17408) {
      operand_17408->mInfo.mCategoryMethodMapForType.modifier_insertOrReplace (inLexique, operand_16645->mCategoryMethodName, operand_16645->mCategoryMethodFormalParameterList COMMA_SOURCE_FILE_AT_LINE (425)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@overridingCategoryMethodAST.collectTypes'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryMethodAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_overridingCategoryMethodAST * operand_17722,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17722 != NULL) {
    GGS_collectedTypeMapIndex  automatic_var_18025_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_17722->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (439)), automatic_var_18025_0 COMMA_SOURCE_FILE_AT_LINE (439)) ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_18109 (operand_17722->mOverridingCategoryMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_18109 = NULL ;
      while (((operand_18109 = enumerator_18109.nextObject ()))) {
        macroValidPointer (operand_18109) ;
        GGS_collectedTypeMapIndex  automatic_var_18216_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_18109->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (442)), automatic_var_18216_0 COMMA_SOURCE_FILE_AT_LINE (442)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@overridingAbstractCategoryMethodAST.collectTypes'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingAbstractCategoryMethodAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_overridingAbstractCategoryMethodAST * operand_18393,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_18393 != NULL) {
    GGS_collectedTypeMapIndex  automatic_var_18696_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_18393->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (453)), automatic_var_18696_0 COMMA_SOURCE_FILE_AT_LINE (453)) ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_18780 (operand_18393->mOverridingCategoryMethodFormalParameterList, true) ;
      const GGS_formalParameterListAST::cElement * operand_18780 = NULL ;
      while (((operand_18780 = enumerator_18780.nextObject ()))) {
        macroValidPointer (operand_18780) ;
        GGS_collectedTypeMapIndex  automatic_var_18887_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_18780->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (456)), automatic_var_18887_0 COMMA_SOURCE_FILE_AT_LINE (456)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Category method '@abstractCategoryReaderAST.collectTypes'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryReaderAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_abstractCategoryReaderAST * operand_19054,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & var_cas_ioCategoryReaderMapForBuildingContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_19054 != NULL) {
    GGS_collectedTypeMapIndex  automatic_var_19380_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_19054->mAbstractCategoryReaderReturnedTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (467)), automatic_var_19380_0 COMMA_SOURCE_FILE_AT_LINE (467)) ;
    GGS_collectedTypeMapIndex  automatic_var_19470_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_19054->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (468)), automatic_var_19470_0 COMMA_SOURCE_FILE_AT_LINE (468)) ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_19557 (operand_19054->mAbstractCategoryReaderFormalInputParameterList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_19557 = NULL ;
      while (((operand_19557 = enumerator_19557.nextObject ()))) {
        macroValidPointer (operand_19557) ;
        GGS_collectedTypeMapIndex  automatic_var_19664_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_19557->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (471)), automatic_var_19664_0 COMMA_SOURCE_FILE_AT_LINE (471)) ;
      }
    }
    const GGS_bool cond_19898 = (var_cas_ioCategoryReaderMapForBuildingContext.reader_hasKey (operand_19054->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (474)))).operator_not () ;
    if (cond_19898.isBuiltAndTrue ()) {
      var_cas_ioCategoryReaderMapForBuildingContext.modifier_insertKey (inLexique, operand_19054->mTypeName, GGS_categoryReaderMapForType ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (477)) COMMA_SOURCE_FILE_AT_LINE (475)) ;
    }
    elementOf_GGS_categoryReaderMapForBuildingContext * operand_19950 = (elementOf_GGS_categoryReaderMapForBuildingContext *) var_cas_ioCategoryReaderMapForBuildingContext.searchForWithInstruction (inLexique, operand_19054->mTypeName, GGS_categoryReaderMapForBuildingContext::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (480)) ;
    if (NULL != operand_19950) {
      GGS_collectedTypeMapIndex  automatic_var_20094_0 ;
      GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_19054->mAbstractCategoryReaderReturnedTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (481)), automatic_var_20094_0 COMMA_SOURCE_FILE_AT_LINE (481)) ;
      operand_19950->mInfo.mCategoryReaderMapForType.modifier_insertOrReplace (inLexique, operand_19054->mAbstractCategoryReaderName, operand_19054->mAbstractCategoryReaderReturnedTypeName, operand_19054->mAbstractCategoryReaderFormalInputParameterList COMMA_SOURCE_FILE_AT_LINE (482)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@categoryReaderAST.collectTypes'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryReaderAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_categoryReaderAST * operand_20444,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & var_cas_ioCategoryReaderMapForBuildingContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_20444 != NULL) {
    GGS_collectedTypeMapIndex  automatic_var_20762_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_20444->mCategoryReaderReturnedTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (497)), automatic_var_20762_0 COMMA_SOURCE_FILE_AT_LINE (497)) ;
    GGS_collectedTypeMapIndex  automatic_var_20852_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_20444->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (498)), automatic_var_20852_0 COMMA_SOURCE_FILE_AT_LINE (498)) ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_20931 (operand_20444->mCategoryReaderFormalInputParameterList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_20931 = NULL ;
      while (((operand_20931 = enumerator_20931.nextObject ()))) {
        macroValidPointer (operand_20931) ;
        GGS_collectedTypeMapIndex  automatic_var_21038_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_20931->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (501)), automatic_var_21038_0 COMMA_SOURCE_FILE_AT_LINE (501)) ;
      }
    }
    const GGS_bool cond_21272 = (var_cas_ioCategoryReaderMapForBuildingContext.reader_hasKey (operand_20444->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (504)))).operator_not () ;
    if (cond_21272.isBuiltAndTrue ()) {
      var_cas_ioCategoryReaderMapForBuildingContext.modifier_insertKey (inLexique, operand_20444->mTypeName, GGS_categoryReaderMapForType ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (507)) COMMA_SOURCE_FILE_AT_LINE (505)) ;
    }
    elementOf_GGS_categoryReaderMapForBuildingContext * operand_21324 = (elementOf_GGS_categoryReaderMapForBuildingContext *) var_cas_ioCategoryReaderMapForBuildingContext.searchForWithInstruction (inLexique, operand_20444->mTypeName, GGS_categoryReaderMapForBuildingContext::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (510)) ;
    if (NULL != operand_21324) {
      operand_21324->mInfo.mCategoryReaderMapForType.modifier_insertOrReplace (inLexique, operand_20444->mCategoryReaderName, operand_20444->mCategoryReaderReturnedTypeName, operand_20444->mCategoryReaderFormalInputParameterList COMMA_SOURCE_FILE_AT_LINE (511)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@overridingCategoryReaderAST.collectTypes'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryReaderAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_overridingCategoryReaderAST * operand_21682,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_21682 != NULL) {
    GGS_collectedTypeMapIndex  automatic_var_22017_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_21682->mOverridingCategoryReaderReturnedTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (526)), automatic_var_22017_0 COMMA_SOURCE_FILE_AT_LINE (526)) ;
    GGS_collectedTypeMapIndex  automatic_var_22107_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_21682->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (527)), automatic_var_22107_0 COMMA_SOURCE_FILE_AT_LINE (527)) ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_22196 (operand_21682->mOverridingCategoryReaderFormalInputParameterList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_22196 = NULL ;
      while (((operand_22196 = enumerator_22196.nextObject ()))) {
        macroValidPointer (operand_22196) ;
        GGS_collectedTypeMapIndex  automatic_var_22303_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_22196->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (530)), automatic_var_22303_0 COMMA_SOURCE_FILE_AT_LINE (530)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@overridingAbstractCategoryReaderAST.collectTypes'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingAbstractCategoryReaderAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_overridingAbstractCategoryReaderAST * operand_22480,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22480 != NULL) {
    GGS_collectedTypeMapIndex  automatic_var_22813_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_22480->mAbstractCategoryReaderReturnedTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (541)), automatic_var_22813_0 COMMA_SOURCE_FILE_AT_LINE (541)) ;
    GGS_collectedTypeMapIndex  automatic_var_22903_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_22480->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (542)), automatic_var_22903_0 COMMA_SOURCE_FILE_AT_LINE (542)) ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_22990 (operand_22480->mAbstractCategoryReaderFormalInputParameterList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_22990 = NULL ;
      while (((operand_22990 = enumerator_22990.nextObject ()))) {
        macroValidPointer (operand_22990) ;
        GGS_collectedTypeMapIndex  automatic_var_23097_0 ;
        GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_22990->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (545)), automatic_var_23097_0 COMMA_SOURCE_FILE_AT_LINE (545)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@predefinedTypeAST.collectTypes'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_predefinedTypeAST * operand_23256,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_23256 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_23256->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (556)) COMMA_SOURCE_FILE_AT_LINE (556)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@mapDeclarationAST.collectTypes'              *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_mapDeclarationAST * operand_23692,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_23692 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_23692->mMapTypeName COMMA_SOURCE_FILE_AT_LINE (566)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_23692->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (567)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@uniqueMapDeclarationAST.collectTypes'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__uniqueMapDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_uniqueMapDeclarationAST * operand_24168,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_24168 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_24168->mMapTypeName COMMA_SOURCE_FILE_AT_LINE (577)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_24168->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (578)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@mapProxyDeclarationAST.collectTypes'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_24643,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_24643 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_24643->mMapProxyTypeName COMMA_SOURCE_FILE_AT_LINE (588)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@enumDeclarationAST.collectTypes'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_enumDeclarationAST * operand_25056,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25056 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_25056->mEnumTypeName COMMA_SOURCE_FILE_AT_LINE (598)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@sortedListDeclarationAST.collectTypes'          *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_25471,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25471 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_25471->mSortedListTypeName COMMA_SOURCE_FILE_AT_LINE (608)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_25471->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (609)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@structDeclarationAST.collectTypes'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_structDeclarationAST * operand_25951,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_25951 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_25951->mStructTypeName COMMA_SOURCE_FILE_AT_LINE (619)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_25951->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (620)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Category method '@listDeclarationAST.collectTypes'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_listDeclarationAST * operand_26425,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_26425 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_26425->mListTypeName COMMA_SOURCE_FILE_AT_LINE (630)) ;
    ::routine_collectAttributeTypes (inLexique,  operand_26425->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (631)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Category method '@classDeclarationAST.collectTypes'             *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_classDeclarationAST * operand_26898,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_26898 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_26898->mClassTypeName COMMA_SOURCE_FILE_AT_LINE (641)) ;
    const GGS_bool cond_27311 = (operand_26898->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (642))).operator_isNotEqual (GGS_string ("")) ;
    if (cond_27311.isBuiltAndTrue ()) {
      GGS_collectedTypeMapIndex  automatic_var_27303_0 ;
      GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_26898->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (643)), automatic_var_27303_0 COMMA_SOURCE_FILE_AT_LINE (643)) ;
    }
    ::routine_collectAttributeTypes (inLexique,  operand_26898->mAttributeList,  var_cas_ioCollectedTypeMap COMMA_SOURCE_FILE_AT_LINE (645)) ;
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_27409 (operand_26898->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_27409 = NULL ;
      while (((operand_27409 = enumerator_27409.nextObject ()))) {
        macroValidPointer (operand_27409) ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_27435 (operand_27409->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_27435 = NULL ;
          while (((operand_27435 = enumerator_27435.nextObject ()))) {
            macroValidPointer (operand_27435) ;
            GGS_collectedTypeMapIndex  automatic_var_27544_0 ;
            GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_27435->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (648)), automatic_var_27544_0 COMMA_SOURCE_FILE_AT_LINE (648)) ;
          }
        }
      }
    }
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_27602 (operand_26898->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_27602 = NULL ;
      while (((operand_27602 = enumerator_27602.nextObject ()))) {
        macroValidPointer (operand_27602) ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_27628 (operand_27602->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_27628 = NULL ;
          while (((operand_27628 = enumerator_27628.nextObject ()))) {
            macroValidPointer (operand_27628) ;
            GGS_collectedTypeMapIndex  automatic_var_27737_0 ;
            GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_27628->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (653)), automatic_var_27737_0 COMMA_SOURCE_FILE_AT_LINE (653)) ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Category method '@listmapDeclarationAST.collectTypes'            *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__collectTypes (C_CompilerEx & inLexique,
                                const cPtr_listmapDeclarationAST * operand_27918,
                                GGS_collectedTypeMap  & var_cas_ioCollectedTypeMap,
                                GGS_categoryMethodMapForBuildingContext  & /* var_cas_ioCategoryMethodMapForBuildingContext */,
                                GGS_categoryReaderMapForBuildingContext  & /* var_cas_ioCategoryReaderMapForBuildingContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_27918 != NULL) {
    var_cas_ioCollectedTypeMap.modifier_insertKey (inLexique, operand_27918->mListmapTypeName COMMA_SOURCE_FILE_AT_LINE (665)) ;
    GGS_collectedTypeMapIndex  automatic_var_28290_0 ;
    GGS_collectedTypeMapIndex::class_method_makeRegularProxy (inLexique, var_cas_ioCollectedTypeMap, operand_27918->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (666)), automatic_var_28290_0 COMMA_SOURCE_FILE_AT_LINE (666)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@semanticDeclarationAST.enterInSemanticContext'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext> gDispatchTableForMethod__semanticDeclarationAST__enterInSemanticContext ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext (typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterInSemanticContext.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext
findCategoryMethod__semanticDeclarationAST__enterInSemanticContext (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterInSemanticContext.count ()) {
      result = gDispatchTableForMethod__semanticDeclarationAST__enterInSemanticContext (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__semanticDeclarationAST__enterInSemanticContext (superClassPtr) ;
        gDispatchTableForMethod__semanticDeclarationAST__enterInSemanticContext.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@abstractCategoryMethodAST.enterInSemanticContext'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryMethodAST__enterInSemanticContext (C_CompilerEx &,
                                const cPtr_abstractCategoryMethodAST * operand_29126,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_29126 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@categoryMethodAST.enterInSemanticContext'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryMethodAST__enterInSemanticContext (C_CompilerEx &,
                                const cPtr_categoryMethodAST * operand_29496,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_29496 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@overridingCategoryMethodAST.enterInSemanticContext'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryMethodAST__enterInSemanticContext (C_CompilerEx &,
                                const cPtr_overridingCategoryMethodAST * operand_29876,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_29876 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@overridingAbstractCategoryMethodAST.enterInSemanticContext'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingAbstractCategoryMethodAST__enterInSemanticContext (C_CompilerEx &,
                                const cPtr_overridingAbstractCategoryMethodAST * operand_30264,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_30264 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@abstractCategoryReaderAST.enterInSemanticContext'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__abstractCategoryReaderAST__enterInSemanticContext (C_CompilerEx &,
                                const cPtr_abstractCategoryReaderAST * operand_30643,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_30643 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@categoryReaderAST.enterInSemanticContext'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__categoryReaderAST__enterInSemanticContext (C_CompilerEx &,
                                const cPtr_categoryReaderAST * operand_31013,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_31013 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@overridingCategoryReaderAST.enterInSemanticContext'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingCategoryReaderAST__enterInSemanticContext (C_CompilerEx &,
                                const cPtr_overridingCategoryReaderAST * operand_31393,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_31393 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@overridingAbstractCategoryReaderAST.enterInSemanticContext'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__overridingAbstractCategoryReaderAST__enterInSemanticContext (C_CompilerEx &,
                                const cPtr_overridingAbstractCategoryReaderAST * operand_31781,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & /* var_cas_ioSemanticContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_31781 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@predefinedTypeAST.enterInSemanticContext'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_predefinedTypeAST * operand_32151,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_32151 != NULL) {
    GGS_constructorMap  var_cas_constructorMap ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap ;
    GGS_classMethodMap  var_cas_classMethodMap ;
    const GGS_predefinedTypeAST  var_cas_t = operand_32151 ;
    { typeCategoryMethod__predefinedTypeAST__getConstructorMap method = findCategoryMethod__predefinedTypeAST__getConstructorMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_constructorMap COMMA_SOURCE_FILE_AT_LINE (768)) ;
      }
    }
    { typeCategoryMethod__predefinedTypeAST__getReaderMap method = findCategoryMethod__predefinedTypeAST__getReaderMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (769)) ;
      }
    }
    { typeCategoryMethod__predefinedTypeAST__getModifierMap method = findCategoryMethod__predefinedTypeAST__getModifierMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_modifierMap COMMA_SOURCE_FILE_AT_LINE (770)) ;
      }
    }
    { typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap method = findCategoryMethod__predefinedTypeAST__getInstanceMethodMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_instanceMethodMap COMMA_SOURCE_FILE_AT_LINE (771)) ;
      }
    }
    { typeCategoryMethod__predefinedTypeAST__getClassMethodMap method = findCategoryMethod__predefinedTypeAST__getClassMethodMap (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_classMethodMap COMMA_SOURCE_FILE_AT_LINE (772)) ;
      }
    }
    GGS_unifiedTypeMapProxyList  var_cas_addAssignArgumentList ;
    { typeCategoryMethod__predefinedTypeAST__getAddAssignArgumentList method = findCategoryMethod__predefinedTypeAST__getAddAssignArgumentList (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_addAssignArgumentList COMMA_SOURCE_FILE_AT_LINE (774)) ;
      }
    }
    GGS_enumerationDescriptorList  var_cas_enumerationList ;
    { typeCategoryMethod__predefinedTypeAST__getEnumerationList method = findCategoryMethod__predefinedTypeAST__getEnumerationList (var_cas_t.galgasObjectRunTimeInfo ()) ;
      if (method != NULL) {
        method (inLexique, var_cas_t (HERE), var_cas_ioSemanticContext.mTypeMap, var_cas_enumerationList COMMA_SOURCE_FILE_AT_LINE (776)) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_selfTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_32151->mPredefinedTypeName, var_cas_selfTypeProxy COMMA_SOURCE_FILE_AT_LINE (778)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_32151->mPredefinedTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (780)), GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (782)), GGS_typeKindEnum::constructor_predefinedType (inLexique COMMA_SOURCE_FILE_AT_LINE (783)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (785)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, var_cas_classMethodMap, var_cas_enumerationList, (findCategoryReader__predefinedTypeAST__getSupportedOperatorFlags (var_cas_t (HERE)->galgasRTTI ()) (inLexique, var_cas_t.getPtr () COMMA_SOURCE_FILE_AT_LINE (793))), var_cas_addAssignArgumentList, GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (799)), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (779)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@mapDeclarationAST.enterInSemanticContext'         *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_mapDeclarationAST * operand_34255,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_34255 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("string"), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (813)) ;
    GGS_unifiedTypeMapProxy  var_cas_locationTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("location"), var_cas_locationTypeProxy COMMA_SOURCE_FILE_AT_LINE (816)) ;
    GGS_unifiedTypeMapProxy  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("lstring"), var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (819)) ;
    GGS_unifiedTypeMapProxy  var_cas_currentMapTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_34255->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (822)), var_cas_currentMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (822)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (824)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (825)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (826)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (827)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_listWithValue (var_cas_lstringTypeIndex, GGS_string ("lkey")) ;
    GGS_unifiedTypeMapProxy  var_cas_locationTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("location"), var_cas_locationTypeIndex COMMA_SOURCE_FILE_AT_LINE (831)) ;
    GGS_formalParameterSignature  var_cas_insertFakeKeyFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertFakeKeyFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (833))) ;
    var_cas_insertFakeKeyFormalArgumentList.addAssign_operation (var_cas_locationTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (834))) ;
    var_cas_insertFakeKeyFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (835))) ;
    var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("insertFakeKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (837)), var_cas_insertFakeKeyFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (840)) COMMA_SOURCE_FILE_AT_LINE (836)) ;
    var_cas_insertFakeKeyFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertFakeKeyFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (844))) ;
    var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("insertSilentFakeKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (846)), var_cas_insertFakeKeyFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (849)) COMMA_SOURCE_FILE_AT_LINE (845)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyMap"),  operand_34255->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (852)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (852)) ;
    ::routine_enterConstructorWithArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("mapWithMapToOverride"),  operand_34255->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (853)),  operand_34255->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (853)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (853)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("allKeys"),  GGS_string ("stringset"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (855)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("allKeyList"),  GGS_string ("lstringlist"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (856)) ;
    ::routine_enterInheritedReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("hasKey"),  GGS_string ("string"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (857)) ;
    ::routine_enterInheritedReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("locationForKey"),  GGS_string ("string"),  GGS_string ("location"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (858)) ;
    ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("overriddenMap"),  operand_34255->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (859)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (859)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (860)) ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_insertMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (864))) ;
    GGS_formalParameterSignature  var_cas_removeMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (866))) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_38086 (operand_34255->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_38086 = NULL ;
      while (((operand_38086 = enumerator_38086.nextObject ()))) {
        macroValidPointer (operand_38086) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_38086->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (869)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (869)) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        GGS_bool var_cas_hasSetter = GGS_bool (true) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_38086->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_38086->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (873))) ;
        var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (874))) ;
        var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (875))) ;
      }
    }
    {
      GGS_insertMethodListAST::cEnumerator enumerator_38772 (operand_34255->mInsertMethodList, true) ;
      const GGS_insertMethodListAST::cElement * operand_38772 = NULL ;
      while (((operand_38772 = enumerator_38772.nextObject ()))) {
        macroValidPointer (operand_38772) ;
        const GGS_bool cond_38945 = var_cas_modifierMap.reader_hasKey (operand_38772->mInsertMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (879))) ;
        if (cond_38945.isBuiltAndTrue ()) {
          operand_38772->mInsertMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_38772->mInsertMethodName)).operator_concat (GGS_string ("' insert method is already declared")) COMMA_SOURCE_FILE_AT_LINE (881)) ;
        }else if (cond_38945.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_38772->mInsertMethodName, var_cas_insertMethodFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (886)) COMMA_SOURCE_FILE_AT_LINE (882)) ;
        }
      }
    }
    {
      GGS_mapRemoveMethodListAST::cEnumerator enumerator_39195 (operand_34255->mRemoveMethodList, true) ;
      const GGS_mapRemoveMethodListAST::cElement * operand_39195 = NULL ;
      while (((operand_39195 = enumerator_39195.nextObject ()))) {
        macroValidPointer (operand_39195) ;
        const GGS_bool cond_39386 = var_cas_modifierMap.reader_hasKey (operand_39195->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (892))) ;
        if (cond_39386.isBuiltAndTrue ()) {
          operand_39195->mMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_39195->mMethodName)).operator_concat (GGS_string ("' method is already declared as an insert modifier or a remove modifier")) COMMA_SOURCE_FILE_AT_LINE (894)) ;
        }else if (cond_39386.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_39195->mMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (899)) COMMA_SOURCE_FILE_AT_LINE (895)) ;
        }
      }
    }
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_39671 (operand_34255->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_39671 = NULL ;
      while (((operand_39671 = enumerator_39671.nextObject ()))) {
        macroValidPointer (operand_39671) ;
        var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_39671->mSearchMethodName, GGS_bool (false), var_cas_removeMethodFormalArgumentList, operand_39671->mSearchMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (909)), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (911)) COMMA_SOURCE_FILE_AT_LINE (905)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_39973 (operand_34255->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_39973 = NULL ;
      while (((operand_39973 = enumerator_39973.nextObject ()))) {
        macroValidPointer (operand_39973) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_39973->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (916))).operator_concat (GGS_string ("ForKey")), operand_39973->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (916)) COMMA_SOURCE_FILE_AT_LINE (916)) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_39973->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (918)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (918)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_listWithValue (var_cas_stringTypeIndex), GGS_location (inLexique), GGS_bool (true), var_cas_attributeTypeIndex, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (926)) COMMA_SOURCE_FILE_AT_LINE (919)) ;
      }
    }
    const GGS_bool cond_40928 = (operand_34255->mInsertOrReplaceDeclarationListAST.reader_length ()).operator_supOrEqual (GGS_uint (1U)) ;
    if (cond_40928.isBuiltAndTrue ()) {
      GGS_location  var_cas_insertOrReplaceLocation ;
      if (operand_34255->mInsertOrReplaceDeclarationListAST.isBuilt ()) {
        operand_34255->mInsertOrReplaceDeclarationListAST (HERE)->method_first (inLexique, var_cas_insertOrReplaceLocation COMMA_SOURCE_FILE_AT_LINE (932)) ;
      }
      var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("insertOrReplace"), var_cas_insertOrReplaceLocation COMMA_SOURCE_FILE_AT_LINE (934)), var_cas_insertMethodFormalArgumentList, GGS_bool (false), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (937)) COMMA_SOURCE_FILE_AT_LINE (933)) ;
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_41013 (operand_34255->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_41013 = NULL ;
      while (((operand_41013 = enumerator_41013.nextObject ()))) {
        macroValidPointer (operand_41013) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_41013->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (942)).reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("ForKey")), operand_41013->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (942)) COMMA_SOURCE_FILE_AT_LINE (942)) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_41013->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (944)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (944)) ;
        GGS_formalParameterSignature  var_cas_accessorFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (946))) ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (947))) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, var_cas_accessorFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (952)) COMMA_SOURCE_FILE_AT_LINE (948)) ;
      }
    }
    GGS_withAccessorMap  var_cas_withAccessorMap = GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (956)) ;
    var_cas_withAccessorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("hasKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (957)), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (957)) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_41965 (operand_34255->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_41965 = NULL ;
      while (((operand_41965 = enumerator_41965.nextObject ()))) {
        macroValidPointer (operand_41965) ;
        var_cas_withAccessorMap.modifier_insertKey (inLexique, operand_41965->mSearchMethodName, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (959)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_34255->mMapTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (968)), GGS_typeKindEnum::constructor_mapType (inLexique COMMA_SOURCE_FILE_AT_LINE (969)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (971)), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (977)), var_cas_enumerationDescriptor, function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (979)), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), operand_34255->mSearchMethodList, GGS_mapSearchMethodListAST ::constructor_emptyList (), var_cas_withAccessorMap, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (965)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@uniqueMapDeclarationAST.enterInSemanticContext'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__uniqueMapDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_uniqueMapDeclarationAST * operand_42908,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_42908 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("string"), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (999)) ;
    GGS_unifiedTypeMapProxy  var_cas_locationTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("location"), var_cas_locationTypeProxy COMMA_SOURCE_FILE_AT_LINE (1002)) ;
    GGS_unifiedTypeMapProxy  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("lstring"), var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1005)) ;
    GGS_unifiedTypeMapProxy  var_cas_currentMapTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_42908->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1008)), var_cas_currentMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (1008)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1010)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1011)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1012)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1013)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_listWithValue (var_cas_lstringTypeIndex, GGS_string ("lkey")) ;
    GGS_unifiedTypeMapProxy  var_cas_locationTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("location"), var_cas_locationTypeIndex COMMA_SOURCE_FILE_AT_LINE (1017)) ;
    GGS_formalParameterSignature  var_cas_insertFakeKeyFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertFakeKeyFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1019))) ;
    var_cas_insertFakeKeyFormalArgumentList.addAssign_operation (var_cas_locationTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1020))) ;
    var_cas_insertFakeKeyFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1021))) ;
    var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("insertFakeKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1023)), var_cas_insertFakeKeyFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1026)) COMMA_SOURCE_FILE_AT_LINE (1022)) ;
    var_cas_insertFakeKeyFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertFakeKeyFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1030))) ;
    var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("insertSilentFakeKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1032)), var_cas_insertFakeKeyFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1035)) COMMA_SOURCE_FILE_AT_LINE (1031)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyMap"),  operand_42908->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1038)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1038)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("allKeys"),  GGS_string ("stringset"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1040)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("allKeyList"),  GGS_string ("lstringlist"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1041)) ;
    ::routine_enterInheritedReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("hasKey"),  GGS_string ("string"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1042)) ;
    ::routine_enterInheritedReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("locationForKey"),  GGS_string ("string"),  GGS_string ("location"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1043)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1044)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("unsolvedProxyCount"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1045)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("unsolvedProxyKeyList"),  GGS_string ("stringlist"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1046)) ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_insertMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1050))) ;
    GGS_formalParameterSignature  var_cas_removeMethodFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_lstringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1052))) ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_46704 (operand_42908->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_46704 = NULL ;
      while (((operand_46704 = enumerator_46704.nextObject ()))) {
        macroValidPointer (operand_46704) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_46704->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1055)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1055)) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        GGS_bool var_cas_hasSetter = GGS_bool (true) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_46704->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_46704->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1059))) ;
        var_cas_insertMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1060))) ;
        var_cas_removeMethodFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (1061))) ;
      }
    }
    {
      GGS_insertMethodListAST::cEnumerator enumerator_47390 (operand_42908->mInsertMethodList, true) ;
      const GGS_insertMethodListAST::cElement * operand_47390 = NULL ;
      while (((operand_47390 = enumerator_47390.nextObject ()))) {
        macroValidPointer (operand_47390) ;
        const GGS_bool cond_47563 = var_cas_modifierMap.reader_hasKey (operand_47390->mInsertMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1065))) ;
        if (cond_47563.isBuiltAndTrue ()) {
          operand_47390->mInsertMethodName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '")).operator_concat (operand_47390->mInsertMethodName)).operator_concat (GGS_string ("' insert method is already declared")) COMMA_SOURCE_FILE_AT_LINE (1067)) ;
        }else if (cond_47563.isBuiltAndFalse ()) {
          var_cas_modifierMap.modifier_insertOrReplace (inLexique, operand_47390->mInsertMethodName, var_cas_insertMethodFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1072)) COMMA_SOURCE_FILE_AT_LINE (1068)) ;
        }
      }
    }
    const GGS_bool cond_48159 = (operand_42908->mMapStateList.reader_length ()).operator_isEqual (GGS_uint (0U)) ;
    if (cond_48159.isBuiltAndTrue ()) {
      {
        GGS_mapSearchMethodListAST::cEnumerator enumerator_47894 (operand_42908->mSearchMethodList, true) ;
        const GGS_mapSearchMethodListAST::cElement * operand_47894 = NULL ;
        while (((operand_47894 = enumerator_47894.nextObject ()))) {
          macroValidPointer (operand_47894) ;
          var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_47894->mSearchMethodName, GGS_bool (false), var_cas_removeMethodFormalArgumentList, operand_47894->mSearchMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1083)), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1085)) COMMA_SOURCE_FILE_AT_LINE (1079)) ;
        }
      }
    }else if (cond_48159.isBuiltAndFalse ()) {
      {
        GGS_mapSearchMethodListAST::cEnumerator enumerator_48189 (operand_42908->mSearchMethodList, true) ;
        const GGS_mapSearchMethodListAST::cElement * operand_48189 = NULL ;
        while (((operand_48189 = enumerator_48189.nextObject ()))) {
          macroValidPointer (operand_48189) ;
          var_cas_modifierMap.modifier_insertKey (inLexique, operand_48189->mSearchMethodName, var_cas_removeMethodFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1094)) COMMA_SOURCE_FILE_AT_LINE (1090)) ;
        }
      }
    }
    const GGS_bool cond_49910 = (operand_42908->mMapStateList.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
    if (cond_49910.isBuiltAndTrue ()) {
      GGS_unifiedTypeMapProxy  var_cas_locationTypeIndex ;
      GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("location"), var_cas_locationTypeIndex COMMA_SOURCE_FILE_AT_LINE (1101)) ;
      var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("openBranch"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1103)), GGS_formalParameterSignature ::constructor_emptyList (), GGS_bool (true), GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1106)) COMMA_SOURCE_FILE_AT_LINE (1102)) ;
      var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("closeBranch"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1109)), GGS_formalParameterSignature ::constructor_listWithValue (var_cas_locationTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1110))), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1112)) COMMA_SOURCE_FILE_AT_LINE (1108)) ;
      var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("closeOverride"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1115)), GGS_formalParameterSignature ::constructor_listWithValue (var_cas_locationTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1116))), GGS_bool (true), GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1118)) COMMA_SOURCE_FILE_AT_LINE (1114)) ;
      var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("checkAutomatonStates"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1121)), GGS_bool (false), GGS_formalParameterSignature ::constructor_listWithValue (var_cas_locationTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1123))), GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1126)) COMMA_SOURCE_FILE_AT_LINE (1120)) ;
      {
        GGS_mapOverrideBlockListAST::cEnumerator enumerator_49638 (operand_42908->mMapOverrideBlockListAST, true) ;
        const GGS_mapOverrideBlockListAST::cElement * operand_49638 = NULL ;
        while (((operand_49638 = enumerator_49638.nextObject ()))) {
          macroValidPointer (operand_49638) ;
          var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, (GGS_string ("openOverrideFor")).operator_concat (operand_49638->mOverrideBlockName.ggs_string ().reader_stringByCapitalizingFirstCharacter ()), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1130)), GGS_formalParameterSignature ::constructor_emptyList (), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1133)) COMMA_SOURCE_FILE_AT_LINE (1129)) ;
        }
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_49977 (operand_42908->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_49977 = NULL ;
      while (((operand_49977 = enumerator_49977.nextObject ()))) {
        macroValidPointer (operand_49977) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, (operand_49977->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1139))).operator_concat (GGS_string ("ForKey")), operand_49977->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1139)) COMMA_SOURCE_FILE_AT_LINE (1139)) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_49977->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1141)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1141)) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_listWithValue (var_cas_stringTypeIndex), GGS_location (inLexique), GGS_bool (true), var_cas_attributeTypeIndex, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1149)) COMMA_SOURCE_FILE_AT_LINE (1142)) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_50593 (operand_42908->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_50593 = NULL ;
      while (((operand_50593 = enumerator_50593.nextObject ()))) {
        macroValidPointer (operand_50593) ;
        const GGS_lstring  var_cas_accessorName = GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_50593->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1154)).reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("ForKey")), operand_50593->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1154)) COMMA_SOURCE_FILE_AT_LINE (1154)) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_50593->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1156)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1156)) ;
        GGS_formalParameterSignature  var_cas_accessorFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1158))) ;
        var_cas_accessorFormalArgumentList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1159))) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, var_cas_accessorName, var_cas_accessorFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1164)) COMMA_SOURCE_FILE_AT_LINE (1160)) ;
      }
    }
    GGS_withAccessorMap  var_cas_withAccessorMap = GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1168)) ;
    var_cas_withAccessorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("hasKey"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1169)), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1169)) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_51545 (operand_42908->mSearchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_51545 = NULL ;
      while (((operand_51545 = enumerator_51545.nextObject ()))) {
        macroValidPointer (operand_51545) ;
        var_cas_withAccessorMap.modifier_insertKey (inLexique, operand_51545->mSearchMethodName, var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1171)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_42908->mMapTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1180)), GGS_typeKindEnum::constructor_uniqueMapType (inLexique COMMA_SOURCE_FILE_AT_LINE (1181)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1183)), var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1189)), var_cas_enumerationDescriptor, function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (1191)), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), operand_42908->mSearchMethodList, GGS_mapSearchMethodListAST ::constructor_emptyList (), var_cas_withAccessorMap, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1177)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@mapProxyDeclarationAST.enterInSemanticContext'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_52493,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_52493 != NULL) {
    GGS_typedAttributeList  var_cas_mapTypedAttributeList ;
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_mapSearchMethodListAST  var_cas_searchMethodList ;
    GGS_bool automatic_var_53107_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_53107_1 ;
    GGS_typedAttributeList  automatic_var_53107_2 ;
    GGS_attributeMap  automatic_var_53107_3 ;
    GGS_constructorMap  automatic_var_53107_4 ;
    GGS_readerMap  automatic_var_53107_5 ;
    GGS_modifierMap  automatic_var_53107_6 ;
    GGS_instanceMethodMap  automatic_var_53107_7 ;
    GGS_classMethodMap  automatic_var_53107_8 ;
    GGS_enumerationDescriptorList  automatic_var_53107_9 ;
    GGS_uint  automatic_var_53107_10 ;
    GGS_unifiedTypeMapProxyList  automatic_var_53107_11 ;
    GGS_stringset  automatic_var_53107_12 ;
    GGS_lstringlist  automatic_var_53107_13 ;
    GGS_mapSearchMethodListAST  automatic_var_53107_14 ;
    GGS_withAccessorMap  automatic_var_53107_15 ;
    GGS_bool automatic_var_53107_16 ;
    if (var_cas_ioSemanticContext.mTypeMap.isBuilt ()) {
      var_cas_ioSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_52493->mAssociatedMapTypeName, automatic_var_53107_0, automatic_var_53107_1, var_cas_typeKindEnum, automatic_var_53107_2, automatic_var_53107_3, var_cas_mapTypedAttributeList, automatic_var_53107_4, automatic_var_53107_5, automatic_var_53107_6, automatic_var_53107_7, automatic_var_53107_8, automatic_var_53107_9, automatic_var_53107_10, automatic_var_53107_11, automatic_var_53107_12, automatic_var_53107_13, var_cas_searchMethodList, automatic_var_53107_14, automatic_var_53107_15, automatic_var_53107_16 COMMA_SOURCE_FILE_AT_LINE (1214)) ;
    }
    const GGS_bool cond_53338 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_uniqueMapType (inLexique COMMA_SOURCE_FILE_AT_LINE (1224))) ;
    if (cond_53338.isBuiltAndTrue ()) {
      operand_52493->mAssociatedMapTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the @")).operator_concat (operand_52493->mAssociatedMapTypeName)).operator_concat (GGS_string (" should be an unique map type")) COMMA_SOURCE_FILE_AT_LINE (1226)) ;
      var_cas_mapTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1229)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1230)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1231)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1232)) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1233)) ;
    GGS_unifiedTypeMapProxy  var_cas_associatedMapTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_52493->mAssociatedMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1236)), var_cas_associatedMapTypeIndex COMMA_SOURCE_FILE_AT_LINE (1236)) ;
    GGS_unifiedTypeMapProxy  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("string"), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1239)) ;
    GGS_unifiedTypeMapProxy  var_cas_lstringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("lstring"), var_cas_lstringTypeIndex COMMA_SOURCE_FILE_AT_LINE (1242)) ;
    GGS_unifiedTypeMapProxy  var_cas_mapProxyTypeProxy ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_52493->mMapProxyTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1245)), var_cas_mapProxyTypeProxy COMMA_SOURCE_FILE_AT_LINE (1245)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_argList.addAssign_operation (var_cas_associatedMapTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentInOut (inLexique COMMA_SOURCE_FILE_AT_LINE (1248))) ;
    var_cas_argList.addAssign_operation (var_cas_stringTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1249))) ;
    var_cas_argList.addAssign_operation (var_cas_mapProxyTypeProxy, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (1250))) ;
    var_cas_classMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("makeRegularProxy"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1252)), var_cas_argList, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1251)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("null"),  operand_52493->mMapProxyTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1257)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1257)) ;
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_associatedMapTypeIndex) ;
    var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_lstringTypeIndex) ;
    {
      GGS_mapSearchMethodListAST::cEnumerator enumerator_55138 (var_cas_searchMethodList, true) ;
      const GGS_mapSearchMethodListAST::cElement * operand_55138 = NULL ;
      while (((operand_55138 = enumerator_55138.nextObject ()))) {
        macroValidPointer (operand_55138) ;
        var_cas_constructorMap.modifier_insertKey (inLexique, operand_55138->mSearchMethodName, var_cas_constructorAttributeTypeList, GGS_bool (true), var_cas_mapProxyTypeProxy COMMA_SOURCE_FILE_AT_LINE (1263)) ;
      }
    }
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isSolved"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1271)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isNull"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1272)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("isRegular"),  GGS_string ("bool"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1273)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("lkey"),  GGS_string ("lstring"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1274)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("key"),  GGS_string ("string"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1275)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("identifierRepresentation"),  GGS_string ("string"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1276)) ;
    const GGS_readerMap  var_cas_inheritedReaderMap = var_cas_readerMap ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_56110 (var_cas_mapTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_56110 = NULL ;
      while (((operand_56110 = enumerator_56110.nextObject ()))) {
        macroValidPointer (operand_56110) ;
        const GGS_bool cond_56517 = var_cas_inheritedReaderMap.reader_hasKey (operand_56110->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1280))) ;
        if (cond_56517.isBuiltAndTrue ()) {
          GGS_string var_cas_s = GGS_string ("") ;
          {
            GGS_stringset::cEnumerator enumerator_56218 (var_cas_inheritedReaderMap.reader_allKeys (inLexique COMMA_SOURCE_FILE_AT_LINE (1282)), true) ;
            if (enumerator_56218 .hasCurrentObject ()) {
              bool _foreach_loop_56218 ;
              do{
                var_cas_s.appendCString ("'") ;
                var_cas_s.dotAssign_operation (enumerator_56218._key (HERE)) ;
                var_cas_s.appendCString ("'") ;
                enumerator_56218.next () ;
                _foreach_loop_56218 = (enumerator_56218 .hasCurrentObject ()) ;
                if (_foreach_loop_56218) {
                  var_cas_s.appendCString (", ") ;
                }
              }while (_foreach_loop_56218) ;
            }
          }
          operand_56110->mAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the map has a associated map proxy, which has predefined readers: ")).operator_concat (var_cas_s)).operator_concat (GGS_string ("; you cannot use theses names for naming an attribute of this map")) COMMA_SOURCE_FILE_AT_LINE (1288)) ;
        }else if (cond_56517.isBuiltAndFalse ()) {
          var_cas_readerMap.modifier_insertKey (inLexique, operand_56110->mAttributeName, GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_location (inLexique), GGS_bool (true), operand_56110->mAttributeTypeProxy, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1296)) COMMA_SOURCE_FILE_AT_LINE (1289)) ;
        }
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_52493->mMapProxyTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1304)), GGS_typeKindEnum::constructor_mapProxyType (inLexique COMMA_SOURCE_FILE_AT_LINE (1305)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1307)), var_cas_mapTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, var_cas_classMethodMap, GGS_enumerationDescriptorList ::constructor_emptyList (), function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (1315)), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), var_cas_searchMethodList, GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1321)), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1301)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@enumDeclarationAST.enterInSemanticContext'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_enumDeclarationAST * operand_57646,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_57646 != NULL) {
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1335)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1336)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1337)) ;
    GGS_classMethodMap  var_cas_classMethodMap = GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1338)) ;
    GGS_unifiedTypeMapProxy  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_57646->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1341)), var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (1341)) ;
    GGS_stringset  var_cas_constantSet = GGS_stringset ::constructor_emptySet () ;
    {
      GGS_lstringlist::cEnumerator enumerator_58374 (operand_57646->mConstantList, true) ;
      const GGS_lstringlist::cElement * operand_58374 = NULL ;
      while (((operand_58374 = enumerator_58374.nextObject ()))) {
        macroValidPointer (operand_58374) ;
        var_cas_constantSet.addAssign_operation (operand_58374->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1345))) ;
        ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  operand_58374->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1346)),  operand_57646->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1346)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1346)) ;
      }
    }
    GGS_readerMap  var_cas_readerMap ;
    ::routine_commonReaderMapForAllTypes (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (1350)) ;
    {
      GGS_enumMessageListAST::cEnumerator enumerator_58702 (operand_57646->mEnumMessageList, true) ;
      const GGS_enumMessageListAST::cElement * operand_58702 = NULL ;
      while (((operand_58702 = enumerator_58702.nextObject ()))) {
        macroValidPointer (operand_58702) ;
        ::routine_enterBaseReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  operand_58702->mEnumMessageName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1352)),  GGS_string ("string"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1352)) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_57646->mEnumTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1358)), GGS_typeKindEnum::constructor_enumType (inLexique COMMA_SOURCE_FILE_AT_LINE (1359)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1361)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1367)), GGS_enumerationDescriptorList ::constructor_emptyList (), (function_generateDescriptionReaderUtilityMethod (inLexique COMMA_SOURCE_FILE_AT_LINE (1369))).operator_or (function_isComparable (inLexique COMMA_SOURCE_FILE_AT_LINE (1369))), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), var_cas_constantSet, operand_57646->mConstantList, GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1375)), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1355)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class map '@wrapperExtensionMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_wrapperExtensionMap ("wrapperExtensionMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_wrapperExtensionMap::
elementOf_GGS_wrapperExtensionMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_wrapperExtensionMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_wrapperExtensionMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_wrapperExtensionMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_wrapperExtensionMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_wrapperExtensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_wrapperExtensionMap * info = (e_wrapperExtensionMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_wrapperExtensionMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_wrapperExtensionMap * info = (e_wrapperExtensionMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
constructor_emptyMap (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperExtensionMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_wrapperExtensionMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::modifier_insertFakeKey (C_CompilerEx & inCompiler,
                         const GGS_string & inKey,
                         const GGS_location & inHelperMessageErrorLocation,
                         const GGS_string & inHelperMessage
                         COMMA_LOCATION_ARGS) {
  e_wrapperExtensionMap info  ;
  internal_insertFakeKey (inCompiler,
                          (void *) & info,
                          inKey,
                          inHelperMessageErrorLocation,
                          inHelperMessage
                          COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperExtensionMap::
operator_isEqual (const GGS_wrapperExtensionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_wrapperExtensionMap::
operator_isNotEqual (const GGS_wrapperExtensionMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
insertElement (C_CompilerEx & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap (THERE) ;
    e_wrapperExtensionMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
searchElement (C_CompilerEx & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inLexique, inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_wrapperExtensionMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('s'),
  TO_UNICODE ('i'),
  TO_UNICODE ('o'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('b'),
  TO_UNICODE ('e'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_wrapperExtensionMap::
modifier_insertKey (C_CompilerEx & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
constructor_mapWithMapToOverride (C_CompilerEx & /* inLexique */,
                                  const GGS_wrapperExtensionMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_wrapperExtensionMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::
reader_overriddenMap (C_CompilerEx & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_wrapperExtensionMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_wrapperExtensionMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @wrapperExtensionMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_wrapperExtensionMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_wrapperExtensionMap * p = NULL ;
    macroMyNew (p, GGS_wrapperExtensionMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_wrapperExtensionMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_wrapperExtensionMap * p = dynamic_cast <const GGS_wrapperExtensionMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_wrapperExtensionMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_wrapperExtensionMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_wrapperExtensionMap ;
}

//---------------------------------------------------------------------------*

GGS_wrapperExtensionMap GGS_wrapperExtensionMap::constructor_mapWithKeyAndValue (C_CompilerEx & inLexique,
                                             const GGS_lstring & inKey
                                             COMMA_LOCATION_ARGS) {
  GGS_wrapperExtensionMap result = constructor_emptyMap (inLexique COMMA_THERE) ;
  result.insertElement (inLexique,
                        0,
                        NULL,
                        inKey,
                        NULL
                        COMMA_THERE) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of routine "recursivelyEnumerateDirectories"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_recursivelyEnumerateDirectories (C_CompilerEx & inLexique,
                                const GGS_string  var_cas_inAbsoluteSourcePath,
                                const GGS_string  var_cas_inPathInWrapper,
                                const GGS_wrapperExtensionMap   var_cas_inExtensionMap,
                                GGS_wrapperFileMap  & var_cas_outWrapperFileMap,
                                GGS_wrapperDirectoryMap  & var_cas_outWrapperDirectoryMap,
                                GGS_uint  & var_cas_ioWrapperFileIndex,
                                GGS_uint  & var_cas_ioWrapperDirectoryIndex
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_recursivelyEnumerateDirectories at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_uint  var_cas_currentDirectoryIndex = var_cas_ioWrapperDirectoryIndex ;
  var_cas_ioWrapperDirectoryIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (1398)) ;
  GGS_stringlist  var_cas_files = var_cas_inAbsoluteSourcePath.reader_regularFiles (GGS_bool (false)) ;
  var_cas_outWrapperFileMap = GGS_wrapperFileMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1401)) ;
  {
    GGS_stringlist::cEnumerator enumerator_60425 (var_cas_files, true) ;
    const GGS_stringlist::cElement * operand_60425 = NULL ;
    while (((operand_60425 = enumerator_60425.nextObject ()))) {
      macroValidPointer (operand_60425) ;
      const GGS_bool cond_60768 = var_cas_inExtensionMap.reader_hasKey (operand_60425->mValue.reader_pathExtension ()) ;
      if (cond_60768.isBuiltAndTrue ()) {
        GGS_string var_cas_absoluteFilePath = ((var_cas_inAbsoluteSourcePath).operator_concat (GGS_string ("/"))).operator_concat (operand_60425->mValue) ;
        var_cas_outWrapperFileMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_60425->mValue, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1406)), var_cas_absoluteFilePath, var_cas_currentDirectoryIndex, var_cas_ioWrapperFileIndex COMMA_SOURCE_FILE_AT_LINE (1405)) ;
        var_cas_ioWrapperFileIndex.increment_operation (inLexique COMMA_SOURCE_FILE_AT_LINE (1411)) ;
      }
    }
  }
  GGS_stringlist  var_cas_directories = var_cas_inAbsoluteSourcePath.reader_directories (GGS_bool (false)) ;
  var_cas_outWrapperDirectoryMap = GGS_wrapperDirectoryMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1416)) ;
  {
    GGS_stringlist::cEnumerator enumerator_60982 (var_cas_directories, true) ;
    const GGS_stringlist::cElement * operand_60982 = NULL ;
    while (((operand_60982 = enumerator_60982.nextObject ()))) {
      macroValidPointer (operand_60982) ;
      GGS_wrapperFileMap  var_cas_internalWrapperFileMap ;
      GGS_wrapperDirectoryMap  var_cas_internalWrapperDirectoryMap ;
      GGS_uint  var_cas_theDirectoryIndex = var_cas_ioWrapperDirectoryIndex ;
      ::routine_recursivelyEnumerateDirectories (inLexique,  ((var_cas_inAbsoluteSourcePath).operator_concat (GGS_string ("/"))).operator_concat (operand_60982->mValue),  ((var_cas_inPathInWrapper).operator_concat (operand_60982->mValue)).operator_concat (GGS_string ("/")),  var_cas_inExtensionMap,  var_cas_internalWrapperFileMap,  var_cas_internalWrapperDirectoryMap,  var_cas_ioWrapperFileIndex,  var_cas_ioWrapperDirectoryIndex COMMA_SOURCE_FILE_AT_LINE (1421)) ;
      var_cas_outWrapperDirectoryMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, operand_60982->mValue, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1431)), var_cas_internalWrapperFileMap, var_cas_internalWrapperDirectoryMap, var_cas_theDirectoryIndex COMMA_SOURCE_FILE_AT_LINE (1430)) ;
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_recursivelyEnumerateDirectories\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@filewrapperDeclarationAST.enterInSemanticContext'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__filewrapperDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_filewrapperDeclarationAST * operand_61761,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_61761 != NULL) {
    GGS_filewrapperTemplateMap  var_cas_filewrapperTemplateMap = GGS_filewrapperTemplateMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1447)) ;
    {
      GGS_filewrapperTemplateListAST::cEnumerator enumerator_62086 (operand_61761->mFilewrapperTemplateList, true) ;
      const GGS_filewrapperTemplateListAST::cElement * operand_62086 = NULL ;
      while (((operand_62086 = enumerator_62086.nextObject ()))) {
        macroValidPointer (operand_62086) ;
        GGS_unifiedTypeMapProxyList  var_cas_templateSignature = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
        {
          GGS_formalTemplateInputParameterListAST::cEnumerator enumerator_62204 (operand_62086->mFilewrapperTemplateFormalInputParameters, true) ;
          const GGS_formalTemplateInputParameterListAST::cElement * operand_62204 = NULL ;
          while (((operand_62204 = enumerator_62204.nextObject ()))) {
            macroValidPointer (operand_62204) ;
            GGS_unifiedTypeMapProxy  var_cas_parameterTypeIndex ;
            GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_62204->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1452)), var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (1452)) ;
            var_cas_templateSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
          }
        }
        var_cas_filewrapperTemplateMap.modifier_insertKey (inLexique, operand_62086->mFilewrapperTemplateName, var_cas_templateSignature, operand_62086->mFilewrapperTemplatePath COMMA_SOURCE_FILE_AT_LINE (1455)) ;
      }
    }
    GGS_wrapperExtensionMap  var_cas_extensionMap = GGS_wrapperExtensionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1462)) ;
    {
      GGS_lstringlist::cEnumerator enumerator_62717 (operand_61761->mFilewrapperExtensionList, true) ;
      const GGS_lstringlist::cElement * operand_62717 = NULL ;
      while (((operand_62717 = enumerator_62717.nextObject ()))) {
        macroValidPointer (operand_62717) ;
        var_cas_extensionMap.modifier_insertKey (inLexique, operand_62717->mValue COMMA_SOURCE_FILE_AT_LINE (1464)) ;
      }
    }
    GGS_wrapperFileMap  var_cas_regularRootFileMap ;
    GGS_wrapperDirectoryMap  var_cas_wrapperDirectoryMap ;
    GGS_string var_cas_absoluteSourcePath ;
    const GGS_bool cond_63051 = (operand_61761->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1470)).reader_firstCharacterOrNul ()).operator_isEqual (GGS_char (TO_UNICODE ('/'))) ;
    if (cond_63051.isBuiltAndTrue ()) {
      var_cas_absoluteSourcePath = operand_61761->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1471)) ;
    }else if (cond_63051.isBuiltAndFalse ()) {
      var_cas_absoluteSourcePath = ((operand_61761->mSourceFileAbsolutePath.reader_stringByDeletingLastPathComponent ()).operator_concat (GGS_string ("/"))).operator_concat (operand_61761->mFilewrapperPath.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1473))) ;
    }
    const GGS_bool cond_63379 = (var_cas_absoluteSourcePath.reader_directoryExists ()).operator_not () ;
    if (cond_63379.isBuiltAndTrue ()) {
      operand_61761->mFilewrapperPath.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("The '")).operator_concat (var_cas_absoluteSourcePath)).operator_concat (GGS_string ("' directory does not exist")) COMMA_SOURCE_FILE_AT_LINE (1478)) ;
      var_cas_regularRootFileMap.drop () ;
      var_cas_wrapperDirectoryMap.drop () ;
    }else if (cond_63379.isBuiltAndFalse ()) {
      GGS_uint  var_cas_wrapperFileIndex = GGS_uint (0U) ;
      GGS_uint  var_cas_wrapperDirectoryIndex = GGS_uint (0U) ;
      ::routine_recursivelyEnumerateDirectories (inLexique,  var_cas_absoluteSourcePath,  GGS_string ("/"),  var_cas_extensionMap,  var_cas_regularRootFileMap,  var_cas_wrapperDirectoryMap,  var_cas_wrapperFileIndex,  var_cas_wrapperDirectoryIndex COMMA_SOURCE_FILE_AT_LINE (1482)) ;
    }
    var_cas_ioSemanticContext.mFilewrapperMap.modifier_insertKey (inLexique, operand_61761->mFilewrapperName, operand_61761->mFilewrapperPath, operand_61761->mFilewrapperExtensionList, var_cas_regularRootFileMap, var_cas_wrapperDirectoryMap, var_cas_filewrapperTemplateMap COMMA_SOURCE_FILE_AT_LINE (1493)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@listDeclarationAST.enterInSemanticContext'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_listDeclarationAST * operand_64070,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_64070 != NULL) {
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_64446 (operand_64070->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_64446 = NULL ;
      while (((operand_64446 = enumerator_64446.nextObject ()))) {
        macroValidPointer (operand_64446) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_64446->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1515)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1515)) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        GGS_bool var_cas_hasSetter = GGS_bool (true) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_64446->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_uintType ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("uint"), var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1522)) ;
    GGS_unifiedTypeMapProxy  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_64070->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1525)), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1525)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierOutputFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierInputFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_65445 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_65445 = NULL ;
      while (((operand_65445 = enumerator_65445.nextObject ()))) {
        macroValidPointer (operand_65445) ;
        var_cas_enumerationDescriptor.addAssign_operation (operand_65445->mAttributeTypeProxy, operand_65445->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1532))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (operand_65445->mAttributeTypeProxy) ;
        var_cas_modifierOutputFormalArgumentList.addAssign_operation (operand_65445->mAttributeTypeProxy, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (1534))) ;
        var_cas_modifierInputFormalArgumentList.addAssign_operation (operand_65445->mAttributeTypeProxy, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1535))) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1538)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyList"),  operand_64070->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1539)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1539)) ;
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("listWithValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1541)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1540)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1547)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1548)) ;
    ::routine_enterBaseReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("subListFromIndex"),  GGS_string ("uint"),  operand_64070->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1549)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1549)) ;
    ::routine_enterBaseReaderWith2Arguments (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("subListWithRange"),  GGS_string ("uint"),  GGS_string ("uint"),  operand_64070->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1550)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (1550)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_66615 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_66615 = NULL ;
      while (((operand_66615 = enumerator_66615.nextObject ()))) {
        macroValidPointer (operand_66615) ;
        var_cas_readerMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, (operand_66615->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1553))).operator_concat (GGS_string ("AtIndex")), operand_66615->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1553)) COMMA_SOURCE_FILE_AT_LINE (1553)), GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_listWithValue (var_cas_uintType), GGS_location (inLexique), GGS_bool (true), operand_66615->mAttributeTypeProxy, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1559)) COMMA_SOURCE_FILE_AT_LINE (1552)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1563)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popFirst"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1565)), var_cas_modifierOutputFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1568)) COMMA_SOURCE_FILE_AT_LINE (1564)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popLast"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1571)), var_cas_modifierOutputFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1574)) COMMA_SOURCE_FILE_AT_LINE (1570)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("prependValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1577)), var_cas_modifierInputFormalArgumentList, GGS_bool (false), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1580)) COMMA_SOURCE_FILE_AT_LINE (1576)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_67495 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_67495 = NULL ;
      while (((operand_67495 = enumerator_67495.nextObject ()))) {
        macroValidPointer (operand_67495) ;
        GGS_formalParameterSignature  var_cas_setterFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        var_cas_setterFormalArgumentList.addAssign_operation (operand_67495->mAttributeTypeProxy, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1584))) ;
        var_cas_setterFormalArgumentList.addAssign_operation (var_cas_uintType, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (1585))) ;
        var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, ((GGS_string ("set")).operator_concat (operand_67495->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1587)).reader_stringByCapitalizingFirstCharacter ())).operator_concat (GGS_string ("AtIndex")), operand_67495->mAttributeName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1587)) COMMA_SOURCE_FILE_AT_LINE (1587)), var_cas_setterFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1590)) COMMA_SOURCE_FILE_AT_LINE (1586)) ;
      }
    }
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1594)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("first"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1596)), GGS_bool (false), var_cas_modifierOutputFormalArgumentList, GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1601)) COMMA_SOURCE_FILE_AT_LINE (1595)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("last"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1604)), GGS_bool (false), var_cas_modifierOutputFormalArgumentList, GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1609)) COMMA_SOURCE_FILE_AT_LINE (1603)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_64070->mListTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1615)), GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (1616)), var_cas_typedAttributeList, GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1618)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1624)), var_cas_enumerationDescriptor, ((function_binaryConcatOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1626))).operator_or (function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (1626)))).operator_or (function_dotAssignOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1626))), var_cas_constructorAttributeTypeList, GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1632)), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1612)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@sortedListDeclarationAST.enterInSemanticContext'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_69409,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_69409 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_uintType ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("uint"), var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1646)) ;
    GGS_unifiedTypeMapProxy  var_cas_listTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_69409->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1649)), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1649)) ;
    GGS_enumerationDescriptorList  var_cas_enumerationDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    GGS_formalParameterSignature  var_cas_modifierFormalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_70308 (operand_69409->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_70308 = NULL ;
      while (((operand_70308 = enumerator_70308.nextObject ()))) {
        macroValidPointer (operand_70308) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_70308->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1657)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1657)) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        GGS_bool var_cas_hasSetter = GGS_bool (true) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_70308->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_enumerationDescriptor.addAssign_operation (var_cas_attributeTypeIndex, operand_70308->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1661))) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_modifierFormalArgumentList.addAssign_operation (var_cas_attributeTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (1663))) ;
      }
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1666)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptySortedList"),  operand_69409->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1667)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1667)) ;
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sortedListWithValue"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1669)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_listTypeIndex COMMA_SOURCE_FILE_AT_LINE (1668)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1675)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("length"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1676)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1678)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popGreatest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1680)), var_cas_modifierFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1683)) COMMA_SOURCE_FILE_AT_LINE (1679)) ;
    var_cas_modifierMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("popSmallest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1686)), var_cas_modifierFormalArgumentList, GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1689)) COMMA_SOURCE_FILE_AT_LINE (1685)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1692)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("greatest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1694)), GGS_bool (false), var_cas_modifierFormalArgumentList, GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1699)) COMMA_SOURCE_FILE_AT_LINE (1693)) ;
    var_cas_instanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("smallest"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1702)), GGS_bool (false), var_cas_modifierFormalArgumentList, GGS_location (inLexique), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1707)) COMMA_SOURCE_FILE_AT_LINE (1701)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_69409->mSortedListTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1713)), GGS_typeKindEnum::constructor_sortedListType (inLexique COMMA_SOURCE_FILE_AT_LINE (1714)), var_cas_typedAttributeList, GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1716)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1722)), var_cas_enumerationDescriptor, ((function_binaryConcatOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1724))).operator_or (function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (1724)))).operator_or (function_dotAssignOperator (inLexique COMMA_SOURCE_FILE_AT_LINE (1724))), var_cas_constructorAttributeTypeList, GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1730)), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1710)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@structDeclarationAST.enterInSemanticContext'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_structDeclarationAST * operand_73124,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_73124 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_structTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_73124->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1745)), var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (1745)) ;
    GGS_attributeMap  var_cas_attributeMap = GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1747)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1748)) ;
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_typedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_73854 (operand_73124->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_73854 = NULL ;
      while (((operand_73854 = enumerator_73854.nextObject ()))) {
        macroValidPointer (operand_73854) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_73854->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1753)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1753)) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        GGS_bool var_cas_hasSetter = GGS_bool (false) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        var_cas_typedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_73854->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_73854->mAttributeName, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1758)) ;
      }
    }
    var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1761)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_structTypeIndex COMMA_SOURCE_FILE_AT_LINE (1760)) ;
    GGS_readerMap  var_cas_readerMap ;
    ::routine_commonReaderMapForAllTypes (inLexique,  var_cas_ioSemanticContext.mTypeMap,  var_cas_readerMap COMMA_SOURCE_FILE_AT_LINE (1768)) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_74592 (var_cas_typedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_74592 = NULL ;
      while (((operand_74592 = enumerator_74592.nextObject ()))) {
        macroValidPointer (operand_74592) ;
        ::routine_enterBaseFinalReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  operand_74592->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1775)),  operand_74592->mAttributeTypeProxy.reader_key (inLexique COMMA_SOURCE_FILE_AT_LINE (1776)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1772)) ;
      }
    }
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1782)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1784)) ;
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_73124->mStructTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1789)), GGS_typeKindEnum::constructor_structType (inLexique COMMA_SOURCE_FILE_AT_LINE (1790)), GGS_typedAttributeList ::constructor_emptyList (), var_cas_attributeMap, var_cas_typedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1798)), GGS_enumerationDescriptorList ::constructor_emptyList (), function_generateDescriptionReaderUtilityMethod (inLexique COMMA_SOURCE_FILE_AT_LINE (1800)), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1806)), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (1786)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@classDeclarationAST.enterInSemanticContext'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_classDeclarationAST * operand_75931,
                                const GGS_categoryMethodMapForBuildingContext   var_cas_inCategoryMethodMapForBuildingContext,
                                const GGS_categoryReaderMapForBuildingContext   var_cas_inCategoryReaderMapForBuildingContext,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_75931 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_uintType ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("uint"), var_cas_uintType COMMA_SOURCE_FILE_AT_LINE (1819)) ;
    GGS_readerMap  var_cas_readerMap ;
    GGS_modifierMap  var_cas_modifierMap ;
    GGS_instanceMethodMap  var_cas_inheritedInstanceMethodMap ;
    GGS_typedAttributeList  var_cas_inheritedTypedAttributeList ;
    GGS_attributeMap  var_cas_attributeMap = GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1825)) ;
    GGS_unifiedTypeMapProxy  var_cas_superClassIndex ;
    GGS_bool var_cas_generateHeaderInSeparateFile ;
    const GGS_bool cond_77148 = (operand_75931->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1829))).operator_isEqual (GGS_string ("")) ;
    if (cond_77148.isBuiltAndTrue ()) {
      var_cas_superClassIndex = GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (1830)) ;
      var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1831)) ;
      var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1832)) ;
      var_cas_inheritedInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1833)) ;
      var_cas_inheritedTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
      var_cas_attributeMap = GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1835)) ;
      var_cas_generateHeaderInSeparateFile = GGS_bool (false) ;
      {
        GGS_lstringlist::cEnumerator enumerator_76999 (operand_75931->mClassFeatureList, true) ;
        const GGS_lstringlist::cElement * operand_76999 = NULL ;
        while (((operand_76999 = enumerator_76999.nextObject ()))) {
          macroValidPointer (operand_76999) ;
          const GGS_bool cond_77118 = (operand_76999->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1838))).operator_isEqual (GGS_string ("generatedInSeparateFile")) ;
          if (cond_77118.isBuiltAndTrue ()) {
            var_cas_generateHeaderInSeparateFile = GGS_bool (true) ;
          }
        }
      }
    }else if (cond_77148.isBuiltAndFalse ()) {
      GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_75931->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1843)), var_cas_superClassIndex COMMA_SOURCE_FILE_AT_LINE (1843)) ;
      GGS_typeKindEnum var_cas_typeKindEnum ;
      GGS_readerMap  var_cas_inheritedReaderMap ;
      GGS_modifierMap  var_cas_inheritedModifierMap ;
      GGS_bool automatic_var_77677_0 ;
      GGS_unifiedTypeMapProxy  automatic_var_77677_1 ;
      GGS_typedAttributeList  automatic_var_77677_2 ;
      GGS_constructorMap  automatic_var_77677_3 ;
      GGS_classMethodMap  automatic_var_77677_4 ;
      GGS_enumerationDescriptorList  automatic_var_77677_5 ;
      GGS_uint  automatic_var_77677_6 ;
      GGS_unifiedTypeMapProxyList  automatic_var_77677_7 ;
      GGS_stringset  automatic_var_77677_8 ;
      GGS_lstringlist  automatic_var_77677_9 ;
      GGS_mapSearchMethodListAST  automatic_var_77677_10 ;
      GGS_mapSearchMethodListAST  automatic_var_77677_11 ;
      GGS_withAccessorMap  automatic_var_77677_12 ;
      if (var_cas_ioSemanticContext.mTypeMap.isBuilt ()) {
        var_cas_ioSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_75931->mSuperClassName, automatic_var_77677_0, automatic_var_77677_1, var_cas_typeKindEnum, var_cas_inheritedTypedAttributeList, var_cas_attributeMap, automatic_var_77677_2, automatic_var_77677_3, var_cas_inheritedReaderMap, var_cas_inheritedModifierMap, var_cas_inheritedInstanceMethodMap, automatic_var_77677_4, automatic_var_77677_5, automatic_var_77677_6, automatic_var_77677_7, automatic_var_77677_8, automatic_var_77677_9, automatic_var_77677_10, automatic_var_77677_11, automatic_var_77677_12, var_cas_generateHeaderInSeparateFile COMMA_SOURCE_FILE_AT_LINE (1847)) ;
      }
      const GGS_bool cond_77834 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (1861))) ;
      if (cond_77834.isBuiltAndTrue ()) {
        operand_75931->mSuperClassName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the @")).operator_concat (operand_75931->mSuperClassName)).operator_concat (GGS_string (" should be a class type")) COMMA_SOURCE_FILE_AT_LINE (1863)) ;
      }
      var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1865)) ;
      {
        GGS_modifierMap::cEnumerator enumerator_77956 (var_cas_inheritedModifierMap, true) ;
        const GGS_modifierMap::cElement * operand_77956 = NULL ;
        while (((operand_77956 = enumerator_77956.nextObject ()))) {
          macroValidPointer (operand_77956) ;
          var_cas_modifierMap.modifier_insertKey (inLexique, operand_77956->mKey, operand_77956->mInfo.mParameterList, operand_77956->mInfo.mHasCompilerArgument, GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1871)) COMMA_SOURCE_FILE_AT_LINE (1867)) ;
        }
      }
      var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1875)) ;
      {
        GGS_readerMap::cEnumerator enumerator_78236 (var_cas_inheritedReaderMap, true) ;
        const GGS_readerMap::cElement * operand_78236 = NULL ;
        while (((operand_78236 = enumerator_78236.nextObject ()))) {
          macroValidPointer (operand_78236) ;
          var_cas_readerMap.modifier_insertKey (inLexique, operand_78236->mKey, operand_78236->mInfo.mIsCategory, operand_78236->mInfo.mArgumentTypeList, operand_78236->mInfo.mDeclarationLocation, operand_78236->mInfo.mHasCompilerArgument, operand_78236->mInfo.mReturnedType, GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1884)) COMMA_SOURCE_FILE_AT_LINE (1877)) ;
        }
      }
    }
    GGS_unifiedTypeMapProxyList  var_cas_constructorAttributeTypeList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_78656 (var_cas_inheritedTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_78656 = NULL ;
      while (((operand_78656 = enumerator_78656.nextObject ()))) {
        macroValidPointer (operand_78656) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (operand_78656->mAttributeTypeProxy) ;
      }
    }
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_78759 (operand_75931->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_78759 = NULL ;
      while (((operand_78759 = enumerator_78759.nextObject ()))) {
        macroValidPointer (operand_78759) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_78759->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1895)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1895)) ;
        var_cas_constructorAttributeTypeList.addAssign_operation (var_cas_attributeTypeIndex) ;
        var_cas_attributeMap.modifier_insertKey (inLexique, operand_78759->mAttributeName, var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (1897)) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_classIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_75931->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1901)), var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1901)) ;
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1903)) ;
    const GGS_bool cond_79485 = (operand_75931->mIsAbstract).operator_not () ;
    if (cond_79485.isBuiltAndTrue ()) {
      var_cas_constructorMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("new"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (1906)), var_cas_constructorAttributeTypeList, GGS_bool (false), var_cas_classIndex COMMA_SOURCE_FILE_AT_LINE (1905)) ;
    }
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (1913)) ;
    {
      GGS_instanceMethodMap::cEnumerator enumerator_79616 (var_cas_inheritedInstanceMethodMap, true) ;
      const GGS_instanceMethodMap::cElement * operand_79616 = NULL ;
      while (((operand_79616 = enumerator_79616.nextObject ()))) {
        macroValidPointer (operand_79616) ;
        var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_79616->mKey, operand_79616->mInfo.mIsCategory, operand_79616->mInfo.mParameterList, operand_79616->mInfo.mDeclarationLocation, operand_79616->mInfo.mHasCompilerArgument, GGS_methodQualifier::constructor_isInherited (inLexique COMMA_SOURCE_FILE_AT_LINE (1921)) COMMA_SOURCE_FILE_AT_LINE (1915)) ;
      }
    }
    {
      GGS_abstractMethodDefinitionListAST::cEnumerator enumerator_79898 (operand_75931->mAbstractMethodList, true) ;
      const GGS_abstractMethodDefinitionListAST::cElement * operand_79898 = NULL ;
      while (((operand_79898 = enumerator_79898.nextObject ()))) {
        macroValidPointer (operand_79898) ;
        GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_79987 (operand_79898->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_79987 = NULL ;
          while (((operand_79987 = enumerator_79987.nextObject ()))) {
            macroValidPointer (operand_79987) ;
            GGS_unifiedTypeMapProxy  var_cas_typeIndex ;
            GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_79987->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1929)), var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1929)) ;
            var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_79987->mFormalArgumentPassingMode) ;
          }
        }
        elementOf_GGS_instanceMethodMap * operand_80268 = (elementOf_GGS_instanceMethodMap *) var_cas_instanceMethodMap.searchForReadWriteWithInstruction (operand_79898->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1932))) ;
        if (NULL != operand_80268) {
          operand_80268->mInfo.mQualifier = GGS_methodQualifier::constructor_isOverridingAbstract (inLexique COMMA_SOURCE_FILE_AT_LINE (1933)) ;
        }else{
          var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_79898->mMethodName, GGS_bool (false), var_cas_formalArgumentList, operand_79898->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1939)), GGS_bool (true), GGS_methodQualifier::constructor_isAbstract (inLexique COMMA_SOURCE_FILE_AT_LINE (1941)) COMMA_SOURCE_FILE_AT_LINE (1935)) ;
        }
      }
    }
    {
      GGS_methodDefinitionListAST::cEnumerator enumerator_80685 (operand_75931->mMethodList, true) ;
      const GGS_methodDefinitionListAST::cElement * operand_80685 = NULL ;
      while (((operand_80685 = enumerator_80685.nextObject ()))) {
        macroValidPointer (operand_80685) ;
        GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
        {
          GGS_formalParameterListAST::cEnumerator enumerator_80774 (operand_80685->mSignature, true) ;
          const GGS_formalParameterListAST::cElement * operand_80774 = NULL ;
          while (((operand_80774 = enumerator_80774.nextObject ()))) {
            macroValidPointer (operand_80774) ;
            GGS_unifiedTypeMapProxy  var_cas_typeIndex ;
            GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_80774->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1950)), var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1950)) ;
            var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_80774->mFormalArgumentPassingMode) ;
          }
        }
        elementOf_GGS_instanceMethodMap * operand_81055 = (elementOf_GGS_instanceMethodMap *) var_cas_instanceMethodMap.searchForReadWriteWithInstruction (operand_80685->mMethodName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1953))) ;
        if (NULL != operand_81055) {
          operand_81055->mInfo.mQualifier = GGS_methodQualifier::constructor_isOverriding (inLexique COMMA_SOURCE_FILE_AT_LINE (1954)) ;
        }else{
          var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_80685->mMethodName, GGS_bool (false), var_cas_formalArgumentList, operand_80685->mMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1960)), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1962)) COMMA_SOURCE_FILE_AT_LINE (1956)) ;
        }
      }
    }
    const GGS_bool cond_82293 = var_cas_inCategoryMethodMapForBuildingContext.reader_hasKey (operand_75931->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1967))) ;
    if (cond_82293.isBuiltAndTrue ()) {
      GGS_categoryMethodMapForType  var_cas_categoryMethodMapForType ;
      if (var_cas_inCategoryMethodMapForBuildingContext.isBuilt ()) {
        var_cas_inCategoryMethodMapForBuildingContext (HERE)->method_searchKey (inLexique, operand_75931->mClassTypeName, var_cas_categoryMethodMapForType COMMA_SOURCE_FILE_AT_LINE (1969)) ;
      }
      {
        GGS_categoryMethodMapForType::cEnumerator enumerator_81712 (var_cas_categoryMethodMapForType, true) ;
        const GGS_categoryMethodMapForType::cElement * operand_81712 = NULL ;
        while (((operand_81712 = enumerator_81712.nextObject ()))) {
          macroValidPointer (operand_81712) ;
          GGS_formalParameterSignature  var_cas_formalArgumentList = GGS_formalParameterSignature ::constructor_emptyList () ;
          {
            GGS_formalParameterListAST::cEnumerator enumerator_81815 (operand_81712->mInfo.mFormalParameterList, true) ;
            const GGS_formalParameterListAST::cElement * operand_81815 = NULL ;
            while (((operand_81815 = enumerator_81815.nextObject ()))) {
              macroValidPointer (operand_81815) ;
              GGS_unifiedTypeMapProxy  var_cas_typeIndex ;
              GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_81815->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1974)), var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1974)) ;
              var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex, operand_81815->mFormalArgumentPassingMode) ;
            }
          }
          var_cas_instanceMethodMap.modifier_insertKey (inLexique, operand_81712->mKey, GGS_bool (true), var_cas_formalArgumentList, operand_81712->mKey.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (1981)), GGS_bool (true), GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (1983)) COMMA_SOURCE_FILE_AT_LINE (1977)) ;
        }
      }
    }
    const GGS_bool cond_83347 = var_cas_inCategoryReaderMapForBuildingContext.reader_hasKey (operand_75931->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1988))) ;
    if (cond_83347.isBuiltAndTrue ()) {
      GGS_categoryReaderMapForType  var_cas_categoryReaderMapForType ;
      if (var_cas_inCategoryReaderMapForBuildingContext.isBuilt ()) {
        var_cas_inCategoryReaderMapForBuildingContext (HERE)->method_searchKey (inLexique, operand_75931->mClassTypeName, var_cas_categoryReaderMapForType COMMA_SOURCE_FILE_AT_LINE (1990)) ;
      }
      {
        GGS_categoryReaderMapForType::cEnumerator enumerator_82616 (var_cas_categoryReaderMapForType, true) ;
        const GGS_categoryReaderMapForType::cElement * operand_82616 = NULL ;
        while (((operand_82616 = enumerator_82616.nextObject ()))) {
          macroValidPointer (operand_82616) ;
          GGS_unifiedTypeMapProxyList  var_cas_formalArgumentList = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
          {
            GGS_formalInputParameterListAST::cEnumerator enumerator_82723 (operand_82616->mInfo.mInputFormalParameterList, true) ;
            const GGS_formalInputParameterListAST::cElement * operand_82723 = NULL ;
            while (((operand_82723 = enumerator_82723.nextObject ()))) {
              macroValidPointer (operand_82723) ;
              GGS_unifiedTypeMapProxy  var_cas_typeIndex ;
              GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_82723->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1995)), var_cas_typeIndex COMMA_SOURCE_FILE_AT_LINE (1995)) ;
              var_cas_formalArgumentList.addAssign_operation (var_cas_typeIndex) ;
            }
          }
          GGS_unifiedTypeMapProxy  var_cas_returnedType ;
          GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_82616->mInfo.mResultTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (1999)), var_cas_returnedType COMMA_SOURCE_FILE_AT_LINE (1999)) ;
          var_cas_readerMap.modifier_insertKey (inLexique, operand_82616->mKey, GGS_bool (true), var_cas_formalArgumentList, operand_82616->mKey.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (2004)), GGS_bool (true), var_cas_returnedType, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (2007)) COMMA_SOURCE_FILE_AT_LINE (2000)) ;
        }
      }
    }
    GGS_typedAttributeList  var_cas_currentClassTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    GGS_typedAttributeList  var_cas_allTypedAttributeList = var_cas_inheritedTypedAttributeList ;
    {
      GGS_attributeInCollectionListAST::cEnumerator enumerator_83547 (operand_75931->mAttributeList, true) ;
      const GGS_attributeInCollectionListAST::cElement * operand_83547 = NULL ;
      while (((operand_83547 = enumerator_83547.nextObject ()))) {
        macroValidPointer (operand_83547) ;
        GGS_unifiedTypeMapProxy  var_cas_attributeTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_83547->mAttributeTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2016)), var_cas_attributeTypeIndex COMMA_SOURCE_FILE_AT_LINE (2016)) ;
        GGS_bool var_cas_hasSetter = GGS_bool (false) ;
        GGS_bool var_cas_hasGetter = GGS_bool (true) ;
        {
          GGS_lstringlist::cEnumerator enumerator_83807 (operand_83547->mFeatureList, true) ;
          const GGS_lstringlist::cElement * operand_83807 = NULL ;
          while (((operand_83807 = enumerator_83807.nextObject ()))) {
            macroValidPointer (operand_83807) ;
            const GGS_bool cond_83892 = (operand_83807->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2020))).operator_isEqual (GGS_string ("setter")) ;
            if (cond_83892.isBuiltAndTrue ()) {
              var_cas_hasSetter = GGS_bool (true) ;
            }else if (cond_83892.isBuiltAndFalse ()) {
              const GGS_bool cond_83966 = (operand_83807->mValue.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2022))).operator_isEqual (GGS_string ("nogetter")) ;
              if (cond_83966.isBuiltAndTrue ()) {
                var_cas_hasGetter = GGS_bool (false) ;
              }
            }
          }
        }
        var_cas_currentClassTypedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_83547->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        var_cas_allTypedAttributeList.addAssign_operation (var_cas_attributeTypeIndex, operand_83547->mAttributeName, var_cas_hasSetter, var_cas_hasGetter) ;
        const GGS_bool cond_84736 = var_cas_hasGetter ;
        if (cond_84736.isBuiltAndTrue ()) {
          var_cas_readerMap.modifier_insertKey (inLexique, operand_83547->mAttributeName, GGS_bool (false), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_location (inLexique), GGS_bool (false), var_cas_attributeTypeIndex, GGS_methodQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (2036)) COMMA_SOURCE_FILE_AT_LINE (2029)) ;
        }
      }
    }
    {
      GGS_typedAttributeList::cEnumerator enumerator_84828 (var_cas_currentClassTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_84828 = NULL ;
      while (((operand_84828 = enumerator_84828.nextObject ()))) {
        macroValidPointer (operand_84828) ;
        const GGS_bool cond_85197 = operand_84828->mHasSetter ;
        if (cond_85197.isBuiltAndTrue ()) {
          var_cas_modifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, (GGS_string ("set")).operator_concat (operand_84828->mAttributeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2050)).reader_stringByCapitalizingFirstCharacter ()), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (2050)), GGS_formalParameterSignature ::constructor_listWithValue (operand_84828->mAttributeTypeProxy, GGS_formalArgumentPassingModeAST::constructor_argumentIn (inLexique COMMA_SOURCE_FILE_AT_LINE (2051))), GGS_bool (false), GGS_methodQualifier::constructor_isBasicFinal (inLexique COMMA_SOURCE_FILE_AT_LINE (2053)) COMMA_SOURCE_FILE_AT_LINE (2049)) ;
        }
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_75931->mClassTypeName, (operand_75931->mIsAbstract).operator_not (), var_cas_superClassIndex, GGS_typeKindEnum::constructor_classType (inLexique COMMA_SOURCE_FILE_AT_LINE (2062)), var_cas_allTypedAttributeList, var_cas_attributeMap, var_cas_currentClassTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2070)), GGS_enumerationDescriptorList ::constructor_emptyList (), GGS_uint (0U), GGS_unifiedTypeMapProxyList ::constructor_emptyList (), GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2078)), var_cas_generateHeaderInSeparateFile COMMA_SOURCE_FILE_AT_LINE (2058)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@externRoutineDeclarationAST.enterInSemanticContext'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_externRoutineDeclarationAST * operand_86047,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_86047 != NULL) {
    GGS_formalParameterSignature  var_cas_routineSignature = GGS_formalParameterSignature ::constructor_emptyList () ;
    {
      GGS_formalParameterListAST::cEnumerator enumerator_86405 (operand_86047->mFormalArgumentList, true) ;
      const GGS_formalParameterListAST::cElement * operand_86405 = NULL ;
      while (((operand_86405 = enumerator_86405.nextObject ()))) {
        macroValidPointer (operand_86405) ;
        GGS_unifiedTypeMapProxy  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_86405->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2094)), var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (2094)) ;
        var_cas_routineSignature.addAssign_operation (var_cas_parameterTypeIndex, operand_86405->mFormalArgumentPassingMode) ;
      }
    }
    var_cas_ioSemanticContext.mRoutineMap.modifier_insertKey (inLexique, operand_86047->mRoutineName, var_cas_routineSignature COMMA_SOURCE_FILE_AT_LINE (2098)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@externFunctionDeclarationAST.enterInSemanticContext'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_externFunctionDeclarationAST * operand_86951,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_86951 != NULL) {
    GGS_unifiedTypeMapProxyList  var_cas_functionSignature = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    {
      GGS_formalInputParameterListAST::cEnumerator enumerator_87310 (operand_86951->mFormalArgumentList, true) ;
      const GGS_formalInputParameterListAST::cElement * operand_87310 = NULL ;
      while (((operand_87310 = enumerator_87310.nextObject ()))) {
        macroValidPointer (operand_87310) ;
        GGS_unifiedTypeMapProxy  var_cas_parameterTypeIndex ;
        GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_87310->mFormalArgumentTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2112)), var_cas_parameterTypeIndex COMMA_SOURCE_FILE_AT_LINE (2112)) ;
        var_cas_functionSignature.addAssign_operation (var_cas_parameterTypeIndex) ;
      }
    }
    GGS_unifiedTypeMapProxy  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_86951->mResultTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2117)), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (2117)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_86951->mFunctionName, var_cas_functionSignature, var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (2119)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@onceFunctionDeclarationAST.enterInSemanticContext'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__onceFunctionDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_onceFunctionDeclarationAST * operand_88023,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_88023 != NULL) {
    GGS_unifiedTypeMapProxy  var_cas_resultTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_88023->mResultTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2131)), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (2131)) ;
    var_cas_ioSemanticContext.mFunctionMap.modifier_insertKey (inLexique, operand_88023->mFunctionName, GGS_unifiedTypeMapProxyList ::constructor_emptyList (), var_cas_resultTypeIndex COMMA_SOURCE_FILE_AT_LINE (2133)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@listmapDeclarationAST.enterInSemanticContext'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterInSemanticContext (C_CompilerEx & inLexique,
                                const cPtr_listmapDeclarationAST * operand_88721,
                                const GGS_categoryMethodMapForBuildingContext   /* var_cas_inCategoryMethodMapForBuildingContext */,
                                const GGS_categoryReaderMapForBuildingContext   /* var_cas_inCategoryReaderMapForBuildingContext */,
                                GGS_semanticContext & var_cas_ioSemanticContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_88721 != NULL) {
    GGS_typedAttributeList  var_cas_listTypedAttributeList ;
    GGS_typeKindEnum var_cas_typeKindEnum ;
    GGS_bool automatic_var_89291_0 ;
    GGS_unifiedTypeMapProxy  automatic_var_89291_1 ;
    GGS_attributeMap  automatic_var_89291_2 ;
    GGS_typedAttributeList  automatic_var_89291_3 ;
    GGS_constructorMap  automatic_var_89291_4 ;
    GGS_readerMap  automatic_var_89291_5 ;
    GGS_modifierMap  automatic_var_89291_6 ;
    GGS_instanceMethodMap  automatic_var_89291_7 ;
    GGS_classMethodMap  automatic_var_89291_8 ;
    GGS_enumerationDescriptorList  automatic_var_89291_9 ;
    GGS_uint  automatic_var_89291_10 ;
    GGS_unifiedTypeMapProxyList  automatic_var_89291_11 ;
    GGS_stringset  automatic_var_89291_12 ;
    GGS_lstringlist  automatic_var_89291_13 ;
    GGS_mapSearchMethodListAST  automatic_var_89291_14 ;
    GGS_mapSearchMethodListAST  automatic_var_89291_15 ;
    GGS_withAccessorMap  automatic_var_89291_16 ;
    GGS_bool automatic_var_89291_17 ;
    if (var_cas_ioSemanticContext.mTypeMap.isBuilt ()) {
      var_cas_ioSemanticContext.mTypeMap (HERE)->method_searchKey (inLexique, operand_88721->mAssociatedListTypeName, automatic_var_89291_0, automatic_var_89291_1, var_cas_typeKindEnum, var_cas_listTypedAttributeList, automatic_var_89291_2, automatic_var_89291_3, automatic_var_89291_4, automatic_var_89291_5, automatic_var_89291_6, automatic_var_89291_7, automatic_var_89291_8, automatic_var_89291_9, automatic_var_89291_10, automatic_var_89291_11, automatic_var_89291_12, automatic_var_89291_13, automatic_var_89291_14, automatic_var_89291_15, automatic_var_89291_16, automatic_var_89291_17 COMMA_SOURCE_FILE_AT_LINE (2147)) ;
    }
    const GGS_bool cond_89520 = (var_cas_typeKindEnum).operator_isNotEqual (GGS_typeKindEnum::constructor_listType (inLexique COMMA_SOURCE_FILE_AT_LINE (2154))) ;
    if (cond_89520.isBuiltAndTrue ()) {
      operand_88721->mAssociatedListTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((GGS_string ("the '@")).operator_concat (operand_88721->mAssociatedListTypeName)).operator_concat (GGS_string ("' type should be a list type")) COMMA_SOURCE_FILE_AT_LINE (2156)) ;
      var_cas_listTypedAttributeList = GGS_typedAttributeList ::constructor_emptyList () ;
    }
    GGS_constructorMap  var_cas_constructorMap = GGS_constructorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2159)) ;
    GGS_readerMap  var_cas_readerMap = GGS_readerMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2160)) ;
    GGS_modifierMap  var_cas_modifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2161)) ;
    GGS_instanceMethodMap  var_cas_instanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2162)) ;
    GGS_unifiedTypeMapProxy  var_cas_associatedListTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_88721->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2165)), var_cas_associatedListTypeIndex COMMA_SOURCE_FILE_AT_LINE (2165)) ;
    GGS_unifiedTypeMapProxy  var_cas_currentTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, operand_88721->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2168)), var_cas_currentTypeIndex COMMA_SOURCE_FILE_AT_LINE (2168)) ;
    GGS_unifiedTypeMapProxy  var_cas_stringTypeIndex ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioSemanticContext.mTypeMap, GGS_string ("string"), var_cas_stringTypeIndex COMMA_SOURCE_FILE_AT_LINE (2171)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("count"),  GGS_string ("uint"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (2173)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("allKeys"),  GGS_string ("stringset"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (2174)) ;
    ::routine_enterInheritedReaderWithoutArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("keyList"),  GGS_string ("stringlist"),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (2175)) ;
    ::routine_enterBaseReaderWithArgument (inLexique,  var_cas_readerMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("listForKey"),  GGS_string ("string"),  operand_88721->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2176)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (2176)) ;
    ::routine_enterConstructorWithoutArgument (inLexique,  var_cas_constructorMap,  var_cas_ioSemanticContext.mTypeMap,  GGS_string ("emptyMap"),  operand_88721->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2178)),  GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (2178)) ;
    GGS_enumerationDescriptorList  var_cas_enumeratorDescriptor = GGS_enumerationDescriptorList ::constructor_emptyList () ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_stringTypeIndex, GGS_string ("key")) ;
    var_cas_enumeratorDescriptor.addAssign_operation (var_cas_associatedListTypeIndex, GGS_string ("mList")) ;
    GGS_unifiedTypeMapProxyList  var_cas_addAssignOperatorDescription = GGS_unifiedTypeMapProxyList ::constructor_emptyList () ;
    var_cas_addAssignOperatorDescription.addAssign_operation (var_cas_stringTypeIndex) ;
    {
      GGS_typedAttributeList::cEnumerator enumerator_91307 (var_cas_listTypedAttributeList, true) ;
      const GGS_typedAttributeList::cElement * operand_91307 = NULL ;
      while (((operand_91307 = enumerator_91307.nextObject ()))) {
        macroValidPointer (operand_91307) ;
        var_cas_addAssignOperatorDescription.addAssign_operation (operand_91307->mAttributeTypeProxy) ;
      }
    }
    var_cas_ioSemanticContext.mTypeMap.modifier_insertKey (inLexique, operand_88721->mListmapTypeName, GGS_bool (true), GGS_unifiedTypeMapProxy ::constructor_null (inLexique COMMA_SOURCE_FILE_AT_LINE (2193)), GGS_typeKindEnum::constructor_listMapType (inLexique COMMA_SOURCE_FILE_AT_LINE (2194)), GGS_typedAttributeList ::constructor_emptyList (), GGS_attributeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2196)), var_cas_listTypedAttributeList, var_cas_constructorMap, var_cas_readerMap, var_cas_modifierMap, var_cas_instanceMethodMap, GGS_classMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2202)), var_cas_enumeratorDescriptor, function_doNotGenererateObjectCompare (inLexique COMMA_SOURCE_FILE_AT_LINE (2204)), var_cas_addAssignOperatorDescription, GGS_stringset ::constructor_emptySet (), GGS_lstringlist ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_mapSearchMethodListAST ::constructor_emptyList (), GGS_withAccessorMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2210)), GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (2190)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Element of list '@partiallyOrderedSemanticDeclarationListAST'        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
elementOf_GGS_partiallyOrderedSemanticDeclarationListAST (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticDeclarationAST & argument_2):
mDependanceString (argument_0),
mTypeString (argument_1),
mSemanticDeclaration (argument_2) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
isEqualToObject (const cSortedListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * ptr = dynamic_cast <const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mDependanceString.operator_isEqual (ptr->mDependanceString).boolValue ()
         && mTypeString.operator_isEqual (ptr->mTypeString).boolValue ()
         && mSemanticDeclaration.operator_isEqual (ptr->mSemanticDeclaration).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

PMSInt32 elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
compareForSorting (const cSortedListElement * inOperand) const {
  const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * operand = (const elementOf_GGS_partiallyOrderedSemanticDeclarationListAST *) inOperand ;
  PMSInt32 result = mDependanceString.genericObjectCompare (operand->mDependanceString) ;
  return result ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_partiallyOrderedSemanticDeclarationListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mDependanceString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTypeString.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mSemanticDeclaration.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Sorted list '@partiallyOrderedSemanticDeclarationListAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST ("partiallyOrderedSemanticDeclarationListAST", false, NULL) ;

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST::GGS_partiallyOrderedSemanticDeclarationListAST (void): AC_GGS_sortedlist () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST::
GGS_partiallyOrderedSemanticDeclarationListAST (const GGS_partiallyOrderedSemanticDeclarationListAST & inSource): AC_GGS_sortedlist (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_partiallyOrderedSemanticDeclarationListAST::
operator_isEqual (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_partiallyOrderedSemanticDeclarationListAST::
operator_isNotEqual (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1,
                    const GGS_semanticDeclarationAST & argument_2) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1,
                                argument_2)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1,
                                const GGS_semanticDeclarationAST & argument_2) {
  if (isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1,
                                argument_2) ;
  }
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST GGS_partiallyOrderedSemanticDeclarationListAST::
operator_concat (const GGS_partiallyOrderedSemanticDeclarationListAST & inOperand) const {
  GGS_partiallyOrderedSemanticDeclarationListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
dotAssign_operation (const GGS_partiallyOrderedSemanticDeclarationListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      *this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_partiallyOrderedSemanticDeclarationListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mDependanceString ;
          GGS_string p_1 = p->mTypeString ;
          GGS_semanticDeclarationAST  p_2 = p->mSemanticDeclaration ;
          internalAppendValues (p_0, p_1, p_2) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mDependanceString,
                                ptr->mTypeString,
                                ptr->mSemanticDeclaration) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST  GGS_partiallyOrderedSemanticDeclarationListAST::
constructor_emptySortedList (void) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST  GGS_partiallyOrderedSemanticDeclarationListAST::
constructor_sortedListWithValue (const GGS_string& argument_0,
                           const GGS_string& argument_1,
                           const GGS_semanticDeclarationAST & argument_2) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1, argument_2) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_partiallyOrderedSemanticDeclarationListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@partiallyOrderedSemanticDeclarationListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
method_smallest (C_CompilerEx & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_semanticDeclarationAST & _out_2
                 COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
method_greatest (C_CompilerEx & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1,
             GGS_semanticDeclarationAST & _out_2
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'greatest' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
modifier_popSmallest (C_CompilerEx & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1,
                 GGS_semanticDeclarationAST & _out_2
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popSmallest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveSmallest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_partiallyOrderedSemanticDeclarationListAST::
modifier_popGreatest (C_CompilerEx & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1,
                GGS_semanticDeclarationAST & _out_2
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popGreatest' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mDependanceString ;
    _out_1 = ptr->mTypeString ;
    _out_2 = ptr->mSemanticDeclaration ;
    insulateList () ;
    _internalRemoveGreatest () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
    _out_2.drop () ;
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mDependanceString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mDependanceString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mTypeString (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTypeString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_semanticDeclarationAST  & GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator::_mSemanticDeclaration (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mSemanticDeclaration ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_partiallyOrderedSemanticDeclarationListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_partiallyOrderedSemanticDeclarationListAST * p = NULL ;
    macroMyNew (p, GGS_partiallyOrderedSemanticDeclarationListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_partiallyOrderedSemanticDeclarationListAST GGS_partiallyOrderedSemanticDeclarationListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_partiallyOrderedSemanticDeclarationListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_partiallyOrderedSemanticDeclarationListAST * p = dynamic_cast <const GGS_partiallyOrderedSemanticDeclarationListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_partiallyOrderedSemanticDeclarationListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_partiallyOrderedSemanticDeclarationListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@semanticDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__semanticDeclarationAST__enterOrderedDeclaration (C_CompilerEx &,
                                const cPtr_semanticDeclarationAST * operand_92827,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & /* var_cas_ioPartiallyOrderedDeclarationList */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_92827 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@semanticDeclarationAST.enterOrderedDeclaration'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration> gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration
findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration result = NULL ;
  if (NULL != inClassPtr) {
    if (inClassPtr->slotID () < gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.count ()) {
      result = gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration (inClassPtr->slotID () COMMA_HERE) ;
    }
    if (NULL == result) {
      AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
      if (superClassPtr != NULL) {
        result = findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (superClassPtr) ;
        gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@predefinedTypeAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__predefinedTypeAST__enterOrderedDeclaration (C_CompilerEx &,
                                const cPtr_predefinedTypeAST * operand_93070,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_93070 != NULL) {
    GGS_predefinedTypeAST  var_cas_t = operand_93070 ;
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_93070->mPredefinedTypeName, operand_93070) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@classDeclarationAST.enterOrderedDeclaration'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__classDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_classDeclarationAST * operand_93439,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_93439 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_93439->mSuperClassName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2250)), operand_93439->mClassTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2250)), operand_93439) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@listDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_listDeclarationAST * operand_93778,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_93778 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_93778->mListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2258)), operand_93778) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@structDeclarationAST.enterOrderedDeclaration'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__structDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_structDeclarationAST * operand_94096,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_94096 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_94096->mStructTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2266)), operand_94096) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@enumDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__enumDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_enumDeclarationAST * operand_94414,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_94414 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_94414->mEnumTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2274)), operand_94414) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@sortedListDeclarationAST.enterOrderedDeclaration'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__sortedListDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_sortedListDeclarationAST * operand_94736,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_94736 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_94736->mSortedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2282)), operand_94736) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@listmapDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__listmapDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_listmapDeclarationAST * operand_95061,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_95061 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_95061->mAssociatedListTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2290)), operand_95061->mListmapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2290)), operand_95061) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@mapDeclarationAST.enterOrderedDeclaration'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_mapDeclarationAST * operand_95409,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_95409 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_95409->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2298)), operand_95409) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@uniqueMapDeclarationAST.enterOrderedDeclaration'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__uniqueMapDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_uniqueMapDeclarationAST * operand_95729,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_95729 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), operand_95729->mMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2306)), operand_95729) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@mapProxyDeclarationAST.enterOrderedDeclaration'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__mapProxyDeclarationAST__enterOrderedDeclaration (C_CompilerEx & inLexique,
                                const cPtr_mapProxyDeclarationAST * operand_96048,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_96048 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (operand_96048->mAssociatedMapTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2314)), operand_96048->mMapProxyTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2314)), operand_96048) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Category method '@externFunctionDeclarationAST.enterOrderedDeclaration'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externFunctionDeclarationAST__enterOrderedDeclaration (C_CompilerEx &,
                                const cPtr_externFunctionDeclarationAST * operand_96407,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_96407 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), GGS_string (""), operand_96407) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@onceFunctionDeclarationAST.enterOrderedDeclaration'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__onceFunctionDeclarationAST__enterOrderedDeclaration (C_CompilerEx &,
                                const cPtr_onceFunctionDeclarationAST * operand_96711,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_96711 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), GGS_string (""), operand_96711) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//  Category method '@externRoutineDeclarationAST.enterOrderedDeclaration'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__externRoutineDeclarationAST__enterOrderedDeclaration (C_CompilerEx &,
                                const cPtr_externRoutineDeclarationAST * operand_97016,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_97016 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), GGS_string (""), operand_97016) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@filewrapperDeclarationAST.enterOrderedDeclaration'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__filewrapperDeclarationAST__enterOrderedDeclaration (C_CompilerEx &,
                                const cPtr_filewrapperDeclarationAST * operand_97319,
                                GGS_partiallyOrderedSemanticDeclarationListAST  & var_cas_ioPartiallyOrderedDeclarationList
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_97319 != NULL) {
    var_cas_ioPartiallyOrderedDeclarationList.addAssign_operation (GGS_string (""), GGS_string (""), operand_97319) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Implementation of routine "buildSemanticContext"              *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_buildSemanticContext (C_CompilerEx & inLexique,
                                const GGS_string  var_cas_inSourceFile,
                                const GGS_semanticDeclarationListAST   var_cas_inSemanticDeclarationList,
                                const GGS_location   var_cas_inEndOfSourceFile,
                                GGS_semanticContext & var_cas_outSemanticContext
                        COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_buildSemanticContext at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_collectedTypeMap  var_cas_collectedTypeMap = GGS_collectedTypeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2362)) ;
  GGS_categoryMethodMapForBuildingContext  var_cas_categoryMethodMapForBuildingContext = GGS_categoryMethodMapForBuildingContext ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2363)) ;
  GGS_categoryReaderMapForBuildingContext  var_cas_categoryReaderMapForBuildingContext = GGS_categoryReaderMapForBuildingContext ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2364)) ;
  {
    GGS_semanticDeclarationListAST::cEnumerator enumerator_98378 (var_cas_inSemanticDeclarationList, true) ;
    const GGS_semanticDeclarationListAST::cElement * operand_98378 = NULL ;
    while (((operand_98378 = enumerator_98378.nextObject ()))) {
      macroValidPointer (operand_98378) ;
      { typeCategoryMethod__semanticDeclarationAST__collectTypes method = findCategoryMethod__semanticDeclarationAST__collectTypes (operand_98378->mSemanticDeclaration.galgasObjectRunTimeInfo ()) ;
        if (method != NULL) {
          method (inLexique, operand_98378->mSemanticDeclaration (HERE), var_cas_collectedTypeMap, var_cas_categoryMethodMapForBuildingContext, var_cas_categoryReaderMapForBuildingContext COMMA_SOURCE_FILE_AT_LINE (2366)) ;
        }
      }
    }
  }
  GGS_stringlist  var_cas_undefinedClasses = var_cas_collectedTypeMap.reader_unsolvedProxyKeyList (inLexique COMMA_SOURCE_FILE_AT_LINE (2373)) ;
  const GGS_bool cond_98937 = (var_cas_undefinedClasses.reader_length ()).operator_isEqual (GGS_uint (1U)) ;
  if (cond_98937.isBuiltAndTrue ()) {
    GGS_string var_cas_errorMessage = GGS_string ("there is 1 undefined type:") ;
    {
      GGS_stringlist::cEnumerator enumerator_98800 (var_cas_undefinedClasses, true) ;
      const GGS_stringlist::cElement * operand_98800 = NULL ;
      while (((operand_98800 = enumerator_98800.nextObject ()))) {
        macroValidPointer (operand_98800) ;
        var_cas_errorMessage.appendCString ("\n"
          "-  @") ;
        var_cas_errorMessage.dotAssign_operation (operand_98800->mValue) ;
      }
    }
    var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (2380)) ;
    var_cas_outSemanticContext.drop () ;
  }else if (cond_98937.isBuiltAndFalse ()) {
    const GGS_bool cond_99239 = (var_cas_undefinedClasses.reader_length ()).operator_strictSup (GGS_uint (1U)) ;
    if (cond_99239.isBuiltAndTrue ()) {
      GGS_string var_cas_errorMessage = ((GGS_string ("there are ")).operator_concat (var_cas_undefinedClasses.reader_length ().reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (2381)))).operator_concat (GGS_string (" undefined types:")) ;
      {
        GGS_stringlist::cEnumerator enumerator_99103 (var_cas_undefinedClasses, true) ;
        const GGS_stringlist::cElement * operand_99103 = NULL ;
        while (((operand_99103 = enumerator_99103.nextObject ()))) {
          macroValidPointer (operand_99103) ;
          var_cas_errorMessage.appendCString ("\n"
            "-  @") ;
          var_cas_errorMessage.dotAssign_operation (operand_99103->mValue) ;
        }
      }
      var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_errorMessage COMMA_SOURCE_FILE_AT_LINE (2386)) ;
      var_cas_outSemanticContext.drop () ;
    }else if (cond_99239.isBuiltAndFalse ()) {
      GGS_partiallyOrderedSemanticDeclarationListAST  var_cas_partiallyOrderedSemanticDeclarationListAST = GGS_partiallyOrderedSemanticDeclarationListAST ::constructor_emptySortedList () ;
      {
        GGS_semanticDeclarationListAST::cEnumerator enumerator_99602 (var_cas_inSemanticDeclarationList, true) ;
        const GGS_semanticDeclarationListAST::cElement * operand_99602 = NULL ;
        while (((operand_99602 = enumerator_99602.nextObject ()))) {
          macroValidPointer (operand_99602) ;
          { typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration method = findCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (operand_99602->mSemanticDeclaration.galgasObjectRunTimeInfo ()) ;
            if (method != NULL) {
              method (inLexique, operand_99602->mSemanticDeclaration (HERE), var_cas_partiallyOrderedSemanticDeclarationListAST COMMA_SOURCE_FILE_AT_LINE (2393)) ;
            }
          }
        }
      }
      GGS_semanticDeclarationListAST  var_cas_orderedSemanticDeclarationListAST = GGS_semanticDeclarationListAST ::constructor_emptyList () ;
      GGS_stringset  var_cas_alreadyDefinedTypes = GGS_stringset ::constructor_emptySet () ;
      var_cas_alreadyDefinedTypes.addAssign_operation (GGS_string ("")) ;
      GGS_bool var_cas_progress = GGS_bool (true) ;
      GGS_uint _variant_100716 = var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length () ;
      GGS_bool _condition_100716 (_variant_100716.isBuilt (), true) ;
      while (_condition_100716.isBuiltAndTrue ()) {
        _condition_100716 = ((var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U))).operator_and (var_cas_progress) ;
        if (_condition_100716.isBuiltAndTrue ()) {
          if (_variant_100716.uintValue () == 0) {
            inLexique.onTheFlyRunTimeError ("loop variant error" COMMA_SOURCE_FILE_AT_LINE (2414)) ;
            _condition_100716 = GGS_bool (false) ;
          }else{
            _variant_100716.decrement_operation (inLexique COMMA_HERE) ;
            var_cas_progress = GGS_bool (false) ;
            const GGS_partiallyOrderedSemanticDeclarationListAST  var_cas_r = var_cas_partiallyOrderedSemanticDeclarationListAST ;
            var_cas_partiallyOrderedSemanticDeclarationListAST = GGS_partiallyOrderedSemanticDeclarationListAST ::constructor_emptySortedList () ;
            {
              GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_100331 (var_cas_r, true) ;
              const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_100331 = NULL ;
              while (((operand_100331 = enumerator_100331.nextObject ()))) {
                macroValidPointer (operand_100331) ;
                const GGS_bool cond_100559 = var_cas_alreadyDefinedTypes.reader_hasKey (operand_100331->mDependanceString) ;
                if (cond_100559.isBuiltAndTrue ()) {
                  var_cas_orderedSemanticDeclarationListAST.addAssign_operation (operand_100331->mSemanticDeclaration) ;
                  var_cas_alreadyDefinedTypes.addAssign_operation (operand_100331->mTypeString) ;
                  var_cas_progress = GGS_bool (true) ;
                }else if (cond_100559.isBuiltAndFalse ()) {
                  var_cas_partiallyOrderedSemanticDeclarationListAST.addAssign_operation (operand_100331->mDependanceString, operand_100331->mTypeString, operand_100331->mSemanticDeclaration) ;
                }
              }
            }
          }
        }
      }
      const GGS_bool cond_101556 = (var_cas_partiallyOrderedSemanticDeclarationListAST.reader_length ()).operator_strictSup (GGS_uint (0U)) ;
      if (cond_101556.isBuiltAndTrue ()) {
        GGS_string var_cas_s = GGS_string ("inheritance circularities involving the ") ;
        {
          GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_101215 (var_cas_partiallyOrderedSemanticDeclarationListAST, true) ;
          const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_101215 = enumerator_101215.nextObject () ;
          if ((operand_101215 != NULL)) {
            bool _foreach_loop_101215 ;
            do{
              macroValidPointer (operand_101215) ;
              var_cas_s.appendCString ("@") ;
              var_cas_s.dotAssign_operation (operand_101215->mTypeString) ;
              operand_101215 = enumerator_101215.nextObject () ;
              _foreach_loop_101215 = ((operand_101215 != NULL)) ;
              if (_foreach_loop_101215) {
                var_cas_s.appendCString (", ") ;
              }
            }while (_foreach_loop_101215) ;
          }
        }
        var_cas_s.appendCString (" classes; detail:") ;
        {
          GGS_partiallyOrderedSemanticDeclarationListAST::cEnumerator enumerator_101388 (var_cas_partiallyOrderedSemanticDeclarationListAST, true) ;
          const GGS_partiallyOrderedSemanticDeclarationListAST::cElement * operand_101388 = NULL ;
          while (((operand_101388 = enumerator_101388.nextObject ()))) {
            macroValidPointer (operand_101388) ;
            var_cas_s.appendCString ("\n"
              "  - @") ;
            var_cas_s.dotAssign_operation (operand_101388->mTypeString) ;
            var_cas_s.appendCString (" inherits from @") ;
            var_cas_s.dotAssign_operation (operand_101388->mDependanceString) ;
          }
        }
        var_cas_inEndOfSourceFile.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_s COMMA_SOURCE_FILE_AT_LINE (2433)) ;
        var_cas_outSemanticContext.drop () ;
      }else if (cond_101556.isBuiltAndFalse ()) {
        var_cas_outSemanticContext = GGS_semanticContext::constructor_new (var_cas_inSourceFile, GGS_unifiedTypeMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2437)), GGS_routineMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2438)), GGS_functionMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2439)), GGS_filewrapperMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2440)), GGS_grammarMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2441)), GGS_optionComponentMapForSemanticAnalysis ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (2442))) ;
        {
          GGS_semanticDeclarationListAST::cEnumerator enumerator_101994 (var_cas_orderedSemanticDeclarationListAST, true) ;
          const GGS_semanticDeclarationListAST::cElement * operand_101994 = NULL ;
          while (((operand_101994 = enumerator_101994.nextObject ()))) {
            macroValidPointer (operand_101994) ;
            { typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext method = findCategoryMethod__semanticDeclarationAST__enterInSemanticContext (operand_101994->mSemanticDeclaration.galgasObjectRunTimeInfo ()) ;
              if (method != NULL) {
                method (inLexique, operand_101994->mSemanticDeclaration (HERE), var_cas_categoryMethodMapForBuildingContext, var_cas_categoryReaderMapForBuildingContext, var_cas_outSemanticContext COMMA_SOURCE_FILE_AT_LINE (2446)) ;
              }
            }
          }
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_buildSemanticContext\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticContext (void) {
  enterCategoryMethod__semanticDeclarationAST__display (category_method__semanticDeclarationAST__display, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__abstractCategoryMethodAST__display, gClassInfoFor__abstractCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__categoryMethodAST__display, gClassInfoFor__categoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__overridingCategoryMethodAST__display, gClassInfoFor__overridingCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__abstractCategoryReaderAST__display, gClassInfoFor__abstractCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__categoryReaderAST__display, gClassInfoFor__categoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__overridingCategoryReaderAST__display, gClassInfoFor__overridingCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__predefinedTypeAST__display, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__uniqueMapDeclarationAST__display, gClassInfoFor__uniqueMapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__mapDeclarationAST__display, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__mapProxyDeclarationAST__display, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__enumDeclarationAST__display, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__sortedListDeclarationAST__display, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__structDeclarationAST__display, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__listDeclarationAST__display, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__classDeclarationAST__display, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__display ((typeCategoryMethod__semanticDeclarationAST__display) category_method__listmapDeclarationAST__display, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes (category_method__semanticDeclarationAST__collectTypes, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__abstractCategoryMethodAST__collectTypes, gClassInfoFor__abstractCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__categoryMethodAST__collectTypes, gClassInfoFor__categoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__overridingCategoryMethodAST__collectTypes, gClassInfoFor__overridingCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__overridingAbstractCategoryMethodAST__collectTypes, gClassInfoFor__overridingAbstractCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__abstractCategoryReaderAST__collectTypes, gClassInfoFor__abstractCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__categoryReaderAST__collectTypes, gClassInfoFor__categoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__overridingCategoryReaderAST__collectTypes, gClassInfoFor__overridingCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__overridingAbstractCategoryReaderAST__collectTypes, gClassInfoFor__overridingAbstractCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__predefinedTypeAST__collectTypes, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__mapDeclarationAST__collectTypes, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__uniqueMapDeclarationAST__collectTypes, gClassInfoFor__uniqueMapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__mapProxyDeclarationAST__collectTypes, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__enumDeclarationAST__collectTypes, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__sortedListDeclarationAST__collectTypes, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__structDeclarationAST__collectTypes, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__listDeclarationAST__collectTypes, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__classDeclarationAST__collectTypes, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__collectTypes ((typeCategoryMethod__semanticDeclarationAST__collectTypes) category_method__listmapDeclarationAST__collectTypes, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__abstractCategoryMethodAST__enterInSemanticContext, gClassInfoFor__abstractCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__categoryMethodAST__enterInSemanticContext, gClassInfoFor__categoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__overridingCategoryMethodAST__enterInSemanticContext, gClassInfoFor__overridingCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__overridingAbstractCategoryMethodAST__enterInSemanticContext, gClassInfoFor__overridingAbstractCategoryMethodAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__abstractCategoryReaderAST__enterInSemanticContext, gClassInfoFor__abstractCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__categoryReaderAST__enterInSemanticContext, gClassInfoFor__categoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__overridingCategoryReaderAST__enterInSemanticContext, gClassInfoFor__overridingCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__overridingAbstractCategoryReaderAST__enterInSemanticContext, gClassInfoFor__overridingAbstractCategoryReaderAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__predefinedTypeAST__enterInSemanticContext, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__mapDeclarationAST__enterInSemanticContext, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__uniqueMapDeclarationAST__enterInSemanticContext, gClassInfoFor__uniqueMapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__mapProxyDeclarationAST__enterInSemanticContext, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__enumDeclarationAST__enterInSemanticContext, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__filewrapperDeclarationAST__enterInSemanticContext, gClassInfoFor__filewrapperDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__listDeclarationAST__enterInSemanticContext, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__sortedListDeclarationAST__enterInSemanticContext, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__structDeclarationAST__enterInSemanticContext, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__classDeclarationAST__enterInSemanticContext, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__externRoutineDeclarationAST__enterInSemanticContext, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__externFunctionDeclarationAST__enterInSemanticContext, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__onceFunctionDeclarationAST__enterInSemanticContext, gClassInfoFor__onceFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterInSemanticContext ((typeCategoryMethod__semanticDeclarationAST__enterInSemanticContext) category_method__listmapDeclarationAST__enterInSemanticContext, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration (category_method__semanticDeclarationAST__enterOrderedDeclaration, gClassInfoFor__semanticDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__predefinedTypeAST__enterOrderedDeclaration, gClassInfoFor__predefinedTypeAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__classDeclarationAST__enterOrderedDeclaration, gClassInfoFor__classDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__listDeclarationAST__enterOrderedDeclaration, gClassInfoFor__listDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__structDeclarationAST__enterOrderedDeclaration, gClassInfoFor__structDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__enumDeclarationAST__enterOrderedDeclaration, gClassInfoFor__enumDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__sortedListDeclarationAST__enterOrderedDeclaration, gClassInfoFor__sortedListDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__listmapDeclarationAST__enterOrderedDeclaration, gClassInfoFor__listmapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__mapDeclarationAST__enterOrderedDeclaration, gClassInfoFor__mapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__uniqueMapDeclarationAST__enterOrderedDeclaration, gClassInfoFor__uniqueMapDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__mapProxyDeclarationAST__enterOrderedDeclaration, gClassInfoFor__mapProxyDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__externFunctionDeclarationAST__enterOrderedDeclaration, gClassInfoFor__externFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__onceFunctionDeclarationAST__enterOrderedDeclaration, gClassInfoFor__onceFunctionDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__externRoutineDeclarationAST__enterOrderedDeclaration, gClassInfoFor__externRoutineDeclarationAST.slotID ()) ;
  enterCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration ((typeCategoryMethod__semanticDeclarationAST__enterOrderedDeclaration) category_method__filewrapperDeclarationAST__enterOrderedDeclaration, gClassInfoFor__filewrapperDeclarationAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticContext (void) {
  gDispatchTableForMethod__semanticDeclarationAST__display.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__collectTypes.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterInSemanticContext.free () ;
  gDispatchTableForMethod__semanticDeclarationAST__enterOrderedDeclaration.free () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticContext (prologueRoutineFor_semanticContext, epilogueRoutineFor_semanticContext) ;

//---------------------------------------------------------------------------*

