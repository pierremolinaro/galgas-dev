//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'lexiqueCompilation.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      june 11th, 2009, at 21h23'16"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "lexiqueCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "lexiqueLL1grammar.h"

//--- START OF USER ZONE 2

//---------------------------------------------------------------------------*

//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//          Implementation of wrapper 'lexiqueGenerationTemplates'           *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_lexiqueGenerationTemplates_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_lexiqueGenerationTemplates_0 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

const cDirectoryWrapper gWrapperDirectory_0_lexiqueGenerationTemplates = {
  "",
  0,
  gWrapperAllFiles_lexiqueGenerationTemplates_0,
  0,
  gWrapperAllDirectories_lexiqueGenerationTemplates_0
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//    'headerZone2' template of 'lexiqueGenerationTemplates' filewrapper     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_lexiqueGenerationTemplates_headerZone2 (C_Compiler & inLexique,
                                const GGS_string& var_cas_LEXIQUE_CLASS_NAME,
                                const GGS_lexicalAttributeMap & var_cas_LEXICAL_ATTRIBUTE_MAP) {
  C_String result ;
  const bool isBuilt = var_cas_LEXIQUE_CLASS_NAME.isBuilt ()
    && var_cas_LEXICAL_ATTRIBUTE_MAP.isBuilt () ;
  if (isBuilt) {
    result << "\n"
      "#ifndef " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_0_DEFINED\n"
      "#define " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_0_DEFINED\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"galgas/GGS_lstring.h\"\n"
      "#include \"galgas/GGS_luint.h\"\n"
      "#include \"galgas/GGS_lsint.h\"\n"
      "#include \"galgas/GGS_luint64.h\"\n"
      "#include \"galgas/GGS_lsint64.h\"\n"
      "#include \"galgas/GGS_lchar.h\"\n"
      "#include \"galgas/GGS_ldouble.h\"\n"
      "#include \"galgas/GGS_lbool.h\"\n"
      "#include \"galgas/C_Lexique.h\"\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                          Lexical scanner class                            *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "class cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " : public cToken {\n" ;
    GGS_lexicalAttributeMap::cEnumerator enumerator_925 (var_cas_LEXICAL_ATTRIBUTE_MAP, true) ;
    const GGS_lexicalAttributeMap::cElement * operand_925 = NULL ;
    while (((operand_925 = enumerator_925.nextObject ()))) {
      macroValidPointer (operand_925) ;
      result << "  public : " ;
      result << operand_925->mInfo.mLexicalType.reader_cppTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (26)) ;
      result << " mLexicalAttribute_" ;
      result << operand_925->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (26)) ;
      result << " ;\n" ;
    }
    result << "\n"
      "  public : cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " (void) ;\n"
      "} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                          Lexical scanner class                            *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "class " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " : public C_Lexique {\n"
      "//--- Constructors\n"
      "  public : " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " (C_Compiler * inCallerCompiler,\n"
      "                       const C_String & inDependencyFileExtension,\n"
      "                       const C_String & inDependencyFilePath,\n"
      "                       C_galgas_io * inParametersPtr,\n"
      "                       const C_String & inSourceFileName\n"
      "                       COMMA_LOCATION_ARGS) ;\n"
      "\n"
      "  public : " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " (C_Compiler * inCallerCompiler,\n"
      "                       C_galgas_io * inParametersPtr,\n"
      "                       const C_String & inSourceString,\n"
      "                       const C_String & inStringForError\n"
      "                       COMMA_LOCATION_ARGS) ;\n"
      "\n"
      "//--- Declaring a protected virtual destructor enables the compiler to raise\n"
      "//    an error if a direct delete is performed; only the static method\n"
      "//    C_GGS_Object::detachPointer may invoke delete.\n"
      "  #ifndef DO_NOT_GENERATE_CHECKINGS\n"
      "    protected : virtual ~" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " (void) {}\n"
      "  #endif\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//    'headerZone3' template of 'lexiqueGenerationTemplates' filewrapper     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_lexiqueGenerationTemplates_headerZone3 (C_Compiler & inLexique,
                                const GGS_string& var_cas_LEXIQUE_CLASS_NAME,
                                const GGS_terminalList & var_cas_TERMINAL_LIST,
                                const GGS_lexicalListDeclarationList & var_cas_DELIMITOR_LIST_LIST) {
  C_String result ;
  const bool isBuilt = var_cas_LEXIQUE_CLASS_NAME.isBuilt ()
    && var_cas_TERMINAL_LIST.isBuilt ()
    && var_cas_DELIMITOR_LIST_LIST.isBuilt () ;
  if (isBuilt) {
    result << "\n"
      "//--- Terminal symbols enumeration\n"
      "  public : enum {" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_" ;
    GGS_terminalList::cEnumerator enumerator_105 (var_cas_TERMINAL_LIST, true) ;
    const GGS_terminalList::cElement * operand_105 = NULL ;
    while (((operand_105 = enumerator_105.nextObject ()))) {
      macroValidPointer (operand_105) ;
      result << ",\n"
        "  " ;
      result << var_cas_LEXIQUE_CLASS_NAME ;
      result << "_1_" ;
      result << operand_105->mTerminalName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (5)).reader_identifierRepresentation (inLexique COMMA_SOURCE_FILE_AT_LINE (5)) ;
    }
    result << "} ;\n" ;
    GGS_lexicalListDeclarationList::cEnumerator enumerator_254 (var_cas_DELIMITOR_LIST_LIST, true) ;
    const GGS_lexicalListDeclarationList::cElement * operand_254 = NULL ;
    while (((operand_254 = enumerator_254.nextObject ()))) {
      macroValidPointer (operand_254) ;
      result << "\n"
        "//--- Key words table '" ;
      result << operand_254->mName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (10)) ;
      result << "'\n"
        "  public : static sint16 search_into_" ;
      result << operand_254->mName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (11)) ;
      result << " (const C_String & inSearchedString) ;\n" ;
    }
    result << "  \n"
      "//--- Key words table 'xmlDelimitorsList'\n"
      "  public : static sint16 search_into_xmlDelimitorsList (const C_String & inSearchedString) ;\n"
      "\n"
      "  protected : virtual bool parseLexicalToken (void) ;\n"
      "  protected : virtual void appendTerminalMessageToSyntaxErrorMessage (const sint16 numeroTerminal,\n"
      "                                                              C_String & messageErreur) ;\n"
      "\n"
      "//--- Get terminal count\n"
      "  public : virtual sint16 terminalVocabularyCount (void) const { return " ;
    result << var_cas_TERMINAL_LIST.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (22)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (22)) ;
    result << " ; }\n"
      "//--- Get Token String\n"
      "  public : virtual C_String getCurrentTokenString (const cToken * inTokenPtr) const ;\n"
      "//--- Enter Token\n"
      "  protected : void enterToken (const cTokenFor_xml_parsing_lexique & inToken) ;\n"
      "} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#endif\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//'implementationZone2' template of 'lexiqueGenerationTemplates' filewrapper *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_string
template_filewrapper_lexiqueGenerationTemplates_implementationZone2 (C_Compiler & inLexique,
                                const GGS_string& var_cas_LEXIQUE_CLASS_NAME,
                                const GGS_lexicalAttributeMap & var_cas_LEXICAL_ATTRIBUTE_MAP) {
  C_String result ;
  const bool isBuilt = var_cas_LEXIQUE_CLASS_NAME.isBuilt ()
    && var_cas_LEXICAL_ATTRIBUTE_MAP.isBuilt () ;
  if (isBuilt) {
    result << "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include \"version_libpm.h\"\n"
      "#if LIBPM_VERSION != THE_LIBPM_VERSION\n"
      "  #error \"This file has been compiled with a version of GALGAS different than the version of libpm\"\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "#include <ctype.h>\n"
      "#include <string.h>\n"
      "\n"
      "#include \"utilities/MF_MemoryControl.h\"\n"
      "#include \"" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << ".h\"\n"
      "\n"
      "#include \"strings/unicode_character.h\"\n"
      "#include \"galgas/scanner_actions.h\"\n"
      "#ifndef DO_NOT_GENERATE_CHECKINGS\n"
      "  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (HERE), lineNumber ()\n"
      "  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE\n"
      "#else\n"
      "  #define LINE_AND_SOURCE_FILE\n"
      "  #define COMMA_LINE_AND_SOURCE_FILE\n"
      "#endif\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                               Constructors                                *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " (void) :\n" ;
    GGS_lexicalAttributeMap::cEnumerator enumerator_1300 (var_cas_LEXICAL_ATTRIBUTE_MAP, true) ;
    const GGS_lexicalAttributeMap::cElement * operand_1300 = NULL ;
    while (((operand_1300 = enumerator_1300.nextObject ()))) {
      macroValidPointer (operand_1300) ;
      result << "mLexicalAttribute_" ;
      result << operand_1300->mKey.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (36)) ;
      result << " ()" ;
      if (enumerator_1300.hasNextObject ()) {
        result << ",\n" ;
      }
    }
    result << " {\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::\n" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " (C_Compiler * inCallerCompiler,\n"
      "                const C_String & inDependencyFileExtension,\n"
      "                const C_String & inDependencyFilePath,\n"
      "                C_galgas_io * inParametersPtr,\n"
      "                const C_String & inSourceFileName\n"
      "                COMMA_LOCATION_ARGS) :\n"
      "C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE) {\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::\n" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " (C_Compiler * inCallerCompiler,\n"
      "                C_galgas_io * inParametersPtr,\n"
      "                const C_String & inSourceString,\n"
      "                const C_String & inStringForError\n"
      "                COMMA_LOCATION_ARGS) :\n"
      "C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE) {\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                        Lexical error message list                         *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "//--- Message 0\n"
      "static const utf32 gErrorMessage_0 [] = {\n"
      "  TO_UNICODE ('d'),\n"
      "  TO_UNICODE ('e'),\n"
      "  TO_UNICODE ('c'),\n"
      "  TO_UNICODE ('i'),\n"
      "  TO_UNICODE ('m'),\n"
      "  TO_UNICODE ('a'),\n"
      "  TO_UNICODE ('l'),\n"
      "  TO_UNICODE (' '),\n"
      "  TO_UNICODE ('n'),\n"
      "  TO_UNICODE ('u'),\n"
      "  TO_UNICODE ('m'),\n"
      "  TO_UNICODE ('b'),\n"
      "  TO_UNICODE ('e'),\n"
      "  TO_UNICODE ('r'),\n"
      "  TO_UNICODE (' '),\n"
      "  TO_UNICODE ('t'),\n"
      "  TO_UNICODE ('o'),\n"
      "  TO_UNICODE ('o'),\n"
      "  TO_UNICODE (' '),\n"
      "  TO_UNICODE ('l'),\n"
      "  TO_UNICODE ('a'),\n"
      "  TO_UNICODE ('r'),\n"
      "  TO_UNICODE ('g'),\n"
      "  TO_UNICODE ('e'),\n"
      "  TO_UNICODE (0)\n"
      "} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                          Syntax error messages                            *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "//--- Syntax error message for terminal '$identifier$' :\n"
      "static const utf32 gSyntaxErrorMessage_identifier [] = {\n"
      "  TO_UNICODE ('a'),\n"
      "  TO_UNICODE ('n'),\n"
      "  TO_UNICODE (' '),\n"
      "  TO_UNICODE ('i'),\n"
      "  TO_UNICODE ('d'),\n"
      "  TO_UNICODE ('e'),\n"
      "  TO_UNICODE ('n'),\n"
      "  TO_UNICODE ('t'),\n"
      "  TO_UNICODE ('i'),\n"
      "  TO_UNICODE ('f'),\n"
      "  TO_UNICODE ('i'),\n"
      "  TO_UNICODE ('e'),\n"
      "  TO_UNICODE ('r'),\n"
      "  TO_UNICODE (0)\n"
      "} ;\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                appendTerminalMessageToSyntaxErrorMessage                  *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "void " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::\n"
      "appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,\n"
      "                                           C_String & outSyntaxErrorMessage) {\n"
      "  static const utf32 * syntaxErrorMessageArray [144] = {kEndOfSourceLexicalErrorMessage,\n"
      "       gSyntaxErrorMessage_identifier,\n"
      "       gSyntaxErrorMessage_abstract,\n"
      "       gSyntaxErrorMessage_after,\n"
      "       gSyntaxErrorMessage_before,\n"
      "       gSyntaxErrorMessage_between,\n"
      "       gSyntaxErrorMessage_block,\n"
      "       gSyntaxErrorMessage_cast,\n"
      "       gSyntaxErrorMessage_class,\n"
      "       gSyntaxErrorMessage_compile,\n"
      "       gSyntaxErrorMessage_const,\n"
      "       gSyntaxErrorMessage_constructor,\n"
      "       gSyntaxErrorMessage_default,\n"
      "       gSyntaxErrorMessage_description,\n"
      "       gSyntaxErrorMessage_dependency,\n"
      "       gSyntaxErrorMessage_do,\n"
      "       gSyntaxErrorMessage_domain,\n"
      "       gSyntaxErrorMessage_drop,\n"
      "       gSyntaxErrorMessage_else,\n"
      "       gSyntaxErrorMessage_elsif,\n"
      "       gSyntaxErrorMessage_end,\n"
      "       gSyntaxErrorMessage_enum,\n"
      "       gSyntaxErrorMessage_error,\n"
      "       gSyntaxErrorMessage_extends,\n"
      "       gSyntaxErrorMessage_extern,\n"
      "       gSyntaxErrorMessage_extract,\n"
      "       gSyntaxErrorMessage_false,\n"
      "       gSyntaxErrorMessage_feature,\n"
      "       gSyntaxErrorMessage_filewrapper,\n"
      "       gSyntaxErrorMessage_foreach,\n"
      "       gSyntaxErrorMessage_function,\n"
      "       gSyntaxErrorMessage_grammar,\n"
      "       gSyntaxErrorMessage_gui,\n"
      "       gSyntaxErrorMessage_here,\n"
      "       gSyntaxErrorMessage_if,\n"
      "       gSyntaxErrorMessage_import,\n"
      "       gSyntaxErrorMessage_import_5F__5F_,\n"
      "       gSyntaxErrorMessage_in,\n"
      "       gSyntaxErrorMessage_insert,\n"
      "       gSyntaxErrorMessage_label,\n"
      "       gSyntaxErrorMessage_lazy,\n"
      "       gSyntaxErrorMessage_lexique,\n"
      "       gSyntaxErrorMessage_list,\n"
      "       gSyntaxErrorMessage_listmap,\n"
      "       gSyntaxErrorMessage_log,\n"
      "       gSyntaxErrorMessage_loop,\n"
      "       gSyntaxErrorMessage_map,\n"
      "       gSyntaxErrorMessage_mapindex,\n"
      "       gSyntaxErrorMessage_match,\n"
      "       gSyntaxErrorMessage_message,\n"
      "       gSyntaxErrorMessage_method,\n"
      "       gSyntaxErrorMessage_mod,\n"
      "       gSyntaxErrorMessage_modifier,\n"
      "       gSyntaxErrorMessage_nonterminal,\n"
      "       gSyntaxErrorMessage_not,\n"
      "       gSyntaxErrorMessage_on,\n"
      "       gSyntaxErrorMessage_operator,\n"
      "       gSyntaxErrorMessage_option,\n"
      "       gSyntaxErrorMessage_or,\n"
      "       gSyntaxErrorMessage_override,\n"
      "       gSyntaxErrorMessage_parse,\n"
      "       gSyntaxErrorMessage_project,\n"
      "       gSyntaxErrorMessage_program,\n"
      "       gSyntaxErrorMessage_reader,\n"
      "       gSyntaxErrorMessage_remove,\n"
      "       gSyntaxErrorMessage_replace,\n"
      "       gSyntaxErrorMessage_repeat,\n"
      "       gSyntaxErrorMessage_rewind,\n"
      "       gSyntaxErrorMessage_root,\n"
      "       gSyntaxErrorMessage_routine,\n"
      "       gSyntaxErrorMessage_rule,\n"
      "       gSyntaxErrorMessage_search,\n"
      "       gSyntaxErrorMessage_select,\n"
      "       gSyntaxErrorMessage_self,\n"
      "       gSyntaxErrorMessage_semantics,\n"
      "       gSyntaxErrorMessage_send,\n"
      "       gSyntaxErrorMessage_sortedlist,\n"
      "       gSyntaxErrorMessage_state,\n"
      "       gSyntaxErrorMessage_struct,\n"
      "       gSyntaxErrorMessage_style,\n"
      "       gSyntaxErrorMessage_switch,\n"
      "       gSyntaxErrorMessage_syntax,\n"
      "       gSyntaxErrorMessage_tag,\n"
      "       gSyntaxErrorMessage_template,\n"
      "       gSyntaxErrorMessage_then,\n"
      "       gSyntaxErrorMessage_true,\n"
      "       gSyntaxErrorMessage_unused,\n"
      "       gSyntaxErrorMessage_warning,\n"
      "       gSyntaxErrorMessage_when,\n"
      "       gSyntaxErrorMessage_while,\n"
      "       gSyntaxErrorMessage_with,\n"
      "       gSyntaxErrorMessage_literal_5F_double,\n"
      "       gSyntaxErrorMessage_unsigned_5F_literal_5F_integer,\n"
      "       gSyntaxErrorMessage_signed_5F_literal_5F_integer,\n"
      "       gSyntaxErrorMessage_unsigned_5F_literal_5F_integer_36__34_,\n"
      "       gSyntaxErrorMessage_signed_5F_literal_5F_integer_36__34_,\n"
      "       gSyntaxErrorMessage__2E_,\n"
      "       gSyntaxErrorMessage__2E__3D_,\n"
      "       gSyntaxErrorMessage__2E__2E__2E_,\n"
      "       gSyntaxErrorMessage_type_5F_name,\n"
      "       gSyntaxErrorMessage_literal_5F_char,\n"
      "       gSyntaxErrorMessage_terminal,\n"
      "       gSyntaxErrorMessage__2A_,\n"
      "       gSyntaxErrorMessage__7C_,\n"
      "       gSyntaxErrorMessage__2C_,\n"
      "       gSyntaxErrorMessage__2B_,\n"
      "       gSyntaxErrorMessage__2D__2D_,\n"
      "       gSyntaxErrorMessage__3A__3A_,\n"
      "       gSyntaxErrorMessage__3E_,\n"
      "       gSyntaxErrorMessage__3B_,\n"
      "       gSyntaxErrorMessage__3A_,\n"
      "       gSyntaxErrorMessage__2D_,\n"
      "       gSyntaxErrorMessage__28_,\n"
      "       gSyntaxErrorMessage__29_,\n"
      "       gSyntaxErrorMessage__2D__3E_,\n"
      "       gSyntaxErrorMessage__3F_,\n"
      "       gSyntaxErrorMessage__3D__3D_,\n"
      "       gSyntaxErrorMessage__3F__3F_,\n"
      "       gSyntaxErrorMessage__21_,\n"
      "       gSyntaxErrorMessage__3A__3D_,\n"
      "       gSyntaxErrorMessage__2B__2B_,\n"
      "       gSyntaxErrorMessage__5B_,\n"
      "       gSyntaxErrorMessage__5D_,\n"
      "       gSyntaxErrorMessage__2B__3D_,\n"
      "       gSyntaxErrorMessage__3F__21_,\n"
      "       gSyntaxErrorMessage__21__3F_,\n"
      "       gSyntaxErrorMessage__2F_,\n"
      "       gSyntaxErrorMessage__21__3D_,\n"
      "       gSyntaxErrorMessage__3E__3D_,\n"
      "       gSyntaxErrorMessage__26_,\n"
      "       gSyntaxErrorMessage__7B_,\n"
      "       gSyntaxErrorMessage__7D_,\n"
      "       gSyntaxErrorMessage__2D__3D_,\n"
      "       gSyntaxErrorMessage__5E_,\n"
      "       gSyntaxErrorMessage__3E__3E_,\n"
      "       gSyntaxErrorMessage__7E_,\n"
      "       gSyntaxErrorMessage__3C__2D_,\n"
      "       gSyntaxErrorMessage__3C_,\n"
      "       gSyntaxErrorMessage__3C__2D__3E_,\n"
      "       gSyntaxErrorMessage__3C__3D_,\n"
      "       gSyntaxErrorMessage__3C__3C_,\n"
      "       gSyntaxErrorMessage_non_5F_terminal_5F_symbol,\n"
      "       gSyntaxErrorMessage_literal_5F_string,\n"
      "       gSyntaxErrorMessage_comment} ;\n"
      "  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                   Key words table 'galgasKeyWordList'                     *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "static const sint32 ktable_size_galgasKeyWordList = 89 ;\n"
      "\n"
      "static const utf32 kEntry_0_forTable_galgasKeyWordList [] = {\n"
      "  TO_UNICODE ('d'),\n"
      "  TO_UNICODE ('o'),\n"
      "  TO_UNICODE (0)\n"
      "}; \n"
      "\n"
      "\n"
      "static const C_unicode_lexique_table_entry ktable_for_galgasKeyWordList [ktable_size_galgasKeyWordList] = {\n"
      "  {kEntry_0_forTable_galgasKeyWordList, 2, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_do},\n"
      "  {kEntry_1_forTable_galgasKeyWordList, 2, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_if},\n"
      "  {kEntry_2_forTable_galgasKeyWordList, 2, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_in},\n"
      "  {kEntry_3_forTable_galgasKeyWordList, 2, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_on},\n"
      "  {kEntry_4_forTable_galgasKeyWordList, 2, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_or},\n"
      "  {kEntry_5_forTable_galgasKeyWordList, 3, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_end},\n"
      "  {kEntry_6_forTable_galgasKeyWordList, 3, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_gui},\n"
      "  {kEntry_7_forTable_galgasKeyWordList, 3, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_log},\n"
      "  {kEntry_8_forTable_galgasKeyWordList, 3, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_map},\n"
      "  {kEntry_9_forTable_galgasKeyWordList, 3, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_mod},\n"
      "  {kEntry_10_forTable_galgasKeyWordList, 3, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_not},\n"
      "  {kEntry_11_forTable_galgasKeyWordList, 3, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_tag},\n"
      "  {kEntry_12_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_cast},\n"
      "  {kEntry_13_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_drop},\n"
      "  {kEntry_14_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_else},\n"
      "  {kEntry_15_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_enum},\n"
      "  {kEntry_16_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_here},\n"
      "  {kEntry_17_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_lazy},\n"
      "  {kEntry_18_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_list},\n"
      "  {kEntry_19_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_loop},\n"
      "  {kEntry_20_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_root},\n"
      "  {kEntry_21_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_rule},\n"
      "  {kEntry_22_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_self},\n"
      "  {kEntry_23_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_send},\n"
      "  {kEntry_24_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_then},\n"
      "  {kEntry_25_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_true},\n"
      "  {kEntry_26_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_when},\n"
      "  {kEntry_27_forTable_galgasKeyWordList, 4, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_with},\n"
      "  {kEntry_28_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_after},\n"
      "  {kEntry_29_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_block},\n"
      "  {kEntry_30_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_class},\n"
      "  {kEntry_31_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_const},\n"
      "  {kEntry_32_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_elsif},\n"
      "  {kEntry_33_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_error},\n"
      "  {kEntry_34_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_false},\n"
      "  {kEntry_35_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_label},\n"
      "  {kEntry_36_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_match},\n"
      "  {kEntry_37_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_parse},\n"
      "  {kEntry_38_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_state},\n"
      "  {kEntry_39_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_style},\n"
      "  {kEntry_40_forTable_galgasKeyWordList, 5, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_while},\n"
      "  {kEntry_41_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_before},\n"
      "  {kEntry_42_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_domain},\n"
      "  {kEntry_43_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_extern},\n"
      "  {kEntry_44_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_import},\n"
      "  {kEntry_45_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_insert},\n"
      "  {kEntry_46_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_method},\n"
      "  {kEntry_47_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_option},\n"
      "  {kEntry_48_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_reader},\n"
      "  {kEntry_49_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_remove},\n"
      "  {kEntry_50_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_repeat},\n"
      "  {kEntry_51_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_rewind},\n"
      "  {kEntry_52_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_search},\n"
      "  {kEntry_53_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_select},\n"
      "  {kEntry_54_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_struct},\n"
      "  {kEntry_55_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_switch},\n"
      "  {kEntry_56_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_syntax},\n"
      "  {kEntry_57_forTable_galgasKeyWordList, 6, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_unused},\n"
      "  {kEntry_58_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_between},\n"
      "  {kEntry_59_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_compile},\n"
      "  {kEntry_60_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_default},\n"
      "  {kEntry_61_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_extends},\n"
      "  {kEntry_62_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_extract},\n"
      "  {kEntry_63_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_feature},\n"
      "  {kEntry_64_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_foreach},\n"
      "  {kEntry_65_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_grammar},\n"
      "  {kEntry_66_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_lexique},\n"
      "  {kEntry_67_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_listmap},\n"
      "  {kEntry_68_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_message},\n"
      "  {kEntry_69_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_program},\n"
      "  {kEntry_70_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_project},\n"
      "  {kEntry_71_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_replace},\n"
      "  {kEntry_72_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_routine},\n"
      "  {kEntry_73_forTable_galgasKeyWordList, 7, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_warning},\n"
      "  {kEntry_74_forTable_galgasKeyWordList, 8, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_abstract},\n"
      "  {kEntry_75_forTable_galgasKeyWordList, 8, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_function},\n"
      "  {kEntry_76_forTable_galgasKeyWordList, 8, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_import_5F__5F_},\n"
      "  {kEntry_77_forTable_galgasKeyWordList, 8, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_mapindex},\n"
      "  {kEntry_78_forTable_galgasKeyWordList, 8, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_modifier},\n"
      "  {kEntry_79_forTable_galgasKeyWordList, 8, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_operator},\n"
      "  {kEntry_80_forTable_galgasKeyWordList, 8, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_override},\n"
      "  {kEntry_81_forTable_galgasKeyWordList, 8, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_template},\n"
      "  {kEntry_82_forTable_galgasKeyWordList, 9, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_semantics},\n"
      "  {kEntry_83_forTable_galgasKeyWordList, 10, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_dependency},\n"
      "  {kEntry_84_forTable_galgasKeyWordList, 10, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_sortedlist},\n"
      "  {kEntry_85_forTable_galgasKeyWordList, 11, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_constructor},\n"
      "  {kEntry_86_forTable_galgasKeyWordList, 11, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_description},\n"
      "  {kEntry_87_forTable_galgasKeyWordList, 11, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_filewrapper},\n"
      "  {kEntry_88_forTable_galgasKeyWordList, 11, " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_nonterminal}\n"
      "} ;\n"
      "\n"
      "sint16 " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::search_into_galgasKeyWordList (const C_String & inSearchedString) {\n"
      "  return searchInList (inSearchedString, ktable_for_galgasKeyWordList, ktable_size_galgasKeyWordList) ;\n"
      "}\n"
      "\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                          getCurrentTokenString                            *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "C_String " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::\n"
      "getCurrentTokenString (const cToken * inTokenPtr) const {\n"
      "  cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " * ptr = (cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " *) inTokenPtr ;\n"
      "  C_String s ;\n"
      "  if (ptr == NULL) {\n"
      "    s << \"$$\" ;\n"
      "  }else{\n"
      "    switch (ptr->mTokenCode) {\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_:\n"
      "      s << \"$$\" ;\n"
      "      break ;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_identifier:\n"
      "      s << \"$\"\n"
      "        << \"identifier\"\n"
      "        << \"$\" ;\n"
      "    s << \" \" ;\n"
      "    s.appendCLiteralStringConstant (ptr->tokenString) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_abstract:\n"
      "      s << \"$\"\n"
      "        << \"abstract\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_after:\n"
      "      s << \"$\"\n"
      "        << \"after\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_before:\n"
      "      s << \"$\"\n"
      "        << \"before\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_between:\n"
      "      s << \"$\"\n"
      "        << \"between\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_block:\n"
      "      s << \"$\"\n"
      "        << \"block\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_cast:\n"
      "      s << \"$\"\n"
      "        << \"cast\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_class:\n"
      "      s << \"$\"\n"
      "        << \"class\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_compile:\n"
      "      s << \"$\"\n"
      "        << \"compile\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_const:\n"
      "      s << \"$\"\n"
      "        << \"const\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_constructor:\n"
      "      s << \"$\"\n"
      "        << \"constructor\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_default:\n"
      "      s << \"$\"\n"
      "        << \"default\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_description:\n"
      "      s << \"$\"\n"
      "        << \"description\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_dependency:\n"
      "      s << \"$\"\n"
      "        << \"dependency\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_do:\n"
      "      s << \"$\"\n"
      "        << \"do\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_domain:\n"
      "      s << \"$\"\n"
      "        << \"domain\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_drop:\n"
      "      s << \"$\"\n"
      "        << \"drop\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_else:\n"
      "      s << \"$\"\n"
      "        << \"else\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_elsif:\n"
      "      s << \"$\"\n"
      "        << \"elsif\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_end:\n"
      "      s << \"$\"\n"
      "        << \"end\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_enum:\n"
      "      s << \"$\"\n"
      "        << \"enum\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_error:\n"
      "      s << \"$\"\n"
      "        << \"error\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_extends:\n"
      "      s << \"$\"\n"
      "        << \"extends\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_extern:\n"
      "      s << \"$\"\n"
      "        << \"extern\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_extract:\n"
      "      s << \"$\"\n"
      "        << \"extract\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_false:\n"
      "      s << \"$\"\n"
      "        << \"false\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_feature:\n"
      "      s << \"$\"\n"
      "        << \"feature\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_filewrapper:\n"
      "      s << \"$\"\n"
      "        << \"filewrapper\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_foreach:\n"
      "      s << \"$\"\n"
      "        << \"foreach\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_function:\n"
      "      s << \"$\"\n"
      "        << \"function\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_grammar:\n"
      "      s << \"$\"\n"
      "        << \"grammar\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_gui:\n"
      "      s << \"$\"\n"
      "        << \"gui\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_here:\n"
      "      s << \"$\"\n"
      "        << \"here\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_if:\n"
      "      s << \"$\"\n"
      "        << \"if\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_import:\n"
      "      s << \"$\"\n"
      "        << \"import\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_import_5F__5F_:\n"
      "      s << \"$\"\n"
      "        << \"import__\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_in:\n"
      "      s << \"$\"\n"
      "        << \"in\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_insert:\n"
      "      s << \"$\"\n"
      "        << \"insert\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_label:\n"
      "      s << \"$\"\n"
      "        << \"label\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_lazy:\n"
      "      s << \"$\"\n"
      "        << \"lazy\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_lexique:\n"
      "      s << \"$\"\n"
      "        << \"lexique\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_list:\n"
      "      s << \"$\"\n"
      "        << \"list\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_listmap:\n"
      "      s << \"$\"\n"
      "        << \"listmap\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_log:\n"
      "      s << \"$\"\n"
      "        << \"log\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_loop:\n"
      "      s << \"$\"\n"
      "        << \"loop\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_map:\n"
      "      s << \"$\"\n"
      "        << \"map\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_mapindex:\n"
      "      s << \"$\"\n"
      "        << \"mapindex\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_match:\n"
      "      s << \"$\"\n"
      "        << \"match\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_message:\n"
      "      s << \"$\"\n"
      "        << \"message\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_method:\n"
      "      s << \"$\"\n"
      "        << \"method\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_mod:\n"
      "      s << \"$\"\n"
      "        << \"mod\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_modifier:\n"
      "      s << \"$\"\n"
      "        << \"modifier\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_nonterminal:\n"
      "      s << \"$\"\n"
      "        << \"nonterminal\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_not:\n"
      "      s << \"$\"\n"
      "        << \"not\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_on:\n"
      "      s << \"$\"\n"
      "        << \"on\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_operator:\n"
      "      s << \"$\"\n"
      "        << \"operator\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_option:\n"
      "      s << \"$\"\n"
      "        << \"option\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_or:\n"
      "      s << \"$\"\n"
      "        << \"or\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_override:\n"
      "      s << \"$\"\n"
      "        << \"override\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_parse:\n"
      "      s << \"$\"\n"
      "        << \"parse\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_project:\n"
      "      s << \"$\"\n"
      "        << \"project\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_program:\n"
      "      s << \"$\"\n"
      "        << \"program\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_reader:\n"
      "      s << \"$\"\n"
      "        << \"reader\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_remove:\n"
      "      s << \"$\"\n"
      "        << \"remove\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_replace:\n"
      "      s << \"$\"\n"
      "        << \"replace\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_repeat:\n"
      "      s << \"$\"\n"
      "        << \"repeat\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_rewind:\n"
      "      s << \"$\"\n"
      "        << \"rewind\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_root:\n"
      "      s << \"$\"\n"
      "        << \"root\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_routine:\n"
      "      s << \"$\"\n"
      "        << \"routine\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_rule:\n"
      "      s << \"$\"\n"
      "        << \"rule\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_search:\n"
      "      s << \"$\"\n"
      "        << \"search\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_select:\n"
      "      s << \"$\"\n"
      "        << \"select\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_self:\n"
      "      s << \"$\"\n"
      "        << \"self\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_semantics:\n"
      "      s << \"$\"\n"
      "        << \"semantics\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_send:\n"
      "      s << \"$\"\n"
      "        << \"send\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_sortedlist:\n"
      "      s << \"$\"\n"
      "        << \"sortedlist\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_state:\n"
      "      s << \"$\"\n"
      "        << \"state\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_struct:\n"
      "      s << \"$\"\n"
      "        << \"struct\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_style:\n"
      "      s << \"$\"\n"
      "        << \"style\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_switch:\n"
      "      s << \"$\"\n"
      "        << \"switch\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_syntax:\n"
      "      s << \"$\"\n"
      "        << \"syntax\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_tag:\n"
      "      s << \"$\"\n"
      "        << \"tag\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_template:\n"
      "      s << \"$\"\n"
      "        << \"template\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_then:\n"
      "      s << \"$\"\n"
      "        << \"then\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_true:\n"
      "      s << \"$\"\n"
      "        << \"true\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_unused:\n"
      "      s << \"$\"\n"
      "        << \"unused\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_warning:\n"
      "      s << \"$\"\n"
      "        << \"warning\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_when:\n"
      "      s << \"$\"\n"
      "        << \"when\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_while:\n"
      "      s << \"$\"\n"
      "        << \"while\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_with:\n"
      "      s << \"$\"\n"
      "        << \"with\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_literal_5F_double:\n"
      "      s << \"$\"\n"
      "        << \"literal_double\"\n"
      "        << \"$\" ;\n"
      "      s << \" \" ;\n"
      "      s.appendDouble (ptr->floatValue) ;\n"
      "    s << \" \" ;\n"
      "    s.appendCLiteralStringConstant (ptr->tokenString) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_unsigned_5F_literal_5F_integer:\n"
      "      s << \"$\"\n"
      "        << \"unsigned_literal_integer\"\n"
      "        << \"$\" ;\n"
      "      s << \" \" ;\n"
      "      s.appendUnsigned (ptr->uint32value) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_signed_5F_literal_5F_integer:\n"
      "      s << \"$\"\n"
      "        << \"signed_literal_integer\"\n"
      "        << \"$\" ;\n"
      "      s << \" \" ;\n"
      "      s.appendSigned (ptr->sint32value) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_unsigned_5F_literal_5F_integer_36__34_:\n"
      "      s << \"$\"\n"
      "        << \"unsigned_literal_integer64\"\n"
      "        << \"$\" ;\n"
      "      s << \" \" ;\n"
      "      s.appendUnsigned64 (ptr->uint64value) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_signed_5F_literal_5F_integer_36__34_:\n"
      "      s << \"$\"\n"
      "        << \"signed_literal_integer64\"\n"
      "        << \"$\" ;\n"
      "      s << \" \" ;\n"
      "      s.appendSigned64 (ptr->sint64value) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2E_:\n"
      "      s << \"$\"\n"
      "        << \".\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2E__3D_:\n"
      "      s << \"$\"\n"
      "        << \".=\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2E__2E__2E_:\n"
      "      s << \"$\"\n"
      "        << \"...\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_type_5F_name:\n"
      "      s << \"$\"\n"
      "        << \"type_name\"\n"
      "        << \"$\" ;\n"
      "    s << \" \" ;\n"
      "    s.appendCLiteralStringConstant (ptr->tokenString) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_literal_5F_char:\n"
      "      s << \"$\"\n"
      "        << \"literal_char\"\n"
      "        << \"$\" ;\n"
      "    s << \" \" ;\n"
      "    s.appendCLiteralCharConstant (ptr->charValue) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_terminal:\n"
      "      s << \"$\"\n"
      "        << \"terminal\"\n"
      "        << \"$\" ;\n"
      "    s << \" \" ;\n"
      "    s.appendCLiteralStringConstant (ptr->tokenString) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2A_:\n"
      "      s << \"$\"\n"
      "        << \"*\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__7C_:\n"
      "      s << \"$\"\n"
      "        << \"|\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2C_:\n"
      "      s << \"$\"\n"
      "        << \",\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2B_:\n"
      "      s << \"$\"\n"
      "        << \"+\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2D__2D_:\n"
      "      s << \"$\"\n"
      "        << \"--\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3A__3A_:\n"
      "      s << \"$\"\n"
      "        << \"::\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3E_:\n"
      "      s << \"$\"\n"
      "        << \">\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3B_:\n"
      "      s << \"$\"\n"
      "        << \";\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3A_:\n"
      "      s << \"$\"\n"
      "        << \":\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2D_:\n"
      "      s << \"$\"\n"
      "        << \"-\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__28_:\n"
      "      s << \"$\"\n"
      "        << \"(\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__29_:\n"
      "      s << \"$\"\n"
      "        << \")\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2D__3E_:\n"
      "      s << \"$\"\n"
      "        << \"->\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3F_:\n"
      "      s << \"$\"\n"
      "        << \"\\\?\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3D__3D_:\n"
      "      s << \"$\"\n"
      "        << \"==\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3F__3F_:\n"
      "      s << \"$\"\n"
      "        << \"\\\?\\\?\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__21_:\n"
      "      s << \"$\"\n"
      "        << \"!\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3A__3D_:\n"
      "      s << \"$\"\n"
      "        << \":=\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2B__2B_:\n"
      "      s << \"$\"\n"
      "        << \"++\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__5B_:\n"
      "      s << \"$\"\n"
      "        << \"[\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__5D_:\n"
      "      s << \"$\"\n"
      "        << \"]\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2B__3D_:\n"
      "      s << \"$\"\n"
      "        << \"+=\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3F__21_:\n"
      "      s << \"$\"\n"
      "        << \"\\\?!\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__21__3F_:\n"
      "      s << \"$\"\n"
      "        << \"!\\\?\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2F_:\n"
      "      s << \"$\"\n"
      "        << \"/\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__21__3D_:\n"
      "      s << \"$\"\n"
      "        << \"!=\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3E__3D_:\n"
      "      s << \"$\"\n"
      "        << \">=\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__26_:\n"
      "      s << \"$\"\n"
      "        << \"&\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__7B_:\n"
      "      s << \"$\"\n"
      "        << \"{\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__7D_:\n"
      "      s << \"$\"\n"
      "        << \"}\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__2D__3D_:\n"
      "      s << \"$\"\n"
      "        << \"-=\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__5E_:\n"
      "      s << \"$\"\n"
      "        << \"^\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3E__3E_:\n"
      "      s << \"$\"\n"
      "        << \">>\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__7E_:\n"
      "      s << \"$\"\n"
      "        << \"~\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3C__2D_:\n"
      "      s << \"$\"\n"
      "        << \"<-\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3C_:\n"
      "      s << \"$\"\n"
      "        << \"<\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3C__2D__3E_:\n"
      "      s << \"$\"\n"
      "        << \"<->\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3C__3D_:\n"
      "      s << \"$\"\n"
      "        << \"<=\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1__3C__3C_:\n"
      "      s << \"$\"\n"
      "        << \"<<\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_non_5F_terminal_5F_symbol:\n"
      "      s << \"$\"\n"
      "        << \"non_terminal_symbol\"\n"
      "        << \"$\" ;\n"
      "    s << \" \" ;\n"
      "    s.appendCLiteralStringConstant (ptr->tokenString) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_literal_5F_string:\n"
      "      s << \"$\"\n"
      "        << \"literal_string\"\n"
      "        << \"$\" ;\n"
      "    s << \" \" ;\n"
      "    s.appendCLiteralStringConstant (ptr->tokenString) ;\n"
      "      break;\n"
      "    case  " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_comment:\n"
      "      s << \"$\"\n"
      "        << \"comment\"\n"
      "        << \"$\" ;\n"
      "      break;\n"
      "    default:\n"
      "      break ;\n"
      "    }\n"
      "  }\n"
      "  return s ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                      U N I C O D E    S T R I N G S                       *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "//--- Unicode string for '!'\n"
      "static const utf32 kUnicodeString__21_ [] = {\n"
      "  TO_UNICODE ('!'),\n"
      "  TO_UNICODE (0)\n"
      "} ; \n"
      "\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "//                                                                           *\n"
      "//                            parseLexicalToken                              *\n"
      "//                                                                           *\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "bool " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::\n"
      "parseLexicalToken (void) {\n"
      "  cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " token ;\n"
      "  bool loop = true ;\n"
      "  token.mTokenCode = -1 ;\n"
      "  while ((token.mTokenCode < 0) && (UNICODE_VALUE (mCurrentChar) != '\\0')) {\n"
      "    token.identifierString.setLengthToZero () ;\n"
      "    token.uint32value = 0 ;\n"
      "    token.sint32value = 0 ;\n"
      "    token.uint64value = 0 ;\n"
      "    token.sint64value = 0 ;\n"
      "    token.charValue = TO_UNICODE ('\\0') ;\n"
      "    token.tokenString.setLengthToZero () ;\n"
      "    token.floatValue = 0.0 ;\n"
      "    mTokenFirstLocation = mCurrentLocation ;\n"
      "    try{\n"
      "      if (testForInputUTF32CharRange (TO_UNICODE ('a'), TO_UNICODE ('z')) ||\n"
      "          testForInputUTF32CharRange (TO_UNICODE ('A'), TO_UNICODE ('Z'))) {\n"
      "        do {\n"
      "          ::scanner_routine_enterCharacterIntoString (*this, token.identifierString, ::scanner_function_toLower (*this, previousChar ())) ;\n"
      "          ::scanner_routine_enterCharacterIntoString (*this, token.tokenString, previousChar ()) ;\n"
      "          if (testForInputUTF32CharRange (TO_UNICODE ('a'), TO_UNICODE ('z')) ||\n"
      "              testForInputUTF32CharRange (TO_UNICODE ('A'), TO_UNICODE ('Z')) ||\n"
      "              testForInputUTF32Char (TO_UNICODE ('_')) ||\n"
      "              testForInputUTF32CharRange (TO_UNICODE ('0'), TO_UNICODE ('9'))) {\n"
      "          }else{\n"
      "            loop = false ;\n"
      "          }\n"
      "        }while (loop) ;\n"
      "        loop = true ;\n"
      "        token.mTokenCode = search_into_galgasKeyWordList (token.identifierString) ;\n"
      "        if (token.mTokenCode == -1) {\n"
      "          token.mTokenCode = " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_identifier ;\n"
      "        }\n"
      "        enterToken (token) ;\n"
      "      }else if (testForInputUTF32String (kUnicodeString__30_x, 2, true)) {\n"
      "      }else if (testForInputUTF32CharRange (TO_UNICODE (1), TO_UNICODE (' '))) {\n"
      "      }else if (testForInputUTF32Char (TO_UNICODE ('\\0'))) { // End of source text \? \n"
      "        token.mTokenCode = " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "_1_ ; // Empty string code\n"
      "      }else{ // Unknown input character\n"
      "        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;\n"
      "      }\n"
      "    }catch (const C_lexicalErrorException &) {\n"
      "      token.mTokenCode = -1 ; // No token\n"
      "      advance () ; // ... go throught unknown character\n"
      "    }\n"
      "  }\n"
      "  if ((UNICODE_VALUE (mCurrentChar) == '\\0') && (token.mTemplateStringBeforeToken.length () > 0)) {\n"
      "    token.mTokenCode = 0 ;\n"
      "    enterToken (token) ;\n"
      "  }\n"
      "  return token.mTokenCode > 0 ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "void " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::enterToken (const cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " & inToken) {\n"
      "  cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " * ptr = NULL ;\n"
      "  macroMyNew (ptr, cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " ()) ;\n"
      "  ptr->mTokenCode = inToken.mTokenCode ;\n"
      "  ptr->mFirstLocation = mTokenFirstLocation ;\n"
      "  ptr->mLastLocation  = mTokenLastLocation ;\n"
      "  ptr->mTemplateStringBeforeToken  = inToken.mTemplateStringBeforeToken ;\n"
      "  ptr->identifierString = inToken.identifierString ;\n"
      "  ptr->uint32value = inToken.uint32value ;\n"
      "  ptr->sint32value = inToken.sint32value ;\n"
      "  ptr->uint64value = inToken.uint64value ;\n"
      "  ptr->sint64value = inToken.sint64value ;\n"
      "  ptr->charValue = inToken.charValue ;\n"
      "  ptr->tokenString = inToken.tokenString ;\n"
      "  ptr->floatValue = inToken.floatValue ;\n"
      "  enterTokenFromPointer (ptr) ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "void " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::\n"
      "assignFromAttribute_identifierString (GGS_lstring & outValue) const {\n"
      "  cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " * ptr = (cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " *) mCurrentTokenPtr ;\n"
      "  outValue = GGS_lstring (* this, ptr->identifierString) ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n"
      "\n"
      "C_String " ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << "::\n"
      "attributeValue_identifierString (void) const {\n"
      "  cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " * ptr = (cTokenFor_" ;
    result << var_cas_LEXIQUE_CLASS_NAME ;
    result << " *) mCurrentTokenPtr ;\n"
      "  return ptr->identifierString ;\n"
      "}\n"
      "\n"
      "//---------------------------------------------------------------------------*\n" ;
  }
  return GGS_string (isBuilt, result) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@lexicalSendDefaultAction.checkLexicalDefaultAction'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction> gDispatchTableFor__lexicalSendDefaultAction__checkLexicalDefaultAction ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction (typeCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__lexicalSendDefaultAction__checkLexicalDefaultAction.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction
findCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__lexicalSendDefaultAction__checkLexicalDefaultAction.count ()) {
    result = gDispatchTableFor__lexicalSendDefaultAction__checkLexicalDefaultAction (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction (superClassPtr) ;
      gDispatchTableFor__lexicalSendDefaultAction__checkLexicalDefaultAction.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalSendTerminalByDefault.checkLexicalDefaultAction'  *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalSendTerminalByDefault__checkLexicalDefaultAction (C_Compiler & inLexique,
                                const cPtr_lexicalSendTerminalByDefault * operand_3108,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_3108 != NULL) {
    GGS_lexicalTypeList  automatic_var_0 ;
    const GGS_terminalMap  _temp_3216 = var_cas_ioLexiqueAnalysisContext.reader_mTerminalMap (inLexique COMMA_SOURCE_FILE_AT_LINE (62)) ;
    if (_temp_3216.isBuilt ()) {
      _temp_3216 (HERE)->method_searchKey (inLexique, operand_3108->mDefaultSentTerminal, automatic_var_0 COMMA_SOURCE_FILE_AT_LINE (62)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@lexicalErrorByDefault.checkLexicalDefaultAction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalErrorByDefault__checkLexicalDefaultAction (C_Compiler & inLexique,
                                const cPtr_lexicalErrorByDefault * operand_3402,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_3402 != NULL) {
    elementOf_GGS_lexicalMessageMap * operand_3517 = (elementOf_GGS_lexicalMessageMap *) var_cas_ioLexiqueAnalysisContext.mLexicalMessageMap.searchForWithInstruction (inLexique, operand_3402->mDefaultErrorMessageName, GGS_lexicalMessageMap::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (70)) ;
    if (NULL != operand_3517) {
      operand_3517->mInfo.mMessageIsUsed = GGS_bool (true) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@lexicalExpression.checkLexicalExpression'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__lexicalExpression__checkLexicalExpression> gDispatchTableFor__lexicalExpression__checkLexicalExpression ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__lexicalExpression__checkLexicalExpression (typeCategoryMethod__lexicalExpression__checkLexicalExpression inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__lexicalExpression__checkLexicalExpression.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__lexicalExpression__checkLexicalExpression
findCategoryMethod__lexicalExpression__checkLexicalExpression (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__lexicalExpression__checkLexicalExpression result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__lexicalExpression__checkLexicalExpression.count ()) {
    result = gDispatchTableFor__lexicalExpression__checkLexicalExpression (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__lexicalExpression__checkLexicalExpression (superClassPtr) ;
      gDispatchTableFor__lexicalExpression__checkLexicalExpression.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@lexicalOrExpression.checkLexicalExpression'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalOrExpression__checkLexicalExpression (C_Compiler & inLexique,
                                const cPtr_lexicalOrExpression * operand_4111,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4111 != NULL) {
    const GGS_lexicalExpression  _temp_4205 = operand_4111->mLeftOperand ;
    if (_temp_4205.isBuilt ()) {
      typeCategoryMethod__lexicalExpression__checkLexicalExpression _method = findCategoryMethod__lexicalExpression__checkLexicalExpression (_temp_4205._galgasObjectRunTimeInfo ()) ;
      if (_method != NULL) {
        _method (inLexique, _temp_4205 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (88)) ;
      }
    }
    const GGS_lexicalExpression  _temp_4276 = operand_4111->mRightOperand ;
    if (_temp_4276.isBuilt ()) {
      typeCategoryMethod__lexicalExpression__checkLexicalExpression _method = findCategoryMethod__lexicalExpression__checkLexicalExpression (_temp_4276._galgasObjectRunTimeInfo ()) ;
      if (_method != NULL) {
        _method (inLexique, _temp_4276 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (89)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@lexicalCharacterMatch.checkLexicalExpression'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalCharacterMatch__checkLexicalExpression (C_Compiler &,
                                const cPtr_lexicalCharacterMatch * operand_4462,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4462 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@lexicalCharacterSetMatch.checkLexicalExpression'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalCharacterSetMatch__checkLexicalExpression (C_Compiler &,
                                const cPtr_lexicalCharacterSetMatch * operand_4682,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4682 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Category method '@lexicalCharacterIntervalMatch.checkLexicalExpression'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalCharacterIntervalMatch__checkLexicalExpression (C_Compiler &,
                                const cPtr_lexicalCharacterIntervalMatch * operand_4907,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4907 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Category method '@lexicalStringMatch.checkLexicalExpression'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalStringMatch__checkLexicalExpression (C_Compiler &,
                                const cPtr_lexicalStringMatch * operand_5121,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_5121 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@lexicalStringNotMatch.checkLexicalExpression'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalStringNotMatch__checkLexicalExpression (C_Compiler & inLexique,
                                const cPtr_lexicalStringNotMatch * operand_5338,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_5338 != NULL) {
    elementOf_GGS_lexicalMessageMap * operand_5446 = (elementOf_GGS_lexicalMessageMap *) var_cas_ioLexiqueAnalysisContext.mLexicalMessageMap.searchForWithInstruction (inLexique, operand_5338->mErrorMessage, GGS_lexicalMessageMap::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (125)) ;
    if (NULL != operand_5446) {
      operand_5446->mInfo.mMessageIsUsed = GGS_bool (true) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@lexicalRoutineOrFunctionFormalInputArgument.checkLexicalFunctionCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument> gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument (typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument
findCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument.count ()) {
    result = gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument (superClassPtr) ;
      gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalAttributeInputArgument.checkLexicalFunctionCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalAttributeInputArgument__checkLexicalFunctionCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalAttributeInputArgument * operand_6143,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_6143 != NULL) {
    GGS_lexicalTypeEnum var_cas_attributeLexicalType ;
    const GGS_lexicalAttributeMap  _temp_6388 = var_cas_ioLexiqueAnalysisContext.reader_mLexicalAttributeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (147)) ;
    if (_temp_6388.isBuilt ()) {
      _temp_6388 (HERE)->method_searchKey (inLexique, operand_6143->mAttributeName, var_cas_attributeLexicalType COMMA_SOURCE_FILE_AT_LINE (147)) ;
    }
    if (((var_cas_attributeLexicalType).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_6143->mAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("type error, attribute type is ")).operator_concat (var_cas_attributeLexicalType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (154)))).operator_concat (GGS_string (" type, but lexical routine prototype requires "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (156)))).operator_concat (GGS_string (" type")) COMMA_SOURCE_FILE_AT_LINE (158)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalCharacterInputArgument.checkLexicalFunctionCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalCharacterInputArgument__checkLexicalFunctionCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalCharacterInputArgument * operand_6942,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_6942 != NULL) {
    if (((GGS_lexicalTypeEnum::constructor_lexicalType_char (inLexique COMMA_HERE)).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_6942->mCharacter.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("type error, a literal character has @char")).operator_concat (GGS_string (" type, but lexical routine prototype requires an "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (171)))).operator_concat (GGS_string (" type value")) COMMA_SOURCE_FILE_AT_LINE (173)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalUnsignedInputArgument.checkLexicalFunctionCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalUnsignedInputArgument__checkLexicalFunctionCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalUnsignedInputArgument * operand_7546,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_7546 != NULL) {
    if (((GGS_lexicalTypeEnum::constructor_lexicalType_uint (inLexique COMMA_HERE)).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_7546->mUnsigned.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("type error, a literal character has @uint")).operator_concat (GGS_string (" type, but lexical routine prototype requires an "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (186)))).operator_concat (GGS_string (" type value")) COMMA_SOURCE_FILE_AT_LINE (188)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalCurrentCharacterInputArgument.checkLexicalFunctionCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalCurrentCharacterInputArgument__checkLexicalFunctionCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalCurrentCharacterInputArgument * operand_8157,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8157 != NULL) {
    if (((GGS_lexicalTypeEnum::constructor_lexicalType_char (inLexique COMMA_HERE)).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_8157->mLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("type error, current character value has @char")).operator_concat (GGS_string (" type, but lexical routine prototype requires an "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (201)))).operator_concat (GGS_string (" type value")) COMMA_SOURCE_FILE_AT_LINE (203)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalFunctionInputArgument.checkLexicalFunctionCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalFunctionInputArgument__checkLexicalFunctionCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalFunctionInputArgument * operand_8764,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_8764 != NULL) {
    GGS_lexicalFunctionFormalArgumentList  var_cas_lexicalFormalTypeList ;
    GGS_lexicalTypeEnum var_cas_returnedLexicalFormalType ;
    GGS_string var_cas_replacementFunctionName ;
    const GGS_lexicalFunctionMap  _temp_9110 = var_cas_ioLexiqueAnalysisContext.reader_mLexicalFunctionMap (inLexique COMMA_SOURCE_FILE_AT_LINE (216)) ;
    if (_temp_9110.isBuilt ()) {
      _temp_9110 (HERE)->method_searchKey (inLexique, operand_8764->mFunctionName, var_cas_lexicalFormalTypeList, var_cas_returnedLexicalFormalType, var_cas_replacementFunctionName COMMA_SOURCE_FILE_AT_LINE (216)) ;
    }
    if (((var_cas_replacementFunctionName).operator_isNotEqual (GGS_string (""))).isBuiltAndTrue ()) {
      operand_8764->mFunctionName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((GGS_string ("obsolete lexical function, replaced by '")).operator_concat (var_cas_replacementFunctionName)).operator_concat (GGS_string ("'")) COMMA_SOURCE_FILE_AT_LINE (224)) ;
    }
    if (((var_cas_returnedLexicalFormalType).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_8764->mFunctionName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("type error, the function returns an ")).operator_concat (var_cas_returnedLexicalFormalType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (229)))).operator_concat (GGS_string (" value, but lexical routine prototype requires an "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (231)))).operator_concat (GGS_string (" value")) COMMA_SOURCE_FILE_AT_LINE (233)) ;
    }
    if (((var_cas_lexicalFormalTypeList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (235))).operator_isNotEqual (operand_8764->mFunctionActualArgumentList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (235)))).isBuiltAndTrue ()) {
      operand_8764->mFunctionName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this lexical function names ")).operator_concat (operand_8764->mFunctionActualArgumentList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (237)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (237)))).operator_concat (GGS_string (" actual argument(s), but the prototype requires "))).operator_concat (var_cas_lexicalFormalTypeList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (239)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (239)))).operator_concat (GGS_string (" actual argument(s)")) COMMA_SOURCE_FILE_AT_LINE (240)) ;
    }
    {
      GGS_lexicalFunctionFormalArgumentList::cEnumerator enumerator_10206 (var_cas_lexicalFormalTypeList, true) ;
      const GGS_lexicalFunctionFormalArgumentList::cElement * operand_10206 = NULL ;
      GGS_lexicalFunctionCallActualArgumentList::cEnumerator enumerator_10235 (operand_8764->mFunctionActualArgumentList, true) ;
      const GGS_lexicalFunctionCallActualArgumentList::cElement * operand_10235 = NULL ;
      while (((operand_10206 = enumerator_10206.nextObject ()))
          && ((operand_10235 = enumerator_10235.nextObject ()))) {
        macroValidPointer (operand_10206) ;
        macroValidPointer (operand_10235) ;
        const GGS_lexicalRoutineOrFunctionFormalInputArgument  _temp_10304 = operand_10235->mLexicalActualInputArgument ;
        if (_temp_10304.isBuilt ()) {
          typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument _method = findCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument (_temp_10304._galgasObjectRunTimeInfo ()) ;
          if (_method != NULL) {
            _method (inLexique, _temp_10304 (HERE), var_cas_ioLexiqueAnalysisContext, operand_10206->mLexicalType COMMA_SOURCE_FILE_AT_LINE (243)) ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@lexicalRoutineOrFunctionFormalInputArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument> gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument (typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument
findCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument.count ()) {
    result = gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument (superClassPtr) ;
      gDispatchTableFor__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalAttributeInputArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalAttributeInputArgument__checkLexicalRoutineCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalAttributeInputArgument * operand_11006,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11006 != NULL) {
    GGS_lexicalTypeEnum var_cas_attributeLexicalType ;
    const GGS_lexicalAttributeMap  _temp_11251 = var_cas_ioLexiqueAnalysisContext.reader_mLexicalAttributeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (267)) ;
    if (_temp_11251.isBuilt ()) {
      _temp_11251 (HERE)->method_searchKey (inLexique, operand_11006->mAttributeName, var_cas_attributeLexicalType COMMA_SOURCE_FILE_AT_LINE (267)) ;
    }
    if (((var_cas_attributeLexicalType).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_11006->mAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("type error, attribute type is ")).operator_concat (var_cas_attributeLexicalType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (274)))).operator_concat (GGS_string (" type, but lexical routine prototype requires "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (276)))).operator_concat (GGS_string (" type")) COMMA_SOURCE_FILE_AT_LINE (278)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalCharacterInputArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalCharacterInputArgument__checkLexicalRoutineCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalCharacterInputArgument * operand_11804,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_11804 != NULL) {
    if (((GGS_lexicalTypeEnum::constructor_lexicalType_char (inLexique COMMA_HERE)).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_11804->mCharacter.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("type error, a literal character has @char")).operator_concat (GGS_string (" type, but lexical routine prototype requires an "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (291)))).operator_concat (GGS_string (" type value")) COMMA_SOURCE_FILE_AT_LINE (293)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalUnsignedInputArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalUnsignedInputArgument__checkLexicalRoutineCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalUnsignedInputArgument * operand_12407,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_12407 != NULL) {
    if (((GGS_lexicalTypeEnum::constructor_lexicalType_uint (inLexique COMMA_HERE)).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_12407->mUnsigned.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("type error, a literal unsigned value has @uint")).operator_concat (GGS_string (" type, but lexical routine prototype requires an "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (306)))).operator_concat (GGS_string (" type value")) COMMA_SOURCE_FILE_AT_LINE (308)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalCurrentCharacterInputArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalCurrentCharacterInputArgument__checkLexicalRoutineCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalCurrentCharacterInputArgument * operand_13022,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13022 != NULL) {
    if (((GGS_lexicalTypeEnum::constructor_lexicalType_char (inLexique COMMA_HERE)).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_13022->mLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, (((GGS_string ("type error, current character value has @char")).operator_concat (GGS_string (" type, but lexical routine prototype requires an "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (321)))).operator_concat (GGS_string (" type value")) COMMA_SOURCE_FILE_AT_LINE (323)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalFunctionInputArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalFunctionInputArgument__checkLexicalRoutineCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalFunctionInputArgument * operand_13628,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_13628 != NULL) {
    GGS_lexicalFunctionFormalArgumentList  var_cas_lexicalFormalTypeList ;
    GGS_lexicalTypeEnum var_cas_returnedLexicalFormalType ;
    GGS_string var_cas_replacementFunctionName ;
    const GGS_lexicalFunctionMap  _temp_13974 = var_cas_ioLexiqueAnalysisContext.reader_mLexicalFunctionMap (inLexique COMMA_SOURCE_FILE_AT_LINE (336)) ;
    if (_temp_13974.isBuilt ()) {
      _temp_13974 (HERE)->method_searchKey (inLexique, operand_13628->mFunctionName, var_cas_lexicalFormalTypeList, var_cas_returnedLexicalFormalType, var_cas_replacementFunctionName COMMA_SOURCE_FILE_AT_LINE (336)) ;
    }
    if (((var_cas_replacementFunctionName).operator_isNotEqual (GGS_string (""))).isBuiltAndTrue ()) {
      operand_13628->mFunctionName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((GGS_string ("obsolete lexical function, replaced by '")).operator_concat (var_cas_replacementFunctionName)).operator_concat (GGS_string ("'")) COMMA_SOURCE_FILE_AT_LINE (344)) ;
    }
    if (((var_cas_returnedLexicalFormalType).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_13628->mFunctionName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("type error, the function returns an ")).operator_concat (var_cas_returnedLexicalFormalType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (349)))).operator_concat (GGS_string (" value, but lexical routine prototype requires an "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (351)))).operator_concat (GGS_string (" value")) COMMA_SOURCE_FILE_AT_LINE (353)) ;
    }
    if (((var_cas_lexicalFormalTypeList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (355))).operator_isNotEqual (operand_13628->mFunctionActualArgumentList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (355)))).isBuiltAndTrue ()) {
      operand_13628->mFunctionName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this lexical function names ")).operator_concat (operand_13628->mFunctionActualArgumentList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (357)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (357)))).operator_concat (GGS_string (" actual argument(s), but the prototype requires "))).operator_concat (var_cas_lexicalFormalTypeList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (359)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (359)))).operator_concat (GGS_string (" actual argument(s)")) COMMA_SOURCE_FILE_AT_LINE (360)) ;
    }
    {
      GGS_lexicalFunctionFormalArgumentList::cEnumerator enumerator_15070 (var_cas_lexicalFormalTypeList, true) ;
      const GGS_lexicalFunctionFormalArgumentList::cElement * operand_15070 = NULL ;
      GGS_lexicalFunctionCallActualArgumentList::cEnumerator enumerator_15099 (operand_13628->mFunctionActualArgumentList, true) ;
      const GGS_lexicalFunctionCallActualArgumentList::cElement * operand_15099 = NULL ;
      while (((operand_15070 = enumerator_15070.nextObject ()))
          && ((operand_15099 = enumerator_15099.nextObject ()))) {
        macroValidPointer (operand_15070) ;
        macroValidPointer (operand_15099) ;
        const GGS_lexicalRoutineOrFunctionFormalInputArgument  _temp_15168 = operand_15099->mLexicalActualInputArgument ;
        if (_temp_15168.isBuilt ()) {
          typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument _method = findCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument (_temp_15168._galgasObjectRunTimeInfo ()) ;
          if (_method != NULL) {
            _method (inLexique, _temp_15168 (HERE), var_cas_ioLexiqueAnalysisContext, operand_15070->mLexicalType COMMA_SOURCE_FILE_AT_LINE (363)) ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@abstractLexicalRoutineActualArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument> gDispatchTableFor__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument (typeCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument
findCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument.count ()) {
    result = gDispatchTableFor__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument (superClassPtr) ;
      gDispatchTableFor__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalAttributeInputOutputArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalAttributeInputOutputArgument__checkLexicalRoutineCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalAttributeInputOutputArgument * operand_15935,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext,
                                GGS_lexicalArgumentMode  var_cas_inLexicalRoutineFormalArgumentMode,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_15935 != NULL) {
    GGS_lexicalTypeEnum var_cas_attributeLexicalType ;
    const GGS_lexicalAttributeMap  _temp_16239 = var_cas_ioLexiqueAnalysisContext.reader_mLexicalAttributeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (389)) ;
    if (_temp_16239.isBuilt ()) {
      _temp_16239 (HERE)->method_searchKey (inLexique, operand_15935->mAttributeName, var_cas_attributeLexicalType COMMA_SOURCE_FILE_AT_LINE (389)) ;
    }
    if (((var_cas_attributeLexicalType).operator_isNotEqual (var_cas_inLexicalRoutineFormalArgumentType)).isBuiltAndTrue ()) {
      operand_15935->mAttributeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("type error, attribute type is ")).operator_concat (var_cas_attributeLexicalType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (396)))).operator_concat (GGS_string (" type, but lexical routine prototype requires "))).operator_concat (var_cas_inLexicalRoutineFormalArgumentType.reader_lexicalTypeName (inLexique COMMA_SOURCE_FILE_AT_LINE (398)))).operator_concat (GGS_string (" type")) COMMA_SOURCE_FILE_AT_LINE (400)) ;
    }
    if (((var_cas_inLexicalRoutineFormalArgumentMode).operator_isNotEqual (GGS_lexicalArgumentMode::constructor_lexicalInputOutputMode (inLexique COMMA_HERE))).isBuiltAndTrue ()) {
      operand_15935->mActualPassingModeLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the output mode (!) is required here, not an output/input mode") COMMA_SOURCE_FILE_AT_LINE (404)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalFormalInputArgument.checkLexicalRoutineCallArgument'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalFormalInputArgument__checkLexicalRoutineCallArgument (C_Compiler & inLexique,
                                const cPtr_lexicalFormalInputArgument * operand_17022,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext,
                                GGS_lexicalArgumentMode  var_cas_inLexicalRoutineFormalArgumentMode,
                                GGS_lexicalTypeEnum  var_cas_inLexicalRoutineFormalArgumentType
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_17022 != NULL) {
    GGS_lexicalTypeEnum var_cas_attributeLexicalType ;
    const GGS_lexicalRoutineOrFunctionFormalInputArgument  _temp_17338 = operand_17022->mRoutineOrFunctionFormalInputArgument ;
    if (_temp_17338.isBuilt ()) {
      typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument _method = findCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument (_temp_17338._galgasObjectRunTimeInfo ()) ;
      if (_method != NULL) {
        _method (inLexique, _temp_17338 (HERE), var_cas_ioLexiqueAnalysisContext, var_cas_inLexicalRoutineFormalArgumentType COMMA_SOURCE_FILE_AT_LINE (416)) ;
      }
    }
    if (((var_cas_inLexicalRoutineFormalArgumentMode).operator_isNotEqual (GGS_lexicalArgumentMode::constructor_lexicalInputMode (inLexique COMMA_HERE))).isBuiltAndTrue ()) {
      operand_17022->mActualPassingModeLocation.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, GGS_string ("the output/input mode (!\?) is required here, not an input mode") COMMA_SOURCE_FILE_AT_LINE (423)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@lexicalInstruction.checkLexicalInstruction'*
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__lexicalInstruction__checkLexicalInstruction> gDispatchTableFor__lexicalInstruction__checkLexicalInstruction ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__lexicalInstruction__checkLexicalInstruction (typeCategoryMethod__lexicalInstruction__checkLexicalInstruction inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__lexicalInstruction__checkLexicalInstruction.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__lexicalInstruction__checkLexicalInstruction
findCategoryMethod__lexicalInstruction__checkLexicalInstruction (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__lexicalInstruction__checkLexicalInstruction result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__lexicalInstruction__checkLexicalInstruction.count ()) {
    result = gDispatchTableFor__lexicalInstruction__checkLexicalInstruction (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__lexicalInstruction__checkLexicalInstruction (superClassPtr) ;
      gDispatchTableFor__lexicalInstruction__checkLexicalInstruction.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//Category method '@lexicalStructuredSendInstruction.checkLexicalInstruction'*
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalStructuredSendInstruction__checkLexicalInstruction (C_Compiler & inLexique,
                                const cPtr_lexicalStructuredSendInstruction * operand_18167,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_18167 != NULL) {
    {
      GGS_lexicalSendSearchList::cEnumerator enumerator_18255 (operand_18167->mLexicalSendSearchList, true) ;
      const GGS_lexicalSendSearchList::cElement * operand_18255 = NULL ;
      while (((operand_18255 = enumerator_18255.nextObject ()))) {
        macroValidPointer (operand_18255) ;
        GGS_lexicalTypeEnum automatic_var_1 ;
        const GGS_lexicalAttributeMap  _temp_18321 = var_cas_ioLexiqueAnalysisContext.reader_mLexicalAttributeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (440)) ;
        if (_temp_18321.isBuilt ()) {
          _temp_18321 (HERE)->method_searchKey (inLexique, operand_18255->mAttributeName, automatic_var_1 COMMA_SOURCE_FILE_AT_LINE (440)) ;
        }
      }
    }
    const GGS_lexicalSendDefaultAction  _temp_18414 = operand_18167->mLexicalSendDefaultAction ;
    if (_temp_18414.isBuilt ()) {
      typeCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction _method = findCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction (_temp_18414._galgasObjectRunTimeInfo ()) ;
      if (_method != NULL) {
        _method (inLexique, _temp_18414 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (442)) ;
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
// Category method '@lexicalSimpleSendInstruction.checkLexicalInstruction'   *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalSimpleSendInstruction__checkLexicalInstruction (C_Compiler & inLexique,
                                const cPtr_lexicalSimpleSendInstruction * operand_18607,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_18607 != NULL) {
    GGS_lexicalTypeList  automatic_var_2 ;
    const GGS_terminalMap  _temp_18715 = var_cas_ioLexiqueAnalysisContext.reader_mTerminalMap (inLexique COMMA_SOURCE_FILE_AT_LINE (450)) ;
    if (_temp_18715.isBuilt ()) {
      _temp_18715 (HERE)->method_searchKey (inLexique, operand_18607->mSentTerminal, automatic_var_2 COMMA_SOURCE_FILE_AT_LINE (450)) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@lexicalRepeatInstruction.checkLexicalInstruction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalRepeatInstruction__checkLexicalInstruction (C_Compiler & inLexique,
                                const cPtr_lexicalRepeatInstruction * operand_18895,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_18895 != NULL) {
    {
      GGS_lexicalWhileBranchList::cEnumerator enumerator_18984 (operand_18895->mLexicalWhileBranchList, true) ;
      const GGS_lexicalWhileBranchList::cElement * operand_18984 = NULL ;
      while (((operand_18984 = enumerator_18984.nextObject ()))) {
        macroValidPointer (operand_18984) ;
        const GGS_lexicalExpression  _temp_19032 = operand_18984->mWhileExpression ;
        if (_temp_19032.isBuilt ()) {
          typeCategoryMethod__lexicalExpression__checkLexicalExpression _method = findCategoryMethod__lexicalExpression__checkLexicalExpression (_temp_19032._galgasObjectRunTimeInfo ()) ;
          if (_method != NULL) {
            _method (inLexique, _temp_19032 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (459)) ;
          }
        }
        {
          GGS_lexicalInstructionList::cEnumerator enumerator_19097 (operand_18984->mWhileInstructionList, true) ;
          const GGS_lexicalInstructionList::cElement * operand_19097 = NULL ;
          while (((operand_19097 = enumerator_19097.nextObject ()))) {
            macroValidPointer (operand_19097) ;
            const GGS_lexicalInstruction  _temp_19144 = operand_19097->mInstruction ;
            if (_temp_19144.isBuilt ()) {
              typeCategoryMethod__lexicalInstruction__checkLexicalInstruction _method = findCategoryMethod__lexicalInstruction__checkLexicalInstruction (_temp_19144._galgasObjectRunTimeInfo ()) ;
              if (_method != NULL) {
                _method (inLexique, _temp_19144 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (461)) ;
              }
            }
          }
        }
      }
    }
    {
      GGS_lexicalInstructionList::cEnumerator enumerator_19244 (operand_18895->mRepeatedInstructionList, true) ;
      const GGS_lexicalInstructionList::cElement * operand_19244 = NULL ;
      while (((operand_19244 = enumerator_19244.nextObject ()))) {
        macroValidPointer (operand_19244) ;
        const GGS_lexicalInstruction  _temp_19289 = operand_19244->mInstruction ;
        if (_temp_19289.isBuilt ()) {
          typeCategoryMethod__lexicalInstruction__checkLexicalInstruction _method = findCategoryMethod__lexicalInstruction__checkLexicalInstruction (_temp_19289._galgasObjectRunTimeInfo ()) ;
          if (_method != NULL) {
            _method (inLexique, _temp_19289 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (465)) ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@lexicalSelectInstruction.checkLexicalInstruction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalSelectInstruction__checkLexicalInstruction (C_Compiler & inLexique,
                                const cPtr_lexicalSelectInstruction * operand_19495,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_19495 != NULL) {
    {
      GGS_lexicalSelectBranchList::cEnumerator enumerator_19585 (operand_19495->mLexicalSelectBranchList, true) ;
      const GGS_lexicalSelectBranchList::cElement * operand_19585 = NULL ;
      while (((operand_19585 = enumerator_19585.nextObject ()))) {
        macroValidPointer (operand_19585) ;
        {
          GGS_lexicalInstructionList::cEnumerator enumerator_19623 (operand_19585->mSelectInstructionList, true) ;
          const GGS_lexicalInstructionList::cElement * operand_19623 = NULL ;
          while (((operand_19623 = enumerator_19623.nextObject ()))) {
            macroValidPointer (operand_19623) ;
            const GGS_lexicalInstruction  _temp_19670 = operand_19623->mInstruction ;
            if (_temp_19670.isBuilt ()) {
              typeCategoryMethod__lexicalInstruction__checkLexicalInstruction _method = findCategoryMethod__lexicalInstruction__checkLexicalInstruction (_temp_19670._galgasObjectRunTimeInfo ()) ;
              if (_method != NULL) {
                _method (inLexique, _temp_19670 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (476)) ;
              }
            }
          }
        }
      }
    }
    {
      GGS_lexicalInstructionList::cEnumerator enumerator_19769 (operand_19495->mDefaultInstructionList, true) ;
      const GGS_lexicalInstructionList::cElement * operand_19769 = NULL ;
      while (((operand_19769 = enumerator_19769.nextObject ()))) {
        macroValidPointer (operand_19769) ;
        const GGS_lexicalInstruction  _temp_19814 = operand_19769->mInstruction ;
        if (_temp_19814.isBuilt ()) {
          typeCategoryMethod__lexicalInstruction__checkLexicalInstruction _method = findCategoryMethod__lexicalInstruction__checkLexicalInstruction (_temp_19814._galgasObjectRunTimeInfo ()) ;
          if (_method != NULL) {
            _method (inLexique, _temp_19814 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (480)) ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@lexicalRoutineInstruction.checkLexicalInstruction'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalRoutineInstruction__checkLexicalInstruction (C_Compiler & inLexique,
                                const cPtr_lexicalRoutineInstruction * operand_20021,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_20021 != NULL) {
    GGS_lexicalRoutineFormalArgumentList  var_cas_lexicalRoutineFormalArgumentList ;
    GGS_stringlist  var_cas_routineErrorMessageList ;
    GGS_string var_cas_replacementRoutineName ;
    const GGS_lexicalRoutineMap  _temp_20288 = var_cas_ioLexiqueAnalysisContext.reader_mLexicalRoutineMessageMap (inLexique COMMA_SOURCE_FILE_AT_LINE (492)) ;
    if (_temp_20288.isBuilt ()) {
      _temp_20288 (HERE)->method_searchKey (inLexique, operand_20021->mRoutineName, var_cas_lexicalRoutineFormalArgumentList, var_cas_routineErrorMessageList, var_cas_replacementRoutineName COMMA_SOURCE_FILE_AT_LINE (492)) ;
    }
    if (((var_cas_replacementRoutineName).operator_isNotEqual (GGS_string (""))).isBuiltAndTrue ()) {
      operand_20021->mRoutineName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((GGS_string ("obsolete lexical routine, replaced by '")).operator_concat (var_cas_replacementRoutineName)).operator_concat (GGS_string ("'")) COMMA_SOURCE_FILE_AT_LINE (500)) ;
    }
    if (((var_cas_lexicalRoutineFormalArgumentList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (503))).operator_isNotEqual (operand_20021->mActualArgumentList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (503)))).isBuiltAndTrue ()) {
      operand_20021->mRoutineName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this lexical routine call names ")).operator_concat (operand_20021->mActualArgumentList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (505)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (505)))).operator_concat (GGS_string (" actual argument(s), but the lexical routine prototype requires "))).operator_concat (var_cas_lexicalRoutineFormalArgumentList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (507)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (507)))).operator_concat (GGS_string (" actual argument(s)")) COMMA_SOURCE_FILE_AT_LINE (508)) ;
    }
    {
      GGS_lexicalRoutineFormalArgumentList::cEnumerator enumerator_21064 (var_cas_lexicalRoutineFormalArgumentList, true) ;
      const GGS_lexicalRoutineFormalArgumentList::cElement * operand_21064 = NULL ;
      GGS_lexicalRoutineCallActualArgumentList::cEnumerator enumerator_21085 (operand_20021->mActualArgumentList, true) ;
      const GGS_lexicalRoutineCallActualArgumentList::cElement * operand_21085 = NULL ;
      while (((operand_21064 = enumerator_21064.nextObject ()))
          && ((operand_21085 = enumerator_21085.nextObject ()))) {
        macroValidPointer (operand_21064) ;
        macroValidPointer (operand_21085) ;
        const GGS_abstractLexicalRoutineActualArgument  _temp_21155 = operand_21085->mLexicalRoutineActualArgument ;
        if (_temp_21155.isBuilt ()) {
          typeCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument _method = findCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument (_temp_21155._galgasObjectRunTimeInfo ()) ;
          if (_method != NULL) {
            _method (inLexique, _temp_21155 (HERE), var_cas_ioLexiqueAnalysisContext, operand_21064->mLexicalFormalArgumentMode, operand_21064->mLexicalFormalArgumentType COMMA_SOURCE_FILE_AT_LINE (511)) ;
          }
        }
      }
    }
    if (((var_cas_routineErrorMessageList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (518))).operator_isNotEqual (operand_20021->mErrorMessageList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (518)))).isBuiltAndTrue ()) {
      operand_20021->mRoutineName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, ((((GGS_string ("this lexical routine call names ")).operator_concat (operand_20021->mErrorMessageList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (520)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (520)))).operator_concat (GGS_string (" error message(s), but the lexical routine prototype requires "))).operator_concat (var_cas_routineErrorMessageList.reader_length (inLexique COMMA_SOURCE_FILE_AT_LINE (522)).reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (522)))).operator_concat (GGS_string (" error message(s)")) COMMA_SOURCE_FILE_AT_LINE (523)) ;
    }
    {
      GGS_lstringlist::cEnumerator enumerator_21714 (operand_20021->mErrorMessageList, true) ;
      const GGS_lstringlist::cElement * operand_21714 = NULL ;
      while (((operand_21714 = enumerator_21714.nextObject ()))) {
        macroValidPointer (operand_21714) ;
        elementOf_GGS_lexicalMessageMap * operand_21779 = (elementOf_GGS_lexicalMessageMap *) var_cas_ioLexiqueAnalysisContext.mLexicalMessageMap.searchForWithInstruction (inLexique, operand_21714->mValue, GGS_lexicalMessageMap::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (526)) ;
        if (NULL != operand_21779) {
          operand_21779->mInfo.mMessageIsUsed = GGS_bool (true) ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@lexicalLogInstruction.checkLexicalInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalLogInstruction__checkLexicalInstruction (C_Compiler &,
                                const cPtr_lexicalLogInstruction * operand_22022,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22022 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@lexicalRewindInstruction.checkLexicalInstruction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalRewindInstruction__checkLexicalInstruction (C_Compiler &,
                                const cPtr_lexicalRewindInstruction * operand_22243,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22243 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@lexicalDropInstruction.checkLexicalInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalDropInstruction__checkLexicalInstruction (C_Compiler &,
                                const cPtr_lexicalDropInstruction * operand_22462,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22462 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@lexicalTagInstruction.checkLexicalInstruction'      *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalTagInstruction__checkLexicalInstruction (C_Compiler &,
                                const cPtr_lexicalTagInstruction * operand_22680,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22680 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Category method '@lexicalErrorInstruction.checkLexicalInstruction'     *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalErrorInstruction__checkLexicalInstruction (C_Compiler & inLexique,
                                const cPtr_lexicalErrorInstruction * operand_22900,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_22900 != NULL) {
    elementOf_GGS_lexicalMessageMap * operand_23008 = (elementOf_GGS_lexicalMessageMap *) var_cas_ioLexiqueAnalysisContext.mLexicalMessageMap.searchForWithInstruction (inLexique, operand_22900->mErrorMessageName, GGS_lexicalMessageMap::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (565)) ;
    if (NULL != operand_23008) {
      operand_23008->mInfo.mMessageIsUsed = GGS_bool (true) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Category method '@lexicalWarningInstruction.checkLexicalInstruction'    *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalWarningInstruction__checkLexicalInstruction (C_Compiler & inLexique,
                                const cPtr_lexicalWarningInstruction * operand_23242,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_23242 != NULL) {
    elementOf_GGS_lexicalMessageMap * operand_23350 = (elementOf_GGS_lexicalMessageMap *) var_cas_ioLexiqueAnalysisContext.mLexicalMessageMap.searchForWithInstruction (inLexique, operand_23242->mWarningMessageName, GGS_lexicalMessageMap::kSearchMessage_searchKey COMMA_SOURCE_FILE_AT_LINE (575)) ;
    if (NULL != operand_23350) {
      operand_23350->mInfo.mMessageIsUsed = GGS_bool (true) ;
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//Virtual Table for category method '@abstractLexicalRule.checkLexicalRule'  *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryMethod__abstractLexicalRule__checkLexicalRule> gDispatchTableFor__abstractLexicalRule__checkLexicalRule ;

//---------------------------------------------------------------------------*

void
enterCategoryMethod__abstractLexicalRule__checkLexicalRule (typeCategoryMethod__abstractLexicalRule__checkLexicalRule inRoutine,
                     const sint32 inClassID) {
  gDispatchTableFor__abstractLexicalRule__checkLexicalRule.forceObjectAtIndex (inClassID, inRoutine, NULL) ;
}

//---------------------------------------------------------------------------*

typeCategoryMethod__abstractLexicalRule__checkLexicalRule
findCategoryMethod__abstractLexicalRule__checkLexicalRule (AC_galgasClassRunTimeInformation * inClassPtr) {
  typeCategoryMethod__abstractLexicalRule__checkLexicalRule result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableFor__abstractLexicalRule__checkLexicalRule.count ()) {
    result = gDispatchTableFor__abstractLexicalRule__checkLexicalRule (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformation * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryMethod__abstractLexicalRule__checkLexicalRule (superClassPtr) ;
      gDispatchTableFor__abstractLexicalRule__checkLexicalRule.forceObjectAtIndex (inClassPtr->slotID (), result, NULL) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@lexicalImplicitRule.checkLexicalRule'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalImplicitRule__checkLexicalRule (C_Compiler &,
                                const cPtr_lexicalImplicitRule * operand_23925,
                                GGS_lexiqueAnalysisContext & /* var_cas_ioLexiqueAnalysisContext */
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_23925 != NULL) {
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//         Category method '@lexicalExplicitRule.checkLexicalRule'           *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__lexicalExplicitRule__checkLexicalRule (C_Compiler & inLexique,
                                const cPtr_lexicalExplicitRule * operand_24134,
                                GGS_lexiqueAnalysisContext & var_cas_ioLexiqueAnalysisContext
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_24134 != NULL) {
    {
      GGS_lexicalInstructionList::cEnumerator enumerator_24216 (operand_24134->mInstructionList, true) ;
      const GGS_lexicalInstructionList::cElement * operand_24216 = NULL ;
      while (((operand_24216 = enumerator_24216.nextObject ()))) {
        macroValidPointer (operand_24216) ;
        const GGS_lexicalInstruction  _temp_24261 = operand_24216->mInstruction ;
        if (_temp_24261.isBuilt ()) {
          typeCategoryMethod__lexicalInstruction__checkLexicalInstruction _method = findCategoryMethod__lexicalInstruction__checkLexicalInstruction (_temp_24261._galgasObjectRunTimeInfo ()) ;
          if (_method != NULL) {
            _method (inLexique, _temp_24261 (HERE), var_cas_ioLexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (601)) ;
          }
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileLexiqueComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileLexiqueComponent (C_Compiler & inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  var_cas_inOutputDirectory COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileLexiqueComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_lexiqueComponentRoot  var_cas_lexiqueComponentRoot ;
  const GGS_string _depExtension = GGS_string ("") ;
  const GGS_string _depPath = GGS_string ("") ;
  if (_depExtension.isBuilt () && _depPath.isBuilt ()) {
    lexiqueLL1grammar::_performSourceFileParsing_ (inLexique,
                                  _depExtension.string (),
                                  _depPath.string (),
                                  NULL,
                                  var_cas_inSourceFile,
                                  var_cas_lexiqueComponentRoot
                                  COMMA_SOURCE_FILE_AT_LINE (614)) ;
  }
  GGS_lstring  var_cas_componentName ;
  var_cas_componentName = var_cas_lexiqueComponentRoot.reader_mLexiqueComponentName (inLexique COMMA_SOURCE_FILE_AT_LINE (616)) ;
  GGS_string var_cas_basename ;
  var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (inLexique COMMA_SOURCE_FILE_AT_LINE (617)).reader_stringByDeletingPathExtension (inLexique COMMA_SOURCE_FILE_AT_LINE (617)) ;
  if (((var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (618))).operator_isNotEqual (var_cas_basename)).isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, ((((GGS_string ("GALGAS checks "
      "the component name ('")).operator_concat (var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (620)))).operator_concat (GGS_string ("') against the source file base name ('"))).operator_concat (var_cas_basename)).operator_concat (GGS_string ("'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (622)) ;
  }
  GGS_lexicalTypeMap  var_cas_lexicalTypeMap ;
  var_cas_lexicalTypeMap = GGS_lexicalTypeMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  var_cas_lexicalTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_HERE), GGS_lexicalTypeEnum::constructor_lexicalType_string (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (626)) ;
  var_cas_lexicalTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("char"), GGS_location (inLexique) COMMA_HERE), GGS_lexicalTypeEnum::constructor_lexicalType_char (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (627)) ;
  var_cas_lexicalTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint"), GGS_location (inLexique) COMMA_HERE), GGS_lexicalTypeEnum::constructor_lexicalType_uint (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (628)) ;
  var_cas_lexicalTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("uint64"), GGS_location (inLexique) COMMA_HERE), GGS_lexicalTypeEnum::constructor_lexicalType_uint64 (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (629)) ;
  var_cas_lexicalTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint"), GGS_location (inLexique) COMMA_HERE), GGS_lexicalTypeEnum::constructor_lexicalType_sint (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (630)) ;
  var_cas_lexicalTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("sint64"), GGS_location (inLexique) COMMA_HERE), GGS_lexicalTypeEnum::constructor_lexicalType_sint64 (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (631)) ;
  var_cas_lexicalTypeMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("double"), GGS_location (inLexique) COMMA_HERE), GGS_lexicalTypeEnum::constructor_lexicalType_double (inLexique COMMA_HERE) COMMA_SOURCE_FILE_AT_LINE (632)) ;
  GGS_lexicalRoutineMap  var_cas_lexicalRoutineMap ;
  ::routine_buildLexicalRoutineMap (inLexique,  var_cas_lexicalRoutineMap COMMA_SOURCE_FILE_AT_LINE (635)) ;
  GGS_lexicalFunctionMap  var_cas_lexicalFunctionMap ;
  ::routine_buildLexicalFunctionMap (inLexique,  var_cas_lexicalFunctionMap COMMA_SOURCE_FILE_AT_LINE (638)) ;
  GGS_lexiqueAnalysisContext var_cas_lexiqueAnalysisContext ;
  var_cas_lexiqueAnalysisContext = GGS_lexiqueAnalysisContext::constructor_new (var_cas_lexicalRoutineMap, var_cas_lexicalFunctionMap, GGS_lexicalMessageMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_terminalMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_terminalList ::constructor_emptyList (), GGS_lexicalAttributeMap ::constructor_emptyMap (inLexique COMMA_HERE), GGS_lexicalExplicitTokenListMapMap ::constructor_emptyMap (inLexique COMMA_HERE)) ;
  {
    GGS_lexicalAttributeList::cEnumerator enumerator_26764 (var_cas_lexiqueComponentRoot.reader_mLexicalAttributeList (inLexique COMMA_SOURCE_FILE_AT_LINE (649)), true) ;
    const GGS_lexicalAttributeList::cElement * operand_26764 = NULL ;
    while (((operand_26764 = enumerator_26764.nextObject ()))) {
      macroValidPointer (operand_26764) ;
      if ((var_cas_lexicalTypeMap.reader_hasKey (inLexique, operand_26764->mTypeName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (650)) COMMA_SOURCE_FILE_AT_LINE (650))).isBuiltAndTrue ()) {
        GGS_lexicalTypeEnum var_cas_lexicalType ;
        const GGS_lexicalTypeMap  _temp_26935 = var_cas_lexicalTypeMap ;
        if (_temp_26935.isBuilt ()) {
          _temp_26935 (HERE)->method_searchKey (inLexique, operand_26764->mTypeName, var_cas_lexicalType COMMA_SOURCE_FILE_AT_LINE (652)) ;
        }
        var_cas_lexiqueAnalysisContext.mLexicalAttributeMap.modifier_insertKey (inLexique, operand_26764->mName, var_cas_lexicalType COMMA_SOURCE_FILE_AT_LINE (653)) ;
      }else{
        GGS_string var_cas_m ;
        var_cas_m = GGS_string ("") ;
        var_cas_m.appendCString ("the @") ;
        var_cas_m.dotAssign_operation (operand_26764->mTypeName) ;
        var_cas_m.appendCString (" type is not a valid lexical attribute type; are allowed:") ;
        GGS_bool var_cas_firstLoop ;
        var_cas_firstLoop = GGS_bool (true) ;
        {
          GGS_lexicalTypeMap::cEnumerator enumerator_27237 (var_cas_lexicalTypeMap, true) ;
          const GGS_lexicalTypeMap::cElement * operand_27237 = enumerator_27237.nextObject () ;
          if ((operand_27237 != NULL)) {
            bool _foreach_loop_27237 ;
            do{
              macroValidPointer (operand_27237) ;
              var_cas_m.appendCString (" @") ;
              var_cas_m.dotAssign_operation (operand_27237->mKey) ;
              operand_27237 = enumerator_27237.nextObject () ;
              _foreach_loop_27237 = ((operand_27237 != NULL)) ;
              if (_foreach_loop_27237) {
                var_cas_m.appendCString (",") ;
              }
            }while (_foreach_loop_27237) ;
          }
        }
        operand_26764->mTypeName.reader_location (inLexique COMMA_HERE).signalGGSSemanticError (inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (664)) ;
      }
    }
  }
  {
    GGS_terminalDeclarationList::cEnumerator enumerator_27447 (var_cas_lexiqueComponentRoot.reader_mTerminalDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (667)), true) ;
    const GGS_terminalDeclarationList::cElement * operand_27447 = NULL ;
    while (((operand_27447 = enumerator_27447.nextObject ()))) {
      macroValidPointer (operand_27447) ;
      GGS_lexicalTypeList  var_cas_argumentTypeList ;
      var_cas_argumentTypeList = GGS_lexicalTypeList ::constructor_emptyList () ;
      {
        GGS_lstringlist::cEnumerator enumerator_27579 (operand_27447->mSentAttributeList, true) ;
        const GGS_lstringlist::cElement * operand_27579 = NULL ;
        while (((operand_27579 = enumerator_27579.nextObject ()))) {
          macroValidPointer (operand_27579) ;
          GGS_lexicalTypeEnum var_cas_attributeLexicalType ;
          const GGS_lexicalAttributeMap  _temp_27718 = var_cas_lexiqueAnalysisContext.reader_mLexicalAttributeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (671)) ;
          if (_temp_27718.isBuilt ()) {
            _temp_27718 (HERE)->method_searchKey (inLexique, operand_27579->mValue, var_cas_attributeLexicalType COMMA_SOURCE_FILE_AT_LINE (671)) ;
          }
          var_cas_argumentTypeList._addAssign_operation (var_cas_attributeLexicalType) ;
        }
      }
      var_cas_lexiqueAnalysisContext.mTerminalMap.modifier_insertKey (inLexique, operand_27447->mName, var_cas_argumentTypeList COMMA_SOURCE_FILE_AT_LINE (674)) ;
      var_cas_lexiqueAnalysisContext.mTerminalList._addAssign_operation (operand_27447->mName, var_cas_argumentTypeList) ;
    }
  }
  {
    GGS_lexicalListDeclarationList::cEnumerator enumerator_28007 (var_cas_lexiqueComponentRoot.reader_mLexicalListDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (677)), true) ;
    const GGS_lexicalListDeclarationList::cElement * operand_28007 = NULL ;
    while (((operand_28007 = enumerator_28007.nextObject ()))) {
      macroValidPointer (operand_28007) ;
      GGS_lexicalTypeList  var_cas_argumentTypeList ;
      var_cas_argumentTypeList = GGS_lexicalTypeList ::constructor_emptyList () ;
      {
        GGS_lstringlist::cEnumerator enumerator_28142 (operand_28007->mSentAttributeList, true) ;
        const GGS_lstringlist::cElement * operand_28142 = NULL ;
        while (((operand_28142 = enumerator_28142.nextObject ()))) {
          macroValidPointer (operand_28142) ;
          GGS_lexicalTypeEnum var_cas_attributeLexicalType ;
          const GGS_lexicalAttributeMap  _temp_28280 = var_cas_lexiqueAnalysisContext.reader_mLexicalAttributeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (681)) ;
          if (_temp_28280.isBuilt ()) {
            _temp_28280 (HERE)->method_searchKey (inLexique, operand_28142->mValue, var_cas_attributeLexicalType COMMA_SOURCE_FILE_AT_LINE (681)) ;
          }
          var_cas_argumentTypeList._addAssign_operation (var_cas_attributeLexicalType) ;
        }
      }
      GGS_lexicalExplicitTokenListMap  var_cas_lexicalTokenListMap ;
      var_cas_lexicalTokenListMap = GGS_lexicalExplicitTokenListMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
      {
        GGS_lexicalListEntryList::cEnumerator enumerator_28478 (operand_28007->mEntryList, true) ;
        const GGS_lexicalListEntryList::cElement * operand_28478 = NULL ;
        while (((operand_28478 = enumerator_28478.nextObject ()))) {
          macroValidPointer (operand_28478) ;
          var_cas_lexiqueAnalysisContext.mTerminalList._addAssign_operation (operand_28478->mTerminalSpelling, var_cas_argumentTypeList) ;
          var_cas_lexiqueAnalysisContext.mTerminalMap.modifier_insertKey (inLexique, operand_28478->mTerminalSpelling, var_cas_argumentTypeList COMMA_SOURCE_FILE_AT_LINE (687)) ;
          var_cas_lexicalTokenListMap.modifier_insertKey (inLexique, operand_28478->mEntrySpelling, operand_28478->mTerminalSpelling, operand_28478->mFeatureList COMMA_SOURCE_FILE_AT_LINE (688)) ;
        }
      }
      var_cas_lexiqueAnalysisContext.mLexicalTokenListMapMap.modifier_insertKey (inLexique, operand_28007->mName, var_cas_lexicalTokenListMap COMMA_SOURCE_FILE_AT_LINE (690)) ;
    }
  }
  {
    GGS_lexicalMessageDeclarationList::cEnumerator enumerator_28952 (var_cas_lexiqueComponentRoot.reader_mLexicalMessageDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (693)), true) ;
    const GGS_lexicalMessageDeclarationList::cElement * operand_28952 = NULL ;
    while (((operand_28952 = enumerator_28952.nextObject ()))) {
      macroValidPointer (operand_28952) ;
      var_cas_lexiqueAnalysisContext.mLexicalMessageMap.modifier_insertKey (inLexique, operand_28952->mMessageName, operand_28952->mMessageValue, GGS_bool (false) COMMA_SOURCE_FILE_AT_LINE (694)) ;
    }
  }
  {
    GGS_lexicalRuleList::cEnumerator enumerator_29186 (var_cas_lexiqueComponentRoot.reader_mLexicalRuleList (inLexique COMMA_SOURCE_FILE_AT_LINE (697)), true) ;
    const GGS_lexicalRuleList::cElement * operand_29186 = NULL ;
    while (((operand_29186 = enumerator_29186.nextObject ()))) {
      macroValidPointer (operand_29186) ;
      const GGS_abstractLexicalRule  _temp_29262 = operand_29186->mLexicalRule ;
      if (_temp_29262.isBuilt ()) {
        typeCategoryMethod__abstractLexicalRule__checkLexicalRule _method = findCategoryMethod__abstractLexicalRule__checkLexicalRule (_temp_29262._galgasObjectRunTimeInfo ()) ;
        if (_method != NULL) {
          _method (inLexique, _temp_29262 (HERE), var_cas_lexiqueAnalysisContext COMMA_SOURCE_FILE_AT_LINE (698)) ;
        }
      }
    }
  }
  {
    GGS_lexicalMessageMap::cEnumerator enumerator_29384 (var_cas_lexiqueAnalysisContext.reader_mLexicalMessageMap (inLexique COMMA_SOURCE_FILE_AT_LINE (701)), true) ;
    const GGS_lexicalMessageMap::cElement * operand_29384 = NULL ;
    while (((operand_29384 = enumerator_29384.nextObject ()))) {
      macroValidPointer (operand_29384) ;
      if (((operand_29384->mInfo.mMessageIsUsed).operator_not ()).isBuiltAndTrue ()) {
        operand_29384->mKey.reader_location (inLexique COMMA_HERE).signalGGSSemanticWarning (inLexique, GGS_string ("unused message") COMMA_SOURCE_FILE_AT_LINE (703)) ;
      }
    }
  }
  GGS_string var_cas_lexiqueClassName ;
  var_cas_lexiqueClassName = var_cas_componentName.reader_string (inLexique COMMA_SOURCE_FILE_AT_LINE (707)) ;
  if (((GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U))).isBuiltAndTrue ()) {
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_lexiqueClassName).operator_concat (GGS_string (".h")), GGS_string ("//"), GGS_string ("\n"
      "\n"), template_filewrapper_lexiqueGenerationTemplates_headerZone2 (inLexique, var_cas_lexiqueClassName, var_cas_lexiqueAnalysisContext.reader_mLexicalAttributeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (717))), GGS_string ("\n"
      "\n"), template_filewrapper_lexiqueGenerationTemplates_headerZone3 (inLexique, var_cas_lexiqueClassName, var_cas_lexiqueAnalysisContext.reader_mTerminalList (inLexique COMMA_SOURCE_FILE_AT_LINE (722)), var_cas_lexiqueComponentRoot.reader_mLexicalListDeclarationList (inLexique COMMA_SOURCE_FILE_AT_LINE (723))) COMMA_SOURCE_FILE_AT_LINE (710)) ;
  }
  if (((GGS_uint ::constructor_errorCount (inLexique COMMA_HERE)).operator_isEqual (GGS_uint (0U))).isBuiltAndTrue ()) {
    GGS_string::class_method_generateFile (inLexique, var_cas_inOutputDirectory, (var_cas_lexiqueClassName).operator_concat (GGS_string (".cpp")), GGS_string ("//"), GGS_string ("\n"
      "\n"), template_filewrapper_lexiqueGenerationTemplates_implementationZone2 (inLexique, var_cas_lexiqueClassName, var_cas_lexiqueAnalysisContext.reader_mLexicalAttributeMap (inLexique COMMA_SOURCE_FILE_AT_LINE (736))), GGS_string ("\n"
      "\n"), GGS_string ("\n"
      "\n") COMMA_SOURCE_FILE_AT_LINE (729)) ;
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileLexiqueComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_lexiqueCompilation (void) {
 enterCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction ((typeCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction) category_method__lexicalSendTerminalByDefault__checkLexicalDefaultAction, gClassInfoFor__lexicalSendTerminalByDefault.slotID ()) ;
 enterCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction ((typeCategoryMethod__lexicalSendDefaultAction__checkLexicalDefaultAction) category_method__lexicalErrorByDefault__checkLexicalDefaultAction, gClassInfoFor__lexicalErrorByDefault.slotID ()) ;
 enterCategoryMethod__lexicalExpression__checkLexicalExpression ((typeCategoryMethod__lexicalExpression__checkLexicalExpression) category_method__lexicalOrExpression__checkLexicalExpression, gClassInfoFor__lexicalOrExpression.slotID ()) ;
 enterCategoryMethod__lexicalExpression__checkLexicalExpression ((typeCategoryMethod__lexicalExpression__checkLexicalExpression) category_method__lexicalCharacterMatch__checkLexicalExpression, gClassInfoFor__lexicalCharacterMatch.slotID ()) ;
 enterCategoryMethod__lexicalExpression__checkLexicalExpression ((typeCategoryMethod__lexicalExpression__checkLexicalExpression) category_method__lexicalCharacterSetMatch__checkLexicalExpression, gClassInfoFor__lexicalCharacterSetMatch.slotID ()) ;
 enterCategoryMethod__lexicalExpression__checkLexicalExpression ((typeCategoryMethod__lexicalExpression__checkLexicalExpression) category_method__lexicalCharacterIntervalMatch__checkLexicalExpression, gClassInfoFor__lexicalCharacterIntervalMatch.slotID ()) ;
 enterCategoryMethod__lexicalExpression__checkLexicalExpression ((typeCategoryMethod__lexicalExpression__checkLexicalExpression) category_method__lexicalStringMatch__checkLexicalExpression, gClassInfoFor__lexicalStringMatch.slotID ()) ;
 enterCategoryMethod__lexicalExpression__checkLexicalExpression ((typeCategoryMethod__lexicalExpression__checkLexicalExpression) category_method__lexicalStringNotMatch__checkLexicalExpression, gClassInfoFor__lexicalStringNotMatch.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument) category_method__lexicalAttributeInputArgument__checkLexicalFunctionCallArgument, gClassInfoFor__lexicalAttributeInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument) category_method__lexicalCharacterInputArgument__checkLexicalFunctionCallArgument, gClassInfoFor__lexicalCharacterInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument) category_method__lexicalUnsignedInputArgument__checkLexicalFunctionCallArgument, gClassInfoFor__lexicalUnsignedInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument) category_method__lexicalCurrentCharacterInputArgument__checkLexicalFunctionCallArgument, gClassInfoFor__lexicalCurrentCharacterInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalFunctionCallArgument) category_method__lexicalFunctionInputArgument__checkLexicalFunctionCallArgument, gClassInfoFor__lexicalFunctionInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument) category_method__lexicalAttributeInputArgument__checkLexicalRoutineCallArgument, gClassInfoFor__lexicalAttributeInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument) category_method__lexicalCharacterInputArgument__checkLexicalRoutineCallArgument, gClassInfoFor__lexicalCharacterInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument) category_method__lexicalUnsignedInputArgument__checkLexicalRoutineCallArgument, gClassInfoFor__lexicalUnsignedInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument) category_method__lexicalCurrentCharacterInputArgument__checkLexicalRoutineCallArgument, gClassInfoFor__lexicalCurrentCharacterInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument ((typeCategoryMethod__lexicalRoutineOrFunctionFormalInputArgument__checkLexicalRoutineCallArgument) category_method__lexicalFunctionInputArgument__checkLexicalRoutineCallArgument, gClassInfoFor__lexicalFunctionInputArgument.slotID ()) ;
 enterCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument ((typeCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument) category_method__lexicalAttributeInputOutputArgument__checkLexicalRoutineCallArgument, gClassInfoFor__lexicalAttributeInputOutputArgument.slotID ()) ;
 enterCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument ((typeCategoryMethod__abstractLexicalRoutineActualArgument__checkLexicalRoutineCallArgument) category_method__lexicalFormalInputArgument__checkLexicalRoutineCallArgument, gClassInfoFor__lexicalFormalInputArgument.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalStructuredSendInstruction__checkLexicalInstruction, gClassInfoFor__lexicalStructuredSendInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalSimpleSendInstruction__checkLexicalInstruction, gClassInfoFor__lexicalSimpleSendInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalRepeatInstruction__checkLexicalInstruction, gClassInfoFor__lexicalRepeatInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalSelectInstruction__checkLexicalInstruction, gClassInfoFor__lexicalSelectInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalRoutineInstruction__checkLexicalInstruction, gClassInfoFor__lexicalRoutineInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalLogInstruction__checkLexicalInstruction, gClassInfoFor__lexicalLogInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalRewindInstruction__checkLexicalInstruction, gClassInfoFor__lexicalRewindInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalDropInstruction__checkLexicalInstruction, gClassInfoFor__lexicalDropInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalTagInstruction__checkLexicalInstruction, gClassInfoFor__lexicalTagInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalErrorInstruction__checkLexicalInstruction, gClassInfoFor__lexicalErrorInstruction.slotID ()) ;
 enterCategoryMethod__lexicalInstruction__checkLexicalInstruction ((typeCategoryMethod__lexicalInstruction__checkLexicalInstruction) category_method__lexicalWarningInstruction__checkLexicalInstruction, gClassInfoFor__lexicalWarningInstruction.slotID ()) ;
 enterCategoryMethod__abstractLexicalRule__checkLexicalRule ((typeCategoryMethod__abstractLexicalRule__checkLexicalRule) category_method__lexicalImplicitRule__checkLexicalRule, gClassInfoFor__lexicalImplicitRule.slotID ()) ;
 enterCategoryMethod__abstractLexicalRule__checkLexicalRule ((typeCategoryMethod__abstractLexicalRule__checkLexicalRule) category_method__lexicalExplicitRule__checkLexicalRule, gClassInfoFor__lexicalExplicitRule.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogueAction prologueEpilogueObjectFor_lexiqueCompilation (prologueRoutineFor_lexiqueCompilation,
                                   NULL) ;

//---------------------------------------------------------------------------*

