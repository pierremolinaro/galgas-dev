//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'lexiqueCompilation.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      june 25th, 2008, at 21h55'25"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "lexiqueCompilation.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "lexiqueCompilation.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Include directives generated by grammar includes              *
//                                                                           *
//---------------------------------------------------------------------------*

#include "lexiqueLL1grammar.h"

//--- START OF USER ZONE 2

//---------------------------------------------------------------------------*

//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//           Implementation of routine "compileLexiqueComponent"             *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_compileLexiqueComponent (C_Compiler & _inLexique,
                                const GGS_lstring   var_cas_inSourceFile,
                                const GGS_string  /* var_cas_inOutputDirectory */ COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_compileLexiqueComponent at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_lexiqueComponentRoot  var_cas_lexiqueComponentRoot ;
  lexiqueLL1grammar::_performSourceFileParsing_ (_inLexique,
                                  NULL,
                                  var_cas_inSourceFile,
                                  var_cas_lexiqueComponentRoot
                                  COMMA_SOURCE_FILE_AT_LINE (33)) ;
  GGS_lstring  var_cas_componentName ;
  var_cas_componentName = var_cas_lexiqueComponentRoot.reader_mLexiqueComponentName (_inLexique COMMA_SOURCE_FILE_AT_LINE (35)) ;
  GGS_string var_cas_basename ;
  var_cas_basename = var_cas_inSourceFile.ggs_string ().reader_lastPathComponent (_inLexique COMMA_SOURCE_FILE_AT_LINE (36)).reader_stringByDeletingPathExtension (_inLexique COMMA_SOURCE_FILE_AT_LINE (36)) ;
  if (((var_cas_componentName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (37)))._operator_isNotEqual (var_cas_basename)).isBuiltAndTrue ()) {
    var_cas_componentName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, ((((GGS_string (true, "GALGAS checks "
      "the component name ('"))._operator_concat (var_cas_componentName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (39))))._operator_concat (GGS_string (true, "') against the source file base name ('")))._operator_concat (var_cas_basename))._operator_concat (GGS_string (true, "'): they should be identical")) COMMA_SOURCE_FILE_AT_LINE (40)) ;
  }
  GGS_stringset  var_cas_allowedLexicalTypeNameSet ;
  var_cas_allowedLexicalTypeNameSet = GGS_stringset ::constructor_emptySet () ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lstring")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lchar")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "luint")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "luint64")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lsint")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "lsint64")) ;
  var_cas_allowedLexicalTypeNameSet._addAssign_operation (GGS_string (true, "ldouble")) ;
  GGS_lexicalAttributeMap  var_cas_lexicalAttributeMap ;
  var_cas_lexicalAttributeMap = GGS_lexicalAttributeMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  {
    GGS_lexicalAttributeList::cEnumerator enumerator_2866 (var_cas_lexiqueComponentRoot.reader_mLexicalAttributeList (_inLexique COMMA_SOURCE_FILE_AT_LINE (54)), true) ;
    const GGS_lexicalAttributeList::cElement * operand_2866 = NULL ;
    while (((operand_2866 = (GGS_lexicalAttributeList::cElement *) enumerator_2866.nextObject ()))) {
      macroValidPointer (operand_2866) ;
      if ((var_cas_allowedLexicalTypeNameSet.reader_hasKey (_inLexique, operand_2866->mTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (55)) COMMA_SOURCE_FILE_AT_LINE (55))).isBuiltAndTrue ()) {
        var_cas_lexicalAttributeMap.modifier_insertKey (_inLexique, operand_2866->mName, operand_2866->mTypeName.reader_string (_inLexique COMMA_SOURCE_FILE_AT_LINE (56)) COMMA_SOURCE_FILE_AT_LINE (56)) ;
      }else{
        GGS_string var_cas_m ;
        var_cas_m = GGS_string (true, "") ;
        var_cas_m.writeString ("the @") ;
        var_cas_m._dotAssign_operation (operand_2866->mTypeName) ;
        var_cas_m.writeString (" type is not a valid lexical attribute type; are allowed:") ;
        GGS_bool var_cas_firstLoop ;
        var_cas_firstLoop = GGS_bool (true, true) ;
        {
          GGS_stringset::cEnumerator enumerator_3224 (var_cas_allowedLexicalTypeNameSet, true) ;
          const GGS_stringset::cElement * operand_3224 = (GGS_stringset::cElement *) enumerator_3224.nextObject () ;
          if ((operand_3224 != NULL)) {
            bool _foreach_loop_3224 ;
            do{
              macroValidPointer (operand_3224) ;
              var_cas_m.writeString (" @") ;
              var_cas_m._dotAssign_operation (operand_3224->mKey) ;
              operand_3224 = enumerator_3224.nextObject () ;
              _foreach_loop_3224 = ((operand_3224 != NULL)) ;
              if (_foreach_loop_3224) {
                var_cas_m.writeString (",") ;
              }
            }while (_foreach_loop_3224) ;
          }
        }
        operand_2866->mTypeName.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, var_cas_m COMMA_SOURCE_FILE_AT_LINE (67)) ;
      }
    }
  }
  GGS_terminalMap  var_cas_terminalMap ;
  var_cas_terminalMap = GGS_terminalMap ::constructor_emptyMap (_inLexique COMMA_HERE) ;
  {
    GGS_terminalDeclarationList::cEnumerator enumerator_3494 (var_cas_lexiqueComponentRoot.reader_mTerminalDeclarationList (_inLexique COMMA_SOURCE_FILE_AT_LINE (72)), true) ;
    const GGS_terminalDeclarationList::cElement * operand_3494 = NULL ;
    while (((operand_3494 = (GGS_terminalDeclarationList::cElement *) enumerator_3494.nextObject ()))) {
      macroValidPointer (operand_3494) ;
      GGS_stringlist  var_cas_argumentTypeList ;
      var_cas_argumentTypeList = GGS_stringlist ::constructor_emptyList () ;
      {
        GGS_lstringlist::cEnumerator enumerator_3604 (operand_3494->mSentAttributeList, true) ;
        const GGS_lstringlist::cElement * operand_3604 = NULL ;
        while (((operand_3604 = (GGS_lstringlist::cElement *) enumerator_3604.nextObject ()))) {
          macroValidPointer (operand_3604) ;
          GGS_string var_cas_attributeTypeName ;
          const GGS_lexicalAttributeMap  _temp_3713 = var_cas_lexicalAttributeMap ;
          if (_temp_3713._isBuilt ()) {
            _temp_3713 (HERE)->method_searchKey (_inLexique, operand_3604->mValue, var_cas_attributeTypeName COMMA_SOURCE_FILE_AT_LINE (76)) ;
          }
          var_cas_argumentTypeList._addAssign_operation (var_cas_attributeTypeName) ;
        }
      }
      var_cas_terminalMap.modifier_insertKey (_inLexique, operand_3494->mName, var_cas_argumentTypeList COMMA_SOURCE_FILE_AT_LINE (79)) ;
    }
  }
  {
    GGS_lexicalListDeclarationList::cEnumerator enumerator_3909 (var_cas_lexiqueComponentRoot.reader_mLexicalListDeclarationList (_inLexique COMMA_SOURCE_FILE_AT_LINE (81)), true) ;
    const GGS_lexicalListDeclarationList::cElement * operand_3909 = NULL ;
    while (((operand_3909 = (GGS_lexicalListDeclarationList::cElement *) enumerator_3909.nextObject ()))) {
      macroValidPointer (operand_3909) ;
      GGS_stringlist  var_cas_argumentTypeList ;
      var_cas_argumentTypeList = GGS_stringlist ::constructor_emptyList () ;
      {
        GGS_lstringlist::cEnumerator enumerator_4022 (operand_3909->mSentAttributeList, true) ;
        const GGS_lstringlist::cElement * operand_4022 = NULL ;
        while (((operand_4022 = (GGS_lstringlist::cElement *) enumerator_4022.nextObject ()))) {
          macroValidPointer (operand_4022) ;
          GGS_string var_cas_attributeTypeName ;
          const GGS_lexicalAttributeMap  _temp_4131 = var_cas_lexicalAttributeMap ;
          if (_temp_4131._isBuilt ()) {
            _temp_4131 (HERE)->method_searchKey (_inLexique, operand_4022->mValue, var_cas_attributeTypeName COMMA_SOURCE_FILE_AT_LINE (85)) ;
          }
          var_cas_argumentTypeList._addAssign_operation (var_cas_attributeTypeName) ;
        }
      }
      {
        GGS_lexicalListEntryList::cEnumerator enumerator_4256 (operand_3909->mEntryList, true) ;
        const GGS_lexicalListEntryList::cElement * operand_4256 = NULL ;
        while (((operand_4256 = (GGS_lexicalListEntryList::cElement *) enumerator_4256.nextObject ()))) {
          macroValidPointer (operand_4256) ;
          var_cas_terminalMap.modifier_insertKey (_inLexique, operand_4256->mTerminalSpelling, var_cas_argumentTypeList COMMA_SOURCE_FILE_AT_LINE (89)) ;
        }
      }
    }
  }
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_compileLexiqueComponent\n") ;
  #endif
}

//---------------------------------------------------------------------------*

