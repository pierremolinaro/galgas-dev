//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'semanticsInstanceMethods.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 1st, 2010, at 17h57'21"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsInstanceMethods.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsInstanceMethods.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "enterInstanceMethodWithoutArgument"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithoutArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                const GGS_lstring   var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithoutArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioInstanceMethodMap.modifier_insertKey (inLexique, var_cas_inInstanceMethodName, GGS_formalParameterSignature ::constructor_emptyList (), var_cas_inInstanceMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (34)), var_cas_inHasCompilerArgument, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (36)) COMMA_SOURCE_FILE_AT_LINE (31)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithoutArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Implementation of routine "enterInstanceMethodWithInputArgument"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithInputArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                const GGS_string  var_cas_inInputArgumentTypeName,
                                const GGS_lstring   var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithInputArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMapProxy  var_cas_argumentTypeIndex ;
  GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioUnifiedTypeMap, var_cas_inInputArgumentTypeName, var_cas_argumentTypeIndex COMMA_SOURCE_FILE_AT_LINE (50)) ;
  GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (var_cas_argumentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (52))) ;
  var_cas_ioInstanceMethodMap.modifier_insertKey (inLexique, var_cas_inInstanceMethodName, var_cas_argList, var_cas_inInstanceMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (56)), var_cas_inHasCompilerArgument, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (58)) COMMA_SOURCE_FILE_AT_LINE (53)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithInputArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "enterInstanceMethodWithOutputArgument"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithOutputArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                const GGS_string  var_cas_inInputArgumentTypeName,
                                const GGS_lstring   var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithOutputArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMapProxy  var_cas_argumentTypeIndex ;
  GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioUnifiedTypeMap, var_cas_inInputArgumentTypeName, var_cas_argumentTypeIndex COMMA_SOURCE_FILE_AT_LINE (72)) ;
  GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (var_cas_argumentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (74))) ;
  var_cas_ioInstanceMethodMap.modifier_insertKey (inLexique, var_cas_inInstanceMethodName, var_cas_argList, var_cas_inInstanceMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (78)), var_cas_inHasCompilerArgument, GGS_readerQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (80)) COMMA_SOURCE_FILE_AT_LINE (75)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithOutputArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@dataPredefinedTypeAST.getInstanceMethodMap'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__dataPredefinedTypeAST__getInstanceMethodMap (C_Compiler & inLexique,
                                const cPtr_dataPredefinedTypeAST * operand_3704,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                GGS_instanceMethodMap  & var_cas_outInstanceMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_3704 != NULL) {
    var_cas_outInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (90)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToFile"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (91)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (91)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@stringPredefinedTypeAST.getInstanceMethodMap'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__stringPredefinedTypeAST__getInstanceMethodMap (C_Compiler & inLexique,
                                const cPtr_stringPredefinedTypeAST * operand_4135,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                GGS_instanceMethodMap  & var_cas_outInstanceMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4135 != NULL) {
    var_cas_outInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (100)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToFile"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (101)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (101)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToExecutableFile"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (102)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (102)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_lstring ::constructor_new (inLexique, GGS_string ("makeDirectoryAndWriteToFile"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (103)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (103)) ;
    ::routine_enterInstanceMethodWithoutArgument (inLexique,  var_cas_outInstanceMethodMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("makeDirectory"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (104)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (104)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_unifiedTypeMapProxy  var_cas_t ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioUnifiedTypeMap, GGS_string ("string"), var_cas_t COMMA_SOURCE_FILE_AT_LINE (107)) ;
    var_cas_argList.addAssign_operation (var_cas_t, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (108))) ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioUnifiedTypeMap, GGS_string ("bool"), var_cas_t COMMA_SOURCE_FILE_AT_LINE (109)) ;
    var_cas_argList.addAssign_operation (var_cas_t, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (110))) ;
    var_cas_outInstanceMethodMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToFileWhenDifferentContents"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (112)), var_cas_argList, GGS_location (inLexique), GGS_bool (true), GGS_readerQualifier::constructor_isBasic (inLexique COMMA_SOURCE_FILE_AT_LINE (116)) COMMA_SOURCE_FILE_AT_LINE (111)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticsInstanceMethods (void) {
  enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap ((typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap) category_method__dataPredefinedTypeAST__getInstanceMethodMap, gClassInfoFor__dataPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap ((typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap) category_method__stringPredefinedTypeAST__getInstanceMethodMap, gClassInfoFor__stringPredefinedTypeAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsInstanceMethods (prologueRoutineFor_semanticsInstanceMethods, NULL) ;

//---------------------------------------------------------------------------*

