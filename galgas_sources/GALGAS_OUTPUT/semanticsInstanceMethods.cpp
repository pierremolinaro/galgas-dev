//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'semanticsInstanceMethods.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     january 24th, 2010, at 16h38'33"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsInstanceMethods.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsInstanceMethods.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//            Category reader '@ACGalgasType.instanceMethodMap'              *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_modifierMap 
category_reader__ACGalgasType__instanceMethodMap (C_Compiler & inLexique,
                                const cPtr_ACGalgasType * operand_1673
                                COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap  var_cas_outModifierMap ;
  if (operand_1673 != NULL) {
    var_cas_outModifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
  }
  return var_cas_outModifierMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//   Virtual Table for category reader '@ACGalgasType.instanceMethodMap'     *
//                                                                           *
//---------------------------------------------------------------------------*

static TC_UniqueArray <typeCategoryReader__ACGalgasType__instanceMethodMap> gDispatchTableForReader__ACGalgasType__instanceMethodMap ;

//---------------------------------------------------------------------------*

void
enterCategoryReader__ACGalgasType__instanceMethodMap (typeCategoryReader__ACGalgasType__instanceMethodMap inRoutine,
                     const PMSInt32 inClassID) {
  gDispatchTableForReader__ACGalgasType__instanceMethodMap.forceObjectAtIndex (inClassID, inRoutine, NULL COMMA_HERE) ;
}

//---------------------------------------------------------------------------*

static GGS_modifierMap 
category_reader__ACGalgasType_defaultReader_instanceMethodMap (C_Compiler &,
                                const cPtr_ACGalgasType *
                                COMMA_UNUSED_LOCATION_ARGS) {
  return GGS_modifierMap  () ;
}

//---------------------------------------------------------------------------*

typeCategoryReader__ACGalgasType__instanceMethodMap
findCategoryReader__ACGalgasType__instanceMethodMap (AC_galgasClassRunTimeInformationEX * inClassPtr) {
  typeCategoryReader__ACGalgasType__instanceMethodMap result = NULL ;
  if (inClassPtr->slotID () < gDispatchTableForReader__ACGalgasType__instanceMethodMap.count ()) {
    result = gDispatchTableForReader__ACGalgasType__instanceMethodMap (inClassPtr->slotID () COMMA_HERE) ;
  }
  if (result == NULL) {
    AC_galgasClassRunTimeInformationEX * superClassPtr = inClassPtr->superClassPtr () ;
    if (superClassPtr != NULL) {
      result = findCategoryReader__ACGalgasType__instanceMethodMap (superClassPtr) ;
      gDispatchTableForReader__ACGalgasType__instanceMethodMap.forceObjectAtIndex (inClassPtr->slotID (), result, NULL COMMA_HERE) ;
    }
  }
  if (NULL == result) {
    result = category_reader__ACGalgasType_defaultReader_instanceMethodMap ;
  }
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       Implementation of once function "instanceMethodMapFor_data"         *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_modifierMap  gCachedResultForOnceFunction_instanceMethodMapFor_data ;
static bool gCacheFlagForOnceFunction_instanceMethodMapFor_data = false ;

//---------------------------------------------------------------------------*

GGS_modifierMap  function_instanceMethodMapFor_data (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_instanceMethodMapFor_data) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_instanceMethodMapFor_data at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_modifierMap  var_cas_outModifierMap ;
    var_cas_outModifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_enterModifierWithStringInputArgument (inLexique,  var_cas_outModifierMap,  GGS_string ("writeToFile"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (34)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_instanceMethodMapFor_data\n") ;
    #endif
    gCacheFlagForOnceFunction_instanceMethodMapFor_data = true ;
    gCachedResultForOnceFunction_instanceMethodMapFor_data = var_cas_outModifierMap ;
  }
  return gCachedResultForOnceFunction_instanceMethodMapFor_data ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_instanceMethodMapFor_data (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_modifierMap  result = function_instanceMethodMapFor_data (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_instanceMethodMapFor_data ("instanceMethodMapFor_data",
                              functionForGenericCall_instanceMethodMapFor_data,
                              & kTypeDescriptor_GGS_modifierMap ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//           Category reader '@dataGalgasType.instanceMethodMap'             *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_modifierMap 
category_reader__dataGalgasType__instanceMethodMap (C_Compiler & inLexique,
                                const cPtr_dataGalgasType * operand_2173
                                COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap  var_cas_outModifierMap ;
  if (operand_2173 != NULL) {
    var_cas_outModifierMap = function_instanceMethodMapFor_data (inLexique COMMA_SOURCE_FILE_AT_LINE (40)) ;
  }
  return var_cas_outModifierMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of once function "instanceMethodMapFor_string"        *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_modifierMap  gCachedResultForOnceFunction_instanceMethodMapFor_string ;
static bool gCacheFlagForOnceFunction_instanceMethodMapFor_string = false ;

//---------------------------------------------------------------------------*

GGS_modifierMap  function_instanceMethodMapFor_string (C_Compiler & inLexique COMMA_UNUSED_LOCATION_ARGS) {
  if (! gCacheFlagForOnceFunction_instanceMethodMapFor_string) {
    #ifdef DEBUG_TRACE_ENABLED
      printf ("ENTER function_instanceMethodMapFor_string at %s:%d\n", __FILE__, __LINE__) ;
    #endif
  GGS_modifierMap  var_cas_outModifierMap ;
    var_cas_outModifierMap = GGS_modifierMap ::constructor_emptyMap (inLexique COMMA_HERE) ;
    ::routine_enterModifierWithStringInputArgument (inLexique,  var_cas_outModifierMap,  GGS_string ("writeToFile"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (47)) ;
    ::routine_enterModifierWithStringInputArgument (inLexique,  var_cas_outModifierMap,  GGS_string ("writeToExecutableFile"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (48)) ;
    ::routine_enterModifierWithStringInputArgument (inLexique,  var_cas_outModifierMap,  GGS_string ("makeDirectoryAndWriteToFile"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (49)) ;
    ::routine_enterModifierWithoutArgument (inLexique,  var_cas_outModifierMap,  GGS_string ("makeDirectory"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (50)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    var_cas_argList.addAssign_operation (GGS_stringGalgasType ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentConstantIn (inLexique COMMA_HERE)) ;
    var_cas_argList.addAssign_operation (GGS_boolGalgasType ::constructor_new (inLexique COMMA_HERE), GGS_formalArgumentPassingMode::constructor_argumentOut (inLexique COMMA_HERE)) ;
    var_cas_outModifierMap.modifier_insertKey (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToFileWhenDifferentContents"), GGS_location (inLexique) COMMA_HERE), var_cas_argList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (54)) ;
    #ifdef DEBUG_TRACE_ENABLED
      printf ("LEAVE function_instanceMethodMapFor_string\n") ;
    #endif
    gCacheFlagForOnceFunction_instanceMethodMapFor_string = true ;
    gCachedResultForOnceFunction_instanceMethodMapFor_string = var_cas_outModifierMap ;
  }
  return gCachedResultForOnceFunction_instanceMethodMapFor_string ;
}

//---------------------------------------------------------------------------*

static GGS_object functionForGenericCall_instanceMethodMapFor_string (C_Compiler & inLexique,
                           const GGS_objectlist & /* inEffectiveParameterArray */,
                           const GGS_location & /* inErrorLocation */
                           COMMA_LOCATION_ARGS) {
  const GGS_modifierMap  result = function_instanceMethodMapFor_string (inLexique
                            COMMA_THERE) ;
  return result.reader_object () ;
}

//---------------------------------------------------------------------------*

const C_galgas_function_descriptorEX kFunction_descriptor_instanceMethodMapFor_string ("instanceMethodMapFor_string",
                              functionForGenericCall_instanceMethodMapFor_string,
                              & kTypeDescriptor_GGS_modifierMap ,
                              0,
                              NULL) ;

//---------------------------------------------------------------------------*
//                                                                           *
//          Category reader '@stringGalgasType.instanceMethodMap'            *
//                                                                           *
//---------------------------------------------------------------------------*

static GGS_modifierMap 
category_reader__stringGalgasType__instanceMethodMap (C_Compiler & inLexique,
                                const cPtr_stringGalgasType * operand_3279
                                COMMA_UNUSED_LOCATION_ARGS) {
  GGS_modifierMap  var_cas_outModifierMap ;
  if (operand_3279 != NULL) {
    var_cas_outModifierMap = function_instanceMethodMapFor_string (inLexique COMMA_SOURCE_FILE_AT_LINE (64)) ;
  }
  return var_cas_outModifierMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticsInstanceMethods (void) {
  enterCategoryReader__ACGalgasType__instanceMethodMap (category_reader__ACGalgasType__instanceMethodMap, gClassInfoFor__ACGalgasType.slotID ()) ;
  enterCategoryReader__ACGalgasType__instanceMethodMap ((typeCategoryReader__ACGalgasType__instanceMethodMap) category_reader__dataGalgasType__instanceMethodMap, gClassInfoFor__dataGalgasType.slotID ()) ;
  enterCategoryReader__ACGalgasType__instanceMethodMap ((typeCategoryReader__ACGalgasType__instanceMethodMap) category_reader__stringGalgasType__instanceMethodMap, gClassInfoFor__stringGalgasType.slotID ()) ;
}

//---------------------------------------------------------------------------*

static void epilogueRoutineFor_semanticsInstanceMethods (void) {
  gDispatchTableForReader__ACGalgasType__instanceMethodMap.free () ;
  gCachedResultForOnceFunction_instanceMethodMapFor_data.drop () ;
  gCachedResultForOnceFunction_instanceMethodMapFor_string.drop () ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsInstanceMethods (prologueRoutineFor_semanticsInstanceMethods, epilogueRoutineFor_semanticsInstanceMethods) ;

//---------------------------------------------------------------------------*

