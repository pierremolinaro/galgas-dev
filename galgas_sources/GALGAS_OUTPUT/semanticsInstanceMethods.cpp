//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'semanticsInstanceMethods.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      march 17th, 2010, at 19h44'5"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsInstanceMethods.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsInstanceMethods.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "enterInstanceMethodWithoutArgument"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithoutArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                const GGS_string  var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithoutArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioInstanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inInstanceMethodName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (32)), GGS_formalParameterSignature ::constructor_emptyList (), var_cas_inHasCompilerArgument COMMA_SOURCE_FILE_AT_LINE (31)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithoutArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Implementation of routine "enterInstanceMethodWithInputArgument"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithInputArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                const GGS_string  var_cas_inInputArgumentTypeName,
                                const GGS_string  var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithInputArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMapIndex  var_cas_argumentTypeIndex ;
  GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inInputArgumentTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (48)), var_cas_ioUnifiedTypeMap, var_cas_argumentTypeIndex COMMA_SOURCE_FILE_AT_LINE (48)) ;
  GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (var_cas_argumentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (50))) ;
  var_cas_ioInstanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inInstanceMethodName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (52)), var_cas_argList, var_cas_inHasCompilerArgument COMMA_SOURCE_FILE_AT_LINE (51)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithInputArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "enterInstanceMethodWithOutputArgument"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithOutputArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                const GGS_string  var_cas_inInputArgumentTypeName,
                                const GGS_string  var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithOutputArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMapIndex  var_cas_argumentTypeIndex ;
  GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inInputArgumentTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (68)), var_cas_ioUnifiedTypeMap, var_cas_argumentTypeIndex COMMA_SOURCE_FILE_AT_LINE (68)) ;
  GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (var_cas_argumentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (70))) ;
  var_cas_ioInstanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, var_cas_inInstanceMethodName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (72)), var_cas_argList, var_cas_inHasCompilerArgument COMMA_SOURCE_FILE_AT_LINE (71)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithOutputArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@dataPredefinedTypeAST.getInstanceMethodMap'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__dataPredefinedTypeAST__getInstanceMethodMap (C_Compiler & inLexique,
                                const cPtr_dataPredefinedTypeAST * operand_3622,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                GGS_instanceMethodMap  & var_cas_outInstanceMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_3622 != NULL) {
    var_cas_outInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (84)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_string ("writeToFile"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (85)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@stringPredefinedTypeAST.getInstanceMethodMap'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__stringPredefinedTypeAST__getInstanceMethodMap (C_Compiler & inLexique,
                                const cPtr_stringPredefinedTypeAST * operand_4031,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                GGS_instanceMethodMap  & var_cas_outInstanceMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4031 != NULL) {
    var_cas_outInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (94)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_string ("writeToFile"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (95)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_string ("writeToExecutableFile"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (96)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_string ("makeDirectoryAndWriteToFile"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (97)) ;
    ::routine_enterInstanceMethodWithoutArgument (inLexique,  var_cas_outInstanceMethodMap,  GGS_string ("makeDirectory"),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (98)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_unifiedTypeMapIndex  var_cas_t ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (101)), var_cas_ioUnifiedTypeMap, var_cas_t COMMA_SOURCE_FILE_AT_LINE (101)) ;
    var_cas_argList.addAssign_operation (var_cas_t, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (102))) ;
    GGS_unifiedTypeMapIndex::class_method_makeRegularIndex (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("bool"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (103)), var_cas_ioUnifiedTypeMap, var_cas_t COMMA_SOURCE_FILE_AT_LINE (103)) ;
    var_cas_argList.addAssign_operation (var_cas_t, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (104))) ;
    var_cas_outInstanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToFileWhenDifferentContents"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (106)), var_cas_argList, GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (105)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticsInstanceMethods (void) {
  enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap ((typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap) category_method__dataPredefinedTypeAST__getInstanceMethodMap, gClassInfoFor__dataPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap ((typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap) category_method__stringPredefinedTypeAST__getInstanceMethodMap, gClassInfoFor__stringPredefinedTypeAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsInstanceMethods (prologueRoutineFor_semanticsInstanceMethods, NULL) ;

//---------------------------------------------------------------------------*

