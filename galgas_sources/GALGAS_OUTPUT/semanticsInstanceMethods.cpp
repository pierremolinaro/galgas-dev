//---------------------------------------------------------------------------*
//                                                                           *
//                   File 'semanticsInstanceMethods.cpp'                     *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      april 30th, 2010, at 13h56'37"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "semanticsInstanceMethods.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "semanticsInstanceMethods.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//      Implementation of routine "enterInstanceMethodWithoutArgument"       *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithoutArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                const GGS_lstring   var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithoutArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  var_cas_ioInstanceMethodMap.modifier_insertOrReplace (inLexique, var_cas_inInstanceMethodName, GGS_formalParameterSignature ::constructor_emptyList (), var_cas_inInstanceMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (34)), var_cas_inHasCompilerArgument COMMA_SOURCE_FILE_AT_LINE (31)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithoutArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Implementation of routine "enterInstanceMethodWithInputArgument"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithInputArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                const GGS_string  var_cas_inInputArgumentTypeName,
                                const GGS_lstring   var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithInputArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMapProxy  var_cas_argumentTypeIndex ;
  GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioUnifiedTypeMap, GGS_lstring ::constructor_new (inLexique, var_cas_inInputArgumentTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (49)), var_cas_argumentTypeIndex COMMA_SOURCE_FILE_AT_LINE (49)) ;
  GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (var_cas_argumentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (51))) ;
  var_cas_ioInstanceMethodMap.modifier_insertOrReplace (inLexique, var_cas_inInstanceMethodName, var_cas_argList, var_cas_inInstanceMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (55)), var_cas_inHasCompilerArgument COMMA_SOURCE_FILE_AT_LINE (52)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithInputArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//    Implementation of routine "enterInstanceMethodWithOutputArgument"      *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_enterInstanceMethodWithOutputArgument (C_Compiler & inLexique,
                                GGS_instanceMethodMap  & var_cas_ioInstanceMethodMap,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                const GGS_string  var_cas_inInputArgumentTypeName,
                                const GGS_lstring   var_cas_inInstanceMethodName,
                                const GGS_bool  var_cas_inHasCompilerArgument COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_enterInstanceMethodWithOutputArgument at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_unifiedTypeMapProxy  var_cas_argumentTypeIndex ;
  GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioUnifiedTypeMap, GGS_lstring ::constructor_new (inLexique, var_cas_inInputArgumentTypeName, GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (70)), var_cas_argumentTypeIndex COMMA_SOURCE_FILE_AT_LINE (70)) ;
  GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
  var_cas_argList.addAssign_operation (var_cas_argumentTypeIndex, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (72))) ;
  var_cas_ioInstanceMethodMap.modifier_insertOrReplace (inLexique, var_cas_inInstanceMethodName, var_cas_argList, var_cas_inInstanceMethodName.reader_location (inLexique COMMA_SOURCE_FILE_AT_LINE (76)), var_cas_inHasCompilerArgument COMMA_SOURCE_FILE_AT_LINE (73)) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_enterInstanceMethodWithOutputArgument\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//      Category method '@dataPredefinedTypeAST.getInstanceMethodMap'        *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__dataPredefinedTypeAST__getInstanceMethodMap (C_Compiler & inLexique,
                                const cPtr_dataPredefinedTypeAST * operand_3670,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                GGS_instanceMethodMap  & var_cas_outInstanceMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_3670 != NULL) {
    var_cas_outInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (87)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToFile"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (88)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (88)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//     Category method '@stringPredefinedTypeAST.getInstanceMethodMap'       *
//                                                                           *
//---------------------------------------------------------------------------*

static void
category_method__stringPredefinedTypeAST__getInstanceMethodMap (C_Compiler & inLexique,
                                const cPtr_stringPredefinedTypeAST * operand_4101,
                                GGS_unifiedTypeMap  & var_cas_ioUnifiedTypeMap,
                                GGS_instanceMethodMap  & var_cas_outInstanceMethodMap
                                COMMA_UNUSED_LOCATION_ARGS) {
  if (operand_4101 != NULL) {
    var_cas_outInstanceMethodMap = GGS_instanceMethodMap ::constructor_emptyMap (inLexique COMMA_SOURCE_FILE_AT_LINE (97)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToFile"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (98)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (98)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToExecutableFile"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (99)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (99)) ;
    ::routine_enterInstanceMethodWithInputArgument (inLexique,  var_cas_outInstanceMethodMap,  var_cas_ioUnifiedTypeMap,  GGS_string ("string"),  GGS_lstring ::constructor_new (inLexique, GGS_string ("makeDirectoryAndWriteToFile"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (100)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (100)) ;
    ::routine_enterInstanceMethodWithoutArgument (inLexique,  var_cas_outInstanceMethodMap,  GGS_lstring ::constructor_new (inLexique, GGS_string ("makeDirectory"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (101)),  GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (101)) ;
    GGS_formalParameterSignature  var_cas_argList = GGS_formalParameterSignature ::constructor_emptyList () ;
    GGS_unifiedTypeMapProxy  var_cas_t ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioUnifiedTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("string"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (104)), var_cas_t COMMA_SOURCE_FILE_AT_LINE (104)) ;
    var_cas_argList.addAssign_operation (var_cas_t, GGS_formalArgumentPassingModeAST::constructor_argumentConstantIn (inLexique COMMA_SOURCE_FILE_AT_LINE (105))) ;
    GGS_unifiedTypeMapProxy::class_method_makeRegularProxy (inLexique, var_cas_ioUnifiedTypeMap, GGS_lstring ::constructor_new (inLexique, GGS_string ("bool"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (106)), var_cas_t COMMA_SOURCE_FILE_AT_LINE (106)) ;
    var_cas_argList.addAssign_operation (var_cas_t, GGS_formalArgumentPassingModeAST::constructor_argumentOut (inLexique COMMA_SOURCE_FILE_AT_LINE (107))) ;
    var_cas_outInstanceMethodMap.modifier_insertOrReplace (inLexique, GGS_lstring ::constructor_new (inLexique, GGS_string ("writeToFileWhenDifferentContents"), GGS_location (inLexique) COMMA_SOURCE_FILE_AT_LINE (109)), var_cas_argList, GGS_location (inLexique), GGS_bool (true) COMMA_SOURCE_FILE_AT_LINE (108)) ;
  }
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void prologueRoutineFor_semanticsInstanceMethods (void) {
  enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap ((typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap) category_method__dataPredefinedTypeAST__getInstanceMethodMap, gClassInfoFor__dataPredefinedTypeAST.slotID ()) ;
  enterCategoryMethod__predefinedTypeAST__getInstanceMethodMap ((typeCategoryMethod__predefinedTypeAST__getInstanceMethodMap) category_method__stringPredefinedTypeAST__getInstanceMethodMap, gClassInfoFor__stringPredefinedTypeAST.slotID ()) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_semanticsInstanceMethods (prologueRoutineFor_semanticsInstanceMethods, NULL) ;

//---------------------------------------------------------------------------*

