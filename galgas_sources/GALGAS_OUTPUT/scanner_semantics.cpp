//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'scanner_semantics.cpp'                        *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                    february 16th, 2007, at 17h57'11"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "scanner_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  static const char gGGSsourceFile [] = "scanner_semantics.ggs" ;
  #define SOURCE_FILE_AT_LINE(line) , gGGSsourceFile, line
#else
  #define SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@typeLexicalAttributesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeLexicalAttributesMap::
elementOf_GGS_typeLexicalAttributesMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeLexicalAttributesMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeLexicalAttributesMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.attributType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeLexicalAttributesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeLexicalAttributesMap * _p = dynamic_cast <const elementOf_GGS_typeLexicalAttributesMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.attributType == _p->mInfo.attributType).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeLexicalAttributesMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeLexicalAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeLexicalAttributesMap * info = (e_typeLexicalAttributesMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap GGS_typeLexicalAttributesMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeLexicalAttributesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeLexicalAttributesMap info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalAttributesMap::
operator == (const GGS_typeLexicalAttributesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalAttributesMap::
operator != (const GGS_typeLexicalAttributesMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeLexicalAttributesMap info  ;
    info.attributType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.attributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the lexical attribute '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the lexical attribute '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap GGS_typeLexicalAttributesMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeLexicalAttributesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeLexicalAttributesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap GGS_typeLexicalAttributesMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeLexicalAttributesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLexicalAttributesMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeLexicalAttributesMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@tagMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_tagMap::
elementOf_GGS_tagMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_tagMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_tagMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_tagMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_tagMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_tagMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_tagMap * info = (e_tagMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_tagMap GGS_tagMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tagMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_tagMap info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tagMap::
operator == (const GGS_tagMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tagMap::
operator != (const GGS_tagMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_tagMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' tag is not declared",
                  inKey,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  const bool _shadowExists = internal_search_in_overridden_maps (inKey) != NULL ;
  if (_shadowExists) {
    emitMapSemanticErrorMessage (_inLexique, inKey, "the '%K' tag declaration shadows the tag declared in %L" COMMA_THERE) ;
  }else{
    _insertElement (_inLexique,
                   "the '%K' tag is already declared in %L",
                   inKey,
                   NULL
                   COMMA_THERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_tagMap GGS_tagMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_tagMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tagMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tagMap GGS_tagMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tagMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tagMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @tagMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@lexicalTypeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_lexicalTypeMap::
elementOf_GGS_lexicalTypeMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_lexicalTypeMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_lexicalTypeMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mAttributType.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_lexicalTypeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_lexicalTypeMap * _p = dynamic_cast <const elementOf_GGS_lexicalTypeMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mAttributType == _p->mInfo.mAttributType).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_lexicalTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_lexicalTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_lexicalTypeMap * info = (e_lexicalTypeMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTypeMap GGS_lexicalTypeMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_lexicalTypeMap info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalTypeMap::
operator == (const GGS_lexicalTypeMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalTypeMap::
operator != (const GGS_lexicalTypeMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_lexicalTypeMap info  ;
    info.mAttributType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "there is no type named '@%K'",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "--- internal error ---",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTypeMap GGS_lexicalTypeMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_lexicalTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_lexicalTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTypeMap GGS_lexicalTypeMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lexicalTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_lexicalTypeMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @lexicalTypeMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@typeTableMessagesErreurs'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableMessagesErreurs::
elementOf_GGS_typeTableMessagesErreurs (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableMessagesErreurs & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableMessagesErreurs::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableMessagesErreurs::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableMessagesErreurs * _p = dynamic_cast <const elementOf_GGS_typeTableMessagesErreurs *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mErrorMessage == _p->mInfo.mErrorMessage).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMessagesErreurs::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableMessagesErreurs *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableMessagesErreurs * info = (e_typeTableMessagesErreurs *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs GGS_typeTableMessagesErreurs::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMessagesErreurs result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableMessagesErreurs info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMessagesErreurs::
operator == (const GGS_typeTableMessagesErreurs & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMessagesErreurs::
operator != (const GGS_typeTableMessagesErreurs & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableMessagesErreurs info  ;
    info.mErrorMessage = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mErrorMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the error message '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the error message '%K' is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the error message '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs GGS_typeTableMessagesErreurs::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableMessagesErreurs & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMessagesErreurs result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs GGS_typeTableMessagesErreurs::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMessagesErreurs result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMessagesErreurs::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableMessagesErreurs " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@M_styles'                            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_M_styles::
elementOf_GGS_M_styles (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_styles & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_styles::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTitle.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_styles::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_styles * _p = dynamic_cast <const elementOf_GGS_M_styles *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mTitle == _p->mInfo.mTitle).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_styles::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_M_styles *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_styles * info = (e_M_styles *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_M_styles GGS_M_styles::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_styles result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_styles info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_styles::
operator == (const GGS_M_styles & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_styles::
operator != (const GGS_M_styles & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_M_styles info  ;
    info.mTitle = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTitle ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' style is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
method_searchKeyGetIndex (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_luint & outIndex,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' style is not declared",
                  inKey,
                  outParameter0,
                  & outIndex
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' style is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_styles GGS_M_styles::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_M_styles & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_styles result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_styles GGS_M_styles::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_styles result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_styles::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @M_styles " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableDefinitionTerminaux'                  *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableDefinitionTerminaux::
elementOf_GGS_typeTableDefinitionTerminaux (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableDefinitionTerminaux & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableDefinitionTerminaux::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mErrorMessage.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.attributListeDesAttributs.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mStyleIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableDefinitionTerminaux::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableDefinitionTerminaux * _p = dynamic_cast <const elementOf_GGS_typeTableDefinitionTerminaux *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mErrorMessage == _p->mInfo.mErrorMessage).boolValue ()
           && (mInfo.attributListeDesAttributs == _p->mInfo.attributListeDesAttributs).boolValue ()
           && (mInfo.mStyleIndex == _p->mInfo.mStyleIndex).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableDefinitionTerminaux::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableDefinitionTerminaux *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableDefinitionTerminaux * info = (e_typeTableDefinitionTerminaux *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux GGS_typeTableDefinitionTerminaux::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableDefinitionTerminaux result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableDefinitionTerminaux info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableDefinitionTerminaux::
operator == (const GGS_typeTableDefinitionTerminaux & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableDefinitionTerminaux::
operator != (const GGS_typeTableDefinitionTerminaux & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_string& inParameter0,
                const GGS_typeListeAttributsSemantiques & inParameter1,
                const GGS_luint & inParameter2,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inParameter1._isBuilt ()
   && inParameter2._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableDefinitionTerminaux info  ;
    info.mErrorMessage = inParameter0 ;
    info.attributListeDesAttributs = inParameter1 ;
    info.mStyleIndex = inParameter2 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_typeListeAttributsSemantiques   & outParameter1,
               GGS_luint   & outParameter2,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    outParameter1._drop_operation () ;
    outParameter2._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mErrorMessage ;
    outParameter1 = node->mInfo.attributListeDesAttributs ;
    outParameter2 = node->mInfo.mStyleIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0,
                                GGS_typeListeAttributsSemantiques   & outParameter1,
                                GGS_luint   & outParameter2 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the terminal symbol '$%K$' is not declared",
                  inKey,
                  outParameter0,
                  outParameter1,
                  outParameter2,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_typeListeAttributsSemantiques & inParameter1,
                                const GGS_luint & inParameter2 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the terminal symbol '$%K$' is already declared in %L",
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux GGS_typeTableDefinitionTerminaux::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableDefinitionTerminaux & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableDefinitionTerminaux result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux GGS_typeTableDefinitionTerminaux::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableDefinitionTerminaux result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableDefinitionTerminaux::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableDefinitionTerminaux " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeTableMotsReserves'                     *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableMotsReserves::
elementOf_GGS_typeTableMotsReserves (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableMotsReserves & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableMotsReserves::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.attributNomTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableMotsReserves::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableMotsReserves * _p = dynamic_cast <const elementOf_GGS_typeTableMotsReserves *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.attributNomTerminal == _p->mInfo.attributNomTerminal).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMotsReserves::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableMotsReserves *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableMotsReserves * info = (e_typeTableMotsReserves *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves GGS_typeTableMotsReserves::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMotsReserves result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableMotsReserves info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMotsReserves::
operator == (const GGS_typeTableMotsReserves & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMotsReserves::
operator != (const GGS_typeTableMotsReserves & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableMotsReserves info  ;
    info.attributNomTerminal = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.attributNomTerminal ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the word '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the word '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves GGS_typeTableMotsReserves::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableMotsReserves & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMotsReserves result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves GGS_typeTableMotsReserves::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMotsReserves result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMotsReserves::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableMotsReserves " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableTablesDeMotsReserves'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeTableTablesDeMotsReserves::
elementOf_GGS_typeTableTablesDeMotsReserves (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableTablesDeMotsReserves & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableTablesDeMotsReserves::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.attributSimpleTable.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableTablesDeMotsReserves::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableTablesDeMotsReserves * _p = dynamic_cast <const elementOf_GGS_typeTableTablesDeMotsReserves *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.attributSimpleTable == _p->mInfo.attributSimpleTable).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableTablesDeMotsReserves::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_typeTableTablesDeMotsReserves *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableTablesDeMotsReserves * info = (e_typeTableTablesDeMotsReserves *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves GGS_typeTableTablesDeMotsReserves::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableTablesDeMotsReserves result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableTablesDeMotsReserves info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableTablesDeMotsReserves::
operator == (const GGS_typeTableTablesDeMotsReserves & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableTablesDeMotsReserves::
operator != (const GGS_typeTableTablesDeMotsReserves & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_typeTableMotsReserves & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_typeTableTablesDeMotsReserves info  ;
    info.attributSimpleTable = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeTableMotsReserves   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.attributSimpleTable ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeTableMotsReserves   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the mord map '%K' is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeTableMotsReserves & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the word map '%K' is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves GGS_typeTableTablesDeMotsReserves::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_typeTableTablesDeMotsReserves & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableTablesDeMotsReserves result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves GGS_typeTableTablesDeMotsReserves::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableTablesDeMotsReserves result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableTablesDeMotsReserves::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableTablesDeMotsReserves " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeConditionLexicale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionLexicale::
cPtr_typeConditionLexicale (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionLexicale * GGS_typeConditionLexicale::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeConditionLexicale::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeConditionLexicale:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeConditionLexicale'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
GGS_typeConditionLexicale (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
GGS_typeConditionLexicale (const GGS_typeConditionLexicale & inOperand) {
  mPointer = (cPtr_typeConditionLexicale *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
~GGS_typeConditionLexicale (void) {
  macroDetachPointer (mPointer, cPtr_typeConditionLexicale) ;
}

//---------------------------------------------------------------------------*

void GGS_typeConditionLexicale::
operator = (const GGS_typeConditionLexicale & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeConditionLexicale::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeConditionLexicale) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConditionLexicale::
operator == (const GGS_typeConditionLexicale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConditionLexicale::
operator != (const GGS_typeConditionLexicale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConditionLexicale::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeConditionLexicale" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeConditionChaine'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionChaine::
cPtr_typeConditionChaine (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeConditionLexicale (THERE),
attributChaine (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionChaine * GGS_typeConditionChaine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionChaine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConditionChaine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConditionChaine::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConditionChaine * _p = dynamic_cast <const cPtr_typeConditionChaine *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributChaine == _p->attributChaine).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConditionChaine::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConditionChaine:"
           << attributChaine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConditionChaine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConditionChaine::
GGS_typeConditionChaine (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionChaine::
GGS_typeConditionChaine (const GGS_typeConditionChaine & inOperand)
:GGS_typeConditionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionChaine::
~GGS_typeConditionChaine (void) {
  macroDetachPointer (mPointer, cPtr_typeConditionChaine) ;
}

//---------------------------------------------------------------------------*

void GGS_typeConditionChaine::
operator = (const GGS_typeConditionChaine & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionChaine GGS_typeConditionChaine::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeConditionChaine result ;
  macroMyNew (result.mPointer, cPtr_typeConditionChaine (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeConditionChaine::
reader_attributChaine (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionChaine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionChaine *) mPointer)->attributChaine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConditionChaine::
operator == (const GGS_typeConditionChaine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConditionChaine::
operator != (const GGS_typeConditionChaine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConditionChaine::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeConditionChaine" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeConditionCaractere'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionCaractere::
cPtr_typeConditionCaractere (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeConditionLexicale (THERE),
attributCaractere (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionCaractere * GGS_typeConditionCaractere::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionCaractere *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConditionCaractere *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConditionCaractere::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConditionCaractere * _p = dynamic_cast <const cPtr_typeConditionCaractere *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributCaractere == _p->attributCaractere).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConditionCaractere::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConditionCaractere:"
           << attributCaractere.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConditionCaractere::
GGS_typeConditionCaractere (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionCaractere::
GGS_typeConditionCaractere (const GGS_typeConditionCaractere & inOperand)
:GGS_typeConditionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionCaractere::
~GGS_typeConditionCaractere (void) {
  macroDetachPointer (mPointer, cPtr_typeConditionCaractere) ;
}

//---------------------------------------------------------------------------*

void GGS_typeConditionCaractere::
operator = (const GGS_typeConditionCaractere & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionCaractere GGS_typeConditionCaractere::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeConditionCaractere result ;
  macroMyNew (result.mPointer, cPtr_typeConditionCaractere (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeConditionCaractere::
reader_attributCaractere (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionCaractere *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionCaractere *) mPointer)->attributCaractere ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConditionCaractere::
operator == (const GGS_typeConditionCaractere & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConditionCaractere::
operator != (const GGS_typeConditionCaractere & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConditionCaractere::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeConditionCaractere" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeConditionIntervalle'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionIntervalle::
cPtr_typeConditionIntervalle (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeConditionLexicale (THERE),
attributBorneInf (argument_0),
attributBorneSup (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionIntervalle * GGS_typeConditionIntervalle::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionIntervalle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeConditionIntervalle *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConditionIntervalle::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConditionIntervalle * _p = dynamic_cast <const cPtr_typeConditionIntervalle *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributBorneInf == _p->attributBorneInf).boolValue ()
         && (attributBorneSup == _p->attributBorneSup).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConditionIntervalle::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeConditionIntervalle:"
           << attributBorneInf.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << attributBorneSup.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionIntervalle'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConditionIntervalle::
GGS_typeConditionIntervalle (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionIntervalle::
GGS_typeConditionIntervalle (const GGS_typeConditionIntervalle & inOperand)
:GGS_typeConditionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionIntervalle::
~GGS_typeConditionIntervalle (void) {
  macroDetachPointer (mPointer, cPtr_typeConditionIntervalle) ;
}

//---------------------------------------------------------------------------*

void GGS_typeConditionIntervalle::
operator = (const GGS_typeConditionIntervalle & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionIntervalle GGS_typeConditionIntervalle::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lchar & argument_0,
                 const GGS_lchar & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeConditionIntervalle result ;
  macroMyNew (result.mPointer, cPtr_typeConditionIntervalle (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeConditionIntervalle::
reader_attributBorneInf (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionIntervalle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionIntervalle *) mPointer)->attributBorneInf ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeConditionIntervalle::
reader_attributBorneSup (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionIntervalle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionIntervalle *) mPointer)->attributBorneSup ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConditionIntervalle::
operator == (const GGS_typeConditionIntervalle & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeConditionIntervalle::
operator != (const GGS_typeConditionIntervalle & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeConditionIntervalle::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeConditionIntervalle" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeConditionsLexicales'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeConditionsLexicales::
elementOf_GGS_typeListeConditionsLexicales (const GGS_typeConditionLexicale & argument_0):
attributCondition (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeConditionsLexicales::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeConditionsLexicales * _p = dynamic_cast <const elementOf_GGS_typeListeConditionsLexicales *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributCondition == _p->attributCondition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeConditionsLexicales::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributCondition.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@typeListeConditionsLexicales'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales::GGS_typeListeConditionsLexicales (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales::
GGS_typeListeConditionsLexicales (const GGS_typeListeConditionsLexicales & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeConditionsLexicales::
operator == (const GGS_typeListeConditionsLexicales & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeConditionsLexicales::
operator != (const GGS_typeListeConditionsLexicales & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
_internalAppendValues (const GGS_typeConditionLexicale & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
_internalPrependValues (const GGS_typeConditionLexicale & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
_addAssign_operation (const GGS_typeConditionLexicale & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales GGS_typeListeConditionsLexicales::
operator + (const GGS_typeListeConditionsLexicales & inOperand) const {
  GGS_typeListeConditionsLexicales result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeConditionsLexicales * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeConditionLexicale  p_0 = p->attributCondition ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeConditionLexicale & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->attributCondition) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales  GGS_typeListeConditionsLexicales::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeConditionsLexicales result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales  GGS_typeListeConditionsLexicales::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeConditionLexicale & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeConditionsLexicales result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeConditionsLexicales::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeConditionsLexicales", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
method_first (C_Lexique & _inLexique,
              GGS_typeConditionLexicale & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributCondition ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
method_last (C_Lexique & _inLexique,
             GGS_typeConditionLexicale & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributCondition ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeConditionLexicale & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributCondition ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeConditionLexicale & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributCondition ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeInstructionLexicale'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionLexicale::
cPtr_typeInstructionLexicale (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionLexicale * GGS_typeInstructionLexicale::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeInstructionLexicale::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeInstructionLexicale:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionLexicale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
GGS_typeInstructionLexicale (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
GGS_typeInstructionLexicale (const GGS_typeInstructionLexicale & inOperand) {
  mPointer = (cPtr_typeInstructionLexicale *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
~GGS_typeInstructionLexicale (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionLexicale) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionLexicale::
operator = (const GGS_typeInstructionLexicale & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionLexicale::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionLexicale) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionLexicale::
operator == (const GGS_typeInstructionLexicale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionLexicale::
operator != (const GGS_typeInstructionLexicale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionLexicale::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionLexicale" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@tListeInstructionsLexicales'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_tListeInstructionsLexicales::
elementOf_GGS_tListeInstructionsLexicales (const GGS_typeInstructionLexicale & argument_0):
attributInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_tListeInstructionsLexicales::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_tListeInstructionsLexicales * _p = dynamic_cast <const elementOf_GGS_tListeInstructionsLexicales *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributInstruction == _p->attributInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_tListeInstructionsLexicales::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributInstruction.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@tListeInstructionsLexicales'                     *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales::GGS_tListeInstructionsLexicales (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales::
GGS_tListeInstructionsLexicales (const GGS_tListeInstructionsLexicales & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tListeInstructionsLexicales::
operator == (const GGS_tListeInstructionsLexicales & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tListeInstructionsLexicales::
operator != (const GGS_tListeInstructionsLexicales & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
_internalAppendValues (const GGS_typeInstructionLexicale & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
_internalPrependValues (const GGS_typeInstructionLexicale & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
_addAssign_operation (const GGS_typeInstructionLexicale & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales GGS_tListeInstructionsLexicales::
operator + (const GGS_tListeInstructionsLexicales & inOperand) const {
  GGS_tListeInstructionsLexicales result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_tListeInstructionsLexicales * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstructionLexicale  p_0 = p->attributInstruction ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeInstructionLexicale & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->attributInstruction) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_tListeInstructionsLexicales::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tListeInstructionsLexicales result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_tListeInstructionsLexicales::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeInstructionLexicale & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tListeInstructionsLexicales result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tListeInstructionsLexicales::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@tListeInstructionsLexicales", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
method_first (C_Lexique & _inLexique,
              GGS_typeInstructionLexicale & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
method_last (C_Lexique & _inLexique,
             GGS_typeInstructionLexicale & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributInstruction ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeInstructionLexicale & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributInstruction ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeInstructionLexicale & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributInstruction ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeTestsEtInstructions'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTestsEtInstructions::
elementOf_GGS_typeListeTestsEtInstructions (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1):
attributListeConditions (argument_0),
attributListeInstructions (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeTestsEtInstructions::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeTestsEtInstructions * _p = dynamic_cast <const elementOf_GGS_typeListeTestsEtInstructions *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributListeConditions == _p->attributListeConditions).boolValue ()
         && (attributListeInstructions == _p->attributListeInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeTestsEtInstructions::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributListeConditions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributListeInstructions.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@typeListeTestsEtInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions::GGS_typeListeTestsEtInstructions (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions::
GGS_typeListeTestsEtInstructions (const GGS_typeListeTestsEtInstructions & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeTestsEtInstructions::
operator == (const GGS_typeListeTestsEtInstructions & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeTestsEtInstructions::
operator != (const GGS_typeListeTestsEtInstructions & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
_internalAppendValues (const GGS_typeListeConditionsLexicales & argument_0,
                    const GGS_tListeInstructionsLexicales & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
_internalPrependValues (const GGS_typeListeConditionsLexicales & argument_0,
                    const GGS_tListeInstructionsLexicales & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
_addAssign_operation (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions GGS_typeListeTestsEtInstructions::
operator + (const GGS_typeListeTestsEtInstructions & inOperand) const {
  GGS_typeListeTestsEtInstructions result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeTestsEtInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeListeConditionsLexicales  p_0 = p->attributListeConditions ;
          GGS_tListeInstructionsLexicales  p_1 = p->attributListeInstructions ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeListeConditionsLexicales & argument_0,
                     const GGS_tListeInstructionsLexicales & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->attributListeConditions,
                                _p->attributListeInstructions) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeListeTestsEtInstructions::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeTestsEtInstructions result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeListeTestsEtInstructions::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeListeConditionsLexicales & argument_0,
                           const GGS_tListeInstructionsLexicales & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeTestsEtInstructions result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeTestsEtInstructions::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeTestsEtInstructions", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
method_first (C_Lexique & _inLexique,
              GGS_typeListeConditionsLexicales & _out_0,
              GGS_tListeInstructionsLexicales & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributListeConditions ;
    _out_1 = _p->attributListeInstructions ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
method_last (C_Lexique & _inLexique,
             GGS_typeListeConditionsLexicales & _out_0,
             GGS_tListeInstructionsLexicales & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributListeConditions ;
    _out_1 = _p->attributListeInstructions ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeListeConditionsLexicales & _out_0,
                 GGS_tListeInstructionsLexicales & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributListeConditions ;
    _out_1 = _p->attributListeInstructions ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeListeConditionsLexicales & _out_0,
                GGS_tListeInstructionsLexicales & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributListeConditions ;
    _out_1 = _p->attributListeInstructions ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeArgumentRoutineExterne'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentRoutineExterne::
cPtr_typeArgumentRoutineExterne (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentRoutineExterne * GGS_typeArgumentRoutineExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeArgumentRoutineExterne::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeArgumentRoutineExterne:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeArgumentRoutineExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
GGS_typeArgumentRoutineExterne (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
GGS_typeArgumentRoutineExterne (const GGS_typeArgumentRoutineExterne & inOperand) {
  mPointer = (cPtr_typeArgumentRoutineExterne *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
~GGS_typeArgumentRoutineExterne (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentRoutineExterne) ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentRoutineExterne::
operator = (const GGS_typeArgumentRoutineExterne & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentRoutineExterne::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentRoutineExterne) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentRoutineExterne::
operator == (const GGS_typeArgumentRoutineExterne & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentRoutineExterne::
operator != (const GGS_typeArgumentRoutineExterne & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeArgumentRoutineExterne::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeArgumentRoutineExterne" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeArgumentsRoutExterne'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeArgumentsRoutExterne::
elementOf_GGS_typeListeArgumentsRoutExterne (const GGS_typeArgumentRoutineExterne & argument_0):
attributArgument (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeArgumentsRoutExterne::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeArgumentsRoutExterne * _p = dynamic_cast <const elementOf_GGS_typeListeArgumentsRoutExterne *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributArgument == _p->attributArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeArgumentsRoutExterne::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributArgument.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeArgumentsRoutExterne'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne::GGS_typeListeArgumentsRoutExterne (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne::
GGS_typeListeArgumentsRoutExterne (const GGS_typeListeArgumentsRoutExterne & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeArgumentsRoutExterne::
operator == (const GGS_typeListeArgumentsRoutExterne & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeArgumentsRoutExterne::
operator != (const GGS_typeListeArgumentsRoutExterne & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
_internalAppendValues (const GGS_typeArgumentRoutineExterne & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
_internalPrependValues (const GGS_typeArgumentRoutineExterne & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
_addAssign_operation (const GGS_typeArgumentRoutineExterne & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne GGS_typeListeArgumentsRoutExterne::
operator + (const GGS_typeListeArgumentsRoutExterne & inOperand) const {
  GGS_typeListeArgumentsRoutExterne result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeArgumentsRoutExterne * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeArgumentRoutineExterne  p_0 = p->attributArgument ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_typeArgumentRoutineExterne & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->attributArgument) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeListeArgumentsRoutExterne::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeArgumentsRoutExterne result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeListeArgumentsRoutExterne::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_typeArgumentRoutineExterne & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeArgumentsRoutExterne result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeArgumentsRoutExterne::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeArgumentsRoutExterne", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
method_first (C_Lexique & _inLexique,
              GGS_typeArgumentRoutineExterne & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributArgument ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
method_last (C_Lexique & _inLexique,
             GGS_typeArgumentRoutineExterne & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributArgument ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_typeArgumentRoutineExterne & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributArgument ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
modifier_popLast (C_Lexique & _inLexique,
                GGS_typeArgumentRoutineExterne & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributArgument ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeArgumentAttribut'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentAttribut::
cPtr_typeArgumentAttribut (const GGS_lstring & argument_0,
                                const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE),
attributNom (argument_0),
attributTypeAttribut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentAttribut * GGS_typeArgumentAttribut::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentAttribut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeArgumentAttribut *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentAttribut::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeArgumentAttribut * _p = dynamic_cast <const cPtr_typeArgumentAttribut *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributNom == _p->attributNom).boolValue ()
         && (attributTypeAttribut == _p->attributTypeAttribut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentAttribut::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeArgumentAttribut:"
           << attributNom.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << attributTypeAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentAttribut'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeArgumentAttribut::
GGS_typeArgumentAttribut (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentAttribut::
GGS_typeArgumentAttribut (const GGS_typeArgumentAttribut & inOperand)
:GGS_typeArgumentRoutineExterne () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentAttribut::
~GGS_typeArgumentAttribut (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentAttribut) ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentAttribut::
operator = (const GGS_typeArgumentAttribut & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentAttribut GGS_typeArgumentAttribut::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_AC_galgasType & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeArgumentAttribut result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentAttribut (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeArgumentAttribut::
reader_attributNom (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentAttribut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentAttribut *) mPointer)->attributNom ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeArgumentAttribut::
reader_attributTypeAttribut (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentAttribut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentAttribut *) mPointer)->attributTypeAttribut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentAttribut::
operator == (const GGS_typeArgumentAttribut & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentAttribut::
operator != (const GGS_typeArgumentAttribut & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeArgumentAttribut::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeArgumentAttribut" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeArgumentCaractere'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentCaractere::
cPtr_typeArgumentCaractere (const GGS_lchar & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE),
attributCaractere (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentCaractere * GGS_typeArgumentCaractere::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentCaractere *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeArgumentCaractere *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentCaractere::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeArgumentCaractere * _p = dynamic_cast <const cPtr_typeArgumentCaractere *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributCaractere == _p->attributCaractere).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentCaractere::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeArgumentCaractere:"
           << attributCaractere.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeArgumentCaractere::
GGS_typeArgumentCaractere (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractere::
GGS_typeArgumentCaractere (const GGS_typeArgumentCaractere & inOperand)
:GGS_typeArgumentRoutineExterne () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractere::
~GGS_typeArgumentCaractere (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentCaractere) ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentCaractere::
operator = (const GGS_typeArgumentCaractere & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractere GGS_typeArgumentCaractere::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lchar & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeArgumentCaractere result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentCaractere (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeArgumentCaractere::
reader_attributCaractere (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentCaractere *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentCaractere *) mPointer)->attributCaractere ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentCaractere::
operator == (const GGS_typeArgumentCaractere & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentCaractere::
operator != (const GGS_typeArgumentCaractere & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeArgumentCaractere::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeArgumentCaractere" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeArgumentCaractereCourant'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentCaractereCourant::
cPtr_typeArgumentCaractereCourant (LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentCaractereCourant * GGS_typeArgumentCaractereCourant::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentCaractereCourant *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeArgumentCaractereCourant *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentCaractereCourant::
isEqualToObject (const C_GGS_Object * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentCaractereCourant::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeArgumentCaractereCourant:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeArgumentCaractereCourant'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeArgumentCaractereCourant::
GGS_typeArgumentCaractereCourant (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractereCourant::
GGS_typeArgumentCaractereCourant (const GGS_typeArgumentCaractereCourant & inOperand)
:GGS_typeArgumentRoutineExterne () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractereCourant::
~GGS_typeArgumentCaractereCourant (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentCaractereCourant) ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentCaractereCourant::
operator = (const GGS_typeArgumentCaractereCourant & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractereCourant GGS_typeArgumentCaractereCourant::
constructor_new (C_Lexique & /* inLexique */ COMMA_LOCATION_ARGS) {
  GGS_typeArgumentCaractereCourant result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentCaractereCourant (THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentCaractereCourant::
operator == (const GGS_typeArgumentCaractereCourant & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentCaractereCourant::
operator != (const GGS_typeArgumentCaractereCourant & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeArgumentCaractereCourant::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeArgumentCaractereCourant" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 abstract class 'cPtr_typeArgumentEntier'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentEntier::
cPtr_typeArgumentEntier (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE),
attributValeur (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentEntier * GGS_typeArgumentEntier::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentEntier *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeArgumentEntier *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentEntier::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeArgumentEntier * _p = dynamic_cast <const cPtr_typeArgumentEntier *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributValeur == _p->attributValeur).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentEntier::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeArgumentEntier:"
           << attributValeur.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentEntier'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeArgumentEntier::
GGS_typeArgumentEntier (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentEntier::
GGS_typeArgumentEntier (const GGS_typeArgumentEntier & inOperand)
:GGS_typeArgumentRoutineExterne () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentEntier::
~GGS_typeArgumentEntier (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentEntier) ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentEntier::
operator = (const GGS_typeArgumentEntier & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentEntier GGS_typeArgumentEntier::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeArgumentEntier result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentEntier (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeArgumentEntier::
reader_attributValeur (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentEntier *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentEntier *) mPointer)->attributValeur ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentEntier::
operator == (const GGS_typeArgumentEntier & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentEntier::
operator != (const GGS_typeArgumentEntier & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeArgumentEntier::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeArgumentEntier" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                abstract class 'cPtr_typeArgumentRoutine'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentRoutine::
cPtr_typeArgumentRoutine (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE),
attributNomRoutine (argument_0),
attributListeArguments (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentRoutine * GGS_typeArgumentRoutine::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeArgumentRoutine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentRoutine::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeArgumentRoutine * _p = dynamic_cast <const cPtr_typeArgumentRoutine *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributNomRoutine == _p->attributNomRoutine).boolValue ()
         && (attributListeArguments == _p->attributListeArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentRoutine::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeArgumentRoutine:"
           << attributNomRoutine.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << attributListeArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentRoutine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeArgumentRoutine::
GGS_typeArgumentRoutine (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutine::
GGS_typeArgumentRoutine (const GGS_typeArgumentRoutine & inOperand)
:GGS_typeArgumentRoutineExterne () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutine::
~GGS_typeArgumentRoutine (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentRoutine) ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentRoutine::
operator = (const GGS_typeArgumentRoutine & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutine GGS_typeArgumentRoutine::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeArgumentsRoutExterne & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeArgumentRoutine result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentRoutine (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeArgumentRoutine::
reader_attributNomRoutine (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentRoutine *) mPointer)->attributNomRoutine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeArgumentRoutine::
reader_attributListeArguments (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeArgumentsRoutExterne   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentRoutine *) mPointer)->attributListeArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentRoutine::
operator == (const GGS_typeArgumentRoutine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeArgumentRoutine::
operator != (const GGS_typeArgumentRoutine & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeArgumentRoutine::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeArgumentRoutine" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeListeMessagesErreur'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeMessagesErreur::
elementOf_GGS_typeListeMessagesErreur (const GGS_luint & argument_0):
mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeMessagesErreur::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeMessagesErreur * _p = dynamic_cast <const elementOf_GGS_typeListeMessagesErreur *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mErrorMessageIndex == _p->mErrorMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeMessagesErreur::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeListeMessagesErreur'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur::GGS_typeListeMessagesErreur (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur::
GGS_typeListeMessagesErreur (const GGS_typeListeMessagesErreur & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeMessagesErreur::
operator == (const GGS_typeListeMessagesErreur & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeMessagesErreur::
operator != (const GGS_typeListeMessagesErreur & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
_internalAppendValues (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
_internalPrependValues (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
_addAssign_operation (const GGS_luint & argument_0) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur GGS_typeListeMessagesErreur::
operator + (const GGS_typeListeMessagesErreur & inOperand) const {
  GGS_typeListeMessagesErreur result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeMessagesErreur * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_luint  p_0 = p->mErrorMessageIndex ;
          result._internalAppendValues (p_0) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_luint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->mErrorMessageIndex) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur  GGS_typeListeMessagesErreur::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeMessagesErreur result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur  GGS_typeListeMessagesErreur::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_luint & argument_0
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeMessagesErreur result ;
  result._alloc () ;
  result._addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeMessagesErreur::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeMessagesErreur", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
method_first (C_Lexique & _inLexique,
              GGS_luint & _out_0
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mErrorMessageIndex ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
method_last (C_Lexique & _inLexique,
             GGS_luint & _out_0
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mErrorMessageIndex ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_luint & _out_0
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mErrorMessageIndex ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
modifier_popLast (C_Lexique & _inLexique,
                GGS_luint & _out_0
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->mErrorMessageIndex ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeEmissionParDefaut'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEmissionParDefaut::
cPtr_typeEmissionParDefaut (LOCATION_ARGS)
:C_GGS_Object (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEmissionParDefaut * GGS_typeEmissionParDefaut::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
      return mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeEmissionParDefaut::
appendForDescription (C_Lexique & /* _inLexique */,
                      C_String & ioString,
                      const sint32 /* inIndentation */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  ioString << "->@typeEmissionParDefaut:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEmissionParDefaut'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
GGS_typeEmissionParDefaut (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
GGS_typeEmissionParDefaut (const GGS_typeEmissionParDefaut & inOperand) {
  mPointer = (cPtr_typeEmissionParDefaut *) NULL ;
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
~GGS_typeEmissionParDefaut (void) {
  macroDetachPointer (mPointer, cPtr_typeEmissionParDefaut) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEmissionParDefaut::
operator = (const GGS_typeEmissionParDefaut & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEmissionParDefaut::
_drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeEmissionParDefaut) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEmissionParDefaut::
operator == (const GGS_typeEmissionParDefaut & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEmissionParDefaut::
operator != (const GGS_typeEmissionParDefaut & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEmissionParDefaut::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEmissionParDefaut" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeEmissionTerminalParDefaut'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEmissionTerminalParDefaut::
cPtr_typeEmissionTerminalParDefaut (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeEmissionParDefaut (THERE),
attributNomTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEmissionTerminalParDefaut * GGS_typeEmissionTerminalParDefaut::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEmissionTerminalParDefaut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEmissionTerminalParDefaut *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEmissionTerminalParDefaut::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEmissionTerminalParDefaut * _p = dynamic_cast <const cPtr_typeEmissionTerminalParDefaut *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributNomTerminal == _p->attributNomTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEmissionTerminalParDefaut::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEmissionTerminalParDefaut:"
           << attributNomTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeEmissionTerminalParDefaut'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEmissionTerminalParDefaut::
GGS_typeEmissionTerminalParDefaut (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionTerminalParDefaut::
GGS_typeEmissionTerminalParDefaut (const GGS_typeEmissionTerminalParDefaut & inOperand)
:GGS_typeEmissionParDefaut () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionTerminalParDefaut::
~GGS_typeEmissionTerminalParDefaut (void) {
  macroDetachPointer (mPointer, cPtr_typeEmissionTerminalParDefaut) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEmissionTerminalParDefaut::
operator = (const GGS_typeEmissionTerminalParDefaut & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionTerminalParDefaut GGS_typeEmissionTerminalParDefaut::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeEmissionTerminalParDefaut result ;
  macroMyNew (result.mPointer, cPtr_typeEmissionTerminalParDefaut (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeEmissionTerminalParDefaut::
reader_attributNomTerminal (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEmissionTerminalParDefaut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEmissionTerminalParDefaut *) mPointer)->attributNomTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEmissionTerminalParDefaut::
operator == (const GGS_typeEmissionTerminalParDefaut & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEmissionTerminalParDefaut::
operator != (const GGS_typeEmissionTerminalParDefaut & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEmissionTerminalParDefaut::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEmissionTerminalParDefaut" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeEmissionErreurParDefaut'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEmissionErreurParDefaut::
cPtr_typeEmissionErreurParDefaut (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeEmissionParDefaut (THERE),
mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEmissionErreurParDefaut * GGS_typeEmissionErreurParDefaut::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEmissionErreurParDefaut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeEmissionErreurParDefaut *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEmissionErreurParDefaut::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEmissionErreurParDefaut * _p = dynamic_cast <const cPtr_typeEmissionErreurParDefaut *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mErrorMessageIndex == _p->mErrorMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEmissionErreurParDefaut::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeEmissionErreurParDefaut:"
           << mErrorMessageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeEmissionErreurParDefaut'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEmissionErreurParDefaut::
GGS_typeEmissionErreurParDefaut (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionErreurParDefaut::
GGS_typeEmissionErreurParDefaut (const GGS_typeEmissionErreurParDefaut & inOperand)
:GGS_typeEmissionParDefaut () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionErreurParDefaut::
~GGS_typeEmissionErreurParDefaut (void) {
  macroDetachPointer (mPointer, cPtr_typeEmissionErreurParDefaut) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEmissionErreurParDefaut::
operator = (const GGS_typeEmissionErreurParDefaut & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionErreurParDefaut GGS_typeEmissionErreurParDefaut::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeEmissionErreurParDefaut result ;
  macroMyNew (result.mPointer, cPtr_typeEmissionErreurParDefaut (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeEmissionErreurParDefaut::
reader_mErrorMessageIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEmissionErreurParDefaut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEmissionErreurParDefaut *) mPointer)->mErrorMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEmissionErreurParDefaut::
operator == (const GGS_typeEmissionErreurParDefaut & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeEmissionErreurParDefaut::
operator != (const GGS_typeEmissionErreurParDefaut & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeEmissionErreurParDefaut::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeEmissionErreurParDefaut" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeListeRecherche'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeRecherche::
elementOf_GGS_typeListeRecherche (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1):
attributNomAttribut (argument_0),
attributNomTable (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeRecherche::
isEqualToElement (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeRecherche * _p = dynamic_cast <const elementOf_GGS_typeListeRecherche *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributNomAttribut == _p->attributNomAttribut).boolValue ()
         && (attributNomTable == _p->attributNomTable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeRecherche::
appendForListDescription (C_Lexique & _inLexique,
                          C_String & ioString,
                          const sint32 inIndentation
                          COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributNomAttribut.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributNomTable.reader_description  (_inLexique COMMA_THERE, inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeListeRecherche'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeRecherche::GGS_typeListeRecherche (void): AC_galgas_list () { // Default Constructor
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche::
GGS_typeListeRecherche (const GGS_typeListeRecherche & inSource): AC_galgas_list (inSource) {
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeRecherche::
operator == (const GGS_typeListeRecherche & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeListeRecherche::
operator != (const GGS_typeListeRecherche & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToList (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
_internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalAppendItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
_internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  _internalPrependItem (nouvelElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
_addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalAppendValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche GGS_typeListeRecherche::
operator + (const GGS_typeListeRecherche & inOperand) const {
  GGS_typeListeRecherche result ;
  if (_isBuilt () && inOperand._isBuilt ()) {
    if (count () == 0) {
      result = inOperand ;
    }else{
      result = * this ;
      if (inOperand.count () > 0) {
        result._insulateList () ;
        elementOf_GGS_typeListeRecherche * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->attributNomAttribut ;
          GGS_lstring  p_1 = p->attributNomTable ;
          result._internalAppendValues (p_0, p_1) ;
          p = p->nextObject () ;
        }
      }
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
modifier_prependValue (C_Lexique & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (_isBuilt ()) {
    _insulateList () ;
    _internalPrependValues (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
_insulateList (void) {
  if (_shared ()) {
    element_type * _p = firstObject () ;
    _alloc () ;
    while (_p != NULL) {
      macroValidPointer (_p) ;
      _internalAppendValues (_p->attributNomAttribut,
                                _p->attributNomTable) ;
      _p = _p->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche  GGS_typeListeRecherche::
constructor_emptyList (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeRecherche result ;
  result._alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche  GGS_typeListeRecherche::
constructor_listWithValue (C_Lexique & /* _inLexique */,
                           const GGS_lstring & argument_0,
                           const GGS_lstring & argument_1
                           COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeListeRecherche result ;
  result._alloc () ;
  result._addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeRecherche::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  return _description (_inLexique, "@typeListeRecherche", inIndentation COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
method_first (C_Lexique & _inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributNomAttribut ;
    _out_1 = _p->attributNomTable ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
method_last (C_Lexique & _inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributNomAttribut ;
    _out_1 = _p->attributNomTable ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
modifier_popFirst (C_Lexique & _inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = firstObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributNomAttribut ;
    _out_1 = _p->attributNomTable ;
    _insulateList () ;
    _internalRemoveFirst () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
modifier_popLast (C_Lexique & _inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  element_type * _p = NULL ;
  if (_isBuilt ()) {
    _p = lastObject () ;
    if (_p == NULL) {
      _inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (_p != NULL) {
    _out_0 = _p->attributNomAttribut ;
    _out_1 = _p->attributNomTable ;
    _insulateList () ;
    _internalRemoveLast () ;
  }else{
    _out_0._drop_operation () ;
    _out_1._drop_operation () ;
  }
}

//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeInstructionActionExterne'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionActionExterne::
cPtr_typeInstructionActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1,
                                const GGS_typeListeMessagesErreur & argument_2 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
attributNomRoutineExterne (argument_0),
attributListeArguments (argument_1),
attributListeMessageErreur (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionActionExterne * GGS_typeInstructionActionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionActionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionActionExterne::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionActionExterne * _p = dynamic_cast <const cPtr_typeInstructionActionExterne *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributNomRoutineExterne == _p->attributNomRoutineExterne).boolValue ()
         && (attributListeArguments == _p->attributListeArguments).boolValue ()
         && (attributListeMessageErreur == _p->attributListeMessageErreur).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionActionExterne::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionActionExterne:"
           << attributNomRoutineExterne.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << attributListeArguments.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << attributListeMessageErreur.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionActionExterne'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionActionExterne::
GGS_typeInstructionActionExterne (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionActionExterne::
GGS_typeInstructionActionExterne (const GGS_typeInstructionActionExterne & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionActionExterne::
~GGS_typeInstructionActionExterne (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionActionExterne) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionActionExterne::
operator = (const GGS_typeInstructionActionExterne & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionActionExterne GGS_typeInstructionActionExterne::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeArgumentsRoutExterne & argument_1,
                 const GGS_typeListeMessagesErreur & argument_2 COMMA_LOCATION_ARGS) {
  GGS_typeInstructionActionExterne result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionActionExterne (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionActionExterne::
reader_attributNomRoutineExterne (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionActionExterne *) mPointer)->attributNomRoutineExterne ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeInstructionActionExterne::
reader_attributListeArguments (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeArgumentsRoutExterne   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionActionExterne *) mPointer)->attributListeArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur  GGS_typeInstructionActionExterne::
reader_attributListeMessageErreur (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeMessagesErreur   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionActionExterne *) mPointer)->attributListeMessageErreur ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionActionExterne::
operator == (const GGS_typeInstructionActionExterne & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionActionExterne::
operator != (const GGS_typeInstructionActionExterne & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionActionExterne::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionActionExterne" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         abstract class 'cPtr_typeInstructionRepetitionLexicale'           *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionRepetitionLexicale::
cPtr_typeInstructionRepetitionLexicale (const GGS_tListeInstructionsLexicales & argument_0,
                                const GGS_typeListeTestsEtInstructions & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
attributListeInstructionsDebut (argument_0),
attributListeBranches (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionRepetitionLexicale * GGS_typeInstructionRepetitionLexicale::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionRepetitionLexicale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionRepetitionLexicale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionRepetitionLexicale::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionRepetitionLexicale * _p = dynamic_cast <const cPtr_typeInstructionRepetitionLexicale *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributListeInstructionsDebut == _p->attributListeInstructionsDebut).boolValue ()
         && (attributListeBranches == _p->attributListeBranches).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionRepetitionLexicale::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionRepetitionLexicale:"
           << attributListeInstructionsDebut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << attributListeBranches.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionRepetitionLexicale'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionRepetitionLexicale::
GGS_typeInstructionRepetitionLexicale (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionRepetitionLexicale::
GGS_typeInstructionRepetitionLexicale (const GGS_typeInstructionRepetitionLexicale & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionRepetitionLexicale::
~GGS_typeInstructionRepetitionLexicale (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionRepetitionLexicale) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionRepetitionLexicale::
operator = (const GGS_typeInstructionRepetitionLexicale & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionRepetitionLexicale GGS_typeInstructionRepetitionLexicale::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_tListeInstructionsLexicales & argument_0,
                 const GGS_typeListeTestsEtInstructions & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeInstructionRepetitionLexicale result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionRepetitionLexicale (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_typeInstructionRepetitionLexicale::
reader_attributListeInstructionsDebut (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tListeInstructionsLexicales   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionRepetitionLexicale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionRepetitionLexicale *) mPointer)->attributListeInstructionsDebut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeInstructionRepetitionLexicale::
reader_attributListeBranches (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeTestsEtInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionRepetitionLexicale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionRepetitionLexicale *) mPointer)->attributListeBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionRepetitionLexicale::
operator == (const GGS_typeInstructionRepetitionLexicale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionRepetitionLexicale::
operator != (const GGS_typeInstructionRepetitionLexicale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionRepetitionLexicale::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionRepetitionLexicale" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeInstructionSiLexical'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionSiLexical::
cPtr_typeInstructionSiLexical (const GGS_typeListeTestsEtInstructions & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
attributListeBranches (argument_0),
attributBrancheSinon (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionSiLexical * GGS_typeInstructionSiLexical::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionSiLexical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionSiLexical *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionSiLexical::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionSiLexical * _p = dynamic_cast <const cPtr_typeInstructionSiLexical *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributListeBranches == _p->attributListeBranches).boolValue ()
         && (attributBrancheSinon == _p->attributBrancheSinon).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionSiLexical::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionSiLexical:"
           << attributListeBranches.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << attributBrancheSinon.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeInstructionSiLexical'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionSiLexical::
GGS_typeInstructionSiLexical (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionSiLexical::
GGS_typeInstructionSiLexical (const GGS_typeInstructionSiLexical & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionSiLexical::
~GGS_typeInstructionSiLexical (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionSiLexical) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionSiLexical::
operator = (const GGS_typeInstructionSiLexical & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionSiLexical GGS_typeInstructionSiLexical::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListeTestsEtInstructions & argument_0,
                 const GGS_tListeInstructionsLexicales & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeInstructionSiLexical result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionSiLexical (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeInstructionSiLexical::
reader_attributListeBranches (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeTestsEtInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionSiLexical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionSiLexical *) mPointer)->attributListeBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_typeInstructionSiLexical::
reader_attributBrancheSinon (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tListeInstructionsLexicales   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionSiLexical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionSiLexical *) mPointer)->attributBrancheSinon ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionSiLexical::
operator == (const GGS_typeInstructionSiLexical & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionSiLexical::
operator != (const GGS_typeInstructionSiLexical & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionSiLexical::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionSiLexical" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            abstract class 'cPtr_typeInstructionEmettreSimple'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionEmettreSimple::
cPtr_typeInstructionEmettreSimple (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionEmettreSimple * GGS_typeInstructionEmettreSimple::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionEmettreSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionEmettreSimple *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionEmettreSimple::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionEmettreSimple * _p = dynamic_cast <const cPtr_typeInstructionEmettreSimple *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTerminal == _p->mTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionEmettreSimple::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionEmettreSimple:"
           << mTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionEmettreSimple'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionEmettreSimple::
GGS_typeInstructionEmettreSimple (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettreSimple::
GGS_typeInstructionEmettreSimple (const GGS_typeInstructionEmettreSimple & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettreSimple::
~GGS_typeInstructionEmettreSimple (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionEmettreSimple) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionEmettreSimple::
operator = (const GGS_typeInstructionEmettreSimple & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettreSimple GGS_typeInstructionEmettreSimple::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeInstructionEmettreSimple result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionEmettreSimple (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionEmettreSimple::
reader_mTerminal (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionEmettreSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionEmettreSimple *) mPointer)->mTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionEmettreSimple::
operator == (const GGS_typeInstructionEmettreSimple & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionEmettreSimple::
operator != (const GGS_typeInstructionEmettreSimple & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionEmettreSimple::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionEmettreSimple" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLexicalDropInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLexicalDropInstruction::
cPtr_typeLexicalDropInstruction (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLexicalDropInstruction * GGS_typeLexicalDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLexicalDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLexicalDropInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLexicalDropInstruction * _p = dynamic_cast <const cPtr_typeLexicalDropInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mTerminal == _p->mTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLexicalDropInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLexicalDropInstruction:"
           << mTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLexicalDropInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLexicalDropInstruction::
GGS_typeLexicalDropInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalDropInstruction::
GGS_typeLexicalDropInstruction (const GGS_typeLexicalDropInstruction & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalDropInstruction::
~GGS_typeLexicalDropInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeLexicalDropInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalDropInstruction::
operator = (const GGS_typeLexicalDropInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalDropInstruction GGS_typeLexicalDropInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeLexicalDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLexicalDropInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLexicalDropInstruction::
reader_mTerminal (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLexicalDropInstruction *) mPointer)->mTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalDropInstruction::
operator == (const GGS_typeLexicalDropInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalDropInstruction::
operator != (const GGS_typeLexicalDropInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLexicalDropInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLexicalDropInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeLexicalTagInstruction'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLexicalTagInstruction::
cPtr_typeLexicalTagInstruction (const GGS_lstring & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mLexicalTagName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLexicalTagInstruction * GGS_typeLexicalTagInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLexicalTagInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLexicalTagInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLexicalTagInstruction * _p = dynamic_cast <const cPtr_typeLexicalTagInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLexicalTagName == _p->mLexicalTagName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLexicalTagInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLexicalTagInstruction:"
           << mLexicalTagName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLexicalTagInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLexicalTagInstruction::
GGS_typeLexicalTagInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalTagInstruction::
GGS_typeLexicalTagInstruction (const GGS_typeLexicalTagInstruction & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalTagInstruction::
~GGS_typeLexicalTagInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeLexicalTagInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalTagInstruction::
operator = (const GGS_typeLexicalTagInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalTagInstruction GGS_typeLexicalTagInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeLexicalTagInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLexicalTagInstruction (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLexicalTagInstruction::
reader_mLexicalTagName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLexicalTagInstruction *) mPointer)->mLexicalTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalTagInstruction::
operator == (const GGS_typeLexicalTagInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalTagInstruction::
operator != (const GGS_typeLexicalTagInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLexicalTagInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLexicalTagInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        abstract class 'cPtr_typeLexicalRewindAndSendInstruction'          *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLexicalRewindAndSendInstruction::
cPtr_typeLexicalRewindAndSendInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mLexicalTagName (argument_0),
mTerminal (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLexicalRewindAndSendInstruction * GGS_typeLexicalRewindAndSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalRewindAndSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeLexicalRewindAndSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLexicalRewindAndSendInstruction::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLexicalRewindAndSendInstruction * _p = dynamic_cast <const cPtr_typeLexicalRewindAndSendInstruction *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mLexicalTagName == _p->mLexicalTagName).boolValue ()
         && (mTerminal == _p->mTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLexicalRewindAndSendInstruction::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeLexicalRewindAndSendInstruction:"
           << mLexicalTagName.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << mTerminal.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeLexicalRewindAndSendInstruction'           *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLexicalRewindAndSendInstruction::
GGS_typeLexicalRewindAndSendInstruction (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalRewindAndSendInstruction::
GGS_typeLexicalRewindAndSendInstruction (const GGS_typeLexicalRewindAndSendInstruction & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalRewindAndSendInstruction::
~GGS_typeLexicalRewindAndSendInstruction (void) {
  macroDetachPointer (mPointer, cPtr_typeLexicalRewindAndSendInstruction) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalRewindAndSendInstruction::
operator = (const GGS_typeLexicalRewindAndSendInstruction & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalRewindAndSendInstruction GGS_typeLexicalRewindAndSendInstruction::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeLexicalRewindAndSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLexicalRewindAndSendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLexicalRewindAndSendInstruction::
reader_mLexicalTagName (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalRewindAndSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLexicalRewindAndSendInstruction *) mPointer)->mLexicalTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLexicalRewindAndSendInstruction::
reader_mTerminal (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalRewindAndSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLexicalRewindAndSendInstruction *) mPointer)->mTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalRewindAndSendInstruction::
operator == (const GGS_typeLexicalRewindAndSendInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalRewindAndSendInstruction::
operator != (const GGS_typeLexicalRewindAndSendInstruction & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLexicalRewindAndSendInstruction::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeLexicalRewindAndSendInstruction" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeInstructionEmettre'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionEmettre::
cPtr_typeInstructionEmettre (const GGS_typeListeRecherche & argument_0,
                                const GGS_typeEmissionParDefaut & argument_1 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
attributListeRecherches (argument_0),
attributEmissionParDefaut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionEmettre * GGS_typeInstructionEmettre::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionEmettre *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionEmettre *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionEmettre::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionEmettre * _p = dynamic_cast <const cPtr_typeInstructionEmettre *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (attributListeRecherches == _p->attributListeRecherches).boolValue ()
         && (attributEmissionParDefaut == _p->attributEmissionParDefaut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionEmettre::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionEmettre:"
           << attributListeRecherches.reader_description  (_inLexique COMMA_THERE, inIndentation + 1)
           << attributEmissionParDefaut.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionEmettre'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionEmettre::
GGS_typeInstructionEmettre (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettre::
GGS_typeInstructionEmettre (const GGS_typeInstructionEmettre & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettre::
~GGS_typeInstructionEmettre (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionEmettre) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionEmettre::
operator = (const GGS_typeInstructionEmettre & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettre GGS_typeInstructionEmettre::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_typeListeRecherche & argument_0,
                 const GGS_typeEmissionParDefaut & argument_1 COMMA_LOCATION_ARGS) {
  GGS_typeInstructionEmettre result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionEmettre (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche  GGS_typeInstructionEmettre::
reader_attributListeRecherches (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeRecherche   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionEmettre *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionEmettre *) mPointer)->attributListeRecherches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut  GGS_typeInstructionEmettre::
reader_attributEmissionParDefaut (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEmissionParDefaut   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionEmettre *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionEmettre *) mPointer)->attributEmissionParDefaut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionEmettre::
operator == (const GGS_typeInstructionEmettre & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionEmettre::
operator != (const GGS_typeInstructionEmettre & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionEmettre::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionEmettre" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           abstract class 'cPtr_typeInstructionErreurLexicale'             *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionErreurLexicale::
cPtr_typeInstructionErreurLexicale (const GGS_luint & argument_0 COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionErreurLexicale * GGS_typeInstructionErreurLexicale::
  operator () (LOCATION_ARGS) const {
    macroValidPointerThere (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionErreurLexicale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    return (cPtr_typeInstructionErreurLexicale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionErreurLexicale::
isEqualToObject (const C_GGS_Object * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionErreurLexicale * _p = dynamic_cast <const cPtr_typeInstructionErreurLexicale *> (inOperand) ;
    macroValidPointer (_p) ;
    equal = (mErrorMessageIndex == _p->mErrorMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionErreurLexicale::
appendForDescription (C_Lexique & _inLexique,
                      C_String & ioString,
                      const sint32 inIndentation
                      COMMA_LOCATION_ARGS) const {
  ioString << "->@typeInstructionErreurLexicale:"
           << mErrorMessageIndex.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionErreurLexicale'              *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionErreurLexicale::
GGS_typeInstructionErreurLexicale (void) {
  mPointer = NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionErreurLexicale::
GGS_typeInstructionErreurLexicale (const GGS_typeInstructionErreurLexicale & inOperand)
:GGS_typeInstructionLexicale () {
  macroAssignPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionErreurLexicale::
~GGS_typeInstructionErreurLexicale (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionErreurLexicale) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionErreurLexicale::
operator = (const GGS_typeInstructionErreurLexicale & inSource) {
  macroAssignPointer (mPointer, inSource.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionErreurLexicale GGS_typeInstructionErreurLexicale::
constructor_new (C_Lexique & /* inLexique */,
                 const GGS_luint & argument_0 COMMA_LOCATION_ARGS) {
  GGS_typeInstructionErreurLexicale result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionErreurLexicale (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeInstructionErreurLexicale::
reader_mErrorMessageIndex (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionErreurLexicale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionErreurLexicale *) mPointer)->mErrorMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionErreurLexicale::
operator == (const GGS_typeInstructionErreurLexicale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), equal) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeInstructionErreurLexicale::
operator != (const GGS_typeInstructionErreurLexicale & inOperand) const {
  bool equal = mPointer == inOperand.mPointer ;
  if (_isBuilt () && inOperand._isBuilt () && ! equal) {
    equal = mPointer->isEqualToObject (inOperand.mPointer) ;
  }
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! equal) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeInstructionErreurLexicale::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<class @typeInstructionErreurLexicale" ;
  if (_isBuilt ()) {
    mPointer->appendForDescription (_inLexique, s, inIndentation + 1 COMMA_THERE) ;
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "appendToLexicalInstructionList"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_appendToLexicalInstructionList (C_Lexique & _inLexique,
                                GGS_typeListeTestsEtInstructions  & var_cas_ioLexicalRulesList,
                                const GGS_lstring  & var_cas_ioDefinitionString,
                                GGS_lstring  & var_cas_ioTerminalSymbolName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_appendToLexicalInstructionList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeConditionsLexicales  var_cas_lexicalConditionsList ;
  var_cas_lexicalConditionsList = GGS_typeListeConditionsLexicales::constructor_emptyList (_inLexique COMMA_HERE) ;
  GGS_typeConditionLexicale  var_cas_c ;
  var_cas_c = GGS_typeConditionChaine::constructor_new (_inLexique, var_cas_ioDefinitionString COMMA_HERE) ;
  var_cas_lexicalConditionsList._addAssign_operation (var_cas_c) ;
  GGS_typeInstructionLexicale  var_cas_lexicalInstruction ;
  var_cas_lexicalInstruction = GGS_typeInstructionEmettreSimple::constructor_new (_inLexique, var_cas_ioTerminalSymbolName COMMA_HERE) ;
  GGS_tListeInstructionsLexicales  var_cas_instructionList ;
  var_cas_instructionList = GGS_tListeInstructionsLexicales::constructor_emptyList (_inLexique COMMA_HERE) ;
  var_cas_instructionList._addAssign_operation (var_cas_lexicalInstruction) ;
  var_cas_ioLexicalRulesList._addAssign_operation (var_cas_lexicalConditionsList, var_cas_instructionList) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_appendToLexicalInstructionList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@tokensInListMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_tokensInListMap::
elementOf_GGS_tokensInListMap (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_tokensInListMap & inInfo) :
AC_galgas_map_element (inKey, inIndex),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_tokensInListMap::
appendForMapDescription (C_Lexique & _inLexique,
                         const sint32 inElementIndex,
                         C_String & ioString,
                         const sint32 inIndentation
                         COMMA_LOCATION_ARGS) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " << inElementIndex << ":" << mKey.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " << inElementIndex << ":" << mInfo.mTerminalSymbol.reader_description  (_inLexique COMMA_THERE, inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_tokensInListMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_tokensInListMap * _p = dynamic_cast <const elementOf_GGS_tokensInListMap *> (inOperand) ;
  macroValidPointer (_p) ;
  return (mInfo.mTerminalSymbol == _p->mInfo.mTerminalSymbol).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_tokensInListMap::
new_element (const GGS_lstring & inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <e_tokensInListMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_tokensInListMap * info = (e_tokensInListMap *) inInfo ;
  macroMyNew (p, element_type (inKey, nextIndex (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

GGS_tokensInListMap GGS_tokensInListMap::
constructor_emptyMap (C_Lexique & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tokensInListMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
enterIndex (const GGS_lstring & inKey,
            AC_galgas_index_core & outIndex) {
  e_tokensInListMap info  ;
  internalEnterIndex (inKey, (void *) & info, outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tokensInListMap::
operator == (const GGS_tokensInListMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tokensInListMap::
operator != (const GGS_tokensInListMap & inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  sint32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, mSharedMapRoot->rootForKey (inPtr->mKey), attributeIndex, existingKeyLocation) ;
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
_insertElement (C_Lexique & inLexique,
                const char * inErrorMessage,
                const GGS_lstring & inKey,
                const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  sint32 elementID = - 1 ;
  if (_isBuilt ()
   && inParameter0._isBuilt ()
   && inKey._isBuilt ()) {
    insulateMap () ;
    e_tokensInListMap info  ;
    info.mTerminalSymbol = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, mSharedMapRoot->rootForKey (inKey), elementID, existingKeyLocation) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (uint32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
_searchElement (C_Lexique & inLexique,
               const char * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  element_type * node = NULL  ;
  if (_isBuilt () && inKey._isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      emitMapSemanticErrorMessage (inLexique, inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0._drop_operation () ;
    if (outIndex != NULL) {
      outIndex->_drop_operation () ;
     }
  }else{
    outParameter0 = node->mInfo.mTerminalSymbol ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
method_searchKey (C_Lexique & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  _searchElement (inLexique,
                  "the '%K' character is not declared",
                  inKey,
                  outParameter0,
                  NULL
                  COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
modifier_insertKey (C_Lexique & _inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  _insertElement (_inLexique,
                 "the '%K' character is already declared in %L",
                 inKey,
                 inParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_tokensInListMap GGS_tokensInListMap::
constructor_mapWithMapToOverride (C_Lexique & /* inLexique */,
                                  const GGS_tokensInListMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tokensInListMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tokensInListMap GGS_tokensInListMap::
reader_overriddenMap (C_Lexique & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tokensInListMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tokensInListMap::
reader_description (C_Lexique & _inLexique
                    COMMA_LOCATION_ARGS,
                    const sint32 inIndentation) const {
  C_String s ;
  s << "<map @tokensInListMap " ;
  if (_isBuilt ()) {
    s << count () << " object" << ((count () > 1) ? "s " : " ") ;
    element_type * p = firstObject () ;
    sint32 elementID = 0 ;
    while (p != NULL) {
      macroValidPointer (p) ;
      p->appendForMapDescription (_inLexique, elementID, s, inIndentation COMMA_THERE) ;
      p = p->nextObject () ;
      elementID ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

