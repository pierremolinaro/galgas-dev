//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'scanner_semantics.cpp'                        *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                        may 3rd, 2010, at 20h26'3"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas/C_galgas_CLI_Options.h"
#include "scanner_semantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "scanner_semantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'e_templateDelimiterMap'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_templateDelimiterMap::e_templateDelimiterMap (void) :
mPreservesStartDelimiter (),
mEndString () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@templateDelimiterMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateDelimiterMap ("templateDelimiterMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_templateDelimiterMap::
elementOf_GGS_templateDelimiterMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_templateDelimiterMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateDelimiterMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mPreservesStartDelimiter.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mEndString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateDelimiterMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_templateDelimiterMap * ptr = dynamic_cast <const elementOf_GGS_templateDelimiterMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mPreservesStartDelimiter.operator_isEqual (ptr->mInfo.mPreservesStartDelimiter)).boolValue ()
           && (mInfo.mEndString.operator_isEqual (ptr->mInfo.mEndString)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_templateDelimiterMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_templateDelimiterMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_templateDelimiterMap * info = (e_templateDelimiterMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimiterMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_templateDelimiterMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_templateDelimiterMap * info = (e_templateDelimiterMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_templateDelimiterMap GGS_templateDelimiterMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_templateDelimiterMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimiterMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_templateDelimiterMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_templateDelimiterMap::
operator_isEqual (const GGS_templateDelimiterMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_templateDelimiterMap::
operator_isNotEqual (const GGS_templateDelimiterMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimiterMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_templateDelimiterMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_bool& inParameter0,
               const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_templateDelimiterMap info  ;
    info.mPreservesStartDelimiter = inParameter0 ;
    info.mEndString = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateDelimiterMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_bool  & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mPreservesStartDelimiter ;
    outParameter1 = node->mInfo.mEndString ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_templateDelimiterMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_templateDelimiterMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_bool  & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_templateDelimiterMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_templateDelimiterMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_bool& inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_templateDelimiterMap GGS_templateDelimiterMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_templateDelimiterMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_templateDelimiterMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateDelimiterMap GGS_templateDelimiterMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateDelimiterMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateDelimiterMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @templateDelimiterMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_templateDelimiterMap::cEnumerator::_mPreservesStartDelimiter (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mPreservesStartDelimiter ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateDelimiterMap::cEnumerator::_mEndString (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mEndString ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateDelimiterMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateDelimiterMap * p = NULL ;
    macroMyNew (p, GGS_templateDelimiterMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateDelimiterMap GGS_templateDelimiterMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateDelimiterMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateDelimiterMap * p = dynamic_cast <const GGS_templateDelimiterMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateDelimiterMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateDelimiterMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateDelimiterMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_templateReplacementMap'                      *
//                                                                           *
//---------------------------------------------------------------------------*

e_templateReplacementMap::e_templateReplacementMap (void) :
mReplacedString (),
mReplacementFunction () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map '@templateReplacementMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateReplacementMap ("templateReplacementMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_templateReplacementMap::
elementOf_GGS_templateReplacementMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_templateReplacementMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateReplacementMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReplacedString.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mReplacementFunction.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateReplacementMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_templateReplacementMap * ptr = dynamic_cast <const elementOf_GGS_templateReplacementMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mReplacedString.operator_isEqual (ptr->mInfo.mReplacedString)).boolValue ()
           && (mInfo.mReplacementFunction.operator_isEqual (ptr->mInfo.mReplacementFunction)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_templateReplacementMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_templateReplacementMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_templateReplacementMap * info = (e_templateReplacementMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_templateReplacementMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_templateReplacementMap * info = (e_templateReplacementMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementMap GGS_templateReplacementMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_templateReplacementMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_templateReplacementMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_templateReplacementMap::
operator_isEqual (const GGS_templateReplacementMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_templateReplacementMap::
operator_isNotEqual (const GGS_templateReplacementMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
               const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_templateReplacementMap info  ;
    info.mReplacedString = inParameter0 ;
    info.mReplacementFunction = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateReplacementMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mReplacedString ;
    outParameter1 = node->mInfo.mReplacementFunction ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_templateReplacementMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_templateReplacementMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_templateReplacementMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('p'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('e'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_templateReplacementMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementMap GGS_templateReplacementMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_templateReplacementMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_templateReplacementMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementMap GGS_templateReplacementMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateReplacementMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateReplacementMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @templateReplacementMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementMap::cEnumerator::_mReplacedString (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReplacedString ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_templateReplacementMap::cEnumerator::_mReplacementFunction (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mReplacementFunction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateReplacementMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateReplacementMap * p = NULL ;
    macroMyNew (p, GGS_templateReplacementMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReplacementMap GGS_templateReplacementMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateReplacementMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateReplacementMap * p = dynamic_cast <const GGS_templateReplacementMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateReplacementMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateReplacementMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateReplacementMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_typeLexicalAttributesMap'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeLexicalAttributesMap::e_typeLexicalAttributesMap (void) :
attributType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@typeLexicalAttributesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLexicalAttributesMap ("typeLexicalAttributesMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeLexicalAttributesMap::
elementOf_GGS_typeLexicalAttributesMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeLexicalAttributesMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeLexicalAttributesMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.attributType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeLexicalAttributesMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeLexicalAttributesMap * ptr = dynamic_cast <const elementOf_GGS_typeLexicalAttributesMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.attributType.operator_isEqual (ptr->mInfo.attributType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeLexicalAttributesMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeLexicalAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeLexicalAttributesMap * info = (e_typeLexicalAttributesMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeLexicalAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeLexicalAttributesMap * info = (e_typeLexicalAttributesMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap GGS_typeLexicalAttributesMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeLexicalAttributesMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeLexicalAttributesMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalAttributesMap::
operator_isEqual (const GGS_typeLexicalAttributesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalAttributesMap::
operator_isNotEqual (const GGS_typeLexicalAttributesMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeLexicalAttributesMap info  ;
    info.attributType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.attributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeLexicalAttributesMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeLexicalAttributesMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE ('x'),
  TO_UNICODE ('i'),
  TO_UNICODE ('c'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('t'),
  TO_UNICODE ('t'),
  TO_UNICODE ('r'),
  TO_UNICODE ('i'),
  TO_UNICODE ('b'),
  TO_UNICODE ('u'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap GGS_typeLexicalAttributesMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeLexicalAttributesMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeLexicalAttributesMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap GGS_typeLexicalAttributesMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeLexicalAttributesMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeLexicalAttributesMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeLexicalAttributesMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_typeLexicalAttributesMap::cEnumerator::_attributType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.attributType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeLexicalAttributesMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLexicalAttributesMap * p = NULL ;
    macroMyNew (p, GGS_typeLexicalAttributesMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap GGS_typeLexicalAttributesMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLexicalAttributesMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLexicalAttributesMap * p = dynamic_cast <const GGS_typeLexicalAttributesMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLexicalAttributesMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLexicalAttributesMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLexicalAttributesMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map '@tagMap'                             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_tagMap ("tagMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_tagMap::
elementOf_GGS_tagMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_tagMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_tagMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_tagMap::
isEqualToMapElement (const AC_galgas_map_element * /* inOperand */) const {
  return true ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_tagMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_tagMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_tagMap * info = (e_tagMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_tagMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_tagMap * info = (e_tagMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_tagMap GGS_tagMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tagMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_tagMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tagMap::
operator_isEqual (const GGS_tagMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tagMap::
operator_isNotEqual (const GGS_tagMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_tagMap info  ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tagMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_tagMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_tagMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_tagMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

const utf32 GGS_tagMap::kShadowMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_tagMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey COMMA_LOCATION_ARGS) {
  const bool shadowExists = internal_search_in_overridden_maps (inKey) != NULL ;
  if (shadowExists) {
    inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, kShadowMessage_insertKey COMMA_THERE) ;
  }else{
    insertElement (inLexique,
                   0,
                   kInsertMessage_insertKey,
                   inKey,
                  NULL
                  COMMA_THERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_tagMap GGS_tagMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_tagMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tagMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tagMap GGS_tagMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tagMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tagMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @tagMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_tagMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_tagMap * p = NULL ;
    macroMyNew (p, GGS_tagMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tagMap GGS_tagMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_tagMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_tagMap * p = dynamic_cast <const GGS_tagMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_tagMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_tagMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_tagMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_EXLexicalTypeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

e_EXLexicalTypeMap::e_EXLexicalTypeMap (void) :
mAttributType () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      class map '@EXLexicalTypeMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_EXLexicalTypeMap ("EXLexicalTypeMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_EXLexicalTypeMap::
elementOf_GGS_EXLexicalTypeMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_EXLexicalTypeMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_EXLexicalTypeMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mAttributType.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_EXLexicalTypeMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_EXLexicalTypeMap * ptr = dynamic_cast <const elementOf_GGS_EXLexicalTypeMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mAttributType.operator_isEqual (ptr->mInfo.mAttributType)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_EXLexicalTypeMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_EXLexicalTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_EXLexicalTypeMap * info = (e_EXLexicalTypeMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_EXLexicalTypeMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_EXLexicalTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_EXLexicalTypeMap * info = (e_EXLexicalTypeMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_EXLexicalTypeMap GGS_EXLexicalTypeMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXLexicalTypeMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_EXLexicalTypeMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_EXLexicalTypeMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXLexicalTypeMap::
operator_isEqual (const GGS_EXLexicalTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_EXLexicalTypeMap::
operator_isNotEqual (const GGS_EXLexicalTypeMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_EXLexicalTypeMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_EXLexicalTypeMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_AC_galgasType & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_EXLexicalTypeMap info  ;
    info.mAttributType = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_EXLexicalTypeMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_AC_galgasType   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mAttributType ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXLexicalTypeMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('p'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('@'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXLexicalTypeMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_EXLexicalTypeMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('-'),
  TO_UNICODE ('-'),
  TO_UNICODE ('-'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('-'),
  TO_UNICODE ('-'),
  TO_UNICODE ('-'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_EXLexicalTypeMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_EXLexicalTypeMap GGS_EXLexicalTypeMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_EXLexicalTypeMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_EXLexicalTypeMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXLexicalTypeMap GGS_EXLexicalTypeMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_EXLexicalTypeMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_EXLexicalTypeMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @EXLexicalTypeMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_AC_galgasType  & GGS_EXLexicalTypeMap::cEnumerator::_mAttributType (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mAttributType ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_EXLexicalTypeMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_EXLexicalTypeMap * p = NULL ;
    macroMyNew (p, GGS_EXLexicalTypeMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_EXLexicalTypeMap GGS_EXLexicalTypeMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_EXLexicalTypeMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_EXLexicalTypeMap * p = dynamic_cast <const GGS_EXLexicalTypeMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_EXLexicalTypeMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_EXLexicalTypeMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_EXLexicalTypeMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'e_typeTableMessagesErreurs'                     *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableMessagesErreurs::e_typeTableMessagesErreurs (void) :
mMesssageIndex (),
mErrorMessage () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class map '@typeTableMessagesErreurs'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableMessagesErreurs ("typeTableMessagesErreurs", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableMessagesErreurs::
elementOf_GGS_typeTableMessagesErreurs (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableMessagesErreurs & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableMessagesErreurs::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mMesssageIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mErrorMessage.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableMessagesErreurs::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableMessagesErreurs * ptr = dynamic_cast <const elementOf_GGS_typeTableMessagesErreurs *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mMesssageIndex.operator_isEqual (ptr->mInfo.mMesssageIndex)).boolValue ()
           && (mInfo.mErrorMessage.operator_isEqual (ptr->mInfo.mErrorMessage)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMessagesErreurs::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableMessagesErreurs *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableMessagesErreurs * info = (e_typeTableMessagesErreurs *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableMessagesErreurs *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableMessagesErreurs * info = (e_typeTableMessagesErreurs *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs GGS_typeTableMessagesErreurs::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMessagesErreurs result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableMessagesErreurs info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMessagesErreurs::
operator_isEqual (const GGS_typeTableMessagesErreurs & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMessagesErreurs::
operator_isNotEqual (const GGS_typeTableMessagesErreurs & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
               const GGS_lstring & inParameter1,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableMessagesErreurs info  ;
    info.mMesssageIndex = inParameter0 ;
    info.mErrorMessage = inParameter1 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_lstring   & outParameter1,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mMesssageIndex ;
    outParameter1 = node->mInfo.mErrorMessage ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableMessagesErreurs::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0,
                                GGS_lstring   & outParameter1 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableMessagesErreurs::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('r'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('e'),
  TO_UNICODE ('s'),
  TO_UNICODE ('s'),
  TO_UNICODE ('a'),
  TO_UNICODE ('g'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0,
                                const GGS_lstring & inParameter1 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs GGS_typeTableMessagesErreurs::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableMessagesErreurs & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMessagesErreurs result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs GGS_typeTableMessagesErreurs::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMessagesErreurs result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMessagesErreurs::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableMessagesErreurs " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_typeTableMessagesErreurs::cEnumerator::_mMesssageIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mMesssageIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeTableMessagesErreurs::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mErrorMessage ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableMessagesErreurs::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableMessagesErreurs * p = NULL ;
    macroMyNew (p, GGS_typeTableMessagesErreurs (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs GGS_typeTableMessagesErreurs::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableMessagesErreurs result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableMessagesErreurs * p = dynamic_cast <const GGS_typeTableMessagesErreurs *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableMessagesErreurs, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableMessagesErreurs::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableMessagesErreurs ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            class 'e_M_styles'                             *
//                                                                           *
//---------------------------------------------------------------------------*

e_M_styles::e_M_styles (void) :
mStyleIndex () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          class map '@M_styles'                            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_M_styles ("M_styles", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_M_styles::
elementOf_GGS_M_styles (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_M_styles & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_M_styles::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStyleIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_M_styles::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_M_styles * ptr = dynamic_cast <const elementOf_GGS_M_styles *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mStyleIndex.operator_isEqual (ptr->mInfo.mStyleIndex)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_styles::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_M_styles *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_M_styles * info = (e_M_styles *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_styles *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_M_styles * info = (e_M_styles *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_M_styles GGS_M_styles::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_styles result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_M_styles info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_styles::
operator_isEqual (const GGS_M_styles & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_styles::
operator_isNotEqual (const GGS_M_styles & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_uint & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_M_styles info  ;
    info.mStyleIndex = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_uint   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mStyleIndex ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_styles::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_styles::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_uint   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_M_styles::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('t'),
  TO_UNICODE ('y'),
  TO_UNICODE ('l'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_M_styles::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_uint & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_M_styles GGS_M_styles::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_M_styles & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_M_styles result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_styles GGS_M_styles::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_M_styles result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_M_styles::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @M_styles " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_M_styles::cEnumerator::_mStyleIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStyleIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_M_styles::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_M_styles * p = NULL ;
    macroMyNew (p, GGS_M_styles (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_styles GGS_M_styles::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_M_styles result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_M_styles * p = dynamic_cast <const GGS_M_styles *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_M_styles, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_M_styles::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_M_styles ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       Element of list '@styleList'                        *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_styleList::
elementOf_GGS_styleList (const GGS_string& argument_0,
                                const GGS_string& argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mStyleName (argument_0),
mTitle (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_styleList::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_styleList * ptr = dynamic_cast <const elementOf_GGS_styleList *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStyleName.operator_isEqual (ptr->mStyleName).boolValue ()
         && mTitle.operator_isEqual (ptr->mTitle).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_styleList::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mStyleName.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mTitle.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            List '@styleList'                              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_styleList ("styleList", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_styleList::
internalAppendValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_styleList::
internalPrependValues (const GGS_string& argument_0,
                    const GGS_string& argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_styleList::
addAssign_operation (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_styleList GGS_styleList::
operator_concat (const GGS_styleList & inOperand) const {
  GGS_styleList result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_styleList::
dotAssign_operation (const GGS_styleList inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_styleList * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_string p_0 = p->mStyleName ;
          GGS_string p_1 = p->mTitle ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_styleList::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_string& argument_0,
                     const GGS_string& argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_styleList::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mStyleName,
                                ptr->mTitle
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_styleList  GGS_styleList::
constructor_emptyList (void) {
  GGS_styleList result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_styleList  GGS_styleList::
constructor_listWithValue (const GGS_string& argument_0,
                                const GGS_string& argument_1) {
  GGS_styleList result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_styleList::
internalSubListWithRange (GGS_styleList & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mStyleName, ptr->mTitle) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_styleList GGS_styleList::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_styleList result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_styleList GGS_styleList::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_styleList result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_styleList::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@styleList", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_styleList::
method_first (C_Compiler & inLexique,
              GGS_string& _out_0,
              GGS_string& _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStyleName ;
    _out_1 = ptr->mTitle ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_styleList::
method_last (C_Compiler & inLexique,
             GGS_string& _out_0,
             GGS_string& _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStyleName ;
    _out_1 = ptr->mTitle ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_styleList::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_string& _out_0,
                 GGS_string& _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStyleName ;
    _out_1 = ptr->mTitle ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_styleList::
modifier_popLast (C_Compiler & inLexique,
                GGS_string& _out_0,
                GGS_string& _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mStyleName ;
    _out_1 = ptr->mTitle ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_styleList::
reader_mStyleNameAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mStyleName ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_styleList::
reader_mTitleAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_string result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mTitle ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_styleList::
modifier_setMStyleNameAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mStyleName = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_styleList::
modifier_setMTitleAtIndex (C_Compiler & inLexique,
                              const GGS_string & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mTitle = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_styleList::cEnumerator::_mStyleName (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mStyleName ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_styleList::cEnumerator::_mTitle (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mTitle ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_styleList::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_styleList * p = NULL ;
    macroMyNew (p, GGS_styleList (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_styleList GGS_styleList::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_styleList result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_styleList * p = dynamic_cast <const GGS_styleList *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_styleList, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_styleList::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_styleList ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'e_typeTableDefinitionTerminaux'                   *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableDefinitionTerminaux::e_typeTableDefinitionTerminaux (void) :
mErrorMessage (),
attributListeDesAttributs (),
mStyleIndex (),
mIsEndOfTemplateMark () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableDefinitionTerminaux'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableDefinitionTerminaux ("typeTableDefinitionTerminaux", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableDefinitionTerminaux::
elementOf_GGS_typeTableDefinitionTerminaux (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableDefinitionTerminaux & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableDefinitionTerminaux::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mErrorMessage.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.attributListeDesAttributs.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mStyleIndex.reader_description (inIndentation + 1) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mIsEndOfTemplateMark.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableDefinitionTerminaux::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableDefinitionTerminaux * ptr = dynamic_cast <const elementOf_GGS_typeTableDefinitionTerminaux *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mErrorMessage.operator_isEqual (ptr->mInfo.mErrorMessage)).boolValue ()
           && (mInfo.attributListeDesAttributs.operator_isEqual (ptr->mInfo.attributListeDesAttributs)).boolValue ()
           && (mInfo.mStyleIndex.operator_isEqual (ptr->mInfo.mStyleIndex)).boolValue ()
           && (mInfo.mIsEndOfTemplateMark.operator_isEqual (ptr->mInfo.mIsEndOfTemplateMark)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableDefinitionTerminaux::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableDefinitionTerminaux *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableDefinitionTerminaux * info = (e_typeTableDefinitionTerminaux *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableDefinitionTerminaux *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableDefinitionTerminaux * info = (e_typeTableDefinitionTerminaux *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux GGS_typeTableDefinitionTerminaux::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableDefinitionTerminaux result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableDefinitionTerminaux info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableDefinitionTerminaux::
operator_isEqual (const GGS_typeTableDefinitionTerminaux & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableDefinitionTerminaux::
operator_isNotEqual (const GGS_typeTableDefinitionTerminaux & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_string& inParameter0,
               const GGS_typeListeAttributsSemantiques & inParameter1,
               const GGS_uint & inParameter2,
               const GGS_bool& inParameter3,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inParameter1.isBuilt ()
   && inParameter2.isBuilt ()
   && inParameter3.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableDefinitionTerminaux info  ;
    info.mErrorMessage = inParameter0 ;
    info.attributListeDesAttributs = inParameter1 ;
    info.mStyleIndex = inParameter2 ;
    info.mIsEndOfTemplateMark = inParameter3 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_string  & outParameter0,
               GGS_typeListeAttributsSemantiques   & outParameter1,
               GGS_uint   & outParameter2,
               GGS_bool  & outParameter3,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    outParameter1.drop () ;
    outParameter2.drop () ;
    outParameter3.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mErrorMessage ;
    outParameter1 = node->mInfo.attributListeDesAttributs ;
    outParameter2 = node->mInfo.mStyleIndex ;
    outParameter3 = node->mInfo.mIsEndOfTemplateMark ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableDefinitionTerminaux::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('$'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('$'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_string  & outParameter0,
                                GGS_typeListeAttributsSemantiques   & outParameter1,
                                GGS_uint   & outParameter2,
                                GGS_bool  & outParameter3 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 outParameter1,
                 outParameter2,
                 outParameter3,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableDefinitionTerminaux::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE ('m'),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('s'),
  TO_UNICODE ('y'),
  TO_UNICODE ('m'),
  TO_UNICODE ('b'),
  TO_UNICODE ('o'),
  TO_UNICODE ('l'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('$'),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('$'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_typeListeAttributsSemantiques & inParameter1,
                                const GGS_uint & inParameter2,
                                const GGS_bool& inParameter3 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                 inParameter1,
                 inParameter2,
                 inParameter3,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux GGS_typeTableDefinitionTerminaux::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableDefinitionTerminaux & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableDefinitionTerminaux result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux GGS_typeTableDefinitionTerminaux::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableDefinitionTerminaux result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableDefinitionTerminaux::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableDefinitionTerminaux " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_string & GGS_typeTableDefinitionTerminaux::cEnumerator::_mErrorMessage (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mErrorMessage ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeAttributsSemantiques  & GGS_typeTableDefinitionTerminaux::cEnumerator::_attributListeDesAttributs (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.attributListeDesAttributs ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_typeTableDefinitionTerminaux::cEnumerator::_mStyleIndex (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mStyleIndex ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_bool & GGS_typeTableDefinitionTerminaux::cEnumerator::_mIsEndOfTemplateMark (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mIsEndOfTemplateMark ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableDefinitionTerminaux::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableDefinitionTerminaux * p = NULL ;
    macroMyNew (p, GGS_typeTableDefinitionTerminaux (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux GGS_typeTableDefinitionTerminaux::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableDefinitionTerminaux result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableDefinitionTerminaux * p = dynamic_cast <const GGS_typeTableDefinitionTerminaux *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableDefinitionTerminaux, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableDefinitionTerminaux::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableDefinitionTerminaux ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'e_typeTableMotsReserves'                       *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableMotsReserves::e_typeTableMotsReserves (void) :
attributNomTerminal () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map '@typeTableMotsReserves'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableMotsReserves ("typeTableMotsReserves", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableMotsReserves::
elementOf_GGS_typeTableMotsReserves (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableMotsReserves & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableMotsReserves::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.attributNomTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableMotsReserves::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableMotsReserves * ptr = dynamic_cast <const elementOf_GGS_typeTableMotsReserves *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.attributNomTerminal.operator_isEqual (ptr->mInfo.attributNomTerminal)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMotsReserves::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableMotsReserves *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableMotsReserves * info = (e_typeTableMotsReserves *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableMotsReserves *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableMotsReserves * info = (e_typeTableMotsReserves *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves GGS_typeTableMotsReserves::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMotsReserves result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableMotsReserves info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMotsReserves::
operator_isEqual (const GGS_typeTableMotsReserves & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMotsReserves::
operator_isNotEqual (const GGS_typeTableMotsReserves & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableMotsReserves info  ;
    info.attributNomTerminal = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.attributNomTerminal ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableMotsReserves::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableMotsReserves::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves GGS_typeTableMotsReserves::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableMotsReserves & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableMotsReserves result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves GGS_typeTableMotsReserves::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableMotsReserves result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableMotsReserves::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableMotsReserves " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeTableMotsReserves::cEnumerator::_attributNomTerminal (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.attributNomTerminal ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableMotsReserves::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableMotsReserves * p = NULL ;
    macroMyNew (p, GGS_typeTableMotsReserves (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves GGS_typeTableMotsReserves::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableMotsReserves result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableMotsReserves * p = dynamic_cast <const GGS_typeTableMotsReserves *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableMotsReserves, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableMotsReserves::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableMotsReserves ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'e_typeTableTablesDeMotsReserves'                   *
//                                                                           *
//---------------------------------------------------------------------------*

e_typeTableTablesDeMotsReserves::e_typeTableTablesDeMotsReserves (void) :
attributSimpleTable () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map '@typeTableTablesDeMotsReserves'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeTableTablesDeMotsReserves ("typeTableTablesDeMotsReserves", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_typeTableTablesDeMotsReserves::
elementOf_GGS_typeTableTablesDeMotsReserves (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_typeTableTablesDeMotsReserves & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeTableTablesDeMotsReserves::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.attributSimpleTable.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeTableTablesDeMotsReserves::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_typeTableTablesDeMotsReserves * ptr = dynamic_cast <const elementOf_GGS_typeTableTablesDeMotsReserves *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.attributSimpleTable.operator_isEqual (ptr->mInfo.attributSimpleTable)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableTablesDeMotsReserves::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_typeTableTablesDeMotsReserves *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_typeTableTablesDeMotsReserves * info = (e_typeTableTablesDeMotsReserves *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableTablesDeMotsReserves *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_typeTableTablesDeMotsReserves * info = (e_typeTableTablesDeMotsReserves *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves GGS_typeTableTablesDeMotsReserves::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableTablesDeMotsReserves result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_typeTableTablesDeMotsReserves info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableTablesDeMotsReserves::
operator_isEqual (const GGS_typeTableTablesDeMotsReserves & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableTablesDeMotsReserves::
operator_isNotEqual (const GGS_typeTableTablesDeMotsReserves & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_typeTableMotsReserves & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_typeTableTablesDeMotsReserves info  ;
    info.attributSimpleTable = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_typeTableMotsReserves   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.attributSimpleTable ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableTablesDeMotsReserves::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_typeTableMotsReserves   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_typeTableTablesDeMotsReserves::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('w'),
  TO_UNICODE ('o'),
  TO_UNICODE ('r'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('m'),
  TO_UNICODE ('a'),
  TO_UNICODE ('p'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_typeTableMotsReserves & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves GGS_typeTableTablesDeMotsReserves::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_typeTableTablesDeMotsReserves & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_typeTableTablesDeMotsReserves result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves GGS_typeTableTablesDeMotsReserves::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeTableTablesDeMotsReserves result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeTableTablesDeMotsReserves::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @typeTableTablesDeMotsReserves " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeTableMotsReserves  & GGS_typeTableTablesDeMotsReserves::cEnumerator::_attributSimpleTable (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.attributSimpleTable ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeTableTablesDeMotsReserves::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeTableTablesDeMotsReserves * p = NULL ;
    macroMyNew (p, GGS_typeTableTablesDeMotsReserves (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves GGS_typeTableTablesDeMotsReserves::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeTableTablesDeMotsReserves result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeTableTablesDeMotsReserves * p = dynamic_cast <const GGS_typeTableTablesDeMotsReserves *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeTableTablesDeMotsReserves, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeTableTablesDeMotsReserves::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeTableTablesDeMotsReserves ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeConditionLexicale'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionLexicale::
cPtr_typeConditionLexicale (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionLexicale * GGS_typeConditionLexicale::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeConditionLexicale) ;
    return (cPtr_typeConditionLexicale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeConditionLexicale::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeConditionLexicale:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConditionLexicale::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConditionLexicale::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConditionLexicale (& typeid (cPtr_typeConditionLexicale), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeConditionLexicale::galgasRTTI (void) const {
  return & gClassInfoFor__typeConditionLexicale ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeConditionLexicale'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeConditionLexicale ("typeConditionLexicale", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
GGS_typeConditionLexicale (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
GGS_typeConditionLexicale (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConditionLexicale GGS_typeConditionLexicale::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConditionLexicale result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConditionLexicale *> (inPointer) != NULL)
      : (typeid (cPtr_typeConditionLexicale) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConditionLexicale (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConditionLexicale),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConditionLexicale::actualTypeName (void) const {
  return "typeConditionLexicale" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeConditionLexicale::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeConditionLexicale ("typeConditionLexicale", & kTypeDescriptor_GGS_typeConditionLexicale) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeConditionLexicale::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeConditionLexicale * p = NULL ;
    macroMyNew (p, GGS_typeConditionLexicale (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale GGS_typeConditionLexicale::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeConditionLexicale result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeConditionLexicale * p = dynamic_cast <const GGS_typeConditionLexicale *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeConditionLexicale, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeConditionLexicale::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeConditionLexicale ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeUnicodeCharSet'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeUnicodeCharSet::
cPtr_typeUnicodeCharSet (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeConditionLexicale (THERE),
mUnicodeCharSetName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeUnicodeCharSet * GGS_typeUnicodeCharSet::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeUnicodeCharSet) ;
    return (cPtr_typeUnicodeCharSet *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeUnicodeCharSet::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeUnicodeCharSet * ptr = dynamic_cast <const cPtr_typeUnicodeCharSet *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mUnicodeCharSetName.operator_isEqual (ptr->mUnicodeCharSetName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeUnicodeCharSet::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeUnicodeCharSet:"
           << mUnicodeCharSetName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeUnicodeCharSet::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeUnicodeCharSet::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeUnicodeCharSet (& typeid (cPtr_typeUnicodeCharSet), & typeid (cPtr_typeConditionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeUnicodeCharSet::galgasRTTI (void) const {
  return & gClassInfoFor__typeUnicodeCharSet ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeUnicodeCharSet::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeUnicodeCharSet (mUnicodeCharSetName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeUnicodeCharSet'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeUnicodeCharSet ("typeUnicodeCharSet", true, & kTypeDescriptor_GGS_typeConditionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeUnicodeCharSet::
GGS_typeUnicodeCharSet (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeUnicodeCharSet::
GGS_typeUnicodeCharSet (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeUnicodeCharSet GGS_typeUnicodeCharSet::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeUnicodeCharSet result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeUnicodeCharSet *> (inPointer) != NULL)
      : (typeid (cPtr_typeUnicodeCharSet) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeUnicodeCharSet (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeUnicodeCharSet),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUnicodeCharSet GGS_typeUnicodeCharSet::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeUnicodeCharSet result ;
  macroMyNew (result.mPointer, cPtr_typeUnicodeCharSet (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeUnicodeCharSet::
reader_mUnicodeCharSetName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeUnicodeCharSet *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeUnicodeCharSet *) mPointer)->mUnicodeCharSetName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeUnicodeCharSet::actualTypeName (void) const {
  return "typeUnicodeCharSet" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeUnicodeCharSet ("typeUnicodeCharSet", gClassInfoFor__typeConditionLexicale, & kTypeDescriptor_GGS_typeUnicodeCharSet) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeUnicodeCharSet::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeUnicodeCharSet * p = NULL ;
    macroMyNew (p, GGS_typeUnicodeCharSet (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeUnicodeCharSet GGS_typeUnicodeCharSet::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeUnicodeCharSet result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeUnicodeCharSet * p = dynamic_cast <const GGS_typeUnicodeCharSet *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeUnicodeCharSet, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeUnicodeCharSet::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeUnicodeCharSet ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeConditionChaine'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionChaine::
cPtr_typeConditionChaine (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeConditionLexicale (THERE),
attributChaine (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionChaine * GGS_typeConditionChaine::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeConditionChaine) ;
    return (cPtr_typeConditionChaine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConditionChaine::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConditionChaine * ptr = dynamic_cast <const cPtr_typeConditionChaine *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributChaine.operator_isEqual (ptr->attributChaine).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConditionChaine::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeConditionChaine:"
           << attributChaine.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConditionChaine::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConditionChaine::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConditionChaine (& typeid (cPtr_typeConditionChaine), & typeid (cPtr_typeConditionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeConditionChaine::galgasRTTI (void) const {
  return & gClassInfoFor__typeConditionChaine ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeConditionChaine::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeConditionChaine (attributChaine COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConditionChaine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeConditionChaine ("typeConditionChaine", true, & kTypeDescriptor_GGS_typeConditionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeConditionChaine::
GGS_typeConditionChaine (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionChaine::
GGS_typeConditionChaine (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConditionChaine GGS_typeConditionChaine::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConditionChaine result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConditionChaine *> (inPointer) != NULL)
      : (typeid (cPtr_typeConditionChaine) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConditionChaine (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConditionChaine),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionChaine GGS_typeConditionChaine::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeConditionChaine result ;
  macroMyNew (result.mPointer, cPtr_typeConditionChaine (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeConditionChaine::
reader_attributChaine (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionChaine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionChaine *) mPointer)->attributChaine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConditionChaine::actualTypeName (void) const {
  return "typeConditionChaine" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeConditionChaine ("typeConditionChaine", gClassInfoFor__typeConditionLexicale, & kTypeDescriptor_GGS_typeConditionChaine) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeConditionChaine::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeConditionChaine * p = NULL ;
    macroMyNew (p, GGS_typeConditionChaine (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionChaine GGS_typeConditionChaine::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeConditionChaine result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeConditionChaine * p = dynamic_cast <const GGS_typeConditionChaine *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeConditionChaine, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeConditionChaine::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeConditionChaine ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeConditionNonChaine'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionNonChaine::
cPtr_typeConditionNonChaine (const GGS_lstringlist & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeConditionLexicale (THERE),
mStrings (argument_0),
mEndOfFileErrorMessageIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionNonChaine * GGS_typeConditionNonChaine::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeConditionNonChaine) ;
    return (cPtr_typeConditionNonChaine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConditionNonChaine::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConditionNonChaine * ptr = dynamic_cast <const cPtr_typeConditionNonChaine *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mStrings.operator_isEqual (ptr->mStrings).boolValue ()
         && mEndOfFileErrorMessageIndex.operator_isEqual (ptr->mEndOfFileErrorMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConditionNonChaine::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeConditionNonChaine:"
           << mStrings.reader_description (inIndentation + 1)
           << mEndOfFileErrorMessageIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConditionNonChaine::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConditionNonChaine::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConditionNonChaine (& typeid (cPtr_typeConditionNonChaine), & typeid (cPtr_typeConditionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeConditionNonChaine::galgasRTTI (void) const {
  return & gClassInfoFor__typeConditionNonChaine ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeConditionNonChaine::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeConditionNonChaine (mStrings, mEndOfFileErrorMessageIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionNonChaine'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeConditionNonChaine ("typeConditionNonChaine", true, & kTypeDescriptor_GGS_typeConditionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeConditionNonChaine::
GGS_typeConditionNonChaine (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionNonChaine::
GGS_typeConditionNonChaine (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConditionNonChaine GGS_typeConditionNonChaine::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConditionNonChaine result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConditionNonChaine *> (inPointer) != NULL)
      : (typeid (cPtr_typeConditionNonChaine) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConditionNonChaine (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConditionNonChaine),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionNonChaine GGS_typeConditionNonChaine::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstringlist & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeConditionNonChaine result ;
  macroMyNew (result.mPointer, cPtr_typeConditionNonChaine (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_typeConditionNonChaine::
reader_mStrings (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionNonChaine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionNonChaine *) mPointer)->mStrings ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeConditionNonChaine::
reader_mEndOfFileErrorMessageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionNonChaine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionNonChaine *) mPointer)->mEndOfFileErrorMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConditionNonChaine::actualTypeName (void) const {
  return "typeConditionNonChaine" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeConditionNonChaine ("typeConditionNonChaine", gClassInfoFor__typeConditionLexicale, & kTypeDescriptor_GGS_typeConditionNonChaine) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeConditionNonChaine::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeConditionNonChaine * p = NULL ;
    macroMyNew (p, GGS_typeConditionNonChaine (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionNonChaine GGS_typeConditionNonChaine::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeConditionNonChaine result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeConditionNonChaine * p = dynamic_cast <const GGS_typeConditionNonChaine *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeConditionNonChaine, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeConditionNonChaine::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeConditionNonChaine ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeConditionCaractere'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionCaractere::
cPtr_typeConditionCaractere (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeConditionLexicale (THERE),
attributCaractere (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionCaractere * GGS_typeConditionCaractere::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeConditionCaractere) ;
    return (cPtr_typeConditionCaractere *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConditionCaractere::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConditionCaractere * ptr = dynamic_cast <const cPtr_typeConditionCaractere *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributCaractere.operator_isEqual (ptr->attributCaractere).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConditionCaractere::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeConditionCaractere:"
           << attributCaractere.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConditionCaractere::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConditionCaractere::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConditionCaractere (& typeid (cPtr_typeConditionCaractere), & typeid (cPtr_typeConditionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeConditionCaractere::galgasRTTI (void) const {
  return & gClassInfoFor__typeConditionCaractere ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeConditionCaractere::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeConditionCaractere (attributCaractere COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeConditionCaractere ("typeConditionCaractere", true, & kTypeDescriptor_GGS_typeConditionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeConditionCaractere::
GGS_typeConditionCaractere (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionCaractere::
GGS_typeConditionCaractere (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConditionCaractere GGS_typeConditionCaractere::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConditionCaractere result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConditionCaractere *> (inPointer) != NULL)
      : (typeid (cPtr_typeConditionCaractere) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConditionCaractere (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConditionCaractere),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionCaractere GGS_typeConditionCaractere::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeConditionCaractere result ;
  macroMyNew (result.mPointer, cPtr_typeConditionCaractere (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeConditionCaractere::
reader_attributCaractere (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionCaractere *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionCaractere *) mPointer)->attributCaractere ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConditionCaractere::actualTypeName (void) const {
  return "typeConditionCaractere" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeConditionCaractere ("typeConditionCaractere", gClassInfoFor__typeConditionLexicale, & kTypeDescriptor_GGS_typeConditionCaractere) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeConditionCaractere::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeConditionCaractere * p = NULL ;
    macroMyNew (p, GGS_typeConditionCaractere (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionCaractere GGS_typeConditionCaractere::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeConditionCaractere result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeConditionCaractere * p = dynamic_cast <const GGS_typeConditionCaractere *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeConditionCaractere, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeConditionCaractere::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeConditionCaractere ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeConditionIntervalle'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionIntervalle::
cPtr_typeConditionIntervalle (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeConditionLexicale (THERE),
attributBorneInf (argument_0),
attributBorneSup (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeConditionIntervalle * GGS_typeConditionIntervalle::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeConditionIntervalle) ;
    return (cPtr_typeConditionIntervalle *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeConditionIntervalle::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeConditionIntervalle * ptr = dynamic_cast <const cPtr_typeConditionIntervalle *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributBorneInf.operator_isEqual (ptr->attributBorneInf).boolValue ()
         && attributBorneSup.operator_isEqual (ptr->attributBorneSup).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeConditionIntervalle::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeConditionIntervalle:"
           << attributBorneInf.reader_description (inIndentation + 1)
           << attributBorneSup.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeConditionIntervalle::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeConditionIntervalle::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeConditionIntervalle (& typeid (cPtr_typeConditionIntervalle), & typeid (cPtr_typeConditionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeConditionIntervalle::galgasRTTI (void) const {
  return & gClassInfoFor__typeConditionIntervalle ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeConditionIntervalle::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeConditionIntervalle (attributBorneInf, attributBorneSup COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionIntervalle'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeConditionIntervalle ("typeConditionIntervalle", true, & kTypeDescriptor_GGS_typeConditionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeConditionIntervalle::
GGS_typeConditionIntervalle (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionIntervalle::
GGS_typeConditionIntervalle (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeConditionIntervalle GGS_typeConditionIntervalle::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeConditionIntervalle result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeConditionIntervalle *> (inPointer) != NULL)
      : (typeid (cPtr_typeConditionIntervalle) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeConditionIntervalle (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeConditionIntervalle),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionIntervalle GGS_typeConditionIntervalle::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0,
                 const GGS_lchar & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeConditionIntervalle result ;
  macroMyNew (result.mPointer, cPtr_typeConditionIntervalle (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeConditionIntervalle::
reader_attributBorneInf (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionIntervalle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionIntervalle *) mPointer)->attributBorneInf ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeConditionIntervalle::
reader_attributBorneSup (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeConditionIntervalle *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeConditionIntervalle *) mPointer)->attributBorneSup ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeConditionIntervalle::actualTypeName (void) const {
  return "typeConditionIntervalle" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeConditionIntervalle ("typeConditionIntervalle", gClassInfoFor__typeConditionLexicale, & kTypeDescriptor_GGS_typeConditionIntervalle) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeConditionIntervalle::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeConditionIntervalle * p = NULL ;
    macroMyNew (p, GGS_typeConditionIntervalle (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionIntervalle GGS_typeConditionIntervalle::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeConditionIntervalle result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeConditionIntervalle * p = dynamic_cast <const GGS_typeConditionIntervalle *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeConditionIntervalle, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeConditionIntervalle::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeConditionIntervalle ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeConditionsLexicales'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeConditionsLexicales::
elementOf_GGS_typeListeConditionsLexicales (const GGS_typeConditionLexicale & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
attributCondition (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeConditionsLexicales::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeConditionsLexicales * ptr = dynamic_cast <const elementOf_GGS_typeListeConditionsLexicales *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributCondition.operator_isEqual (ptr->attributCondition).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeConditionsLexicales::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributCondition.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@typeListeConditionsLexicales'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeConditionsLexicales ("typeListeConditionsLexicales", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
internalAppendValues (const GGS_typeConditionLexicale & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
internalPrependValues (const GGS_typeConditionLexicale & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
addAssign_operation (const GGS_typeConditionLexicale & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales GGS_typeListeConditionsLexicales::
operator_concat (const GGS_typeListeConditionsLexicales & inOperand) const {
  GGS_typeListeConditionsLexicales result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
dotAssign_operation (const GGS_typeListeConditionsLexicales inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeConditionsLexicales * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeConditionLexicale  p_0 = p->attributCondition ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeConditionLexicale & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->attributCondition
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales  GGS_typeListeConditionsLexicales::
constructor_emptyList (void) {
  GGS_typeListeConditionsLexicales result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales  GGS_typeListeConditionsLexicales::
constructor_listWithValue (const GGS_typeConditionLexicale & argument_0) {
  GGS_typeListeConditionsLexicales result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
internalSubListWithRange (GGS_typeListeConditionsLexicales & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->attributCondition) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales GGS_typeListeConditionsLexicales::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeConditionsLexicales result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales GGS_typeListeConditionsLexicales::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeConditionsLexicales result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeConditionsLexicales::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeConditionsLexicales", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
method_first (C_Compiler & inLexique,
              GGS_typeConditionLexicale & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributCondition ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
method_last (C_Compiler & inLexique,
             GGS_typeConditionLexicale & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributCondition ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeConditionLexicale & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributCondition ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeConditionLexicale & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributCondition ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale  GGS_typeListeConditionsLexicales::
reader_attributConditionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeConditionLexicale  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->attributCondition ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
modifier_setAttributConditionAtIndex (C_Compiler & inLexique,
                              const GGS_typeConditionLexicale  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->attributCondition = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeConditionLexicale  & GGS_typeListeConditionsLexicales::cEnumerator::_attributCondition (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->attributCondition ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeConditionsLexicales::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeConditionsLexicales * p = NULL ;
    macroMyNew (p, GGS_typeListeConditionsLexicales (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales GGS_typeListeConditionsLexicales::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeConditionsLexicales result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeConditionsLexicales * p = dynamic_cast <const GGS_typeListeConditionsLexicales *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeConditionsLexicales, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeConditionsLexicales::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeConditionsLexicales ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeInstructionLexicale'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionLexicale::
cPtr_typeInstructionLexicale (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionLexicale * GGS_typeInstructionLexicale::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionLexicale) ;
    return (cPtr_typeInstructionLexicale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeInstructionLexicale::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeInstructionLexicale:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionLexicale::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionLexicale::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionLexicale (& typeid (cPtr_typeInstructionLexicale), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionLexicale::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionLexicale ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionLexicale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionLexicale ("typeInstructionLexicale", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
GGS_typeInstructionLexicale (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
GGS_typeInstructionLexicale (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionLexicale GGS_typeInstructionLexicale::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionLexicale result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionLexicale *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionLexicale) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionLexicale (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionLexicale),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionLexicale::actualTypeName (void) const {
  return "typeInstructionLexicale" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeInstructionLexicale::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeInstructionLexicale ("typeInstructionLexicale", & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionLexicale::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionLexicale * p = NULL ;
    macroMyNew (p, GGS_typeInstructionLexicale (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale GGS_typeInstructionLexicale::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionLexicale result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionLexicale * p = dynamic_cast <const GGS_typeInstructionLexicale *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionLexicale, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionLexicale::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionLexicale ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@tListeInstructionsLexicales'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_tListeInstructionsLexicales::
elementOf_GGS_tListeInstructionsLexicales (const GGS_typeInstructionLexicale & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
attributInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_tListeInstructionsLexicales::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_tListeInstructionsLexicales * ptr = dynamic_cast <const elementOf_GGS_tListeInstructionsLexicales *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributInstruction.operator_isEqual (ptr->attributInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_tListeInstructionsLexicales::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@tListeInstructionsLexicales'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_tListeInstructionsLexicales ("tListeInstructionsLexicales", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
internalAppendValues (const GGS_typeInstructionLexicale & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
internalPrependValues (const GGS_typeInstructionLexicale & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
addAssign_operation (const GGS_typeInstructionLexicale & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales GGS_tListeInstructionsLexicales::
operator_concat (const GGS_tListeInstructionsLexicales & inOperand) const {
  GGS_tListeInstructionsLexicales result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
dotAssign_operation (const GGS_tListeInstructionsLexicales inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_tListeInstructionsLexicales * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeInstructionLexicale  p_0 = p->attributInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeInstructionLexicale & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->attributInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_tListeInstructionsLexicales::
constructor_emptyList (void) {
  GGS_tListeInstructionsLexicales result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_tListeInstructionsLexicales::
constructor_listWithValue (const GGS_typeInstructionLexicale & argument_0) {
  GGS_tListeInstructionsLexicales result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
internalSubListWithRange (GGS_tListeInstructionsLexicales & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->attributInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales GGS_tListeInstructionsLexicales::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_tListeInstructionsLexicales result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales GGS_tListeInstructionsLexicales::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_tListeInstructionsLexicales result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tListeInstructionsLexicales::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@tListeInstructionsLexicales", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
method_first (C_Compiler & inLexique,
              GGS_typeInstructionLexicale & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
method_last (C_Compiler & inLexique,
             GGS_typeInstructionLexicale & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeInstructionLexicale & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeInstructionLexicale & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale  GGS_tListeInstructionsLexicales::
reader_attributInstructionAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeInstructionLexicale  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->attributInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
modifier_setAttributInstructionAtIndex (C_Compiler & inLexique,
                              const GGS_typeInstructionLexicale  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->attributInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeInstructionLexicale  & GGS_tListeInstructionsLexicales::cEnumerator::_attributInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->attributInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_tListeInstructionsLexicales::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_tListeInstructionsLexicales * p = NULL ;
    macroMyNew (p, GGS_tListeInstructionsLexicales (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales GGS_tListeInstructionsLexicales::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_tListeInstructionsLexicales result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_tListeInstructionsLexicales * p = dynamic_cast <const GGS_tListeInstructionsLexicales *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_tListeInstructionsLexicales, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_tListeInstructionsLexicales::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_tListeInstructionsLexicales ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeTestsEtInstructions'               *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeTestsEtInstructions::
elementOf_GGS_typeListeTestsEtInstructions (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
attributListeConditions (argument_0),
attributListeInstructions (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeTestsEtInstructions::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeTestsEtInstructions * ptr = dynamic_cast <const elementOf_GGS_typeListeTestsEtInstructions *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributListeConditions.operator_isEqual (ptr->attributListeConditions).boolValue ()
         && attributListeInstructions.operator_isEqual (ptr->attributListeInstructions).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeTestsEtInstructions::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributListeConditions.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributListeInstructions.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   List '@typeListeTestsEtInstructions'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeTestsEtInstructions ("typeListeTestsEtInstructions", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
internalAppendValues (const GGS_typeListeConditionsLexicales & argument_0,
                    const GGS_tListeInstructionsLexicales & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
internalPrependValues (const GGS_typeListeConditionsLexicales & argument_0,
                    const GGS_tListeInstructionsLexicales & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
addAssign_operation (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions GGS_typeListeTestsEtInstructions::
operator_concat (const GGS_typeListeTestsEtInstructions & inOperand) const {
  GGS_typeListeTestsEtInstructions result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
dotAssign_operation (const GGS_typeListeTestsEtInstructions inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeTestsEtInstructions * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeListeConditionsLexicales  p_0 = p->attributListeConditions ;
          GGS_tListeInstructionsLexicales  p_1 = p->attributListeInstructions ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeListeConditionsLexicales & argument_0,
                     const GGS_tListeInstructionsLexicales & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->attributListeConditions,
                                ptr->attributListeInstructions
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeListeTestsEtInstructions::
constructor_emptyList (void) {
  GGS_typeListeTestsEtInstructions result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeListeTestsEtInstructions::
constructor_listWithValue (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) {
  GGS_typeListeTestsEtInstructions result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
internalSubListWithRange (GGS_typeListeTestsEtInstructions & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->attributListeConditions, ptr->attributListeInstructions) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions GGS_typeListeTestsEtInstructions::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeTestsEtInstructions result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions GGS_typeListeTestsEtInstructions::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeTestsEtInstructions result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeTestsEtInstructions::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeTestsEtInstructions", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
method_first (C_Compiler & inLexique,
              GGS_typeListeConditionsLexicales & _out_0,
              GGS_tListeInstructionsLexicales & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributListeConditions ;
    _out_1 = ptr->attributListeInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
method_last (C_Compiler & inLexique,
             GGS_typeListeConditionsLexicales & _out_0,
             GGS_tListeInstructionsLexicales & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributListeConditions ;
    _out_1 = ptr->attributListeInstructions ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeListeConditionsLexicales & _out_0,
                 GGS_tListeInstructionsLexicales & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributListeConditions ;
    _out_1 = ptr->attributListeInstructions ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeListeConditionsLexicales & _out_0,
                GGS_tListeInstructionsLexicales & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributListeConditions ;
    _out_1 = ptr->attributListeInstructions ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales  GGS_typeListeTestsEtInstructions::
reader_attributListeConditionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeListeConditionsLexicales  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->attributListeConditions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_typeListeTestsEtInstructions::
reader_attributListeInstructionsAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_tListeInstructionsLexicales  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->attributListeInstructions ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
modifier_setAttributListeConditionsAtIndex (C_Compiler & inLexique,
                              const GGS_typeListeConditionsLexicales  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->attributListeConditions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
modifier_setAttributListeInstructionsAtIndex (C_Compiler & inLexique,
                              const GGS_tListeInstructionsLexicales  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->attributListeInstructions = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeListeConditionsLexicales  & GGS_typeListeTestsEtInstructions::cEnumerator::_attributListeConditions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->attributListeConditions ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_tListeInstructionsLexicales  & GGS_typeListeTestsEtInstructions::cEnumerator::_attributListeInstructions (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->attributListeInstructions ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeTestsEtInstructions::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeTestsEtInstructions * p = NULL ;
    macroMyNew (p, GGS_typeListeTestsEtInstructions (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions GGS_typeListeTestsEtInstructions::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeTestsEtInstructions result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeTestsEtInstructions * p = dynamic_cast <const GGS_typeListeTestsEtInstructions *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeTestsEtInstructions, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeTestsEtInstructions::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeTestsEtInstructions ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeArgumentRoutineExterne'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentRoutineExterne::
cPtr_typeArgumentRoutineExterne (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentRoutineExterne * GGS_typeArgumentRoutineExterne::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeArgumentRoutineExterne) ;
    return (cPtr_typeArgumentRoutineExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeArgumentRoutineExterne::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeArgumentRoutineExterne:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentRoutineExterne::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentRoutineExterne::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeArgumentRoutineExterne (& typeid (cPtr_typeArgumentRoutineExterne), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeArgumentRoutineExterne::galgasRTTI (void) const {
  return & gClassInfoFor__typeArgumentRoutineExterne ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeArgumentRoutineExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeArgumentRoutineExterne ("typeArgumentRoutineExterne", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
GGS_typeArgumentRoutineExterne (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
GGS_typeArgumentRoutineExterne (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeArgumentRoutineExterne GGS_typeArgumentRoutineExterne::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeArgumentRoutineExterne result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeArgumentRoutineExterne *> (inPointer) != NULL)
      : (typeid (cPtr_typeArgumentRoutineExterne) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeArgumentRoutineExterne (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeArgumentRoutineExterne),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeArgumentRoutineExterne::actualTypeName (void) const {
  return "typeArgumentRoutineExterne" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeArgumentRoutineExterne::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeArgumentRoutineExterne ("typeArgumentRoutineExterne", & kTypeDescriptor_GGS_typeArgumentRoutineExterne) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeArgumentRoutineExterne::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeArgumentRoutineExterne * p = NULL ;
    macroMyNew (p, GGS_typeArgumentRoutineExterne (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne GGS_typeArgumentRoutineExterne::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeArgumentRoutineExterne result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeArgumentRoutineExterne * p = dynamic_cast <const GGS_typeArgumentRoutineExterne *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeArgumentRoutineExterne, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeArgumentRoutineExterne::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeArgumentRoutineExterne ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             Element of list '@typeListeArgumentsRoutExterne'              *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeArgumentsRoutExterne::
elementOf_GGS_typeListeArgumentsRoutExterne (const GGS_typeArgumentRoutineExterne & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
attributArgument (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeArgumentsRoutExterne::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeArgumentsRoutExterne * ptr = dynamic_cast <const elementOf_GGS_typeListeArgumentsRoutExterne *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributArgument.operator_isEqual (ptr->attributArgument).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeArgumentsRoutExterne::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributArgument.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  List '@typeListeArgumentsRoutExterne'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeArgumentsRoutExterne ("typeListeArgumentsRoutExterne", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
internalAppendValues (const GGS_typeArgumentRoutineExterne & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
internalPrependValues (const GGS_typeArgumentRoutineExterne & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
addAssign_operation (const GGS_typeArgumentRoutineExterne & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne GGS_typeListeArgumentsRoutExterne::
operator_concat (const GGS_typeListeArgumentsRoutExterne & inOperand) const {
  GGS_typeListeArgumentsRoutExterne result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
dotAssign_operation (const GGS_typeListeArgumentsRoutExterne inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeArgumentsRoutExterne * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_typeArgumentRoutineExterne  p_0 = p->attributArgument ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_typeArgumentRoutineExterne & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->attributArgument
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeListeArgumentsRoutExterne::
constructor_emptyList (void) {
  GGS_typeListeArgumentsRoutExterne result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeListeArgumentsRoutExterne::
constructor_listWithValue (const GGS_typeArgumentRoutineExterne & argument_0) {
  GGS_typeListeArgumentsRoutExterne result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
internalSubListWithRange (GGS_typeListeArgumentsRoutExterne & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->attributArgument) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne GGS_typeListeArgumentsRoutExterne::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeArgumentsRoutExterne result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne GGS_typeListeArgumentsRoutExterne::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeArgumentsRoutExterne result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeArgumentsRoutExterne::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeArgumentsRoutExterne", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
method_first (C_Compiler & inLexique,
              GGS_typeArgumentRoutineExterne & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
method_last (C_Compiler & inLexique,
             GGS_typeArgumentRoutineExterne & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributArgument ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_typeArgumentRoutineExterne & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributArgument ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
modifier_popLast (C_Compiler & inLexique,
                GGS_typeArgumentRoutineExterne & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributArgument ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne  GGS_typeListeArgumentsRoutExterne::
reader_attributArgumentAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_typeArgumentRoutineExterne  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->attributArgument ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
modifier_setAttributArgumentAtIndex (C_Compiler & inLexique,
                              const GGS_typeArgumentRoutineExterne  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->attributArgument = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_typeArgumentRoutineExterne  & GGS_typeListeArgumentsRoutExterne::cEnumerator::_attributArgument (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->attributArgument ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeArgumentsRoutExterne::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeArgumentsRoutExterne * p = NULL ;
    macroMyNew (p, GGS_typeListeArgumentsRoutExterne (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne GGS_typeListeArgumentsRoutExterne::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeArgumentsRoutExterne result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeArgumentsRoutExterne * p = dynamic_cast <const GGS_typeListeArgumentsRoutExterne *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeArgumentsRoutExterne, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeArgumentsRoutExterne::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeArgumentsRoutExterne ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeArgumentAttribut'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentAttribut::
cPtr_typeArgumentAttribut (const GGS_lstring & argument_0,
                                const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE),
attributNom (argument_0),
attributTypeAttribut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentAttribut * GGS_typeArgumentAttribut::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeArgumentAttribut) ;
    return (cPtr_typeArgumentAttribut *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentAttribut::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeArgumentAttribut * ptr = dynamic_cast <const cPtr_typeArgumentAttribut *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributNom.operator_isEqual (ptr->attributNom).boolValue ()
         && attributTypeAttribut.operator_isEqual (ptr->attributTypeAttribut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentAttribut::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeArgumentAttribut:"
           << attributNom.reader_description (inIndentation + 1)
           << attributTypeAttribut.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentAttribut::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentAttribut::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeArgumentAttribut (& typeid (cPtr_typeArgumentAttribut), & typeid (cPtr_typeArgumentRoutineExterne), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeArgumentAttribut::galgasRTTI (void) const {
  return & gClassInfoFor__typeArgumentAttribut ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeArgumentAttribut::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeArgumentAttribut (attributNom, attributTypeAttribut COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentAttribut'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeArgumentAttribut ("typeArgumentAttribut", true, & kTypeDescriptor_GGS_typeArgumentRoutineExterne) ;

//---------------------------------------------------------------------------*

GGS_typeArgumentAttribut::
GGS_typeArgumentAttribut (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentAttribut::
GGS_typeArgumentAttribut (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeArgumentAttribut GGS_typeArgumentAttribut::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeArgumentAttribut result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeArgumentAttribut *> (inPointer) != NULL)
      : (typeid (cPtr_typeArgumentAttribut) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeArgumentAttribut (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeArgumentAttribut),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentAttribut GGS_typeArgumentAttribut::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_AC_galgasType & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeArgumentAttribut result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentAttribut (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeArgumentAttribut::
reader_attributNom (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentAttribut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentAttribut *) mPointer)->attributNom ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_AC_galgasType  GGS_typeArgumentAttribut::
reader_attributTypeAttribut (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_AC_galgasType   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentAttribut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentAttribut *) mPointer)->attributTypeAttribut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeArgumentAttribut::actualTypeName (void) const {
  return "typeArgumentAttribut" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeArgumentAttribut ("typeArgumentAttribut", gClassInfoFor__typeArgumentRoutineExterne, & kTypeDescriptor_GGS_typeArgumentAttribut) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeArgumentAttribut::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeArgumentAttribut * p = NULL ;
    macroMyNew (p, GGS_typeArgumentAttribut (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentAttribut GGS_typeArgumentAttribut::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeArgumentAttribut result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeArgumentAttribut * p = dynamic_cast <const GGS_typeArgumentAttribut *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeArgumentAttribut, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeArgumentAttribut::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeArgumentAttribut ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeArgumentCaractere'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentCaractere::
cPtr_typeArgumentCaractere (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE),
attributCaractere (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentCaractere * GGS_typeArgumentCaractere::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeArgumentCaractere) ;
    return (cPtr_typeArgumentCaractere *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentCaractere::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeArgumentCaractere * ptr = dynamic_cast <const cPtr_typeArgumentCaractere *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributCaractere.operator_isEqual (ptr->attributCaractere).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentCaractere::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeArgumentCaractere:"
           << attributCaractere.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentCaractere::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentCaractere::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeArgumentCaractere (& typeid (cPtr_typeArgumentCaractere), & typeid (cPtr_typeArgumentRoutineExterne), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeArgumentCaractere::galgasRTTI (void) const {
  return & gClassInfoFor__typeArgumentCaractere ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeArgumentCaractere::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeArgumentCaractere (attributCaractere COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeArgumentCaractere ("typeArgumentCaractere", true, & kTypeDescriptor_GGS_typeArgumentRoutineExterne) ;

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractere::
GGS_typeArgumentCaractere (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractere::
GGS_typeArgumentCaractere (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeArgumentCaractere GGS_typeArgumentCaractere::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeArgumentCaractere result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeArgumentCaractere *> (inPointer) != NULL)
      : (typeid (cPtr_typeArgumentCaractere) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeArgumentCaractere (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeArgumentCaractere),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractere GGS_typeArgumentCaractere::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeArgumentCaractere result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentCaractere (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_typeArgumentCaractere::
reader_attributCaractere (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentCaractere *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentCaractere *) mPointer)->attributCaractere ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeArgumentCaractere::actualTypeName (void) const {
  return "typeArgumentCaractere" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeArgumentCaractere ("typeArgumentCaractere", gClassInfoFor__typeArgumentRoutineExterne, & kTypeDescriptor_GGS_typeArgumentCaractere) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeArgumentCaractere::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeArgumentCaractere * p = NULL ;
    macroMyNew (p, GGS_typeArgumentCaractere (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractere GGS_typeArgumentCaractere::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeArgumentCaractere result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeArgumentCaractere * p = dynamic_cast <const GGS_typeArgumentCaractere *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeArgumentCaractere, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeArgumentCaractere::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeArgumentCaractere ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeArgumentCaractereCourant'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentCaractereCourant::
cPtr_typeArgumentCaractereCourant (LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentCaractereCourant * GGS_typeArgumentCaractereCourant::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeArgumentCaractereCourant) ;
    return (cPtr_typeArgumentCaractereCourant *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentCaractereCourant::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentCaractereCourant::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeArgumentCaractereCourant:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentCaractereCourant::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentCaractereCourant::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeArgumentCaractereCourant (& typeid (cPtr_typeArgumentCaractereCourant), & typeid (cPtr_typeArgumentRoutineExterne), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeArgumentCaractereCourant::galgasRTTI (void) const {
  return & gClassInfoFor__typeArgumentCaractereCourant ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeArgumentCaractereCourant'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeArgumentCaractereCourant ("typeArgumentCaractereCourant", true, & kTypeDescriptor_GGS_typeArgumentRoutineExterne) ;

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractereCourant::
GGS_typeArgumentCaractereCourant (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractereCourant::
GGS_typeArgumentCaractereCourant (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeArgumentCaractereCourant GGS_typeArgumentCaractereCourant::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeArgumentCaractereCourant result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeArgumentCaractereCourant *> (inPointer) != NULL)
      : (typeid (cPtr_typeArgumentCaractereCourant) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeArgumentCaractereCourant (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeArgumentCaractereCourant),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeArgumentCaractereCourant * gSingleton_typeArgumentCaractereCourant = NULL ;

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractereCourant GGS_typeArgumentCaractereCourant::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeArgumentCaractereCourant result ;
  if (NULL == gSingleton_typeArgumentCaractereCourant) {
    macroMyNew (gSingleton_typeArgumentCaractereCourant, cPtr_typeArgumentCaractereCourant (THERE)) ;
    macroRetainObject (gSingleton_typeArgumentCaractereCourant) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeArgumentCaractereCourant) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeArgumentCaractereCourant::actualTypeName (void) const {
  return "typeArgumentCaractereCourant" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeArgumentCaractereCourant ("typeArgumentCaractereCourant", gClassInfoFor__typeArgumentRoutineExterne, & kTypeDescriptor_GGS_typeArgumentCaractereCourant) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeArgumentCaractereCourant::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeArgumentCaractereCourant * p = NULL ;
    macroMyNew (p, GGS_typeArgumentCaractereCourant (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentCaractereCourant GGS_typeArgumentCaractereCourant::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeArgumentCaractereCourant result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeArgumentCaractereCourant * p = dynamic_cast <const GGS_typeArgumentCaractereCourant *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeArgumentCaractereCourant, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeArgumentCaractereCourant::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeArgumentCaractereCourant ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeArgumentEntier'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentEntier::
cPtr_typeArgumentEntier (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE),
attributValeur (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentEntier * GGS_typeArgumentEntier::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeArgumentEntier) ;
    return (cPtr_typeArgumentEntier *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentEntier::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeArgumentEntier * ptr = dynamic_cast <const cPtr_typeArgumentEntier *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributValeur.operator_isEqual (ptr->attributValeur).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentEntier::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeArgumentEntier:"
           << attributValeur.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentEntier::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentEntier::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeArgumentEntier (& typeid (cPtr_typeArgumentEntier), & typeid (cPtr_typeArgumentRoutineExterne), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeArgumentEntier::galgasRTTI (void) const {
  return & gClassInfoFor__typeArgumentEntier ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeArgumentEntier::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeArgumentEntier (attributValeur COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentEntier'                    *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeArgumentEntier ("typeArgumentEntier", true, & kTypeDescriptor_GGS_typeArgumentRoutineExterne) ;

//---------------------------------------------------------------------------*

GGS_typeArgumentEntier::
GGS_typeArgumentEntier (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentEntier::
GGS_typeArgumentEntier (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeArgumentEntier GGS_typeArgumentEntier::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeArgumentEntier result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeArgumentEntier *> (inPointer) != NULL)
      : (typeid (cPtr_typeArgumentEntier) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeArgumentEntier (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeArgumentEntier),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentEntier GGS_typeArgumentEntier::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeArgumentEntier result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentEntier (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_typeArgumentEntier::
reader_attributValeur (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentEntier *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentEntier *) mPointer)->attributValeur ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeArgumentEntier::actualTypeName (void) const {
  return "typeArgumentEntier" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeArgumentEntier ("typeArgumentEntier", gClassInfoFor__typeArgumentRoutineExterne, & kTypeDescriptor_GGS_typeArgumentEntier) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeArgumentEntier::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeArgumentEntier * p = NULL ;
    macroMyNew (p, GGS_typeArgumentEntier (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentEntier GGS_typeArgumentEntier::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeArgumentEntier result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeArgumentEntier * p = dynamic_cast <const GGS_typeArgumentEntier *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeArgumentEntier, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeArgumentEntier::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeArgumentEntier ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_typeArgumentRoutine'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentRoutine::
cPtr_typeArgumentRoutine (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeArgumentRoutineExterne (THERE),
attributNomRoutine (argument_0),
attributListeArguments (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeArgumentRoutine * GGS_typeArgumentRoutine::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeArgumentRoutine) ;
    return (cPtr_typeArgumentRoutine *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentRoutine::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeArgumentRoutine * ptr = dynamic_cast <const cPtr_typeArgumentRoutine *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributNomRoutine.operator_isEqual (ptr->attributNomRoutine).boolValue ()
         && attributListeArguments.operator_isEqual (ptr->attributListeArguments).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeArgumentRoutine::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeArgumentRoutine:"
           << attributNomRoutine.reader_description (inIndentation + 1)
           << attributListeArguments.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentRoutine::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeArgumentRoutine::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeArgumentRoutine (& typeid (cPtr_typeArgumentRoutine), & typeid (cPtr_typeArgumentRoutineExterne), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeArgumentRoutine::galgasRTTI (void) const {
  return & gClassInfoFor__typeArgumentRoutine ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeArgumentRoutine::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeArgumentRoutine (attributNomRoutine, attributListeArguments COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentRoutine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeArgumentRoutine ("typeArgumentRoutine", true, & kTypeDescriptor_GGS_typeArgumentRoutineExterne) ;

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutine::
GGS_typeArgumentRoutine (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutine::
GGS_typeArgumentRoutine (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeArgumentRoutine GGS_typeArgumentRoutine::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeArgumentRoutine result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeArgumentRoutine *> (inPointer) != NULL)
      : (typeid (cPtr_typeArgumentRoutine) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeArgumentRoutine (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeArgumentRoutine),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutine GGS_typeArgumentRoutine::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeArgumentsRoutExterne & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeArgumentRoutine result ;
  macroMyNew (result.mPointer, cPtr_typeArgumentRoutine (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeArgumentRoutine::
reader_attributNomRoutine (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentRoutine *) mPointer)->attributNomRoutine ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeArgumentRoutine::
reader_attributListeArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeArgumentsRoutExterne   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeArgumentRoutine *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeArgumentRoutine *) mPointer)->attributListeArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeArgumentRoutine::actualTypeName (void) const {
  return "typeArgumentRoutine" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeArgumentRoutine ("typeArgumentRoutine", gClassInfoFor__typeArgumentRoutineExterne, & kTypeDescriptor_GGS_typeArgumentRoutine) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeArgumentRoutine::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeArgumentRoutine * p = NULL ;
    macroMyNew (p, GGS_typeArgumentRoutine (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutine GGS_typeArgumentRoutine::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeArgumentRoutine result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeArgumentRoutine * p = dynamic_cast <const GGS_typeArgumentRoutine *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeArgumentRoutine, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeArgumentRoutine::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeArgumentRoutine ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                Element of list '@typeListeMessagesErreur'                 *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeMessagesErreur::
elementOf_GGS_typeListeMessagesErreur (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeMessagesErreur::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeMessagesErreur * ptr = dynamic_cast <const elementOf_GGS_typeListeMessagesErreur *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorMessageIndex.operator_isEqual (ptr->mErrorMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeMessagesErreur::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mErrorMessageIndex.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     List '@typeListeMessagesErreur'                       *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeMessagesErreur ("typeListeMessagesErreur", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
internalAppendValues (const GGS_uint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
internalPrependValues (const GGS_uint & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
addAssign_operation (const GGS_uint & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur GGS_typeListeMessagesErreur::
operator_concat (const GGS_typeListeMessagesErreur & inOperand) const {
  GGS_typeListeMessagesErreur result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
dotAssign_operation (const GGS_typeListeMessagesErreur inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeMessagesErreur * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_uint  p_0 = p->mErrorMessageIndex ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_uint & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mErrorMessageIndex
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur  GGS_typeListeMessagesErreur::
constructor_emptyList (void) {
  GGS_typeListeMessagesErreur result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur  GGS_typeListeMessagesErreur::
constructor_listWithValue (const GGS_uint & argument_0) {
  GGS_typeListeMessagesErreur result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
internalSubListWithRange (GGS_typeListeMessagesErreur & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mErrorMessageIndex) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur GGS_typeListeMessagesErreur::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeMessagesErreur result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur GGS_typeListeMessagesErreur::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeMessagesErreur result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeMessagesErreur::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeMessagesErreur", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
method_first (C_Compiler & inLexique,
              GGS_uint & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mErrorMessageIndex ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
method_last (C_Compiler & inLexique,
             GGS_uint & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mErrorMessageIndex ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_uint & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mErrorMessageIndex ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
modifier_popLast (C_Compiler & inLexique,
                GGS_uint & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mErrorMessageIndex ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeListeMessagesErreur::
reader_mErrorMessageIndexAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_uint  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mErrorMessageIndex ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
modifier_setMErrorMessageIndexAtIndex (C_Compiler & inLexique,
                              const GGS_uint  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mErrorMessageIndex = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_uint  & GGS_typeListeMessagesErreur::cEnumerator::_mErrorMessageIndex (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mErrorMessageIndex ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeMessagesErreur::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeMessagesErreur * p = NULL ;
    macroMyNew (p, GGS_typeListeMessagesErreur (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur GGS_typeListeMessagesErreur::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeMessagesErreur result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeMessagesErreur * p = dynamic_cast <const GGS_typeListeMessagesErreur *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeMessagesErreur, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeMessagesErreur::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeMessagesErreur ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_typeEmissionParDefaut'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEmissionParDefaut::
cPtr_typeEmissionParDefaut (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEmissionParDefaut * GGS_typeEmissionParDefaut::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeEmissionParDefaut) ;
    return (cPtr_typeEmissionParDefaut *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_typeEmissionParDefaut::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeEmissionParDefaut:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEmissionParDefaut::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEmissionParDefaut::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEmissionParDefaut (& typeid (cPtr_typeEmissionParDefaut), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEmissionParDefaut::galgasRTTI (void) const {
  return & gClassInfoFor__typeEmissionParDefaut ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEmissionParDefaut'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEmissionParDefaut ("typeEmissionParDefaut", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
GGS_typeEmissionParDefaut (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
GGS_typeEmissionParDefaut (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEmissionParDefaut GGS_typeEmissionParDefaut::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEmissionParDefaut result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEmissionParDefaut *> (inPointer) != NULL)
      : (typeid (cPtr_typeEmissionParDefaut) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEmissionParDefaut (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEmissionParDefaut),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEmissionParDefaut::actualTypeName (void) const {
  return "typeEmissionParDefaut" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_typeEmissionParDefaut::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__typeEmissionParDefaut ("typeEmissionParDefaut", & kTypeDescriptor_GGS_typeEmissionParDefaut) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEmissionParDefaut::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEmissionParDefaut * p = NULL ;
    macroMyNew (p, GGS_typeEmissionParDefaut (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut GGS_typeEmissionParDefaut::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEmissionParDefaut result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEmissionParDefaut * p = dynamic_cast <const GGS_typeEmissionParDefaut *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEmissionParDefaut, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEmissionParDefaut::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEmissionParDefaut ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeEmissionTerminalParDefaut'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEmissionTerminalParDefaut::
cPtr_typeEmissionTerminalParDefaut (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeEmissionParDefaut (THERE),
attributNomTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEmissionTerminalParDefaut * GGS_typeEmissionTerminalParDefaut::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeEmissionTerminalParDefaut) ;
    return (cPtr_typeEmissionTerminalParDefaut *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEmissionTerminalParDefaut::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEmissionTerminalParDefaut * ptr = dynamic_cast <const cPtr_typeEmissionTerminalParDefaut *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributNomTerminal.operator_isEqual (ptr->attributNomTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEmissionTerminalParDefaut::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEmissionTerminalParDefaut:"
           << attributNomTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEmissionTerminalParDefaut::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEmissionTerminalParDefaut::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEmissionTerminalParDefaut (& typeid (cPtr_typeEmissionTerminalParDefaut), & typeid (cPtr_typeEmissionParDefaut), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEmissionTerminalParDefaut::galgasRTTI (void) const {
  return & gClassInfoFor__typeEmissionTerminalParDefaut ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEmissionTerminalParDefaut::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEmissionTerminalParDefaut (attributNomTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeEmissionTerminalParDefaut'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEmissionTerminalParDefaut ("typeEmissionTerminalParDefaut", true, & kTypeDescriptor_GGS_typeEmissionParDefaut) ;

//---------------------------------------------------------------------------*

GGS_typeEmissionTerminalParDefaut::
GGS_typeEmissionTerminalParDefaut (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionTerminalParDefaut::
GGS_typeEmissionTerminalParDefaut (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEmissionTerminalParDefaut GGS_typeEmissionTerminalParDefaut::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEmissionTerminalParDefaut result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEmissionTerminalParDefaut *> (inPointer) != NULL)
      : (typeid (cPtr_typeEmissionTerminalParDefaut) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEmissionTerminalParDefaut (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEmissionTerminalParDefaut),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionTerminalParDefaut GGS_typeEmissionTerminalParDefaut::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEmissionTerminalParDefaut result ;
  macroMyNew (result.mPointer, cPtr_typeEmissionTerminalParDefaut (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeEmissionTerminalParDefaut::
reader_attributNomTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEmissionTerminalParDefaut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEmissionTerminalParDefaut *) mPointer)->attributNomTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEmissionTerminalParDefaut::actualTypeName (void) const {
  return "typeEmissionTerminalParDefaut" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEmissionTerminalParDefaut ("typeEmissionTerminalParDefaut", gClassInfoFor__typeEmissionParDefaut, & kTypeDescriptor_GGS_typeEmissionTerminalParDefaut) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEmissionTerminalParDefaut::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEmissionTerminalParDefaut * p = NULL ;
    macroMyNew (p, GGS_typeEmissionTerminalParDefaut (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionTerminalParDefaut GGS_typeEmissionTerminalParDefaut::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEmissionTerminalParDefaut result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEmissionTerminalParDefaut * p = dynamic_cast <const GGS_typeEmissionTerminalParDefaut *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEmissionTerminalParDefaut, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEmissionTerminalParDefaut::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEmissionTerminalParDefaut ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeEmissionErreurParDefaut'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEmissionErreurParDefaut::
cPtr_typeEmissionErreurParDefaut (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeEmissionParDefaut (THERE),
mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeEmissionErreurParDefaut * GGS_typeEmissionErreurParDefaut::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeEmissionErreurParDefaut) ;
    return (cPtr_typeEmissionErreurParDefaut *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeEmissionErreurParDefaut::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeEmissionErreurParDefaut * ptr = dynamic_cast <const cPtr_typeEmissionErreurParDefaut *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorMessageIndex.operator_isEqual (ptr->mErrorMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeEmissionErreurParDefaut::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeEmissionErreurParDefaut:"
           << mErrorMessageIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeEmissionErreurParDefaut::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeEmissionErreurParDefaut::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeEmissionErreurParDefaut (& typeid (cPtr_typeEmissionErreurParDefaut), & typeid (cPtr_typeEmissionParDefaut), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeEmissionErreurParDefaut::galgasRTTI (void) const {
  return & gClassInfoFor__typeEmissionErreurParDefaut ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeEmissionErreurParDefaut::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeEmissionErreurParDefaut (mErrorMessageIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeEmissionErreurParDefaut'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeEmissionErreurParDefaut ("typeEmissionErreurParDefaut", true, & kTypeDescriptor_GGS_typeEmissionParDefaut) ;

//---------------------------------------------------------------------------*

GGS_typeEmissionErreurParDefaut::
GGS_typeEmissionErreurParDefaut (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionErreurParDefaut::
GGS_typeEmissionErreurParDefaut (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeEmissionErreurParDefaut GGS_typeEmissionErreurParDefaut::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeEmissionErreurParDefaut result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeEmissionErreurParDefaut *> (inPointer) != NULL)
      : (typeid (cPtr_typeEmissionErreurParDefaut) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeEmissionErreurParDefaut (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeEmissionErreurParDefaut),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionErreurParDefaut GGS_typeEmissionErreurParDefaut::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeEmissionErreurParDefaut result ;
  macroMyNew (result.mPointer, cPtr_typeEmissionErreurParDefaut (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeEmissionErreurParDefaut::
reader_mErrorMessageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeEmissionErreurParDefaut *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeEmissionErreurParDefaut *) mPointer)->mErrorMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeEmissionErreurParDefaut::actualTypeName (void) const {
  return "typeEmissionErreurParDefaut" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeEmissionErreurParDefaut ("typeEmissionErreurParDefaut", gClassInfoFor__typeEmissionParDefaut, & kTypeDescriptor_GGS_typeEmissionErreurParDefaut) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeEmissionErreurParDefaut::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeEmissionErreurParDefaut * p = NULL ;
    macroMyNew (p, GGS_typeEmissionErreurParDefaut (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionErreurParDefaut GGS_typeEmissionErreurParDefaut::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeEmissionErreurParDefaut result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeEmissionErreurParDefaut * p = dynamic_cast <const GGS_typeEmissionErreurParDefaut *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeEmissionErreurParDefaut, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeEmissionErreurParDefaut::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeEmissionErreurParDefaut ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  Element of list '@typeListeRecherche'                    *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_typeListeRecherche::
elementOf_GGS_typeListeRecherche (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
attributNomAttribut (argument_0),
attributNomTable (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_typeListeRecherche::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_typeListeRecherche * ptr = dynamic_cast <const elementOf_GGS_typeListeRecherche *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributNomAttribut.operator_isEqual (ptr->attributNomAttribut).boolValue ()
         && attributNomTable.operator_isEqual (ptr->attributNomTable).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_typeListeRecherche::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributNomAttribut.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << attributNomTable.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        List '@typeListeRecherche'                         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeListeRecherche ("typeListeRecherche", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
internalAppendValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
internalPrependValues (const GGS_lstring & argument_0,
                    const GGS_lstring & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche GGS_typeListeRecherche::
operator_concat (const GGS_typeListeRecherche & inOperand) const {
  GGS_typeListeRecherche result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
dotAssign_operation (const GGS_typeListeRecherche inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_typeListeRecherche * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstring  p_0 = p->attributNomAttribut ;
          GGS_lstring  p_1 = p->attributNomTable ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
modifier_prependValue (C_Compiler & /* inLexique */,
                     const GGS_lstring & argument_0,
                     const GGS_lstring & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->attributNomAttribut,
                                ptr->attributNomTable
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche  GGS_typeListeRecherche::
constructor_emptyList (void) {
  GGS_typeListeRecherche result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche  GGS_typeListeRecherche::
constructor_listWithValue (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  GGS_typeListeRecherche result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
internalSubListWithRange (GGS_typeListeRecherche & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->attributNomAttribut, ptr->attributNomTable) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche GGS_typeListeRecherche::
reader_subListWithRange (C_Compiler & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeRecherche result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche GGS_typeListeRecherche::
reader_subListFromIndex (C_Compiler & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_typeListeRecherche result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_typeListeRecherche::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@typeListeRecherche", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
method_first (C_Compiler & inLexique,
              GGS_lstring & _out_0,
              GGS_lstring & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributNomAttribut ;
    _out_1 = ptr->attributNomTable ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
method_last (C_Compiler & inLexique,
             GGS_lstring & _out_0,
             GGS_lstring & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributNomAttribut ;
    _out_1 = ptr->attributNomTable ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
modifier_popFirst (C_Compiler & inLexique,
                 GGS_lstring & _out_0,
                 GGS_lstring & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributNomAttribut ;
    _out_1 = ptr->attributNomTable ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
modifier_popLast (C_Compiler & inLexique,
                GGS_lstring & _out_0,
                GGS_lstring & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->attributNomAttribut ;
    _out_1 = ptr->attributNomTable ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeListeRecherche::
reader_attributNomAttributAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->attributNomAttribut ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeListeRecherche::
reader_attributNomTableAtIndex (C_Compiler & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstring  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->attributNomTable ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
modifier_setAttributNomAttributAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->attributNomAttribut = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
modifier_setAttributNomTableAtIndex (C_Compiler & inLexique,
                              const GGS_lstring  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->attributNomTable = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeListeRecherche::cEnumerator::_attributNomAttribut (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->attributNomAttribut ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_typeListeRecherche::cEnumerator::_attributNomTable (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->attributNomTable ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_typeListeRecherche::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeListeRecherche * p = NULL ;
    macroMyNew (p, GGS_typeListeRecherche (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche GGS_typeListeRecherche::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeListeRecherche result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeListeRecherche * p = dynamic_cast <const GGS_typeListeRecherche *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeListeRecherche, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeListeRecherche::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeListeRecherche ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeInstructionActionExterne'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionActionExterne::
cPtr_typeInstructionActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1,
                                const GGS_typeListeMessagesErreur & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
attributNomRoutineExterne (argument_0),
attributListeArguments (argument_1),
attributListeMessageErreur (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionActionExterne * GGS_typeInstructionActionExterne::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionActionExterne) ;
    return (cPtr_typeInstructionActionExterne *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionActionExterne::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionActionExterne * ptr = dynamic_cast <const cPtr_typeInstructionActionExterne *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributNomRoutineExterne.operator_isEqual (ptr->attributNomRoutineExterne).boolValue ()
         && attributListeArguments.operator_isEqual (ptr->attributListeArguments).boolValue ()
         && attributListeMessageErreur.operator_isEqual (ptr->attributListeMessageErreur).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionActionExterne::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionActionExterne:"
           << attributNomRoutineExterne.reader_description (inIndentation + 1)
           << attributListeArguments.reader_description (inIndentation + 1)
           << attributListeMessageErreur.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionActionExterne::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionActionExterne::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionActionExterne (& typeid (cPtr_typeInstructionActionExterne), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionActionExterne::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionActionExterne ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionActionExterne::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionActionExterne (attributNomRoutineExterne, attributListeArguments, attributListeMessageErreur COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionActionExterne'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionActionExterne ("typeInstructionActionExterne", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionActionExterne::
GGS_typeInstructionActionExterne (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionActionExterne::
GGS_typeInstructionActionExterne (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionActionExterne GGS_typeInstructionActionExterne::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionActionExterne result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionActionExterne *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionActionExterne) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionActionExterne (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionActionExterne),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionActionExterne GGS_typeInstructionActionExterne::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_typeListeArgumentsRoutExterne & argument_1,
                 const GGS_typeListeMessagesErreur & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionActionExterne result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionActionExterne (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionActionExterne::
reader_attributNomRoutineExterne (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionActionExterne *) mPointer)->attributNomRoutineExterne ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeInstructionActionExterne::
reader_attributListeArguments (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeArgumentsRoutExterne   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionActionExterne *) mPointer)->attributListeArguments ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur  GGS_typeInstructionActionExterne::
reader_attributListeMessageErreur (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeMessagesErreur   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionActionExterne *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionActionExterne *) mPointer)->attributListeMessageErreur ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionActionExterne::actualTypeName (void) const {
  return "typeInstructionActionExterne" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionActionExterne ("typeInstructionActionExterne", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeInstructionActionExterne) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionActionExterne::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionActionExterne * p = NULL ;
    macroMyNew (p, GGS_typeInstructionActionExterne (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionActionExterne GGS_typeInstructionActionExterne::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionActionExterne result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionActionExterne * p = dynamic_cast <const GGS_typeInstructionActionExterne *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionActionExterne, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionActionExterne::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionActionExterne ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_typeInstructionRepetitionLexicale'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionRepetitionLexicale::
cPtr_typeInstructionRepetitionLexicale (const GGS_tListeInstructionsLexicales & argument_0,
                                const GGS_typeListeTestsEtInstructions & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
attributListeInstructionsDebut (argument_0),
attributListeBranches (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionRepetitionLexicale * GGS_typeInstructionRepetitionLexicale::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionRepetitionLexicale) ;
    return (cPtr_typeInstructionRepetitionLexicale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionRepetitionLexicale::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionRepetitionLexicale * ptr = dynamic_cast <const cPtr_typeInstructionRepetitionLexicale *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributListeInstructionsDebut.operator_isEqual (ptr->attributListeInstructionsDebut).boolValue ()
         && attributListeBranches.operator_isEqual (ptr->attributListeBranches).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionRepetitionLexicale::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionRepetitionLexicale:"
           << attributListeInstructionsDebut.reader_description (inIndentation + 1)
           << attributListeBranches.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionRepetitionLexicale::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionRepetitionLexicale::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionRepetitionLexicale (& typeid (cPtr_typeInstructionRepetitionLexicale), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionRepetitionLexicale::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionRepetitionLexicale ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionRepetitionLexicale::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionRepetitionLexicale (attributListeInstructionsDebut, attributListeBranches COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionRepetitionLexicale'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionRepetitionLexicale ("typeInstructionRepetitionLexicale", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionRepetitionLexicale::
GGS_typeInstructionRepetitionLexicale (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionRepetitionLexicale::
GGS_typeInstructionRepetitionLexicale (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionRepetitionLexicale GGS_typeInstructionRepetitionLexicale::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionRepetitionLexicale result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionRepetitionLexicale *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionRepetitionLexicale) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionRepetitionLexicale (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionRepetitionLexicale),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionRepetitionLexicale GGS_typeInstructionRepetitionLexicale::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_tListeInstructionsLexicales & argument_0,
                 const GGS_typeListeTestsEtInstructions & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionRepetitionLexicale result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionRepetitionLexicale (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_typeInstructionRepetitionLexicale::
reader_attributListeInstructionsDebut (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tListeInstructionsLexicales   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionRepetitionLexicale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionRepetitionLexicale *) mPointer)->attributListeInstructionsDebut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeInstructionRepetitionLexicale::
reader_attributListeBranches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeTestsEtInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionRepetitionLexicale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionRepetitionLexicale *) mPointer)->attributListeBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionRepetitionLexicale::actualTypeName (void) const {
  return "typeInstructionRepetitionLexicale" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionRepetitionLexicale ("typeInstructionRepetitionLexicale", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeInstructionRepetitionLexicale) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionRepetitionLexicale::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionRepetitionLexicale * p = NULL ;
    macroMyNew (p, GGS_typeInstructionRepetitionLexicale (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionRepetitionLexicale GGS_typeInstructionRepetitionLexicale::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionRepetitionLexicale result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionRepetitionLexicale * p = dynamic_cast <const GGS_typeInstructionRepetitionLexicale *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionRepetitionLexicale, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionRepetitionLexicale::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionRepetitionLexicale ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeInstructionSiLexical'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionSiLexical::
cPtr_typeInstructionSiLexical (const GGS_typeListeTestsEtInstructions & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
attributListeBranches (argument_0),
attributBrancheSinon (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionSiLexical * GGS_typeInstructionSiLexical::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionSiLexical) ;
    return (cPtr_typeInstructionSiLexical *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionSiLexical::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionSiLexical * ptr = dynamic_cast <const cPtr_typeInstructionSiLexical *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributListeBranches.operator_isEqual (ptr->attributListeBranches).boolValue ()
         && attributBrancheSinon.operator_isEqual (ptr->attributBrancheSinon).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionSiLexical::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionSiLexical:"
           << attributListeBranches.reader_description (inIndentation + 1)
           << attributBrancheSinon.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionSiLexical::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionSiLexical::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionSiLexical (& typeid (cPtr_typeInstructionSiLexical), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionSiLexical::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionSiLexical ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionSiLexical::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionSiLexical (attributListeBranches, attributBrancheSinon COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeInstructionSiLexical'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionSiLexical ("typeInstructionSiLexical", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionSiLexical::
GGS_typeInstructionSiLexical (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionSiLexical::
GGS_typeInstructionSiLexical (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionSiLexical GGS_typeInstructionSiLexical::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionSiLexical result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionSiLexical *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionSiLexical) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionSiLexical (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionSiLexical),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionSiLexical GGS_typeInstructionSiLexical::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeListeTestsEtInstructions & argument_0,
                 const GGS_tListeInstructionsLexicales & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionSiLexical result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionSiLexical (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeInstructionSiLexical::
reader_attributListeBranches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeTestsEtInstructions   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionSiLexical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionSiLexical *) mPointer)->attributListeBranches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_typeInstructionSiLexical::
reader_attributBrancheSinon (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tListeInstructionsLexicales   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionSiLexical *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionSiLexical *) mPointer)->attributBrancheSinon ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionSiLexical::actualTypeName (void) const {
  return "typeInstructionSiLexical" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionSiLexical ("typeInstructionSiLexical", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeInstructionSiLexical) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionSiLexical::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionSiLexical * p = NULL ;
    macroMyNew (p, GGS_typeInstructionSiLexical (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionSiLexical GGS_typeInstructionSiLexical::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionSiLexical result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionSiLexical * p = dynamic_cast <const GGS_typeInstructionSiLexical *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionSiLexical, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionSiLexical::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionSiLexical ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeInstructionEmettreSimple'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionEmettreSimple::
cPtr_typeInstructionEmettreSimple (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionEmettreSimple * GGS_typeInstructionEmettreSimple::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionEmettreSimple) ;
    return (cPtr_typeInstructionEmettreSimple *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionEmettreSimple::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionEmettreSimple * ptr = dynamic_cast <const cPtr_typeInstructionEmettreSimple *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTerminal.operator_isEqual (ptr->mTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionEmettreSimple::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionEmettreSimple:"
           << mTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionEmettreSimple::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionEmettreSimple::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionEmettreSimple (& typeid (cPtr_typeInstructionEmettreSimple), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionEmettreSimple::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionEmettreSimple ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionEmettreSimple::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionEmettreSimple (mTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionEmettreSimple'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionEmettreSimple ("typeInstructionEmettreSimple", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettreSimple::
GGS_typeInstructionEmettreSimple (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettreSimple::
GGS_typeInstructionEmettreSimple (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionEmettreSimple GGS_typeInstructionEmettreSimple::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionEmettreSimple result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionEmettreSimple *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionEmettreSimple) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionEmettreSimple (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionEmettreSimple),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettreSimple GGS_typeInstructionEmettreSimple::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionEmettreSimple result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionEmettreSimple (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeInstructionEmettreSimple::
reader_mTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionEmettreSimple *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionEmettreSimple *) mPointer)->mTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionEmettreSimple::actualTypeName (void) const {
  return "typeInstructionEmettreSimple" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionEmettreSimple ("typeInstructionEmettreSimple", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeInstructionEmettreSimple) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionEmettreSimple::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionEmettreSimple * p = NULL ;
    macroMyNew (p, GGS_typeInstructionEmettreSimple (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettreSimple GGS_typeInstructionEmettreSimple::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionEmettreSimple result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionEmettreSimple * p = dynamic_cast <const GGS_typeInstructionEmettreSimple *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionEmettreSimple, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionEmettreSimple::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionEmettreSimple ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_typeLexicalDropInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLexicalDropInstruction::
cPtr_typeLexicalDropInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLexicalDropInstruction * GGS_typeLexicalDropInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLexicalDropInstruction) ;
    return (cPtr_typeLexicalDropInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLexicalDropInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLexicalDropInstruction * ptr = dynamic_cast <const cPtr_typeLexicalDropInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTerminal.operator_isEqual (ptr->mTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLexicalDropInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLexicalDropInstruction:"
           << mTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLexicalDropInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLexicalDropInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLexicalDropInstruction (& typeid (cPtr_typeLexicalDropInstruction), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLexicalDropInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeLexicalDropInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLexicalDropInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLexicalDropInstruction (mTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeLexicalDropInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLexicalDropInstruction ("typeLexicalDropInstruction", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeLexicalDropInstruction::
GGS_typeLexicalDropInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalDropInstruction::
GGS_typeLexicalDropInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLexicalDropInstruction GGS_typeLexicalDropInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLexicalDropInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLexicalDropInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeLexicalDropInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLexicalDropInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLexicalDropInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalDropInstruction GGS_typeLexicalDropInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLexicalDropInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLexicalDropInstruction (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLexicalDropInstruction::
reader_mTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalDropInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLexicalDropInstruction *) mPointer)->mTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLexicalDropInstruction::actualTypeName (void) const {
  return "typeLexicalDropInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLexicalDropInstruction ("typeLexicalDropInstruction", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeLexicalDropInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLexicalDropInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLexicalDropInstruction * p = NULL ;
    macroMyNew (p, GGS_typeLexicalDropInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalDropInstruction GGS_typeLexicalDropInstruction::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLexicalDropInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLexicalDropInstruction * p = dynamic_cast <const GGS_typeLexicalDropInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLexicalDropInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLexicalDropInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLexicalDropInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLexicalLogInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLexicalLogInstruction::
cPtr_typeLexicalLogInstruction (LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLexicalLogInstruction * GGS_typeLexicalLogInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLexicalLogInstruction) ;
    return (cPtr_typeLexicalLogInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLexicalLogInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLexicalLogInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@typeLexicalLogInstruction:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLexicalLogInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLexicalLogInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLexicalLogInstruction (& typeid (cPtr_typeLexicalLogInstruction), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLexicalLogInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeLexicalLogInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLexicalLogInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLexicalLogInstruction ("typeLexicalLogInstruction", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeLexicalLogInstruction::
GGS_typeLexicalLogInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalLogInstruction::
GGS_typeLexicalLogInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLexicalLogInstruction GGS_typeLexicalLogInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLexicalLogInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLexicalLogInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeLexicalLogInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLexicalLogInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLexicalLogInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_typeLexicalLogInstruction * gSingleton_typeLexicalLogInstruction = NULL ;

//---------------------------------------------------------------------------*

GGS_typeLexicalLogInstruction GGS_typeLexicalLogInstruction::
constructor_new (C_Compiler & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_typeLexicalLogInstruction result ;
  if (NULL == gSingleton_typeLexicalLogInstruction) {
    macroMyNew (gSingleton_typeLexicalLogInstruction, cPtr_typeLexicalLogInstruction (THERE)) ;
    macroRetainObject (gSingleton_typeLexicalLogInstruction) ;
  }
  macroAssignObject (result.mPointer, gSingleton_typeLexicalLogInstruction) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLexicalLogInstruction::actualTypeName (void) const {
  return "typeLexicalLogInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLexicalLogInstruction ("typeLexicalLogInstruction", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeLexicalLogInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLexicalLogInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLexicalLogInstruction * p = NULL ;
    macroMyNew (p, GGS_typeLexicalLogInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalLogInstruction GGS_typeLexicalLogInstruction::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLexicalLogInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLexicalLogInstruction * p = dynamic_cast <const GGS_typeLexicalLogInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLexicalLogInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLexicalLogInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLexicalLogInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_typeLexicalTagInstruction'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLexicalTagInstruction::
cPtr_typeLexicalTagInstruction (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mLexicalTagName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLexicalTagInstruction * GGS_typeLexicalTagInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLexicalTagInstruction) ;
    return (cPtr_typeLexicalTagInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLexicalTagInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLexicalTagInstruction * ptr = dynamic_cast <const cPtr_typeLexicalTagInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalTagName.operator_isEqual (ptr->mLexicalTagName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLexicalTagInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLexicalTagInstruction:"
           << mLexicalTagName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLexicalTagInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLexicalTagInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLexicalTagInstruction (& typeid (cPtr_typeLexicalTagInstruction), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLexicalTagInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeLexicalTagInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLexicalTagInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLexicalTagInstruction (mLexicalTagName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeLexicalTagInstruction'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLexicalTagInstruction ("typeLexicalTagInstruction", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeLexicalTagInstruction::
GGS_typeLexicalTagInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalTagInstruction::
GGS_typeLexicalTagInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLexicalTagInstruction GGS_typeLexicalTagInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLexicalTagInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLexicalTagInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeLexicalTagInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLexicalTagInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLexicalTagInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalTagInstruction GGS_typeLexicalTagInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeLexicalTagInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLexicalTagInstruction (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLexicalTagInstruction::
reader_mLexicalTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalTagInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLexicalTagInstruction *) mPointer)->mLexicalTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLexicalTagInstruction::actualTypeName (void) const {
  return "typeLexicalTagInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLexicalTagInstruction ("typeLexicalTagInstruction", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeLexicalTagInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLexicalTagInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLexicalTagInstruction * p = NULL ;
    macroMyNew (p, GGS_typeLexicalTagInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalTagInstruction GGS_typeLexicalTagInstruction::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLexicalTagInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLexicalTagInstruction * p = dynamic_cast <const GGS_typeLexicalTagInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLexicalTagInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLexicalTagInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLexicalTagInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_typeLexicalRewindAndSendInstruction'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeLexicalRewindAndSendInstruction::
cPtr_typeLexicalRewindAndSendInstruction (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mLexicalTagName (argument_0),
mTerminal (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeLexicalRewindAndSendInstruction * GGS_typeLexicalRewindAndSendInstruction::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeLexicalRewindAndSendInstruction) ;
    return (cPtr_typeLexicalRewindAndSendInstruction *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeLexicalRewindAndSendInstruction::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeLexicalRewindAndSendInstruction * ptr = dynamic_cast <const cPtr_typeLexicalRewindAndSendInstruction *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLexicalTagName.operator_isEqual (ptr->mLexicalTagName).boolValue ()
         && mTerminal.operator_isEqual (ptr->mTerminal).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeLexicalRewindAndSendInstruction::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeLexicalRewindAndSendInstruction:"
           << mLexicalTagName.reader_description (inIndentation + 1)
           << mTerminal.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeLexicalRewindAndSendInstruction::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeLexicalRewindAndSendInstruction::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeLexicalRewindAndSendInstruction (& typeid (cPtr_typeLexicalRewindAndSendInstruction), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeLexicalRewindAndSendInstruction::galgasRTTI (void) const {
  return & gClassInfoFor__typeLexicalRewindAndSendInstruction ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeLexicalRewindAndSendInstruction::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeLexicalRewindAndSendInstruction (mLexicalTagName, mTerminal COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_typeLexicalRewindAndSendInstruction'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeLexicalRewindAndSendInstruction ("typeLexicalRewindAndSendInstruction", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeLexicalRewindAndSendInstruction::
GGS_typeLexicalRewindAndSendInstruction (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalRewindAndSendInstruction::
GGS_typeLexicalRewindAndSendInstruction (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeLexicalRewindAndSendInstruction GGS_typeLexicalRewindAndSendInstruction::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeLexicalRewindAndSendInstruction result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeLexicalRewindAndSendInstruction *> (inPointer) != NULL)
      : (typeid (cPtr_typeLexicalRewindAndSendInstruction) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeLexicalRewindAndSendInstruction (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeLexicalRewindAndSendInstruction),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalRewindAndSendInstruction GGS_typeLexicalRewindAndSendInstruction::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeLexicalRewindAndSendInstruction result ;
  macroMyNew (result.mPointer, cPtr_typeLexicalRewindAndSendInstruction (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLexicalRewindAndSendInstruction::
reader_mLexicalTagName (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalRewindAndSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLexicalRewindAndSendInstruction *) mPointer)->mLexicalTagName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_typeLexicalRewindAndSendInstruction::
reader_mTerminal (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeLexicalRewindAndSendInstruction *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeLexicalRewindAndSendInstruction *) mPointer)->mTerminal ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeLexicalRewindAndSendInstruction::actualTypeName (void) const {
  return "typeLexicalRewindAndSendInstruction" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeLexicalRewindAndSendInstruction ("typeLexicalRewindAndSendInstruction", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeLexicalRewindAndSendInstruction) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeLexicalRewindAndSendInstruction::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeLexicalRewindAndSendInstruction * p = NULL ;
    macroMyNew (p, GGS_typeLexicalRewindAndSendInstruction (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalRewindAndSendInstruction GGS_typeLexicalRewindAndSendInstruction::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeLexicalRewindAndSendInstruction result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeLexicalRewindAndSendInstruction * p = dynamic_cast <const GGS_typeLexicalRewindAndSendInstruction *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeLexicalRewindAndSendInstruction, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeLexicalRewindAndSendInstruction::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeLexicalRewindAndSendInstruction ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_typeInstructionEmettre'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionEmettre::
cPtr_typeInstructionEmettre (const GGS_typeListeRecherche & argument_0,
                                const GGS_typeEmissionParDefaut & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
attributListeRecherches (argument_0),
attributEmissionParDefaut (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionEmettre * GGS_typeInstructionEmettre::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionEmettre) ;
    return (cPtr_typeInstructionEmettre *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionEmettre::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionEmettre * ptr = dynamic_cast <const cPtr_typeInstructionEmettre *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = attributListeRecherches.operator_isEqual (ptr->attributListeRecherches).boolValue ()
         && attributEmissionParDefaut.operator_isEqual (ptr->attributEmissionParDefaut).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionEmettre::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionEmettre:"
           << attributListeRecherches.reader_description (inIndentation + 1)
           << attributEmissionParDefaut.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionEmettre::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionEmettre::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionEmettre (& typeid (cPtr_typeInstructionEmettre), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionEmettre::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionEmettre ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionEmettre::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionEmettre (attributListeRecherches, attributEmissionParDefaut COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionEmettre'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionEmettre ("typeInstructionEmettre", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettre::
GGS_typeInstructionEmettre (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettre::
GGS_typeInstructionEmettre (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionEmettre GGS_typeInstructionEmettre::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionEmettre result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionEmettre *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionEmettre) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionEmettre (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionEmettre),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettre GGS_typeInstructionEmettre::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_typeListeRecherche & argument_0,
                 const GGS_typeEmissionParDefaut & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionEmettre result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionEmettre (argument_0,
                                argument_1 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche  GGS_typeInstructionEmettre::
reader_attributListeRecherches (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeListeRecherche   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionEmettre *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionEmettre *) mPointer)->attributListeRecherches ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut  GGS_typeInstructionEmettre::
reader_attributEmissionParDefaut (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_typeEmissionParDefaut   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionEmettre *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionEmettre *) mPointer)->attributEmissionParDefaut ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionEmettre::actualTypeName (void) const {
  return "typeInstructionEmettre" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionEmettre ("typeInstructionEmettre", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeInstructionEmettre) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionEmettre::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionEmettre * p = NULL ;
    macroMyNew (p, GGS_typeInstructionEmettre (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionEmettre GGS_typeInstructionEmettre::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionEmettre result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionEmettre * p = dynamic_cast <const GGS_typeInstructionEmettre *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionEmettre, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionEmettre::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionEmettre ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeInstructionErreurLexicale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionErreurLexicale::
cPtr_typeInstructionErreurLexicale (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionErreurLexicale * GGS_typeInstructionErreurLexicale::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionErreurLexicale) ;
    return (cPtr_typeInstructionErreurLexicale *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionErreurLexicale::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionErreurLexicale * ptr = dynamic_cast <const cPtr_typeInstructionErreurLexicale *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorMessageIndex.operator_isEqual (ptr->mErrorMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionErreurLexicale::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionErreurLexicale:"
           << mErrorMessageIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionErreurLexicale::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionErreurLexicale::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionErreurLexicale (& typeid (cPtr_typeInstructionErreurLexicale), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionErreurLexicale::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionErreurLexicale ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionErreurLexicale::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionErreurLexicale (mErrorMessageIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionErreurLexicale'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionErreurLexicale ("typeInstructionErreurLexicale", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionErreurLexicale::
GGS_typeInstructionErreurLexicale (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionErreurLexicale::
GGS_typeInstructionErreurLexicale (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionErreurLexicale GGS_typeInstructionErreurLexicale::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionErreurLexicale result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionErreurLexicale *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionErreurLexicale) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionErreurLexicale (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionErreurLexicale),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionErreurLexicale GGS_typeInstructionErreurLexicale::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionErreurLexicale result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionErreurLexicale (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeInstructionErreurLexicale::
reader_mErrorMessageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionErreurLexicale *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionErreurLexicale *) mPointer)->mErrorMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionErreurLexicale::actualTypeName (void) const {
  return "typeInstructionErreurLexicale" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionErreurLexicale ("typeInstructionErreurLexicale", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeInstructionErreurLexicale) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionErreurLexicale::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionErreurLexicale * p = NULL ;
    macroMyNew (p, GGS_typeInstructionErreurLexicale (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionErreurLexicale GGS_typeInstructionErreurLexicale::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionErreurLexicale result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionErreurLexicale * p = dynamic_cast <const GGS_typeInstructionErreurLexicale *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionErreurLexicale, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionErreurLexicale::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionErreurLexicale ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_typeInstructionLexicalWarning'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionLexicalWarning::
cPtr_typeInstructionLexicalWarning (const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_typeInstructionLexicale (THERE),
mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_typeInstructionLexicalWarning * GGS_typeInstructionLexicalWarning::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_typeInstructionLexicalWarning) ;
    return (cPtr_typeInstructionLexicalWarning *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionLexicalWarning::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_typeInstructionLexicalWarning * ptr = dynamic_cast <const cPtr_typeInstructionLexicalWarning *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mErrorMessageIndex.operator_isEqual (ptr->mErrorMessageIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_typeInstructionLexicalWarning::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@typeInstructionLexicalWarning:"
           << mErrorMessageIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionLexicalWarning::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_typeInstructionLexicalWarning::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_typeInstructionLexicalWarning (& typeid (cPtr_typeInstructionLexicalWarning), & typeid (cPtr_typeInstructionLexicale), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_typeInstructionLexicalWarning::galgasRTTI (void) const {
  return & gClassInfoFor__typeInstructionLexicalWarning ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_typeInstructionLexicalWarning::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_typeInstructionLexicalWarning (mErrorMessageIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionLexicalWarning'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_typeInstructionLexicalWarning ("typeInstructionLexicalWarning", true, & kTypeDescriptor_GGS_typeInstructionLexicale) ;

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicalWarning::
GGS_typeInstructionLexicalWarning (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicalWarning::
GGS_typeInstructionLexicalWarning (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_typeInstructionLexicalWarning GGS_typeInstructionLexicalWarning::
castFrom (C_Compiler & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_typeInstructionLexicalWarning result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_typeInstructionLexicalWarning *> (inPointer) != NULL)
      : (typeid (cPtr_typeInstructionLexicalWarning) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_typeInstructionLexicalWarning (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_typeInstructionLexicalWarning),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicalWarning GGS_typeInstructionLexicalWarning::
constructor_new (C_Compiler & /* inLexique */,
                 const GGS_uint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_typeInstructionLexicalWarning result ;
  macroMyNew (result.mPointer, cPtr_typeInstructionLexicalWarning (argument_0 COMMA_THERE)) ;
  macroRetainObject (result.mPointer) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_typeInstructionLexicalWarning::
reader_mErrorMessageIndex (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_typeInstructionLexicalWarning *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_typeInstructionLexicalWarning *) mPointer)->mErrorMessageIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_typeInstructionLexicalWarning::actualTypeName (void) const {
  return "typeInstructionLexicalWarning" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__typeInstructionLexicalWarning ("typeInstructionLexicalWarning", gClassInfoFor__typeInstructionLexicale, & kTypeDescriptor_GGS_typeInstructionLexicalWarning) ;

//---------------------------------------------------------------------------*

GGS_object GGS_typeInstructionLexicalWarning::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_typeInstructionLexicalWarning * p = NULL ;
    macroMyNew (p, GGS_typeInstructionLexicalWarning (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicalWarning GGS_typeInstructionLexicalWarning::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_typeInstructionLexicalWarning result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_typeInstructionLexicalWarning * p = dynamic_cast <const GGS_typeInstructionLexicalWarning *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_typeInstructionLexicalWarning, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_typeInstructionLexicalWarning::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_typeInstructionLexicalWarning ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "appendToLexicalInstructionList"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_appendToLexicalInstructionList (C_Compiler & inLexique,
                                GGS_typeListeTestsEtInstructions  & var_cas_ioLexicalRulesList,
                                const GGS_lstring   var_cas_ioDefinitionString,
                                const GGS_lstring   var_cas_ioTerminalSymbolName COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER routine_appendToLexicalInstructionList at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  GGS_typeListeConditionsLexicales  var_cas_lexicalConditionsList = GGS_typeListeConditionsLexicales ::constructor_emptyList () ;
  GGS_typeConditionLexicale  var_cas_c = GGS_typeConditionChaine ::constructor_new (inLexique, var_cas_ioDefinitionString COMMA_SOURCE_FILE_AT_LINE (296)) ;
  var_cas_lexicalConditionsList.addAssign_operation (var_cas_c) ;
  GGS_typeInstructionLexicale  var_cas_lexicalInstruction = GGS_typeInstructionEmettreSimple ::constructor_new (inLexique, var_cas_ioTerminalSymbolName COMMA_SOURCE_FILE_AT_LINE (300)) ;
  GGS_tListeInstructionsLexicales  var_cas_instructionList = GGS_tListeInstructionsLexicales ::constructor_emptyList () ;
  var_cas_instructionList.addAssign_operation (var_cas_lexicalInstruction) ;
  var_cas_ioLexicalRulesList.addAssign_operation (var_cas_lexicalConditionsList, var_cas_instructionList) ;
  #ifdef DEBUG_TRACE_ENABLED
    printf ("LEAVE routine_appendToLexicalInstructionList\n") ;
  #endif
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'e_tokensInListMap'                          *
//                                                                           *
//---------------------------------------------------------------------------*

e_tokensInListMap::e_tokensInListMap (void) :
mTerminalSymbol () {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class map '@tokensInListMap'                        *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_tokensInListMap ("tokensInListMap", false, NULL) ;

//---------------------------------------------------------------------------*

elementOf_GGS_tokensInListMap::
elementOf_GGS_tokensInListMap (const GGS_lstring & inKey,
              const PMSInt32 inIndex,
              const e_tokensInListMap & inInfo,
              const PMUInt32 inInitialState) :
AC_galgas_map_element (inKey, inIndex, inInitialState),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

void elementOf_GGS_tokensInListMap::
appendForMapDescription (const PMSInt32 inElementIndex,
                         C_String & ioString,
                         const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-key " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mKey.reader_description (inIndentation + 1) ;
  ioString << (mIsDefined ? "" : "(not solved)") ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-value " ;
  ioString.appendSigned (inElementIndex) ;
  ioString << ":" << mInfo.mTerminalSymbol.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_tokensInListMap::
isEqualToMapElement (const AC_galgas_map_element * inOperand) const {
  const elementOf_GGS_tokensInListMap * ptr = dynamic_cast <const elementOf_GGS_tokensInListMap *> (inOperand) ;
  macroValidPointer (ptr) ;
  return (mInfo.mTerminalSymbol.operator_isEqual (ptr->mInfo.mTerminalSymbol)).boolValue () ;
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_tokensInListMap::
new_element (const GGS_lstring & inKey, void * inInfo, const PMUInt32 inInitialState) {
  MF_Assert (reinterpret_cast <e_tokensInListMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  e_tokensInListMap * info = (e_tokensInListMap *) inInfo ;
  macroMyNew (p, cElement (inKey, nextIndex (), * info, inInitialState)) ;
  return p ;
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
assignInfo (AC_galgas_map_element * inPtr, void * inInfo) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_tokensInListMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  e_tokensInListMap * info = (e_tokensInListMap *) inInfo ;
  p->mInfo = * info ;
}

//---------------------------------------------------------------------------*

GGS_tokensInListMap GGS_tokensInListMap::
constructor_emptyMap (C_Compiler & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tokensInListMap result ;
  macroMyNew (result.mSharedMapRoot, cMapRoot) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
enterIndex (const GGS_string & inKey,
            AC_galgas_index_core & outIndex) {
  e_tokensInListMap info  ;
  internalEnterIndex (inKey,
                      (void *) & info,
                      outIndex) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tokensInListMap::
operator_isEqual (const GGS_tokensInListMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_tokensInListMap::
operator_isNotEqual (const GGS_tokensInListMap & inOperand) const {
  return GGS_bool (isBuilt () && inOperand.isBuilt (), ! isEqualToMap (inOperand)) ;
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <cElement *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  cElement * p = (cElement *) inPtr ;
  PMSInt32 attributeIndex = -1 ; // Unused here
  GGS_location existingKeyLocation ; // Unused here
  internalInsert (p->mKey, (void *) & p->mInfo, attributeIndex, existingKeyLocation, p->mIsDefined, p->mCurrentState) ;
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
insertElement (C_Compiler & inLexique,
               const PMUInt32 inInitialState,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               const GGS_lstring & inParameter0,
                GGS_luint * outIndex
                COMMA_LOCATION_ARGS) {
  PMSInt32 elementID = - 1 ;
  if (isBuilt ()
   && inParameter0.isBuilt ()
   && inKey.isBuilt ()) {
    insulateMap () ;
    e_tokensInListMap info  ;
    info.mTerminalSymbol = inParameter0 ;
    GGS_location existingKeyLocation ;
    internalInsert (inKey, (void *) & info, elementID, existingKeyLocation, true, inInitialState) ;
    if (elementID < 0) {
      emitInsertMapSemanticErrorMessage (inLexique, inKey, inErrorMessage, existingKeyLocation COMMA_THERE) ;
    }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (elementID >= 0, (PMUInt32) elementID), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
searchElement (C_Compiler & inLexique,
               const PMUInt32 /* inActionIndex */,
               const utf32 * inErrorMessage,
               const GGS_lstring & inKey,
               GGS_lstring   & outParameter0,
               GGS_luint * outIndex
               COMMA_LOCATION_ARGS) const {
  cElement * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search (inKey.string ()) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <cElement *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (cElement *) p ;
    if (node == NULL) {
      inLexique.semanticErrorUsingPerCentK (inKey.string (), inKey, inErrorMessage COMMA_THERE) ;
    }
  }
  if (node == NULL) {
    outParameter0.drop () ;
    if (outIndex != NULL) {
      outIndex->drop () ;
    }
  }else{
    outParameter0 = node->mInfo.mTerminalSymbol ;
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (PMUInt32) node->mID), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

const utf32 GGS_tokensInListMap::kSearchMessage_searchKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('n'),
  TO_UNICODE ('o'),
  TO_UNICODE ('t'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
method_searchKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                GGS_lstring   & outParameter0 COMMA_LOCATION_ARGS) const {
  searchElement (inLexique,
                 0,
                 kSearchMessage_searchKey,
                 inKey,
                 outParameter0,
                 NULL
                 COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

const utf32 GGS_tokensInListMap::kInsertMessage_insertKey [] = {
  TO_UNICODE ('t'),
  TO_UNICODE ('h'),
  TO_UNICODE ('e'),
  TO_UNICODE (' '),
  TO_UNICODE ('\''),
  TO_UNICODE ('%'),
  TO_UNICODE ('K'),
  TO_UNICODE ('\''),
  TO_UNICODE (' '),
  TO_UNICODE ('c'),
  TO_UNICODE ('h'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('a'),
  TO_UNICODE ('c'),
  TO_UNICODE ('t'),
  TO_UNICODE ('e'),
  TO_UNICODE ('r'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('s'),
  TO_UNICODE (' '),
  TO_UNICODE ('a'),
  TO_UNICODE ('l'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('a'),
  TO_UNICODE ('d'),
  TO_UNICODE ('y'),
  TO_UNICODE (' '),
  TO_UNICODE ('d'),
  TO_UNICODE ('e'),
  TO_UNICODE ('c'),
  TO_UNICODE ('l'),
  TO_UNICODE ('a'),
  TO_UNICODE ('r'),
  TO_UNICODE ('e'),
  TO_UNICODE ('d'),
  TO_UNICODE (' '),
  TO_UNICODE ('i'),
  TO_UNICODE ('n'),
  TO_UNICODE (' '),
  TO_UNICODE ('%'),
  TO_UNICODE ('L'),
  TO_UNICODE (0)
} ;

//---------------------------------------------------------------------------*

void GGS_tokensInListMap::
modifier_insertKey (C_Compiler & inLexique,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0 COMMA_LOCATION_ARGS) {
  insertElement (inLexique,
                 0,
                 kInsertMessage_insertKey,
                 inKey,
                 inParameter0,
                NULL
                COMMA_THERE) ;
}

//---------------------------------------------------------------------------*

GGS_tokensInListMap GGS_tokensInListMap::
constructor_mapWithMapToOverride (C_Compiler & /* inLexique */,
                                  const GGS_tokensInListMap & inMapToOverride
                                  COMMA_UNUSED_LOCATION_ARGS) {
  GGS_tokensInListMap result ; // Not Built
  if (inMapToOverride.mSharedMapRoot != NULL) {
    macroValidPointer (inMapToOverride.mSharedMapRoot) ;
    macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    result.mSharedMapRoot->mNextMap = inMapToOverride.mSharedMapRoot ;
    inMapToOverride.mSharedMapRoot->mReferenceCount ++ ;
    result.mSharedMapRoot->mSequenceNumber = inMapToOverride.mSharedMapRoot->mSequenceNumber ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tokensInListMap GGS_tokensInListMap::
reader_overriddenMap (C_Compiler & /* inLexique */
                      COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_tokensInListMap result ; // Not Built
  if (mSharedMapRoot != NULL) {
    macroValidPointer (mSharedMapRoot) ;
    result.mSharedMapRoot = mSharedMapRoot->mNextMap ;
    if (result.mSharedMapRoot != NULL) {
      macroValidPointer (result.mSharedMapRoot) ;
      result.mSharedMapRoot->mReferenceCount ++ ;
    }else{
      macroMyNew (result.mSharedMapRoot, cMapRoot) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_tokensInListMap::
reader_description (const PMSInt32 inIndentation) const {
  C_String s ;
  s << "<map @tokensInListMap " ;
  if (isBuilt ()) {
    s.appendSigned (count ()) ;
    s << " object" << ((count () > 1) ? "s " : " ") ;
    cMapRoot * mapRoot = mSharedMapRoot ;
    PMSInt32 level = 0 ;
    while (mapRoot != NULL) {
      if (level > 0) {
        s << "\n" ;
        s.writeStringMultiple ("| ", inIndentation) ;
        s << "------- level " << cStringWithSigned (level) ;
      }
      macroValidPointer (mapRoot) ;
      cElement * p = (cElement *) mapRoot->mFirstItem ;
      PMSInt32 elementID = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        p->appendForMapDescription (elementID, s, inIndentation) ;
        p = p->nextObject () ;
        elementID ++ ;
      }
      mapRoot = mapRoot->mNextMap ;
      level ++ ;
    }
  }else{
    s << "not built" ;
  }
  s << "\n" ;
  s.writeStringMultiple ("| ", inIndentation) ;
  s << ">" ;
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstring  & GGS_tokensInListMap::cEnumerator::_mTerminalSymbol (LOCATION_ARGS) const {
  return ((cElement *) mObjectArray (mCurrentIndex COMMA_THERE))->mInfo.mTerminalSymbol ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_tokensInListMap::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_tokensInListMap * p = NULL ;
    macroMyNew (p, GGS_tokensInListMap (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_tokensInListMap GGS_tokensInListMap::castFromObject (C_Compiler & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_tokensInListMap result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_tokensInListMap * p = dynamic_cast <const GGS_tokensInListMap *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_tokensInListMap, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_tokensInListMap::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_tokensInListMap ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_scanner_semantics (void) {
  macroReleaseObject (gSingleton_typeArgumentCaractereCourant) ;
  macroReleaseObject (gSingleton_typeLexicalLogInstruction) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_scanner_semantics (NULL, epilogueRoutineFor_scanner_semantics) ;

//---------------------------------------------------------------------------*

