//---------------------------------------------------------------------------*
//                                                                           *
//                       File 'scanner_semantics.cpp'                        *
//               Generated by version 0.14.0 (LL(1) grammar)                 *
//                     february 1st, 2005, at 20h17'22"                      *
//                                                                           *
// This program is free software; you can redistribute it and/or modify it   *
// under the terms of the GNU General Public License as published by the     *
// Free Software Foundation.                                                 *
//                                                                           *
// This program is distributed in the hope it will be useful, but WITHOUT    *
// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
// more details.                                                             *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "scanner_semantics.h"


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'typeLexicalAttributesMap'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeLexicalAttributesMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeLexicalAttributesMap::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeLexicalAttributesMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeLexicalAttributesMap * info = (e_typeLexicalAttributesMap *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeLexicalAttributesMap::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeLexicalAttributesMap::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeLexicalAttributesMap GGS_typeLexicalAttributesMap::constructor_empty (void) {
  GGS_typeLexicalAttributesMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeLexicalAttributesMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeLexicalAttributesMap info  ;
    info.attributType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeLexicalAttributesMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_AC_galgasType   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.attributType ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeLexicalAttributesMap (C_Lexique & inLexique,
                                GGS_typeLexicalAttributesMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the lexical attribute '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeLexicalAttributesMap (C_Lexique & lexique_var_,
                                GGS_typeLexicalAttributesMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the lexical attribute '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        class map 'lexicalTypeMap'                         *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_lexicalTypeMap::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_lexicalTypeMap & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_lexicalTypeMap::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_lexicalTypeMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_lexicalTypeMap * info = (e_lexicalTypeMap *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_lexicalTypeMap::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_lexicalTypeMap::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lexicalTypeMap GGS_lexicalTypeMap::constructor_empty (void) {
  GGS_lexicalTypeMap result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_lexicalTypeMap::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_AC_galgasType &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_lexicalTypeMap info  ;
    info.mAttributType = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_lexicalTypeMap::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_AC_galgasType   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mAttributType ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_lexicalTypeMap (C_Lexique & inLexique,
                                GGS_lexicalTypeMap & ioMap,
                                const GGS_lstring & inKey,
                                GGS_AC_galgasType   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"there is no type named '%'",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_lexicalTypeMap (C_Lexique & lexique_var_,
                                GGS_lexicalTypeMap & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_AC_galgasType & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"--- internal error ---",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class map 'typeTableMessagesErreurs'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableMessagesErreurs & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMessagesErreurs::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableMessagesErreurs *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableMessagesErreurs * info = (e_typeTableMessagesErreurs *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableMessagesErreurs::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeTableMessagesErreurs::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMessagesErreurs GGS_typeTableMessagesErreurs::constructor_empty (void) {
  GGS_typeTableMessagesErreurs result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMessagesErreurs::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeTableMessagesErreurs info  ;
    info.mErrorMessage = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMessagesErreurs::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_lstring   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mErrorMessage ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableMessagesErreurs (C_Lexique & inLexique,
                                GGS_typeTableMessagesErreurs & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lstring   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the error message '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableMessagesErreurs (C_Lexique & lexique_var_,
                                GGS_typeTableMessagesErreurs & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the error message '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                           class map 'M_styles'                            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_M_styles::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_M_styles & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_M_styles::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_M_styles *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_M_styles * info = (e_M_styles *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_M_styles::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_M_styles::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_M_styles GGS_M_styles::constructor_empty (void) {
  GGS_M_styles result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_M_styles::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_M_styles info  ;
    info.mTitle = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_M_styles::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_lstring   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mTitle ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_M_styles (C_Lexique & inLexique,
                                GGS_M_styles & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lstring   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' style is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_M_styles (C_Lexique & lexique_var_,
                                GGS_M_styles & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the '",
                                   "",
                                   "' style is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class map 'typeTableDefinitionTerminaux'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableDefinitionTerminaux & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableDefinitionTerminaux::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableDefinitionTerminaux *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableDefinitionTerminaux * info = (e_typeTableDefinitionTerminaux *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableDefinitionTerminaux::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeTableDefinitionTerminaux::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableDefinitionTerminaux GGS_typeTableDefinitionTerminaux::constructor_empty (void) {
  GGS_typeTableDefinitionTerminaux result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableDefinitionTerminaux::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_string&  inParameter0,
               const GGS_typeListeAttributsSemantiques &  inParameter1,
               const GGS_luint &  inParameter2,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()
                 && inParameter1.isBuilt ()
                 && inParameter2.isBuilt ()) {
     insulateMap () ;
    e_typeTableDefinitionTerminaux info  ;
    info.mErrorMessage = inParameter0 ;
    info.attributListeDesAttributs = inParameter1 ;
    info.mStyleIndex = inParameter2 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableDefinitionTerminaux::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_string  * outParameter0,
               GGS_typeListeAttributsSemantiques   * outParameter1,
               GGS_luint   * outParameter2,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outParameter1 != NULL) {
      outParameter1->drop_operation () ;
    }
    if (outParameter2 != NULL) {
      outParameter2->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.mErrorMessage ;
    }
    if (outParameter1 != NULL) {
      * outParameter1 = node->mInfo.attributListeDesAttributs ;
    }
    if (outParameter2 != NULL) {
      * outParameter2 = node->mInfo.mStyleIndex ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableDefinitionTerminaux (C_Lexique & inLexique,
                                GGS_typeTableDefinitionTerminaux & ioMap,
                                const GGS_lstring & inKey,
                                GGS_string  * outParameter0,
                                GGS_typeListeAttributsSemantiques   * outParameter1,
                                GGS_luint   * outParameter2,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the terminal symbol '$",
                                   "",
                                   "$' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outParameter1,
                       outParameter2,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableDefinitionTerminaux (C_Lexique & lexique_var_,
                                GGS_typeTableDefinitionTerminaux & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_string& inParameter0,
                                const GGS_typeListeAttributsSemantiques & inParameter1,
                                const GGS_luint & inParameter2,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the terminal symbol '$",
                                   "",
                                   "$' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       inParameter1,
                       inParameter2,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class map 'typeTableMotsReserves'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableMotsReserves & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableMotsReserves::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableMotsReserves *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableMotsReserves * info = (e_typeTableMotsReserves *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableMotsReserves::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeTableMotsReserves::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableMotsReserves GGS_typeTableMotsReserves::constructor_empty (void) {
  GGS_typeTableMotsReserves result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableMotsReserves::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_lstring &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeTableMotsReserves info  ;
    info.attributNomTerminal = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableMotsReserves::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_lstring   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.attributNomTerminal ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableMotsReserves (C_Lexique & inLexique,
                                GGS_typeTableMotsReserves & ioMap,
                                const GGS_lstring & inKey,
                                GGS_lstring   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the word '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableMotsReserves (C_Lexique & lexique_var_,
                                GGS_typeTableMotsReserves & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_lstring & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the word '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class map 'typeTableTablesDeMotsReserves'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves::element_type::
element_type (const GGS_lstring & inKey,
              const sint32 inIndex,
              const e_typeTableTablesDeMotsReserves & inInfo) :
AC_galgas_map_element (inIndex),
mKey (inKey),
mInfo (inInfo) {
}

//---------------------------------------------------------------------------*

AC_galgas_map_element * GGS_typeTableTablesDeMotsReserves::
new_element (void * inKey, void * inInfo) {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  MF_Assert (reinterpret_cast <e_typeTableTablesDeMotsReserves *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;
  AC_galgas_map_element * p = NULL ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  e_typeTableTablesDeMotsReserves * info = (e_typeTableTablesDeMotsReserves *) inInfo ;
  macroMyNew (p, element_type (* key, count (), * info)) ;
  return p ;
}

//---------------------------------------------------------------------------*

sint32 GGS_typeTableTablesDeMotsReserves::element_type::compareKeys (void * inKey) const {
  MF_Assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;
  GGS_lstring * key = (GGS_lstring *) inKey ;
  return mKey.compare_key_for_map (* key) ;
}

//---------------------------------------------------------------------------*

C_String GGS_typeTableTablesDeMotsReserves::element_type::stringForKey (void) const {
  C_String result ;
  result << mKey ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_typeTableTablesDeMotsReserves GGS_typeTableTablesDeMotsReserves::constructor_empty (void) {
  GGS_typeTableTablesDeMotsReserves result ;
  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_typeTableTablesDeMotsReserves::reader_hasKey (const GGS_lstring & inKey) const {
  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::internalInsertForDuplication (AC_galgas_map_element * inPtr) {
  MF_Assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;
  element_type * p = (element_type *) inPtr ;
  bool extension = false ; // Unused here
  sint32 index = -1 ; // Unused here
  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
insertElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               const GGS_typeTableMotsReserves &  inParameter0,
               GGS_luint * outIndex) {
  sint32 index = - 1 ;
  if (isBuilt () && inKey.isBuilt ()
                 && inParameter0.isBuilt ()) {
     insulateMap () ;
    e_typeTableTablesDeMotsReserves info  ;
    info.attributSimpleTable = inParameter0 ;
    bool extension = false ; // Unused here
    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;
    if (index < 0) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
     }
  }
  if (outIndex != NULL) {
    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeTableTablesDeMotsReserves::
searchElement (C_Lexique & inLexique,
               const char * inErrorMessagesArray [],
               const GGS_lstring & inKey,
               GGS_typeTableMotsReserves   * outParameter0,
               GGS_luint * outIndex) {
  element_type * node = NULL  ;
  if (isBuilt () && inKey.isBuilt ()) {
    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;
    MF_Assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;
    node = (element_type *) p ;
    if (node == NULL) {
      C_String keyString ;
      keyString << inKey ;
      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;
    }
  }
  if (node == NULL) {
    if (outParameter0 != NULL) {
      outParameter0->drop_operation () ;
    }
    if (outIndex != NULL) {
      outIndex->drop_operation () ;
     }
  }else{
    if (outParameter0 != NULL) {
      * outParameter0 = node->mInfo.attributSimpleTable ;
    }
    if (outIndex != NULL) {
      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;
    }
  }
}

//---------------------------------------------------------------------------*

void searchKey_typeTableTablesDeMotsReserves (C_Lexique & inLexique,
                                GGS_typeTableTablesDeMotsReserves & ioMap,
                                const GGS_lstring & inKey,
                                GGS_typeTableMotsReserves   * outParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the mord map '",
                                   "",
                                   "' is not declared",
                                   NULL} ;
  ioMap.searchElement (inLexique,
                       kErrorMessage,
                       inKey,
                       outParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*

void insertKey_typeTableTablesDeMotsReserves (C_Lexique & lexique_var_,
                                GGS_typeTableTablesDeMotsReserves & ioMap,
                                const GGS_lstring & inKey,
                                const GGS_typeTableMotsReserves & inParameter0,
                                GGS_luint * outIndex) {
  const char * kErrorMessage [] = {"the word map '",
                                   "",
                                   "' is already declared",
                                   NULL} ;
  ioMap.insertElement (lexique_var_,
                       kErrorMessage,
                       inKey,
                       inParameter0,
                       outIndex) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeConditionLexicale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeConditionLexicale'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
GGS_typeConditionLexicale (void) {
  mPointer = (cPtr_typeConditionLexicale *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
GGS_typeConditionLexicale (const GGS_typeConditionLexicale & inOperand) {
  mPointer = (cPtr_typeConditionLexicale *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
~GGS_typeConditionLexicale (void) {
  macroDetachPointer (mPointer, cPtr_typeConditionLexicale) ;
}

//---------------------------------------------------------------------------*

void GGS_typeConditionLexicale::
operator = (const GGS_typeConditionLexicale & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeConditionLexicale::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeConditionLexicale::
operator = (cPtr_typeConditionLexicale * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeConditionLexicale::
GGS_typeConditionLexicale (cPtr_typeConditionLexicale * inSource) {
  mPointer = (cPtr_typeConditionLexicale *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeConditionLexicale * GGS_typeConditionLexicale
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeConditionLexicale
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeConditionLexicale) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeConditionChaine'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionChaine::cPtr_typeConditionChaine (const GGS_lstring & argument_0)
:attributChaine (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeConditionChaine::isBuilt (void) const {
  return attributChaine.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeConditionChaine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeConditionChaine * GGS_typeConditionChaine::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeConditionChaine * ptr_ = (cPtr_typeConditionChaine *) NULL ;
    macroMyNew (ptr_, cPtr_typeConditionChaine (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeConditionCaractere'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionCaractere::cPtr_typeConditionCaractere (const GGS_lchar & argument_0)
:attributCaractere (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeConditionCaractere::isBuilt (void) const {
  return attributCaractere.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeConditionCaractere * GGS_typeConditionCaractere::
    constructor_new (const GGS_lchar & argument_0) {
    cPtr_typeConditionCaractere * ptr_ = (cPtr_typeConditionCaractere *) NULL ;
    macroMyNew (ptr_, cPtr_typeConditionCaractere (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeConditionIntervalle'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeConditionIntervalle::cPtr_typeConditionIntervalle (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1)
:attributBorneInf (argument_0),
attributBorneSup (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeConditionIntervalle::isBuilt (void) const {
  return attributBorneInf.isBuilt () &&
       attributBorneSup.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeConditionIntervalle'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeConditionIntervalle * GGS_typeConditionIntervalle::
    constructor_new (const GGS_lchar & argument_0,
                                const GGS_lchar & argument_1) {
    cPtr_typeConditionIntervalle * ptr_ = (cPtr_typeConditionIntervalle *) NULL ;
    macroMyNew (ptr_, cPtr_typeConditionIntervalle (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//           Class element of list 'typeListeConditionsLexicales'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales::element_type::
element_type (const GGS_typeConditionLexicale & argument_0) {
  mNextItem = (element_type *) NULL ;
  attributCondition = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'typeListeConditionsLexicales'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales
::GGS_typeListeConditionsLexicales (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales::~GGS_typeListeConditionsLexicales (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales::GGS_typeListeConditionsLexicales (const GGS_typeListeConditionsLexicales & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales
::operator = (const GGS_typeListeConditionsLexicales & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
internalAppendItem (const GGS_typeConditionLexicale & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales::
addAssign_operation (const GGS_typeConditionLexicale & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->attributCondition) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeConditionsLexicales  GGS_typeListeConditionsLexicales::
constructor_empty (void) {
  GGS_typeListeConditionsLexicales result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeConditionsLexicales
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              abstract class 'cPtr_typeInstructionLexicale'                *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionLexicale'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
GGS_typeInstructionLexicale (void) {
  mPointer = (cPtr_typeInstructionLexicale *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
GGS_typeInstructionLexicale (const GGS_typeInstructionLexicale & inOperand) {
  mPointer = (cPtr_typeInstructionLexicale *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
~GGS_typeInstructionLexicale (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionLexicale) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionLexicale::
operator = (const GGS_typeInstructionLexicale & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeInstructionLexicale::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionLexicale::
operator = (cPtr_typeInstructionLexicale * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeInstructionLexicale::
GGS_typeInstructionLexicale (cPtr_typeInstructionLexicale * inSource) {
  mPointer = (cPtr_typeInstructionLexicale *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeInstructionLexicale * GGS_typeInstructionLexicale
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeInstructionLexicale
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInstructionLexicale) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class element of list 'tListeInstructionsLexicales'             *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales::element_type::
element_type (const GGS_typeInstructionLexicale & argument_0) {
  mNextItem = (element_type *) NULL ;
  attributInstruction = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class list 'tListeInstructionsLexicales'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales
::GGS_tListeInstructionsLexicales (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales::~GGS_tListeInstructionsLexicales (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales::GGS_tListeInstructionsLexicales (const GGS_tListeInstructionsLexicales & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales
::operator = (const GGS_tListeInstructionsLexicales & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
internalAppendItem (const GGS_typeInstructionLexicale & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales::
addAssign_operation (const GGS_typeInstructionLexicale & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->attributInstruction) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_tListeInstructionsLexicales  GGS_tListeInstructionsLexicales::
constructor_empty (void) {
  GGS_tListeInstructionsLexicales result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_tListeInstructionsLexicales
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class element of list 'typeListeTestsEtInstructions'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions::element_type::
element_type (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) {
  mNextItem = (element_type *) NULL ;
  attributListeConditions = argument_0 ;
  attributListeInstructions = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'typeListeTestsEtInstructions'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions
::GGS_typeListeTestsEtInstructions (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions::~GGS_typeListeTestsEtInstructions (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions::GGS_typeListeTestsEtInstructions (const GGS_typeListeTestsEtInstructions & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions
::operator = (const GGS_typeListeTestsEtInstructions & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
internalAppendItem (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions::
addAssign_operation (const GGS_typeListeConditionsLexicales & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->attributListeConditions,
                                p->attributListeInstructions) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeTestsEtInstructions  GGS_typeListeTestsEtInstructions::
constructor_empty (void) {
  GGS_typeListeTestsEtInstructions result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeTestsEtInstructions
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             abstract class 'cPtr_typeArgumentRoutineExterne'              *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeArgumentRoutineExterne'                *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
GGS_typeArgumentRoutineExterne (void) {
  mPointer = (cPtr_typeArgumentRoutineExterne *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
GGS_typeArgumentRoutineExterne (const GGS_typeArgumentRoutineExterne & inOperand) {
  mPointer = (cPtr_typeArgumentRoutineExterne *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
~GGS_typeArgumentRoutineExterne (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentRoutineExterne) ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentRoutineExterne::
operator = (const GGS_typeArgumentRoutineExterne & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeArgumentRoutineExterne::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentRoutineExterne::
operator = (cPtr_typeArgumentRoutineExterne * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeArgumentRoutineExterne::
GGS_typeArgumentRoutineExterne (cPtr_typeArgumentRoutineExterne * inSource) {
  mPointer = (cPtr_typeArgumentRoutineExterne *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeArgumentRoutineExterne * GGS_typeArgumentRoutineExterne
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeArgumentRoutineExterne
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeArgumentRoutineExterne) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Class element of list 'typeListeArgumentsRoutExterne'            *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne::element_type::
element_type (const GGS_typeArgumentRoutineExterne & argument_0) {
  mNextItem = (element_type *) NULL ;
  attributArgument = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class list 'typeListeArgumentsRoutExterne'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne
::GGS_typeListeArgumentsRoutExterne (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne::~GGS_typeListeArgumentsRoutExterne (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne::GGS_typeListeArgumentsRoutExterne (const GGS_typeListeArgumentsRoutExterne & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne
::operator = (const GGS_typeListeArgumentsRoutExterne & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
internalAppendItem (const GGS_typeArgumentRoutineExterne & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne::
addAssign_operation (const GGS_typeArgumentRoutineExterne & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->attributArgument) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeArgumentsRoutExterne  GGS_typeListeArgumentsRoutExterne::
constructor_empty (void) {
  GGS_typeListeArgumentsRoutExterne result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeArgumentsRoutExterne
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeArgumentAttribut'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentAttribut::cPtr_typeArgumentAttribut (const GGS_lstring & argument_0,
                                const GGS_AC_galgasType & argument_1)
:attributNom (argument_0),
attributTypeAttribut (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentAttribut::isBuilt (void) const {
  return attributNom.isBuilt () &&
       attributTypeAttribut.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentAttribut'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeArgumentAttribut * GGS_typeArgumentAttribut::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_AC_galgasType & argument_1) {
    cPtr_typeArgumentAttribut * ptr_ = (cPtr_typeArgumentAttribut *) NULL ;
    macroMyNew (ptr_, cPtr_typeArgumentAttribut (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeArgumentCaractere'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentCaractere::cPtr_typeArgumentCaractere (const GGS_lchar & argument_0)
:attributCaractere (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentCaractere::isBuilt (void) const {
  return attributCaractere.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeArgumentCaractere'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeArgumentCaractere * GGS_typeArgumentCaractere::
    constructor_new (const GGS_lchar & argument_0) {
    cPtr_typeArgumentCaractere * ptr_ = (cPtr_typeArgumentCaractere *) NULL ;
    macroMyNew (ptr_, cPtr_typeArgumentCaractere (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeArgumentCaractereCourant'                    *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentCaractereCourant::isBuilt (void) const {
  return true ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeArgumentCaractereCourant'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeArgumentCaractereCourant * GGS_typeArgumentCaractereCourant::
    constructor_new () {
    cPtr_typeArgumentCaractereCourant * ptr_ = (cPtr_typeArgumentCaractereCourant *) NULL ;
    macroMyNew (ptr_, cPtr_typeArgumentCaractereCourant ()) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                        class 'typeArgumentEntier'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentEntier::cPtr_typeArgumentEntier (const GGS_luint & argument_0)
:attributValeur (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentEntier::isBuilt (void) const {
  return attributValeur.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentEntier'                    *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeArgumentEntier * GGS_typeArgumentEntier::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeArgumentEntier * ptr_ = (cPtr_typeArgumentEntier *) NULL ;
    macroMyNew (ptr_, cPtr_typeArgumentEntier (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeArgumentRoutine'                         *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeArgumentRoutine::cPtr_typeArgumentRoutine (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1)
:attributNomRoutine (argument_0),
attributListeArguments (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeArgumentRoutine::isBuilt (void) const {
  return attributNomRoutine.isBuilt () &&
       attributListeArguments.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_typeArgumentRoutine'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeArgumentRoutine * GGS_typeArgumentRoutine::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1) {
    cPtr_typeArgumentRoutine * ptr_ = (cPtr_typeArgumentRoutine *) NULL ;
    macroMyNew (ptr_, cPtr_typeArgumentRoutine (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//             Class element of list 'typeListeMessagesErreur'               *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur::element_type::
element_type (const GGS_luint & argument_0) {
  mNextItem = (element_type *) NULL ;
  mErrorMessageIndex = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class list 'typeListeMessagesErreur'                    *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur
::GGS_typeListeMessagesErreur (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur::~GGS_typeListeMessagesErreur (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur::GGS_typeListeMessagesErreur (const GGS_typeListeMessagesErreur & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur
::operator = (const GGS_typeListeMessagesErreur & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
internalAppendItem (const GGS_luint & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur::
addAssign_operation (const GGS_luint & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->mErrorMessageIndex) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeMessagesErreur  GGS_typeListeMessagesErreur::
constructor_empty (void) {
  GGS_typeListeMessagesErreur result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeMessagesErreur
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               abstract class 'cPtr_typeEmissionParDefaut'                 *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeEmissionParDefaut'                  *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
GGS_typeEmissionParDefaut (void) {
  mPointer = (cPtr_typeEmissionParDefaut *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
GGS_typeEmissionParDefaut (const GGS_typeEmissionParDefaut & inOperand) {
  mPointer = (cPtr_typeEmissionParDefaut *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
~GGS_typeEmissionParDefaut (void) {
  macroDetachPointer (mPointer, cPtr_typeEmissionParDefaut) ;
}

//---------------------------------------------------------------------------*

void GGS_typeEmissionParDefaut::
operator = (const GGS_typeEmissionParDefaut & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeEmissionParDefaut::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeEmissionParDefaut::
operator = (cPtr_typeEmissionParDefaut * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeEmissionParDefaut::
GGS_typeEmissionParDefaut (cPtr_typeEmissionParDefaut * inSource) {
  mPointer = (cPtr_typeEmissionParDefaut *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeEmissionParDefaut * GGS_typeEmissionParDefaut
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeEmissionParDefaut
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeEmissionParDefaut) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeEmissionTerminalParDefaut'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEmissionTerminalParDefaut::cPtr_typeEmissionTerminalParDefaut (const GGS_lstring & argument_0)
:attributNomTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeEmissionTerminalParDefaut::isBuilt (void) const {
  return attributNomTerminal.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeEmissionTerminalParDefaut'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEmissionTerminalParDefaut * GGS_typeEmissionTerminalParDefaut::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeEmissionTerminalParDefaut * ptr_ = (cPtr_typeEmissionTerminalParDefaut *) NULL ;
    macroMyNew (ptr_, cPtr_typeEmissionTerminalParDefaut (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeEmissionErreurParDefaut'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeEmissionErreurParDefaut::cPtr_typeEmissionErreurParDefaut (const GGS_luint & argument_0)
:mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeEmissionErreurParDefaut::isBuilt (void) const {
  return mErrorMessageIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_typeEmissionErreurParDefaut'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeEmissionErreurParDefaut * GGS_typeEmissionErreurParDefaut::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeEmissionErreurParDefaut * ptr_ = (cPtr_typeEmissionErreurParDefaut *) NULL ;
    macroMyNew (ptr_, cPtr_typeEmissionErreurParDefaut (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                Class element of list 'typeListeRecherche'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeRecherche::element_type::
element_type (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  mNextItem = (element_type *) NULL ;
  attributNomAttribut = argument_0 ;
  attributNomTable = argument_1 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class list 'typeListeRecherche'                       *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeRecherche
::GGS_typeListeRecherche (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche::~GGS_typeListeRecherche (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche::GGS_typeListeRecherche (const GGS_typeListeRecherche & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche
::operator = (const GGS_typeListeRecherche & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
internalAppendItem (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0,
                                argument_1)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche::
addAssign_operation (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1) {
  if (isBuilt ()
                 && argument_0.isBuilt ()
                 && argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0,
                                argument_1) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->attributNomAttribut,
                                p->attributNomTable) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeRecherche  GGS_typeListeRecherche::
constructor_empty (void) {
  GGS_typeListeRecherche result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeRecherche
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeInstructionActionExterne'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionActionExterne::cPtr_typeInstructionActionExterne (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1,
                                const GGS_typeListeMessagesErreur & argument_2)
:attributNomRoutineExterne (argument_0),
attributListeArguments (argument_1),
attributListeMessageErreur (argument_2) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionActionExterne::isBuilt (void) const {
  return attributNomRoutineExterne.isBuilt () &&
       attributListeArguments.isBuilt () &&
       attributListeMessageErreur.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionActionExterne'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionActionExterne * GGS_typeInstructionActionExterne::
    constructor_new (const GGS_lstring & argument_0,
                                const GGS_typeListeArgumentsRoutExterne & argument_1,
                                const GGS_typeListeMessagesErreur & argument_2) {
    cPtr_typeInstructionActionExterne * ptr_ = (cPtr_typeInstructionActionExterne *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionActionExterne (argument_0,
                                argument_1,
                                argument_2)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'typeInstructionRepetitionLexicale'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionRepetitionLexicale::cPtr_typeInstructionRepetitionLexicale (const GGS_tListeInstructionsLexicales & argument_0,
                                const GGS_typeListeTestsEtInstructions & argument_1)
:attributListeInstructionsDebut (argument_0),
attributListeBranches (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionRepetitionLexicale::isBuilt (void) const {
  return attributListeInstructionsDebut.isBuilt () &&
       attributListeBranches.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_typeInstructionRepetitionLexicale'            *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionRepetitionLexicale * GGS_typeInstructionRepetitionLexicale::
    constructor_new (const GGS_tListeInstructionsLexicales & argument_0,
                                const GGS_typeListeTestsEtInstructions & argument_1) {
    cPtr_typeInstructionRepetitionLexicale * ptr_ = (cPtr_typeInstructionRepetitionLexicale *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionRepetitionLexicale (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeInstructionSiLexical'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionSiLexical::cPtr_typeInstructionSiLexical (const GGS_typeListeTestsEtInstructions & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1)
:attributListeBranches (argument_0),
attributBrancheSinon (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionSiLexical::isBuilt (void) const {
  return attributListeBranches.isBuilt () &&
       attributBrancheSinon.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeInstructionSiLexical'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionSiLexical * GGS_typeInstructionSiLexical::
    constructor_new (const GGS_typeListeTestsEtInstructions & argument_0,
                                const GGS_tListeInstructionsLexicales & argument_1) {
    cPtr_typeInstructionSiLexical * ptr_ = (cPtr_typeInstructionSiLexical *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionSiLexical (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'typeInstructionEmettreSimple'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionEmettreSimple::cPtr_typeInstructionEmettreSimple (const GGS_lstring & argument_0)
:attributTerminal (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionEmettreSimple::isBuilt (void) const {
  return attributTerminal.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionEmettreSimple'               *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionEmettreSimple * GGS_typeInstructionEmettreSimple::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeInstructionEmettreSimple * ptr_ = (cPtr_typeInstructionEmettreSimple *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionEmettreSimple (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                      class 'typeInstructionEmettre'                       *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionEmettre::cPtr_typeInstructionEmettre (const GGS_typeListeRecherche & argument_0,
                                const GGS_typeEmissionParDefaut & argument_1)
:attributListeRecherches (argument_0),
attributEmissionParDefaut (argument_1) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionEmettre::isBuilt (void) const {
  return attributListeRecherches.isBuilt () &&
       attributEmissionParDefaut.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_typeInstructionEmettre'                  *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionEmettre * GGS_typeInstructionEmettre::
    constructor_new (const GGS_typeListeRecherche & argument_0,
                                const GGS_typeEmissionParDefaut & argument_1) {
    cPtr_typeInstructionEmettre * ptr_ = (cPtr_typeInstructionEmettre *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionEmettre (argument_0,
                                argument_1)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'typeInstructionErreurLexicale'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInstructionErreurLexicale::cPtr_typeInstructionErreurLexicale (const GGS_luint & argument_0)
:mErrorMessageIndex (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInstructionErreurLexicale::isBuilt (void) const {
  return mErrorMessageIndex.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_typeInstructionErreurLexicale'              *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInstructionErreurLexicale * GGS_typeInstructionErreurLexicale::
    constructor_new (const GGS_luint & argument_0) {
    cPtr_typeInstructionErreurLexicale * ptr_ = (cPtr_typeInstructionErreurLexicale *) NULL ;
    macroMyNew (ptr_, cPtr_typeInstructionErreurLexicale (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                   abstract class 'cPtr_typeInclusion'                     *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*
//                                                                           *
//                     GALGAS class 'GGS_typeInclusion'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeInclusion::
GGS_typeInclusion (void) {
  mPointer = (cPtr_typeInclusion *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeInclusion::
GGS_typeInclusion (const GGS_typeInclusion & inOperand) {
  mPointer = (cPtr_typeInclusion *) NULL ;
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

GGS_typeInclusion::
~GGS_typeInclusion (void) {
  macroDetachPointer (mPointer, cPtr_typeInclusion) ;
}

//---------------------------------------------------------------------------*

void GGS_typeInclusion::
operator = (const GGS_typeInclusion & inOperand) {
  macroAttachPointer (mPointer, inOperand.mPointer) ;
}

//---------------------------------------------------------------------------*

bool GGS_typeInclusion::isBuilt (void) const {
  bool result = false ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    result = mPointer->isBuilt () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeInclusion::
operator = (cPtr_typeInclusion * inSource) {
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

GGS_typeInclusion::
GGS_typeInclusion (cPtr_typeInclusion * inSource) {
  mPointer = (cPtr_typeInclusion *) NULL ;
  macroAttachPointer (mPointer, inSource) ;
}

//---------------------------------------------------------------------------*

cPtr_typeInclusion * GGS_typeInclusion
::operator () (void) const {
  macroValidPointer (mPointer) ;
  return mPointer ;
}

//---------------------------------------------------------------------------*

void GGS_typeInclusion
::drop_operation (void) {
  macroDetachPointer (mPointer, cPtr_typeInclusion) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'typeInclusionUtilisateur'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInclusionUtilisateur::cPtr_typeInclusionUtilisateur (const GGS_lstring & argument_0)
:attributNomFichierInclus (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInclusionUtilisateur::isBuilt (void) const {
  return attributNomFichierInclus.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_typeInclusionUtilisateur'                 *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInclusionUtilisateur * GGS_typeInclusionUtilisateur::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeInclusionUtilisateur * ptr_ = (cPtr_typeInclusionUtilisateur *) NULL ;
    macroMyNew (ptr_, cPtr_typeInclusionUtilisateur (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                       class 'typeInclusionSysteme'                        *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_typeInclusionSysteme::cPtr_typeInclusionSysteme (const GGS_lstring & argument_0)
:attributNomFichierInclus (argument_0) {
}

//---------------------------------------------------------------------------*

bool cPtr_typeInclusionSysteme::isBuilt (void) const {
  return attributNomFichierInclus.isBuilt () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_typeInclusionSysteme'                   *
//                                                                           *
//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE
  cPtr_typeInclusionSysteme * GGS_typeInclusionSysteme::
    constructor_new (const GGS_lstring & argument_0) {
    cPtr_typeInclusionSysteme * ptr_ = (cPtr_typeInclusionSysteme *) NULL ;
    macroMyNew (ptr_, cPtr_typeInclusionSysteme (argument_0)) ;
    return ptr_ ;
  }
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//               Class element of list 'typeListeInclusions'                 *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeInclusions::element_type::
element_type (const GGS_typeInclusion & argument_0) {
  mNextItem = (element_type *) NULL ;
  attributInclusion = argument_0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class list 'typeListeInclusions'                      *
//                                                                           *
//---------------------------------------------------------------------------*

GGS_typeListeInclusions
::GGS_typeListeInclusions (void) { // Default Constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
}

//---------------------------------------------------------------------------*

GGS_typeListeInclusions::~GGS_typeListeInclusions (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*

GGS_typeListeInclusions::GGS_typeListeInclusions (const GGS_typeListeInclusions & source) { // Copy constructor
  mFirstItem = (element_type *) NULL ;
  mLastItem = (element_type *) NULL ;
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mCountReference = (sint32 *) NULL ;
  *this = source ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeInclusions
::operator = (const GGS_typeListeInclusions & source) { // Assignment operator
  if (this != & source) {
    emptyList () ;
    mFirstItem = source.mFirstItem ;
    mLastItem = source.mLastItem ;
    mCurrentItemPtr = (element_type *) NULL ;
    mCurrentItemIndex = 0 ;
    mListLength = source.mListLength ;
    mCountReference = source.mCountReference ;
    if (mCountReference != NULL) {
      macroValidPointer (mCountReference) ;
      (*mCountReference) ++ ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeInclusions
::emptyList (void) {
  mCurrentItemPtr = (element_type *) NULL ;
  mCurrentItemIndex = 0 ;
  mListLength = 0 ;
  mLastItem = (element_type *) NULL ;
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) == 1) {
      macroMyDelete (mCountReference, sint32) ;
      while (mFirstItem != NULL) {
        macroValidPointer (mFirstItem) ;
        mLastItem = mFirstItem->mNextItem ;
        macroMyDelete (mFirstItem, element_type) ;
        mFirstItem = mLastItem ;
      }
    }else{
      mFirstItem = (element_type *) NULL ;
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeInclusions::
internalAppendItem (const GGS_typeInclusion & argument_0) {
  element_type * nouvelElement = (element_type *) NULL ;
  macroMyNew (nouvelElement, element_type (argument_0)) ;
  if (nouvelElement != NULL) {
    macroValidPointer (nouvelElement) ;
    if (mLastItem == NULL) {
      mFirstItem = nouvelElement ;
    }else{
      macroValidPointer (mLastItem) ;
      mLastItem->mNextItem = nouvelElement ;
    }
    mLastItem = nouvelElement ;
    nouvelElement = (element_type *) NULL ;
    mListLength ++ ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeInclusions::
addAssign_operation (const GGS_typeInclusion & argument_0) {
  if (isBuilt ()
                 && argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendItem (argument_0) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_typeListeInclusions
::insulateList (void) {
  if (mCountReference != NULL) {
    macroValidPointer (mCountReference) ;
    if ((*mCountReference) > 1) {
      element_type * p = mFirstItem ;
      mFirstItem = (element_type *)  NULL ;
      mLastItem = (element_type *)  NULL ;
      mListLength = 0 ;
      mCurrentItemPtr = (element_type *) NULL ;
      mCurrentItemIndex = 0 ;
      while (p != NULL) {
        macroValidPointer (p) ;
        internalAppendItem (p->attributInclusion) ;
        p = p->mNextItem ;
      }
      (*mCountReference) -- ;
      mCountReference = (sint32 *) NULL ;
      macroMyNew (mCountReference, sint32 (1)) ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_typeListeInclusions  GGS_typeListeInclusions::
constructor_empty (void) {
  GGS_typeListeInclusions result ;
  macroMyNew (result.mCountReference, sint32 (1)) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_typeListeInclusions
::drop_operation (void) {
  emptyList () ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Implementation of routine "appendToLexicalInstructionList"         *
//                                                                           *
//---------------------------------------------------------------------------*

void routine_appendToLexicalInstructionList (C_Lexique &,
                                GGS_typeListeTestsEtInstructions  & var_cas_ioLexicalRulesList,
                                const GGS_lstring  & var_cas_ioDefinitionString,
                                GGS_lstring  & var_cas_ioTerminalSymbolName) {
  GGS_typeListeConditionsLexicales  var_cas_lexicalConditionsList ;
  var_cas_lexicalConditionsList = GGS_typeListeConditionsLexicales::constructor_empty () ;
  GGS_typeConditionLexicale  var_cas_c ;
  var_cas_c = GGS_typeConditionChaine::constructor_new (var_cas_ioDefinitionString) ;
  var_cas_lexicalConditionsList.addAssign_operation (var_cas_c) ;
  GGS_typeInstructionLexicale  var_cas_lexicalInstruction ;
  var_cas_lexicalInstruction = GGS_typeInstructionEmettreSimple::constructor_new (var_cas_ioTerminalSymbolName) ;
  GGS_tListeInstructionsLexicales  var_cas_instructionList ;
  var_cas_instructionList = GGS_tListeInstructionsLexicales::constructor_empty () ;
  var_cas_instructionList.addAssign_operation (var_cas_lexicalInstruction) ;
  var_cas_ioLexicalRulesList.addAssign_operation (var_cas_lexicalConditionsList, var_cas_instructionList) ;
}

//---------------------------------------------------------------------------*

