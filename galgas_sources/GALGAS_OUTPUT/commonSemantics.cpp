//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'commonSemantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                       may 17th, 2007, at 20h32'5"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "commonSemantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "commonSemantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'actualParametersPassingMode' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_actualParametersPassingMode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_isEqual (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_isNotEqual (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_infOrEqual (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_supOrEqual (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_strictInf (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_strictSup (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_actualArgumentMessage (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [4] = {"",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter",
    "an input (\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @actualParametersPassingMode" ;
  switch (mValue) {
case enum_parameterOut:
  s << " parameterOut>" ;
    break ;
case enum_parameterOutIn:
  s << " parameterOutIn>" ;
    break ;
case enum_parameterIn:
  s << " parameterIn>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'formalArgumentPassingMode' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_formalArgumentPassingMode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_isEqual (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_isNotEqual (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_infOrEqual (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_supOrEqual (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_strictInf (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_strictSup (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_formalArgumentMessage (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "an input (\?) formal argument",
    "an output (!) formal argument",
    "an input/output (\?!) argument",
    "a constant input (\?\?) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @formalArgumentPassingMode" ;
  switch (mValue) {
case enum_argumentIn:
  s << " argumentIn>" ;
    break ;
case enum_argumentOut:
  s << " argumentOut>" ;
    break ;
case enum_argumentInOut:
  s << " argumentInOut>" ;
    break ;
case enum_argumentConstantIn:
  s << " argumentConstantIn>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*

