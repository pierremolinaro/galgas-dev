//---------------------------------------------------------------------------*
//                                                                           *
//                        File 'commonSemantics.cpp'                         *
//         Generated by version GALGAS_BETA_VERSION (LL(1) grammar)          *
//                    february 29th, 2008, at 16h58'24"                      *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "commonSemantics.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "commonSemantics.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'actualParametersPassingMode' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_actualParametersPassingMode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_isEqual (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_isNotEqual (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_infOrEqual (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_supOrEqual (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_strictInf (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_actualParametersPassingMode::
_operator_strictSup (const GGS_actualParametersPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_actualArgumentMessage (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [4] = {"",
    "an input (\?) actual parameter",
    "an output (!) actual parameter",
    "an output/input (!\?) actual parameter"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_actualParametersPassingMode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @actualParametersPassingMode" ;
  switch (mValue) {
  case enum_parameterOut:
    s << " parameterOut>" ;
    break ;
  case enum_parameterOutIn:
    s << " parameterOutIn>" ;
    break ;
  case enum_parameterIn:
    s << " parameterIn>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            Class for 'formalArgumentPassingMode' Enumeration              *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_formalArgumentPassingMode::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_isEqual (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_isNotEqual (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_infOrEqual (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_supOrEqual (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_strictInf (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_formalArgumentPassingMode::
_operator_strictSup (const GGS_formalArgumentPassingMode inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_formalArgumentMessage (C_Compiler & /* _inLexique */
                       COMMA_UNUSED_LOCATION_ARGS) const {
  const char * kMessages [5] = {"",
    "a constant input (\?\?) formal argument",
    "an input (\?) formal argument",
    "an input/output (\?!) argument",
    "an output (!) formal argument"
  } ;
  return GGS_string (mValue > 0, kMessages [mValue]) ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_formalArgumentPassingMode::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @formalArgumentPassingMode" ;
  switch (mValue) {
  case enum_argumentIn:
    s << " argumentIn>" ;
    break ;
  case enum_argumentOut:
    s << " argumentOut>" ;
    break ;
  case enum_argumentInOut:
    s << " argumentInOut>" ;
    break ;
  case enum_argumentConstantIn:
    s << " argumentConstantIn>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Class for 'variableStateAutomaton' Enumeration               *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_variableStateAutomaton::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_isEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_isNotEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_infOrEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_supOrEqual (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_strictInf (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_variableStateAutomaton::
_operator_strictSup (const GGS_variableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_writeAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_writeAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localConstantDefined ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localConstantDefined ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local constant is already defined") COMMA_SOURCE_FILE_AT_LINE (79)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local constant is already defined") COMMA_SOURCE_FILE_AT_LINE (80)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterDefined ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be written") COMMA_SOURCE_FILE_AT_LINE (86)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be written") COMMA_SOURCE_FILE_AT_LINE (87)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_readAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_readAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (93)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (95)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localConstantDefined ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local constant cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (97)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDefined ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (103)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_readWriteAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_readWriteAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (112)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (114)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (116)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (117)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be modified") COMMA_SOURCE_FILE_AT_LINE (118)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (120)) ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterUsed ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDefined ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (122)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an input parameter cannot be modified") COMMA_SOURCE_FILE_AT_LINE (124)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an input parameter cannot be modified") COMMA_SOURCE_FILE_AT_LINE (125)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_variableStateAutomaton::
modifier_dropAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_variableStateAutomaton::modifier_dropAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (131)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableDropped ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable is already dropped") COMMA_SOURCE_FILE_AT_LINE (133)) ;
    break ;
  case enum_localConstantDeclared:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (135)) ;
    break ;
  case enum_localConstantDefined:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (136)) ;
    break ;
  case enum_localContantUsed:
    mValue = enum_localContantUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "a local constant cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (137)) ;
    break ;
  case enum_inputFormalParameterDefined:
    mValue = enum_inputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (139)) ;
    break ;
  case enum_inputFormalParameterUsed:
    mValue = enum_inputFormalParameterDropped ;
    break ;
  case enum_inputFormalParameterDropped:
    mValue = enum_inputFormalParameterDropped ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the input parameter is already dropped") COMMA_SOURCE_FILE_AT_LINE (141)) ;
    break ;
  case enum_constantInputFormalParameterDefined:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an input parameter cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (143)) ;
    break ;
  case enum_constantInputFormalParameterUsed:
    mValue = enum_constantInputFormalParameterUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "an input parameter cannot be dropped") COMMA_SOURCE_FILE_AT_LINE (144)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_variableStateAutomaton::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @variableStateAutomaton" ;
  switch (mValue) {
  case enum_localVariableDeclared:
    s << " localVariableDeclared>" ;
    break ;
  case enum_localVariableUsed:
    s << " localVariableUsed>" ;
    break ;
  case enum_localVariableDropped:
    s << " localVariableDropped>" ;
    break ;
  case enum_localConstantDeclared:
    s << " localConstantDeclared>" ;
    break ;
  case enum_localConstantDefined:
    s << " localConstantDefined>" ;
    break ;
  case enum_localContantUsed:
    s << " localContantUsed>" ;
    break ;
  case enum_inputFormalParameterDefined:
    s << " inputFormalParameterDefined>" ;
    break ;
  case enum_inputFormalParameterUsed:
    s << " inputFormalParameterUsed>" ;
    break ;
  case enum_inputFormalParameterDropped:
    s << " inputFormalParameterDropped>" ;
    break ;
  case enum_constantInputFormalParameterDefined:
    s << " constantInputFormalParameterDefined>" ;
    break ;
  case enum_constantInputFormalParameterUsed:
    s << " constantInputFormalParameterUsed>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           Class for 'localVariableStateAutomaton' Enumeration             *
//                                                                           *
//---------------------------------------------------------------------------*

bool GGS_localVariableStateAutomaton::
_isBuilt (void) const {
  return mValue > kNotBuilt ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableStateAutomaton::
_operator_isEqual (const GGS_localVariableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue == inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableStateAutomaton::
_operator_isNotEqual (const GGS_localVariableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue != inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableStateAutomaton::
_operator_infOrEqual (const GGS_localVariableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue <= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableStateAutomaton::
_operator_supOrEqual (const GGS_localVariableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue >= inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableStateAutomaton::
_operator_strictInf (const GGS_localVariableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue < inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_localVariableStateAutomaton::
_operator_strictSup (const GGS_localVariableStateAutomaton inOperand) const {
  return GGS_bool (_isBuilt () && inOperand._isBuilt (),
                   mValue > inOperand.mValue) ;
}

//---------------------------------------------------------------------------*

void GGS_localVariableStateAutomaton::
modifier_writeAccess (C_Compiler &,
                                const GGS_location   /* var_cas_inErrorLocation */
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_localVariableStateAutomaton::modifier_writeAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableStateAutomaton::
modifier_readAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_localVariableStateAutomaton::modifier_readAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be read, it has no value") COMMA_SOURCE_FILE_AT_LINE (163)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be read, it is dropped") COMMA_SOURCE_FILE_AT_LINE (165)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableStateAutomaton::
modifier_readWriteAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_localVariableStateAutomaton::modifier_readWriteAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be modified, has no value") COMMA_SOURCE_FILE_AT_LINE (170)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableUsed ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableUsed ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be modified, it is dropped") COMMA_SOURCE_FILE_AT_LINE (172)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableStateAutomaton::
modifier_dropAccess (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_localVariableStateAutomaton::modifier_dropAccess at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable cannot be dropped, has no value") COMMA_SOURCE_FILE_AT_LINE (177)) ;
    break ;
  case enum_localVariableUsed:
    mValue = enum_localVariableDropped ;
    break ;
  case enum_localVariableDropped:
    mValue = enum_localVariableDropped ;
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticError (_inLexique, GGS_string (true, "the local variable is already dropped") COMMA_SOURCE_FILE_AT_LINE (179)) ;
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

void GGS_localVariableStateAutomaton::
method_checkFinalState (C_Compiler & _inLexique,
                                const GGS_location   var_cas_inErrorLocation
                                COMMA_UNUSED_LOCATION_ARGS) const {
  #ifdef DEBUG_TRACE_ENABLED
    printf ("ENTER GGS_localVariableStateAutomaton::modifier_checkFinalState at %s:%d\n", __FILE__, __LINE__) ;
  #endif
  switch (mValue) {
  case enum_localVariableDeclared:
    var_cas_inErrorLocation.reader_location (_inLexique COMMA_HERE).signalGGSSemanticWarning (_inLexique, GGS_string (true, "the local variable is unused") COMMA_SOURCE_FILE_AT_LINE (184)) ;
    break ;
  case enum_localVariableUsed:
    break ;
  case enum_localVariableDropped:
    break ;
  default : break ;
  }
}

//---------------------------------------------------------------------------*

GGS_string GGS_localVariableStateAutomaton::
reader_description (C_Compiler & /* _inLexique */
                    COMMA_UNUSED_LOCATION_ARGS,
                    const sint32 /* inIndentation */) const {
  C_String s ;
  s << "<enum @localVariableStateAutomaton" ;
  switch (mValue) {
  case enum_localVariableDeclared:
    s << " localVariableDeclared>" ;
    break ;
  case enum_localVariableUsed:
    s << " localVariableUsed>" ;
    break ;
  case enum_localVariableDropped:
    s << " localVariableDropped>" ;
    break ;
  case kNotBuilt:
    s << " (not built)>" ;
    break ;
  }
  return GGS_string (true, s) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 Implementation of wrapper 'wrapperTest'                   *
//                                                                           *
//---------------------------------------------------------------------------*

//---------------------------------------------------------------------------*

//--- File 'azerty/bip.ext1'

const char * gWrapperFileContent_2_wrapperTest = // 1143 bytes
  "#!/bin/sh\n"
  "set -x\n"
  "DIR=`dirname $0` &&\n"
  "#----------------- class_sample_language\n"
  "galgas -v --Werror ${DIR}/class_sample_language/galgas_sources/_all_class_sample_language.ggs &&\n"
  "cd ${DIR}/class_sample_language/makefile_macosx && make --warn-undefined-variables all &&\n"
  "#----------------- dangling_else_solution\n"
  "galgas -v --Werror ${DIR}/dangling_else_solution/galgas_sources/_all_dangling_else_solution.ggs &&\n"
  "cd ${DIR}/dangling_else_solution/makefile_macosx && make --warn-undefined-variables all &&\n"
  "#----------------- SLR_expression\n"
  "galgas -v --Werror ${DIR}/SLR_expression/galgas_sources/_all_SLR_expression.ggs &&\n"
  "cd ${DIR}/SLR_expression/makefile_macosx && make --warn-undefined-variables all &&\n"
  "#----------------- LL1_expression\n"
  "galgas -v --Werror ${DIR}/LL1_expression/galgas_sources/_all_LL1_expression.ggs &&\n"
  "cd ${DIR}/LL1_expression/makefile_macosx && make --warn-undefined-variables all &&\n"
  "#----------------- LR1_grammar\n"
  "galgas -v --Werror ${DIR}/LR1_grammar/galgas_sources/_all_LR1_grammar.ggs &&\n"
  "cd ${DIR}/LR1_grammar/makefile_macosx && make --warn-undefined-variables all &&\n"
  "echo \"------------ SUCCESS ----------------------------\"\n"
;

static const cRegularFileWrapper gWrapperFile_2_wrapperTest = {
  "bip.ext1",
  gWrapperFileContent_2_wrapperTest
} ;

//---------------------------------------------------------------------------*

//--- File 'azerty/bop.bat'

const char * gWrapperFileContent_3_wrapperTest = // 1031 bytes
  "#!/bin/sh\n"
  "set -x\n"
  "DIR=`dirname $0` &&\n"
  "#----------------- class_sample_language\n"
  "rm -fr ${DIR}/class_sample_language/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/class_sample_language/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "#----------------- dangling_else_solution\n"
  "rm -fr ${DIR}/dangling_else_solution/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/dangling_else_solution/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "#----------------- SLR_expression\n"
  "rm -fr ${DIR}/SLR_expression/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/SLR_expression/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "#----------------- LL1_expression\n"
  "rm -fr ${DIR}/LL1_expression/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/LL1_expression/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "#----------------- LR1_grammar\n"
  "rm -fr ${DIR}/LR1_grammar/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/LR1_grammar/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "echo \"------------ SUCCESS ----------------------------\"\n"
;

static const cRegularFileWrapper gWrapperFile_3_wrapperTest = {
  "bop.bat",
  gWrapperFileContent_3_wrapperTest
} ;

//---------------------------------------------------------------------------*

//--- All files of 'azerty' directory

static const cRegularFileWrapper * gWrapperAllFiles_wrapperTest_1 [3] = {
  & gWrapperFile_2_wrapperTest,
  & gWrapperFile_3_wrapperTest,
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of 'azerty' directory

static const cDirectoryWrapper * gWrapperAllDirectories_wrapperTest_1 [1] = {
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory 'azerty'

static const cDirectoryWrapper gWrapperDirectory_1_wrapperTest = {
  "azerty",
  2,
  gWrapperAllFiles_wrapperTest_1,
  0,
  gWrapperAllDirectories_wrapperTest_1
} ;

//---------------------------------------------------------------------------*

//--- File '/_build_all_macosx.ext1'

const char * gWrapperFileContent_0_wrapperTest = // 1143 bytes
  "#!/bin/sh\n"
  "set -x\n"
  "DIR=`dirname $0` &&\n"
  "#----------------- class_sample_language\n"
  "galgas -v --Werror ${DIR}/class_sample_language/galgas_sources/_all_class_sample_language.ggs &&\n"
  "cd ${DIR}/class_sample_language/makefile_macosx && make --warn-undefined-variables all &&\n"
  "#----------------- dangling_else_solution\n"
  "galgas -v --Werror ${DIR}/dangling_else_solution/galgas_sources/_all_dangling_else_solution.ggs &&\n"
  "cd ${DIR}/dangling_else_solution/makefile_macosx && make --warn-undefined-variables all &&\n"
  "#----------------- SLR_expression\n"
  "galgas -v --Werror ${DIR}/SLR_expression/galgas_sources/_all_SLR_expression.ggs &&\n"
  "cd ${DIR}/SLR_expression/makefile_macosx && make --warn-undefined-variables all &&\n"
  "#----------------- LL1_expression\n"
  "galgas -v --Werror ${DIR}/LL1_expression/galgas_sources/_all_LL1_expression.ggs &&\n"
  "cd ${DIR}/LL1_expression/makefile_macosx && make --warn-undefined-variables all &&\n"
  "#----------------- LR1_grammar\n"
  "galgas -v --Werror ${DIR}/LR1_grammar/galgas_sources/_all_LR1_grammar.ggs &&\n"
  "cd ${DIR}/LR1_grammar/makefile_macosx && make --warn-undefined-variables all &&\n"
  "echo \"------------ SUCCESS ----------------------------\"\n"
;

static const cRegularFileWrapper gWrapperFile_0_wrapperTest = {
  "_build_all_macosx.ext1",
  gWrapperFileContent_0_wrapperTest
} ;

//---------------------------------------------------------------------------*

//--- File '/_clean_all_macosx.bat'

const char * gWrapperFileContent_1_wrapperTest = // 1031 bytes
  "#!/bin/sh\n"
  "set -x\n"
  "DIR=`dirname $0` &&\n"
  "#----------------- class_sample_language\n"
  "rm -fr ${DIR}/class_sample_language/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/class_sample_language/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "#----------------- dangling_else_solution\n"
  "rm -fr ${DIR}/dangling_else_solution/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/dangling_else_solution/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "#----------------- SLR_expression\n"
  "rm -fr ${DIR}/SLR_expression/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/SLR_expression/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "#----------------- LL1_expression\n"
  "rm -fr ${DIR}/LL1_expression/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/LL1_expression/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "#----------------- LR1_grammar\n"
  "rm -fr ${DIR}/LR1_grammar/galgas_sources/GALGAS_OUTPUT &&\n"
  "cd ${DIR}/LR1_grammar/makefile_macosx && make clean --warn-undefined-variables &&\n"
  "echo \"------------ SUCCESS ----------------------------\"\n"
;

static const cRegularFileWrapper gWrapperFile_1_wrapperTest = {
  "_clean_all_macosx.bat",
  gWrapperFileContent_1_wrapperTest
} ;

//---------------------------------------------------------------------------*

//--- All files of '' directory

static const cRegularFileWrapper * gWrapperAllFiles_wrapperTest_0 [3] = {
  & gWrapperFile_0_wrapperTest,
  & gWrapperFile_1_wrapperTest,
  NULL
} ;

//---------------------------------------------------------------------------*

//--- All sub-directories of '' directory

static const cDirectoryWrapper * gWrapperAllDirectories_wrapperTest_0 [2] = {
  & gWrapperDirectory_1_wrapperTest,
  NULL
} ;

//---------------------------------------------------------------------------*

//--- Directory ''

static const cDirectoryWrapper gWrapperDirectory_0_wrapperTest = {
  "",
  2,
  gWrapperAllFiles_wrapperTest_0,
  1,
  gWrapperAllDirectories_wrapperTest_0
} ;

//---------------------------------------------------------------------------*

