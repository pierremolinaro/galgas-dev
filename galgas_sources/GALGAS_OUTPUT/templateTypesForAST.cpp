//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'templateTypesForAST.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                     november 1st, 2010, at 21h23'7"                       *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if CURRENT_LIBPM_VERSION != VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER
  #error "This file has been compiled with a version of GALGAS that uses libpm version VERSION_OF_LIBPM_USED_BY_GALGAS_COMPILER, different than the current version (CURRENT_LIBPM_VERSION) of libpm"
#endif

//---------------------------------------------------------------------------*

#include <typeinfo>
#include "utilities/MF_MemoryControl.h"
#include "files/C_TextFileWrite.h"
#include "galgas2/C_galgas_CLI_Options.h"
#include "templateTypesForAST.h"

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define SOURCE_FILE_AT_LINE(line) "templateTypesForAST.gSemantics", line
  #define COMMA_SOURCE_FILE_AT_LINE(line) , SOURCE_FILE_AT_LINE(line)
#else
  #define SOURCE_FILE_AT_LINE(line) 
  #define COMMA_SOURCE_FILE_AT_LINE(line) 
#endif


//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateInstructionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionAST::
cPtr_templateInstructionAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionAST * GGS_templateInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionAST) ;
    return (cPtr_templateInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_templateInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@templateInstructionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionAST (& typeid (cPtr_templateInstructionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionAST ("templateInstructionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionAST::
GGS_templateInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionAST::
GGS_templateInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionAST GGS_templateInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionAST::actualTypeName (void) const {
  return "templateInstructionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_templateInstructionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__templateInstructionAST ("templateInstructionAST", & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionAST GGS_templateInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionAST * p = dynamic_cast <const GGS_templateInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              Element of list '@templateInstructionListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionListAST::
elementOf_GGS_templateInstructionListAST (const GGS_templateInstructionAST & argument_0
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mInstruction (argument_0) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionListAST * ptr = dynamic_cast <const elementOf_GGS_templateInstructionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mInstruction.operator_isEqual (ptr->mInstruction).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstruction.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@templateInstructionListAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionListAST ("templateInstructionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
internalAppendValues (const GGS_templateInstructionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
internalPrependValues (const GGS_templateInstructionAST & argument_0
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
addAssign_operation (const GGS_templateInstructionAST & argument_0) {
  if (isBuilt ()&& argument_0.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST GGS_templateInstructionListAST::
operator_concat (const GGS_templateInstructionListAST & inOperand) const {
  GGS_templateInstructionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
dotAssign_operation (const GGS_templateInstructionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateInstructionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_templateInstructionAST  p_0 = p->mInstruction ;
          internalAppendValues (p_0 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_templateInstructionAST & argument_0
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mInstruction
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionListAST::
constructor_emptyList (void) {
  GGS_templateInstructionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionListAST::
constructor_listWithValue (const GGS_templateInstructionAST & argument_0) {
  GGS_templateInstructionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
internalSubListWithRange (GGS_templateInstructionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mInstruction) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST GGS_templateInstructionListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST GGS_templateInstructionListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateInstructionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
method_first (C_CompilerEx & inLexique,
              GGS_templateInstructionAST & _out_0
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
method_last (C_CompilerEx & inLexique,
             GGS_templateInstructionAST & _out_0
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_templateInstructionAST & _out_0
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_templateInstructionAST & _out_0
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mInstruction ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionAST  GGS_templateInstructionListAST::
reader_mInstructionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstruction ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionListAST::
modifier_setMInstructionAtIndex (C_CompilerEx & inLexique,
                              const GGS_templateInstructionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstruction = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstructionAST  & GGS_templateInstructionListAST::cEnumerator::_mInstruction (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstruction ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionListAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST GGS_templateInstructionListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionListAST * p = dynamic_cast <const GGS_templateInstructionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_templateExpressionAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateExpressionAST::
cPtr_templateExpressionAST (LOCATION_ARGS)
:cPtr__AC_galgas_class (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateExpressionAST * GGS_templateExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateExpressionAST) ;
    return (cPtr_templateExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

void cPtr_templateExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@templateExpressionAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateExpressionAST (& typeid (cPtr_templateExpressionAST), NULL, "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_templateExpressionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateExpressionAST ("templateExpressionAST", true, NULL) ;

//---------------------------------------------------------------------------*

GGS_templateExpressionAST::
GGS_templateExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST::
GGS_templateExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateExpressionAST GGS_templateExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateExpressionAST::actualTypeName (void) const {
  return "templateExpressionAST" ;
}

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * GGS_templateExpressionAST::galgasObjectRunTimeInfo (void) const {
  AC_galgasClassRunTimeInformationEX * result = NULL ;
  if (mPointer != NULL) {
    result = mPointer->galgasRTTI () ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

C_galgasRootClassRunTimeInformationEX gClassInfoFor__templateExpressionAST ("templateExpressionAST", & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST GGS_templateExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateExpressionAST * p = dynamic_cast <const GGS_templateExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               Element of list '@templateExpressionListAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateExpressionListAST::
elementOf_GGS_templateExpressionListAST (const GGS_templateExpressionAST & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mExpression (argument_0),
mEndOfExpressionLocation (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateExpressionListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateExpressionListAST * ptr = dynamic_cast <const elementOf_GGS_templateExpressionListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mEndOfExpressionLocation.operator_isEqual (ptr->mEndOfExpressionLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateExpressionListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mEndOfExpressionLocation.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    List '@templateExpressionListAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateExpressionListAST ("templateExpressionListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
internalAppendValues (const GGS_templateExpressionAST & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
internalPrependValues (const GGS_templateExpressionAST & argument_0,
                    const GGS_location & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
addAssign_operation (const GGS_templateExpressionAST & argument_0,
                                const GGS_location & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST GGS_templateExpressionListAST::
operator_concat (const GGS_templateExpressionListAST & inOperand) const {
  GGS_templateExpressionListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
dotAssign_operation (const GGS_templateExpressionListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateExpressionListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_templateExpressionAST  p_0 = p->mExpression ;
          GGS_location  p_1 = p->mEndOfExpressionLocation ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_templateExpressionAST & argument_0,
                     const GGS_location & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression,
                                ptr->mEndOfExpressionLocation
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST  GGS_templateExpressionListAST::
constructor_emptyList (void) {
  GGS_templateExpressionListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST  GGS_templateExpressionListAST::
constructor_listWithValue (const GGS_templateExpressionAST & argument_0,
                                const GGS_location & argument_1) {
  GGS_templateExpressionListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
internalSubListWithRange (GGS_templateExpressionListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression, ptr->mEndOfExpressionLocation) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST GGS_templateExpressionListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateExpressionListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST GGS_templateExpressionListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateExpressionListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateExpressionListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateExpressionListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
method_first (C_CompilerEx & inLexique,
              GGS_templateExpressionAST & _out_0,
              GGS_location & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mEndOfExpressionLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
method_last (C_CompilerEx & inLexique,
             GGS_templateExpressionAST & _out_0,
             GGS_location & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mEndOfExpressionLocation ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_templateExpressionAST & _out_0,
                 GGS_location & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mEndOfExpressionLocation ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_templateExpressionAST & _out_0,
                GGS_location & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mEndOfExpressionLocation ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateExpressionListAST::
reader_mExpressionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateExpressionListAST::
reader_mEndOfExpressionLocationAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_location  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mEndOfExpressionLocation ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
modifier_setMExpressionAtIndex (C_CompilerEx & inLexique,
                              const GGS_templateExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateExpressionListAST::
modifier_setMEndOfExpressionLocationAtIndex (C_CompilerEx & inLexique,
                              const GGS_location  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mEndOfExpressionLocation = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateExpressionAST  & GGS_templateExpressionListAST::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_location  & GGS_templateExpressionListAST::cEnumerator::_mEndOfExpressionLocation (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mEndOfExpressionLocation ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateExpressionListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateExpressionListAST * p = NULL ;
    macroMyNew (p, GGS_templateExpressionListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST GGS_templateExpressionListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateExpressionListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateExpressionListAST * p = dynamic_cast <const GGS_templateExpressionListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateExpressionListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateExpressionListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateExpressionListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_templateReaderCallInExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateReaderCallInExpressionAST::
cPtr_templateReaderCallInExpressionAST (const GGS_templateExpressionAST & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_templateExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mReceiverExpression (argument_0),
mReaderName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateReaderCallInExpressionAST * GGS_templateReaderCallInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateReaderCallInExpressionAST) ;
    return (cPtr_templateReaderCallInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateReaderCallInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateReaderCallInExpressionAST * ptr = dynamic_cast <const cPtr_templateReaderCallInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mReceiverExpression.operator_isEqual (ptr->mReceiverExpression).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateReaderCallInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateReaderCallInExpressionAST:"
           << mReceiverExpression.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateReaderCallInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateReaderCallInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateReaderCallInExpressionAST (& typeid (cPtr_templateReaderCallInExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateReaderCallInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateReaderCallInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateReaderCallInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateReaderCallInExpressionAST (mReceiverExpression, mReaderName, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_templateReaderCallInExpressionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateReaderCallInExpressionAST ("templateReaderCallInExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateReaderCallInExpressionAST::
GGS_templateReaderCallInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateReaderCallInExpressionAST::
GGS_templateReaderCallInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateReaderCallInExpressionAST GGS_templateReaderCallInExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateReaderCallInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateReaderCallInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateReaderCallInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateReaderCallInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateReaderCallInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReaderCallInExpressionAST GGS_templateReaderCallInExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_templateExpressionAST & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_templateExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateReaderCallInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateReaderCallInExpressionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateReaderCallInExpressionAST::
reader_mReceiverExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateReaderCallInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateReaderCallInExpressionAST *) mPointer)->mReceiverExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateReaderCallInExpressionAST::
reader_mReaderName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateReaderCallInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateReaderCallInExpressionAST *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST  GGS_templateReaderCallInExpressionAST::
reader_mExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateReaderCallInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateReaderCallInExpressionAST *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateReaderCallInExpressionAST::actualTypeName (void) const {
  return "templateReaderCallInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateReaderCallInExpressionAST ("templateReaderCallInExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateReaderCallInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateReaderCallInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateReaderCallInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateReaderCallInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateReaderCallInExpressionAST GGS_templateReaderCallInExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateReaderCallInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateReaderCallInExpressionAST * p = dynamic_cast <const GGS_templateReaderCallInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateReaderCallInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateReaderCallInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateReaderCallInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateConstructorAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateConstructorAST::
cPtr_templateConstructorAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_templateExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mTypeName (argument_0),
mConstructorName (argument_1),
mExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateConstructorAST * GGS_templateConstructorAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateConstructorAST) ;
    return (cPtr_templateConstructorAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateConstructorAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateConstructorAST * ptr = dynamic_cast <const cPtr_templateConstructorAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue ()
         && mConstructorName.operator_isEqual (ptr->mConstructorName).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateConstructorAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateConstructorAST:"
           << mTypeName.reader_description (inIndentation + 1)
           << mConstructorName.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateConstructorAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateConstructorAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateConstructorAST (& typeid (cPtr_templateConstructorAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateConstructorAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateConstructorAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateConstructorAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateConstructorAST (mTypeName, mConstructorName, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateConstructorAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateConstructorAST ("templateConstructorAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateConstructorAST::
GGS_templateConstructorAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateConstructorAST::
GGS_templateConstructorAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateConstructorAST GGS_templateConstructorAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateConstructorAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateConstructorAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateConstructorAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateConstructorAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateConstructorAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateConstructorAST GGS_templateConstructorAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_templateExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateConstructorAST result ;
  macroMyNew (result.mPointer, cPtr_templateConstructorAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateConstructorAST::
reader_mTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateConstructorAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateConstructorAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateConstructorAST::
reader_mConstructorName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateConstructorAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateConstructorAST *) mPointer)->mConstructorName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST  GGS_templateConstructorAST::
reader_mExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateConstructorAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateConstructorAST *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateConstructorAST::actualTypeName (void) const {
  return "templateConstructorAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateConstructorAST ("templateConstructorAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateConstructorAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateConstructorAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateConstructorAST * p = NULL ;
    macroMyNew (p, GGS_templateConstructorAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateConstructorAST GGS_templateConstructorAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateConstructorAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateConstructorAST * p = dynamic_cast <const GGS_templateConstructorAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateConstructorAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateConstructorAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateConstructorAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            class 'cPtr_templateFileWrapperWithStaticPathAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateFileWrapperWithStaticPathAST::
cPtr_templateFileWrapperWithStaticPathAST (const GGS_lstring & argument_0,
                                const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mFileWrapperName (argument_0),
mFileIndex (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateFileWrapperWithStaticPathAST * GGS_templateFileWrapperWithStaticPathAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateFileWrapperWithStaticPathAST) ;
    return (cPtr_templateFileWrapperWithStaticPathAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateFileWrapperWithStaticPathAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateFileWrapperWithStaticPathAST * ptr = dynamic_cast <const cPtr_templateFileWrapperWithStaticPathAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFileWrapperName.operator_isEqual (ptr->mFileWrapperName).boolValue ()
         && mFileIndex.operator_isEqual (ptr->mFileIndex).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateFileWrapperWithStaticPathAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateFileWrapperWithStaticPathAST:"
           << mFileWrapperName.reader_description (inIndentation + 1)
           << mFileIndex.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateFileWrapperWithStaticPathAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateFileWrapperWithStaticPathAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateFileWrapperWithStaticPathAST (& typeid (cPtr_templateFileWrapperWithStaticPathAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateFileWrapperWithStaticPathAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateFileWrapperWithStaticPathAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateFileWrapperWithStaticPathAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateFileWrapperWithStaticPathAST (mFileWrapperName, mFileIndex COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//         GALGAS class 'GGS_templateFileWrapperWithStaticPathAST'           *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateFileWrapperWithStaticPathAST ("templateFileWrapperWithStaticPathAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateFileWrapperWithStaticPathAST::
GGS_templateFileWrapperWithStaticPathAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateFileWrapperWithStaticPathAST::
GGS_templateFileWrapperWithStaticPathAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateFileWrapperWithStaticPathAST GGS_templateFileWrapperWithStaticPathAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateFileWrapperWithStaticPathAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateFileWrapperWithStaticPathAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateFileWrapperWithStaticPathAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateFileWrapperWithStaticPathAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateFileWrapperWithStaticPathAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateFileWrapperWithStaticPathAST GGS_templateFileWrapperWithStaticPathAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_uint & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateFileWrapperWithStaticPathAST result ;
  macroMyNew (result.mPointer, cPtr_templateFileWrapperWithStaticPathAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateFileWrapperWithStaticPathAST::
reader_mFileWrapperName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateFileWrapperWithStaticPathAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateFileWrapperWithStaticPathAST *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_uint  GGS_templateFileWrapperWithStaticPathAST::
reader_mFileIndex (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_uint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateFileWrapperWithStaticPathAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateFileWrapperWithStaticPathAST *) mPointer)->mFileIndex ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateFileWrapperWithStaticPathAST::actualTypeName (void) const {
  return "templateFileWrapperWithStaticPathAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateFileWrapperWithStaticPathAST ("templateFileWrapperWithStaticPathAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateFileWrapperWithStaticPathAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateFileWrapperWithStaticPathAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateFileWrapperWithStaticPathAST * p = NULL ;
    macroMyNew (p, GGS_templateFileWrapperWithStaticPathAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateFileWrapperWithStaticPathAST GGS_templateFileWrapperWithStaticPathAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateFileWrapperWithStaticPathAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateFileWrapperWithStaticPathAST * p = dynamic_cast <const GGS_templateFileWrapperWithStaticPathAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateFileWrapperWithStaticPathAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateFileWrapperWithStaticPathAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateFileWrapperWithStaticPathAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_templateFileWrapperTemplateCallAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateFileWrapperTemplateCallAST::
cPtr_templateFileWrapperTemplateCallAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_templateExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mFileWrapperName (argument_0),
mTemplateName (argument_1),
mOutExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateFileWrapperTemplateCallAST * GGS_templateFileWrapperTemplateCallAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateFileWrapperTemplateCallAST) ;
    return (cPtr_templateFileWrapperTemplateCallAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateFileWrapperTemplateCallAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateFileWrapperTemplateCallAST * ptr = dynamic_cast <const cPtr_templateFileWrapperTemplateCallAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFileWrapperName.operator_isEqual (ptr->mFileWrapperName).boolValue ()
         && mTemplateName.operator_isEqual (ptr->mTemplateName).boolValue ()
         && mOutExpressionList.operator_isEqual (ptr->mOutExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateFileWrapperTemplateCallAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateFileWrapperTemplateCallAST:"
           << mFileWrapperName.reader_description (inIndentation + 1)
           << mTemplateName.reader_description (inIndentation + 1)
           << mOutExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateFileWrapperTemplateCallAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateFileWrapperTemplateCallAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateFileWrapperTemplateCallAST (& typeid (cPtr_templateFileWrapperTemplateCallAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateFileWrapperTemplateCallAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateFileWrapperTemplateCallAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateFileWrapperTemplateCallAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateFileWrapperTemplateCallAST (mFileWrapperName, mTemplateName, mOutExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_templateFileWrapperTemplateCallAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateFileWrapperTemplateCallAST ("templateFileWrapperTemplateCallAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateFileWrapperTemplateCallAST::
GGS_templateFileWrapperTemplateCallAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateFileWrapperTemplateCallAST::
GGS_templateFileWrapperTemplateCallAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateFileWrapperTemplateCallAST GGS_templateFileWrapperTemplateCallAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateFileWrapperTemplateCallAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateFileWrapperTemplateCallAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateFileWrapperTemplateCallAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateFileWrapperTemplateCallAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateFileWrapperTemplateCallAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateFileWrapperTemplateCallAST GGS_templateFileWrapperTemplateCallAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_templateExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateFileWrapperTemplateCallAST result ;
  macroMyNew (result.mPointer, cPtr_templateFileWrapperTemplateCallAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateFileWrapperTemplateCallAST::
reader_mFileWrapperName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateFileWrapperTemplateCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateFileWrapperTemplateCallAST *) mPointer)->mFileWrapperName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateFileWrapperTemplateCallAST::
reader_mTemplateName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateFileWrapperTemplateCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateFileWrapperTemplateCallAST *) mPointer)->mTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST  GGS_templateFileWrapperTemplateCallAST::
reader_mOutExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateFileWrapperTemplateCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateFileWrapperTemplateCallAST *) mPointer)->mOutExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateFileWrapperTemplateCallAST::actualTypeName (void) const {
  return "templateFileWrapperTemplateCallAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateFileWrapperTemplateCallAST ("templateFileWrapperTemplateCallAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateFileWrapperTemplateCallAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateFileWrapperTemplateCallAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateFileWrapperTemplateCallAST * p = NULL ;
    macroMyNew (p, GGS_templateFileWrapperTemplateCallAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateFileWrapperTemplateCallAST GGS_templateFileWrapperTemplateCallAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateFileWrapperTemplateCallAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateFileWrapperTemplateCallAST * p = dynamic_cast <const GGS_templateFileWrapperTemplateCallAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateFileWrapperTemplateCallAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateFileWrapperTemplateCallAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateFileWrapperTemplateCallAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_templateCategoryTemplateCallAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateCategoryTemplateCallAST::
cPtr_templateCategoryTemplateCallAST (const GGS_templateExpressionAST & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_templateExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mExpressionValue (argument_0),
mTemplateName (argument_1),
mOutExpressionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateCategoryTemplateCallAST * GGS_templateCategoryTemplateCallAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateCategoryTemplateCallAST) ;
    return (cPtr_templateCategoryTemplateCallAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateCategoryTemplateCallAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateCategoryTemplateCallAST * ptr = dynamic_cast <const cPtr_templateCategoryTemplateCallAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpressionValue.operator_isEqual (ptr->mExpressionValue).boolValue ()
         && mTemplateName.operator_isEqual (ptr->mTemplateName).boolValue ()
         && mOutExpressionList.operator_isEqual (ptr->mOutExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateCategoryTemplateCallAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateCategoryTemplateCallAST:"
           << mExpressionValue.reader_description (inIndentation + 1)
           << mTemplateName.reader_description (inIndentation + 1)
           << mOutExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateCategoryTemplateCallAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateCategoryTemplateCallAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateCategoryTemplateCallAST (& typeid (cPtr_templateCategoryTemplateCallAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateCategoryTemplateCallAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateCategoryTemplateCallAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateCategoryTemplateCallAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateCategoryTemplateCallAST (mExpressionValue, mTemplateName, mOutExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_templateCategoryTemplateCallAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateCategoryTemplateCallAST ("templateCategoryTemplateCallAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateCategoryTemplateCallAST::
GGS_templateCategoryTemplateCallAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateCategoryTemplateCallAST::
GGS_templateCategoryTemplateCallAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateCategoryTemplateCallAST GGS_templateCategoryTemplateCallAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateCategoryTemplateCallAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateCategoryTemplateCallAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateCategoryTemplateCallAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateCategoryTemplateCallAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateCategoryTemplateCallAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateCategoryTemplateCallAST GGS_templateCategoryTemplateCallAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_templateExpressionAST & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_templateExpressionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateCategoryTemplateCallAST result ;
  macroMyNew (result.mPointer, cPtr_templateCategoryTemplateCallAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateCategoryTemplateCallAST::
reader_mExpressionValue (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateCategoryTemplateCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateCategoryTemplateCallAST *) mPointer)->mExpressionValue ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateCategoryTemplateCallAST::
reader_mTemplateName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateCategoryTemplateCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateCategoryTemplateCallAST *) mPointer)->mTemplateName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST  GGS_templateCategoryTemplateCallAST::
reader_mOutExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateCategoryTemplateCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateCategoryTemplateCallAST *) mPointer)->mOutExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateCategoryTemplateCallAST::actualTypeName (void) const {
  return "templateCategoryTemplateCallAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateCategoryTemplateCallAST ("templateCategoryTemplateCallAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateCategoryTemplateCallAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateCategoryTemplateCallAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateCategoryTemplateCallAST * p = NULL ;
    macroMyNew (p, GGS_templateCategoryTemplateCallAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateCategoryTemplateCallAST GGS_templateCategoryTemplateCallAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateCategoryTemplateCallAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateCategoryTemplateCallAST * p = dynamic_cast <const GGS_templateCategoryTemplateCallAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateCategoryTemplateCallAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateCategoryTemplateCallAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateCategoryTemplateCallAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateAndOperationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateAndOperationAST::
cPtr_templateAndOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateAndOperationAST * GGS_templateAndOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateAndOperationAST) ;
    return (cPtr_templateAndOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateAndOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateAndOperationAST * ptr = dynamic_cast <const cPtr_templateAndOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateAndOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateAndOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateAndOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateAndOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateAndOperationAST (& typeid (cPtr_templateAndOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateAndOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateAndOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateAndOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateAndOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateAndOperationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateAndOperationAST ("templateAndOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateAndOperationAST::
GGS_templateAndOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateAndOperationAST::
GGS_templateAndOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateAndOperationAST GGS_templateAndOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateAndOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateAndOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateAndOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateAndOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateAndOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateAndOperationAST GGS_templateAndOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateAndOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateAndOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateAndOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateAndOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateAndOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateAndOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateAndOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateAndOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateAndOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateAndOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateAndOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateAndOperationAST::actualTypeName (void) const {
  return "templateAndOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateAndOperationAST ("templateAndOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateAndOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateAndOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateAndOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateAndOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateAndOperationAST GGS_templateAndOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateAndOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateAndOperationAST * p = dynamic_cast <const GGS_templateAndOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateAndOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateAndOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateAndOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateOrOperationAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateOrOperationAST::
cPtr_templateOrOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateOrOperationAST * GGS_templateOrOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateOrOperationAST) ;
    return (cPtr_templateOrOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateOrOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateOrOperationAST * ptr = dynamic_cast <const cPtr_templateOrOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateOrOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateOrOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateOrOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateOrOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateOrOperationAST (& typeid (cPtr_templateOrOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateOrOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateOrOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateOrOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateOrOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateOrOperationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateOrOperationAST ("templateOrOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateOrOperationAST::
GGS_templateOrOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateOrOperationAST::
GGS_templateOrOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateOrOperationAST GGS_templateOrOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateOrOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateOrOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateOrOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateOrOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateOrOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateOrOperationAST GGS_templateOrOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateOrOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateOrOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateOrOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateOrOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateOrOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateOrOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateOrOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateOrOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateOrOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateOrOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateOrOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateOrOperationAST::actualTypeName (void) const {
  return "templateOrOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateOrOperationAST ("templateOrOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateOrOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateOrOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateOrOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateOrOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateOrOperationAST GGS_templateOrOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateOrOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateOrOperationAST * p = dynamic_cast <const GGS_templateOrOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateOrOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateOrOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateOrOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateXorOperationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateXorOperationAST::
cPtr_templateXorOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateXorOperationAST * GGS_templateXorOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateXorOperationAST) ;
    return (cPtr_templateXorOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateXorOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateXorOperationAST * ptr = dynamic_cast <const cPtr_templateXorOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateXorOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateXorOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateXorOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateXorOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateXorOperationAST (& typeid (cPtr_templateXorOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateXorOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateXorOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateXorOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateXorOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateXorOperationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateXorOperationAST ("templateXorOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateXorOperationAST::
GGS_templateXorOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateXorOperationAST::
GGS_templateXorOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateXorOperationAST GGS_templateXorOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateXorOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateXorOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateXorOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateXorOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateXorOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateXorOperationAST GGS_templateXorOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateXorOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateXorOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateXorOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateXorOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateXorOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateXorOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateXorOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateXorOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateXorOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateXorOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateXorOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateXorOperationAST::actualTypeName (void) const {
  return "templateXorOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateXorOperationAST ("templateXorOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateXorOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateXorOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateXorOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateXorOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateXorOperationAST GGS_templateXorOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateXorOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateXorOperationAST * p = dynamic_cast <const GGS_templateXorOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateXorOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateXorOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateXorOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_templateConcatOperationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateConcatOperationAST::
cPtr_templateConcatOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateConcatOperationAST * GGS_templateConcatOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateConcatOperationAST) ;
    return (cPtr_templateConcatOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateConcatOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateConcatOperationAST * ptr = dynamic_cast <const cPtr_templateConcatOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateConcatOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateConcatOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateConcatOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateConcatOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateConcatOperationAST (& typeid (cPtr_templateConcatOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateConcatOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateConcatOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateConcatOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateConcatOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_templateConcatOperationAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateConcatOperationAST ("templateConcatOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateConcatOperationAST::
GGS_templateConcatOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateConcatOperationAST::
GGS_templateConcatOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateConcatOperationAST GGS_templateConcatOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateConcatOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateConcatOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateConcatOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateConcatOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateConcatOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateConcatOperationAST GGS_templateConcatOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateConcatOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateConcatOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateConcatOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateConcatOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateConcatOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateConcatOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateConcatOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateConcatOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateConcatOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateConcatOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateConcatOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateConcatOperationAST::actualTypeName (void) const {
  return "templateConcatOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateConcatOperationAST ("templateConcatOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateConcatOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateConcatOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateConcatOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateConcatOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateConcatOperationAST GGS_templateConcatOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateConcatOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateConcatOperationAST * p = dynamic_cast <const GGS_templateConcatOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateConcatOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateConcatOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateConcatOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                     class 'cPtr_templateTrueBoolAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateTrueBoolAST::
cPtr_templateTrueBoolAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateTrueBoolAST * GGS_templateTrueBoolAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateTrueBoolAST) ;
    return (cPtr_templateTrueBoolAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateTrueBoolAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateTrueBoolAST * ptr = dynamic_cast <const cPtr_templateTrueBoolAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateTrueBoolAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateTrueBoolAST:"
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateTrueBoolAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateTrueBoolAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateTrueBoolAST (& typeid (cPtr_templateTrueBoolAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateTrueBoolAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateTrueBoolAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateTrueBoolAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateTrueBoolAST (mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  GALGAS class 'GGS_templateTrueBoolAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateTrueBoolAST ("templateTrueBoolAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateTrueBoolAST::
GGS_templateTrueBoolAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateTrueBoolAST::
GGS_templateTrueBoolAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateTrueBoolAST GGS_templateTrueBoolAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateTrueBoolAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateTrueBoolAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateTrueBoolAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateTrueBoolAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateTrueBoolAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateTrueBoolAST GGS_templateTrueBoolAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateTrueBoolAST result ;
  macroMyNew (result.mPointer, cPtr_templateTrueBoolAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateTrueBoolAST::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateTrueBoolAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateTrueBoolAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateTrueBoolAST::actualTypeName (void) const {
  return "templateTrueBoolAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateTrueBoolAST ("templateTrueBoolAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateTrueBoolAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateTrueBoolAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateTrueBoolAST * p = NULL ;
    macroMyNew (p, GGS_templateTrueBoolAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateTrueBoolAST GGS_templateTrueBoolAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateTrueBoolAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateTrueBoolAST * p = dynamic_cast <const GGS_templateTrueBoolAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateTrueBoolAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateTrueBoolAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateTrueBoolAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_templateFalseBoolAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateFalseBoolAST::
cPtr_templateFalseBoolAST (const GGS_location & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLocation (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateFalseBoolAST * GGS_templateFalseBoolAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateFalseBoolAST) ;
    return (cPtr_templateFalseBoolAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateFalseBoolAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateFalseBoolAST * ptr = dynamic_cast <const cPtr_templateFalseBoolAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateFalseBoolAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateFalseBoolAST:"
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateFalseBoolAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateFalseBoolAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateFalseBoolAST (& typeid (cPtr_templateFalseBoolAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateFalseBoolAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateFalseBoolAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateFalseBoolAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateFalseBoolAST (mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_templateFalseBoolAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateFalseBoolAST ("templateFalseBoolAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateFalseBoolAST::
GGS_templateFalseBoolAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateFalseBoolAST::
GGS_templateFalseBoolAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateFalseBoolAST GGS_templateFalseBoolAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateFalseBoolAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateFalseBoolAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateFalseBoolAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateFalseBoolAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateFalseBoolAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateFalseBoolAST GGS_templateFalseBoolAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateFalseBoolAST result ;
  macroMyNew (result.mPointer, cPtr_templateFalseBoolAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateFalseBoolAST::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateFalseBoolAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateFalseBoolAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateFalseBoolAST::actualTypeName (void) const {
  return "templateFalseBoolAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateFalseBoolAST ("templateFalseBoolAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateFalseBoolAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateFalseBoolAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateFalseBoolAST * p = NULL ;
    macroMyNew (p, GGS_templateFalseBoolAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateFalseBoolAST GGS_templateFalseBoolAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateFalseBoolAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateFalseBoolAST * p = dynamic_cast <const GGS_templateFalseBoolAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateFalseBoolAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateFalseBoolAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateFalseBoolAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_templateLiteralStringExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLiteralStringExpressionAST::
cPtr_templateLiteralStringExpressionAST (const GGS_stringlist & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLiteralStringList (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLiteralStringExpressionAST * GGS_templateLiteralStringExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLiteralStringExpressionAST) ;
    return (cPtr_templateLiteralStringExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLiteralStringExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLiteralStringExpressionAST * ptr = dynamic_cast <const cPtr_templateLiteralStringExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralStringList.operator_isEqual (ptr->mLiteralStringList).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLiteralStringExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLiteralStringExpressionAST:"
           << mLiteralStringList.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralStringExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralStringExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLiteralStringExpressionAST (& typeid (cPtr_templateLiteralStringExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLiteralStringExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLiteralStringExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLiteralStringExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLiteralStringExpressionAST (mLiteralStringList, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_templateLiteralStringExpressionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLiteralStringExpressionAST ("templateLiteralStringExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLiteralStringExpressionAST::
GGS_templateLiteralStringExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralStringExpressionAST::
GGS_templateLiteralStringExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLiteralStringExpressionAST GGS_templateLiteralStringExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLiteralStringExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLiteralStringExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLiteralStringExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLiteralStringExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLiteralStringExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralStringExpressionAST GGS_templateLiteralStringExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_stringlist & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateLiteralStringExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateLiteralStringExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_stringlist  GGS_templateLiteralStringExpressionAST::
reader_mLiteralStringList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_stringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLiteralStringExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLiteralStringExpressionAST *) mPointer)->mLiteralStringList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateLiteralStringExpressionAST::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLiteralStringExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLiteralStringExpressionAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLiteralStringExpressionAST::actualTypeName (void) const {
  return "templateLiteralStringExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLiteralStringExpressionAST ("templateLiteralStringExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLiteralStringExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLiteralStringExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLiteralStringExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateLiteralStringExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralStringExpressionAST GGS_templateLiteralStringExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLiteralStringExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLiteralStringExpressionAST * p = dynamic_cast <const GGS_templateLiteralStringExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLiteralStringExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLiteralStringExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLiteralStringExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_templateLiteralUIntExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLiteralUIntExpressionAST::
cPtr_templateLiteralUIntExpressionAST (const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLiteralUIntExpressionAST * GGS_templateLiteralUIntExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLiteralUIntExpressionAST) ;
    return (cPtr_templateLiteralUIntExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLiteralUIntExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLiteralUIntExpressionAST * ptr = dynamic_cast <const cPtr_templateLiteralUIntExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLiteralUIntExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLiteralUIntExpressionAST:"
           << mLiteralInt.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralUIntExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralUIntExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLiteralUIntExpressionAST (& typeid (cPtr_templateLiteralUIntExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLiteralUIntExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLiteralUIntExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLiteralUIntExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLiteralUIntExpressionAST (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_templateLiteralUIntExpressionAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLiteralUIntExpressionAST ("templateLiteralUIntExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLiteralUIntExpressionAST::
GGS_templateLiteralUIntExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralUIntExpressionAST::
GGS_templateLiteralUIntExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLiteralUIntExpressionAST GGS_templateLiteralUIntExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLiteralUIntExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLiteralUIntExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLiteralUIntExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLiteralUIntExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLiteralUIntExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralUIntExpressionAST GGS_templateLiteralUIntExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_luint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateLiteralUIntExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateLiteralUIntExpressionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint  GGS_templateLiteralUIntExpressionAST::
reader_mLiteralInt (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLiteralUIntExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLiteralUIntExpressionAST *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLiteralUIntExpressionAST::actualTypeName (void) const {
  return "templateLiteralUIntExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLiteralUIntExpressionAST ("templateLiteralUIntExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLiteralUIntExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLiteralUIntExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLiteralUIntExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateLiteralUIntExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralUIntExpressionAST GGS_templateLiteralUIntExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLiteralUIntExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLiteralUIntExpressionAST * p = dynamic_cast <const GGS_templateLiteralUIntExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLiteralUIntExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLiteralUIntExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLiteralUIntExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_templateLiteralSIntExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLiteralSIntExpressionAST::
cPtr_templateLiteralSIntExpressionAST (const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLiteralSIntExpressionAST * GGS_templateLiteralSIntExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLiteralSIntExpressionAST) ;
    return (cPtr_templateLiteralSIntExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLiteralSIntExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLiteralSIntExpressionAST * ptr = dynamic_cast <const cPtr_templateLiteralSIntExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLiteralSIntExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLiteralSIntExpressionAST:"
           << mLiteralInt.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralSIntExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralSIntExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLiteralSIntExpressionAST (& typeid (cPtr_templateLiteralSIntExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLiteralSIntExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLiteralSIntExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLiteralSIntExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLiteralSIntExpressionAST (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_templateLiteralSIntExpressionAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLiteralSIntExpressionAST ("templateLiteralSIntExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLiteralSIntExpressionAST::
GGS_templateLiteralSIntExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralSIntExpressionAST::
GGS_templateLiteralSIntExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLiteralSIntExpressionAST GGS_templateLiteralSIntExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLiteralSIntExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLiteralSIntExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLiteralSIntExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLiteralSIntExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLiteralSIntExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralSIntExpressionAST GGS_templateLiteralSIntExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lsint & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateLiteralSIntExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateLiteralSIntExpressionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint  GGS_templateLiteralSIntExpressionAST::
reader_mLiteralInt (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLiteralSIntExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLiteralSIntExpressionAST *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLiteralSIntExpressionAST::actualTypeName (void) const {
  return "templateLiteralSIntExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLiteralSIntExpressionAST ("templateLiteralSIntExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLiteralSIntExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLiteralSIntExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLiteralSIntExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateLiteralSIntExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralSIntExpressionAST GGS_templateLiteralSIntExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLiteralSIntExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLiteralSIntExpressionAST * p = dynamic_cast <const GGS_templateLiteralSIntExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLiteralSIntExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLiteralSIntExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLiteralSIntExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_templateLiteralUInt64ExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLiteralUInt64ExpressionAST::
cPtr_templateLiteralUInt64ExpressionAST (const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLiteralUInt64ExpressionAST * GGS_templateLiteralUInt64ExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLiteralUInt64ExpressionAST) ;
    return (cPtr_templateLiteralUInt64ExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLiteralUInt64ExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLiteralUInt64ExpressionAST * ptr = dynamic_cast <const cPtr_templateLiteralUInt64ExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLiteralUInt64ExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLiteralUInt64ExpressionAST:"
           << mLiteralInt.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralUInt64ExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralUInt64ExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLiteralUInt64ExpressionAST (& typeid (cPtr_templateLiteralUInt64ExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLiteralUInt64ExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLiteralUInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLiteralUInt64ExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLiteralUInt64ExpressionAST (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_templateLiteralUInt64ExpressionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLiteralUInt64ExpressionAST ("templateLiteralUInt64ExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLiteralUInt64ExpressionAST::
GGS_templateLiteralUInt64ExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralUInt64ExpressionAST::
GGS_templateLiteralUInt64ExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLiteralUInt64ExpressionAST GGS_templateLiteralUInt64ExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLiteralUInt64ExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLiteralUInt64ExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLiteralUInt64ExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLiteralUInt64ExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLiteralUInt64ExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralUInt64ExpressionAST GGS_templateLiteralUInt64ExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_luint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateLiteralUInt64ExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateLiteralUInt64ExpressionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_luint64  GGS_templateLiteralUInt64ExpressionAST::
reader_mLiteralInt (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_luint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLiteralUInt64ExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLiteralUInt64ExpressionAST *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLiteralUInt64ExpressionAST::actualTypeName (void) const {
  return "templateLiteralUInt64ExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLiteralUInt64ExpressionAST ("templateLiteralUInt64ExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLiteralUInt64ExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLiteralUInt64ExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLiteralUInt64ExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateLiteralUInt64ExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralUInt64ExpressionAST GGS_templateLiteralUInt64ExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLiteralUInt64ExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLiteralUInt64ExpressionAST * p = dynamic_cast <const GGS_templateLiteralUInt64ExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLiteralUInt64ExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLiteralUInt64ExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLiteralUInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_templateLiteralSInt64ExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLiteralSInt64ExpressionAST::
cPtr_templateLiteralSInt64ExpressionAST (const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLiteralInt (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLiteralSInt64ExpressionAST * GGS_templateLiteralSInt64ExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLiteralSInt64ExpressionAST) ;
    return (cPtr_templateLiteralSInt64ExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLiteralSInt64ExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLiteralSInt64ExpressionAST * ptr = dynamic_cast <const cPtr_templateLiteralSInt64ExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralInt.operator_isEqual (ptr->mLiteralInt).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLiteralSInt64ExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLiteralSInt64ExpressionAST:"
           << mLiteralInt.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralSInt64ExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralSInt64ExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLiteralSInt64ExpressionAST (& typeid (cPtr_templateLiteralSInt64ExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLiteralSInt64ExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLiteralSInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLiteralSInt64ExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLiteralSInt64ExpressionAST (mLiteralInt COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_templateLiteralSInt64ExpressionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLiteralSInt64ExpressionAST ("templateLiteralSInt64ExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLiteralSInt64ExpressionAST::
GGS_templateLiteralSInt64ExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralSInt64ExpressionAST::
GGS_templateLiteralSInt64ExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLiteralSInt64ExpressionAST GGS_templateLiteralSInt64ExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLiteralSInt64ExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLiteralSInt64ExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLiteralSInt64ExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLiteralSInt64ExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLiteralSInt64ExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralSInt64ExpressionAST GGS_templateLiteralSInt64ExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lsint64 & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateLiteralSInt64ExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateLiteralSInt64ExpressionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lsint64  GGS_templateLiteralSInt64ExpressionAST::
reader_mLiteralInt (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lsint64   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLiteralSInt64ExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLiteralSInt64ExpressionAST *) mPointer)->mLiteralInt ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLiteralSInt64ExpressionAST::actualTypeName (void) const {
  return "templateLiteralSInt64ExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLiteralSInt64ExpressionAST ("templateLiteralSInt64ExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLiteralSInt64ExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLiteralSInt64ExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLiteralSInt64ExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateLiteralSInt64ExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralSInt64ExpressionAST GGS_templateLiteralSInt64ExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLiteralSInt64ExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLiteralSInt64ExpressionAST * p = dynamic_cast <const GGS_templateLiteralSInt64ExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLiteralSInt64ExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLiteralSInt64ExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLiteralSInt64ExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_templateLiteralCharExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLiteralCharExpressionAST::
cPtr_templateLiteralCharExpressionAST (const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLiteralChar (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLiteralCharExpressionAST * GGS_templateLiteralCharExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLiteralCharExpressionAST) ;
    return (cPtr_templateLiteralCharExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLiteralCharExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLiteralCharExpressionAST * ptr = dynamic_cast <const cPtr_templateLiteralCharExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralChar.operator_isEqual (ptr->mLiteralChar).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLiteralCharExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLiteralCharExpressionAST:"
           << mLiteralChar.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralCharExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralCharExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLiteralCharExpressionAST (& typeid (cPtr_templateLiteralCharExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLiteralCharExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLiteralCharExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLiteralCharExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLiteralCharExpressionAST (mLiteralChar COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_templateLiteralCharExpressionAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLiteralCharExpressionAST ("templateLiteralCharExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLiteralCharExpressionAST::
GGS_templateLiteralCharExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralCharExpressionAST::
GGS_templateLiteralCharExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLiteralCharExpressionAST GGS_templateLiteralCharExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLiteralCharExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLiteralCharExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLiteralCharExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLiteralCharExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLiteralCharExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralCharExpressionAST GGS_templateLiteralCharExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lchar & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateLiteralCharExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateLiteralCharExpressionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lchar  GGS_templateLiteralCharExpressionAST::
reader_mLiteralChar (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lchar   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLiteralCharExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLiteralCharExpressionAST *) mPointer)->mLiteralChar ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLiteralCharExpressionAST::actualTypeName (void) const {
  return "templateLiteralCharExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLiteralCharExpressionAST ("templateLiteralCharExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLiteralCharExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLiteralCharExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLiteralCharExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateLiteralCharExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralCharExpressionAST GGS_templateLiteralCharExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLiteralCharExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLiteralCharExpressionAST * p = dynamic_cast <const GGS_templateLiteralCharExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLiteralCharExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLiteralCharExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLiteralCharExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             class 'cPtr_templateLiteralDoubleExpressionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLiteralDoubleExpressionAST::
cPtr_templateLiteralDoubleExpressionAST (const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mLiteralDouble (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLiteralDoubleExpressionAST * GGS_templateLiteralDoubleExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLiteralDoubleExpressionAST) ;
    return (cPtr_templateLiteralDoubleExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLiteralDoubleExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLiteralDoubleExpressionAST * ptr = dynamic_cast <const cPtr_templateLiteralDoubleExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mLiteralDouble.operator_isEqual (ptr->mLiteralDouble).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLiteralDoubleExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLiteralDoubleExpressionAST:"
           << mLiteralDouble.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralDoubleExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLiteralDoubleExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLiteralDoubleExpressionAST (& typeid (cPtr_templateLiteralDoubleExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLiteralDoubleExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLiteralDoubleExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLiteralDoubleExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLiteralDoubleExpressionAST (mLiteralDouble COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          GALGAS class 'GGS_templateLiteralDoubleExpressionAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLiteralDoubleExpressionAST ("templateLiteralDoubleExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLiteralDoubleExpressionAST::
GGS_templateLiteralDoubleExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralDoubleExpressionAST::
GGS_templateLiteralDoubleExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLiteralDoubleExpressionAST GGS_templateLiteralDoubleExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLiteralDoubleExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLiteralDoubleExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLiteralDoubleExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLiteralDoubleExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLiteralDoubleExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralDoubleExpressionAST GGS_templateLiteralDoubleExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_ldouble & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateLiteralDoubleExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateLiteralDoubleExpressionAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_ldouble  GGS_templateLiteralDoubleExpressionAST::
reader_mLiteralDouble (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_ldouble   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLiteralDoubleExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLiteralDoubleExpressionAST *) mPointer)->mLiteralDouble ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLiteralDoubleExpressionAST::actualTypeName (void) const {
  return "templateLiteralDoubleExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLiteralDoubleExpressionAST ("templateLiteralDoubleExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLiteralDoubleExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLiteralDoubleExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLiteralDoubleExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateLiteralDoubleExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLiteralDoubleExpressionAST GGS_templateLiteralDoubleExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLiteralDoubleExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLiteralDoubleExpressionAST * p = dynamic_cast <const GGS_templateLiteralDoubleExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLiteralDoubleExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLiteralDoubleExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLiteralDoubleExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_templateIfThenElseExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateIfThenElseExpressionAST::
cPtr_templateIfThenElseExpressionAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2,
                                const GGS_templateExpressionAST & argument_3
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mIfExpression (argument_1),
mThenExpression (argument_2),
mElseExpression (argument_3) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateIfThenElseExpressionAST * GGS_templateIfThenElseExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateIfThenElseExpressionAST) ;
    return (cPtr_templateIfThenElseExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateIfThenElseExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateIfThenElseExpressionAST * ptr = dynamic_cast <const cPtr_templateIfThenElseExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mIfExpression.operator_isEqual (ptr->mIfExpression).boolValue ()
         && mThenExpression.operator_isEqual (ptr->mThenExpression).boolValue ()
         && mElseExpression.operator_isEqual (ptr->mElseExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateIfThenElseExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateIfThenElseExpressionAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mIfExpression.reader_description (inIndentation + 1)
           << mThenExpression.reader_description (inIndentation + 1)
           << mElseExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateIfThenElseExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateIfThenElseExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateIfThenElseExpressionAST (& typeid (cPtr_templateIfThenElseExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateIfThenElseExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateIfThenElseExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateIfThenElseExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateIfThenElseExpressionAST (mOperatorLocation, mIfExpression, mThenExpression, mElseExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_templateIfThenElseExpressionAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateIfThenElseExpressionAST ("templateIfThenElseExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateIfThenElseExpressionAST::
GGS_templateIfThenElseExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateIfThenElseExpressionAST::
GGS_templateIfThenElseExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateIfThenElseExpressionAST GGS_templateIfThenElseExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateIfThenElseExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateIfThenElseExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateIfThenElseExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateIfThenElseExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateIfThenElseExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateIfThenElseExpressionAST GGS_templateIfThenElseExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2,
                 const GGS_templateExpressionAST & argument_3
                                COMMA_LOCATION_ARGS) {
  GGS_templateIfThenElseExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateIfThenElseExpressionAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateIfThenElseExpressionAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateIfThenElseExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateIfThenElseExpressionAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateIfThenElseExpressionAST::
reader_mIfExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateIfThenElseExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateIfThenElseExpressionAST *) mPointer)->mIfExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateIfThenElseExpressionAST::
reader_mThenExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateIfThenElseExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateIfThenElseExpressionAST *) mPointer)->mThenExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateIfThenElseExpressionAST::
reader_mElseExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateIfThenElseExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateIfThenElseExpressionAST *) mPointer)->mElseExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateIfThenElseExpressionAST::actualTypeName (void) const {
  return "templateIfThenElseExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateIfThenElseExpressionAST ("templateIfThenElseExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateIfThenElseExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateIfThenElseExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateIfThenElseExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateIfThenElseExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateIfThenElseExpressionAST GGS_templateIfThenElseExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateIfThenElseExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateIfThenElseExpressionAST * p = dynamic_cast <const GGS_templateIfThenElseExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateIfThenElseExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateIfThenElseExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateIfThenElseExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateNotOperatorAST'                     *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateNotOperatorAST::
cPtr_templateNotOperatorAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateNotOperatorAST * GGS_templateNotOperatorAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateNotOperatorAST) ;
    return (cPtr_templateNotOperatorAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateNotOperatorAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateNotOperatorAST * ptr = dynamic_cast <const cPtr_templateNotOperatorAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateNotOperatorAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateNotOperatorAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateNotOperatorAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateNotOperatorAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateNotOperatorAST (& typeid (cPtr_templateNotOperatorAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateNotOperatorAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateNotOperatorAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateNotOperatorAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateNotOperatorAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateNotOperatorAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateNotOperatorAST ("templateNotOperatorAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateNotOperatorAST::
GGS_templateNotOperatorAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateNotOperatorAST::
GGS_templateNotOperatorAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateNotOperatorAST GGS_templateNotOperatorAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateNotOperatorAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateNotOperatorAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateNotOperatorAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateNotOperatorAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateNotOperatorAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateNotOperatorAST GGS_templateNotOperatorAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateNotOperatorAST result ;
  macroMyNew (result.mPointer, cPtr_templateNotOperatorAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateNotOperatorAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateNotOperatorAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateNotOperatorAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateNotOperatorAST::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateNotOperatorAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateNotOperatorAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateNotOperatorAST::actualTypeName (void) const {
  return "templateNotOperatorAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateNotOperatorAST ("templateNotOperatorAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateNotOperatorAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateNotOperatorAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateNotOperatorAST * p = NULL ;
    macroMyNew (p, GGS_templateNotOperatorAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateNotOperatorAST GGS_templateNotOperatorAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateNotOperatorAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateNotOperatorAST * p = dynamic_cast <const GGS_templateNotOperatorAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateNotOperatorAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateNotOperatorAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateNotOperatorAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateLogicalNegateAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLogicalNegateAST::
cPtr_templateLogicalNegateAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLogicalNegateAST * GGS_templateLogicalNegateAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLogicalNegateAST) ;
    return (cPtr_templateLogicalNegateAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLogicalNegateAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLogicalNegateAST * ptr = dynamic_cast <const cPtr_templateLogicalNegateAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLogicalNegateAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLogicalNegateAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLogicalNegateAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLogicalNegateAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLogicalNegateAST (& typeid (cPtr_templateLogicalNegateAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLogicalNegateAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLogicalNegateAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLogicalNegateAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLogicalNegateAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateLogicalNegateAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLogicalNegateAST ("templateLogicalNegateAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLogicalNegateAST::
GGS_templateLogicalNegateAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLogicalNegateAST::
GGS_templateLogicalNegateAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLogicalNegateAST GGS_templateLogicalNegateAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLogicalNegateAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLogicalNegateAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLogicalNegateAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLogicalNegateAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLogicalNegateAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLogicalNegateAST GGS_templateLogicalNegateAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateLogicalNegateAST result ;
  macroMyNew (result.mPointer, cPtr_templateLogicalNegateAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateLogicalNegateAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLogicalNegateAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLogicalNegateAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateLogicalNegateAST::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLogicalNegateAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLogicalNegateAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLogicalNegateAST::actualTypeName (void) const {
  return "templateLogicalNegateAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLogicalNegateAST ("templateLogicalNegateAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLogicalNegateAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLogicalNegateAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLogicalNegateAST * p = NULL ;
    macroMyNew (p, GGS_templateLogicalNegateAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLogicalNegateAST GGS_templateLogicalNegateAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLogicalNegateAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLogicalNegateAST * p = dynamic_cast <const GGS_templateLogicalNegateAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLogicalNegateAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLogicalNegateAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLogicalNegateAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateOptionAccessAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateOptionAccessAST::
cPtr_templateOptionAccessAST (const GGS_lstring & argument_0,
                                const GGS_lstring & argument_1,
                                const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOptionComponentName (argument_0),
mOptionName (argument_1),
mReaderName (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateOptionAccessAST * GGS_templateOptionAccessAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateOptionAccessAST) ;
    return (cPtr_templateOptionAccessAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateOptionAccessAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateOptionAccessAST * ptr = dynamic_cast <const cPtr_templateOptionAccessAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOptionComponentName.operator_isEqual (ptr->mOptionComponentName).boolValue ()
         && mOptionName.operator_isEqual (ptr->mOptionName).boolValue ()
         && mReaderName.operator_isEqual (ptr->mReaderName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateOptionAccessAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateOptionAccessAST:"
           << mOptionComponentName.reader_description (inIndentation + 1)
           << mOptionName.reader_description (inIndentation + 1)
           << mReaderName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateOptionAccessAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateOptionAccessAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateOptionAccessAST (& typeid (cPtr_templateOptionAccessAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateOptionAccessAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateOptionAccessAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateOptionAccessAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateOptionAccessAST (mOptionComponentName, mOptionName, mReaderName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateOptionAccessAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateOptionAccessAST ("templateOptionAccessAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateOptionAccessAST::
GGS_templateOptionAccessAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateOptionAccessAST::
GGS_templateOptionAccessAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateOptionAccessAST GGS_templateOptionAccessAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateOptionAccessAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateOptionAccessAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateOptionAccessAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateOptionAccessAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateOptionAccessAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateOptionAccessAST GGS_templateOptionAccessAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstring & argument_1,
                 const GGS_lstring & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateOptionAccessAST result ;
  macroMyNew (result.mPointer, cPtr_templateOptionAccessAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateOptionAccessAST::
reader_mOptionComponentName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateOptionAccessAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateOptionAccessAST *) mPointer)->mOptionComponentName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateOptionAccessAST::
reader_mOptionName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateOptionAccessAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateOptionAccessAST *) mPointer)->mOptionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateOptionAccessAST::
reader_mReaderName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateOptionAccessAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateOptionAccessAST *) mPointer)->mReaderName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateOptionAccessAST::actualTypeName (void) const {
  return "templateOptionAccessAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateOptionAccessAST ("templateOptionAccessAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateOptionAccessAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateOptionAccessAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateOptionAccessAST * p = NULL ;
    macroMyNew (p, GGS_templateOptionAccessAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateOptionAccessAST GGS_templateOptionAccessAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateOptionAccessAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateOptionAccessAST * p = dynamic_cast <const GGS_templateOptionAccessAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateOptionAccessAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateOptionAccessAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateOptionAccessAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateFunctionCallAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateFunctionCallAST::
cPtr_templateFunctionCallAST (const GGS_lstring & argument_0,
                                const GGS_templateExpressionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mFunctionName (argument_0),
mExpressionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateFunctionCallAST * GGS_templateFunctionCallAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateFunctionCallAST) ;
    return (cPtr_templateFunctionCallAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateFunctionCallAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateFunctionCallAST * ptr = dynamic_cast <const cPtr_templateFunctionCallAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mFunctionName.operator_isEqual (ptr->mFunctionName).boolValue ()
         && mExpressionList.operator_isEqual (ptr->mExpressionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateFunctionCallAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateFunctionCallAST:"
           << mFunctionName.reader_description (inIndentation + 1)
           << mExpressionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateFunctionCallAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateFunctionCallAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateFunctionCallAST (& typeid (cPtr_templateFunctionCallAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateFunctionCallAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateFunctionCallAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateFunctionCallAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateFunctionCallAST (mFunctionName, mExpressionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateFunctionCallAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateFunctionCallAST ("templateFunctionCallAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateFunctionCallAST::
GGS_templateFunctionCallAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateFunctionCallAST::
GGS_templateFunctionCallAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateFunctionCallAST GGS_templateFunctionCallAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateFunctionCallAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateFunctionCallAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateFunctionCallAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateFunctionCallAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateFunctionCallAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateFunctionCallAST GGS_templateFunctionCallAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_templateExpressionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateFunctionCallAST result ;
  macroMyNew (result.mPointer, cPtr_templateFunctionCallAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateFunctionCallAST::
reader_mFunctionName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateFunctionCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateFunctionCallAST *) mPointer)->mFunctionName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionListAST  GGS_templateFunctionCallAST::
reader_mExpressionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateFunctionCallAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateFunctionCallAST *) mPointer)->mExpressionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateFunctionCallAST::actualTypeName (void) const {
  return "templateFunctionCallAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateFunctionCallAST ("templateFunctionCallAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateFunctionCallAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateFunctionCallAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateFunctionCallAST * p = NULL ;
    macroMyNew (p, GGS_templateFunctionCallAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateFunctionCallAST GGS_templateFunctionCallAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateFunctionCallAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateFunctionCallAST * p = dynamic_cast <const GGS_templateFunctionCallAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateFunctionCallAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateFunctionCallAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateFunctionCallAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_templateVarInExpressionAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateVarInExpressionAST::
cPtr_templateVarInExpressionAST (const GGS_lstring & argument_0,
                                const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mVarName (argument_0),
mStructAttributeList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateVarInExpressionAST * GGS_templateVarInExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateVarInExpressionAST) ;
    return (cPtr_templateVarInExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateVarInExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateVarInExpressionAST * ptr = dynamic_cast <const cPtr_templateVarInExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mVarName.operator_isEqual (ptr->mVarName).boolValue ()
         && mStructAttributeList.operator_isEqual (ptr->mStructAttributeList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateVarInExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateVarInExpressionAST:"
           << mVarName.reader_description (inIndentation + 1)
           << mStructAttributeList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateVarInExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateVarInExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateVarInExpressionAST (& typeid (cPtr_templateVarInExpressionAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateVarInExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateVarInExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateVarInExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateVarInExpressionAST (mVarName, mStructAttributeList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_templateVarInExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateVarInExpressionAST ("templateVarInExpressionAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateVarInExpressionAST::
GGS_templateVarInExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateVarInExpressionAST::
GGS_templateVarInExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateVarInExpressionAST GGS_templateVarInExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateVarInExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateVarInExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateVarInExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateVarInExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateVarInExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateVarInExpressionAST GGS_templateVarInExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0,
                 const GGS_lstringlist & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateVarInExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateVarInExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateVarInExpressionAST::
reader_mVarName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateVarInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateVarInExpressionAST *) mPointer)->mVarName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_templateVarInExpressionAST::
reader_mStructAttributeList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstringlist   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateVarInExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateVarInExpressionAST *) mPointer)->mStructAttributeList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateVarInExpressionAST::actualTypeName (void) const {
  return "templateVarInExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateVarInExpressionAST ("templateVarInExpressionAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateVarInExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateVarInExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateVarInExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateVarInExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateVarInExpressionAST GGS_templateVarInExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateVarInExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateVarInExpressionAST * p = dynamic_cast <const GGS_templateVarInExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateVarInExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateVarInExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateVarInExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateAddOperationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateAddOperationAST::
cPtr_templateAddOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateAddOperationAST * GGS_templateAddOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateAddOperationAST) ;
    return (cPtr_templateAddOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateAddOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateAddOperationAST * ptr = dynamic_cast <const cPtr_templateAddOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateAddOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateAddOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateAddOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateAddOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateAddOperationAST (& typeid (cPtr_templateAddOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateAddOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateAddOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateAddOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateAddOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateAddOperationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateAddOperationAST ("templateAddOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateAddOperationAST::
GGS_templateAddOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateAddOperationAST::
GGS_templateAddOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateAddOperationAST GGS_templateAddOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateAddOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateAddOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateAddOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateAddOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateAddOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateAddOperationAST GGS_templateAddOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateAddOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateAddOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateAddOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateAddOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateAddOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateAddOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateAddOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateAddOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateAddOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateAddOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateAddOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateAddOperationAST::actualTypeName (void) const {
  return "templateAddOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateAddOperationAST ("templateAddOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateAddOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateAddOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateAddOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateAddOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateAddOperationAST GGS_templateAddOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateAddOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateAddOperationAST * p = dynamic_cast <const GGS_templateAddOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateAddOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateAddOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateAddOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateSubOperationAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateSubOperationAST::
cPtr_templateSubOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateSubOperationAST * GGS_templateSubOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateSubOperationAST) ;
    return (cPtr_templateSubOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateSubOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateSubOperationAST * ptr = dynamic_cast <const cPtr_templateSubOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateSubOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateSubOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateSubOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateSubOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateSubOperationAST (& typeid (cPtr_templateSubOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateSubOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateSubOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateSubOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateSubOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateSubOperationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateSubOperationAST ("templateSubOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateSubOperationAST::
GGS_templateSubOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateSubOperationAST::
GGS_templateSubOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateSubOperationAST GGS_templateSubOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateSubOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateSubOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateSubOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateSubOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateSubOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateSubOperationAST GGS_templateSubOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateSubOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateSubOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateSubOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateSubOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateSubOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateSubOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateSubOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateSubOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateSubOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateSubOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateSubOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateSubOperationAST::actualTypeName (void) const {
  return "templateSubOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateSubOperationAST ("templateSubOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateSubOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateSubOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateSubOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateSubOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateSubOperationAST GGS_templateSubOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateSubOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateSubOperationAST * p = dynamic_cast <const GGS_templateSubOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateSubOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateSubOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateSubOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_templateMultiplyOperationAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateMultiplyOperationAST::
cPtr_templateMultiplyOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateMultiplyOperationAST * GGS_templateMultiplyOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateMultiplyOperationAST) ;
    return (cPtr_templateMultiplyOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateMultiplyOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateMultiplyOperationAST * ptr = dynamic_cast <const cPtr_templateMultiplyOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateMultiplyOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateMultiplyOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateMultiplyOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateMultiplyOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateMultiplyOperationAST (& typeid (cPtr_templateMultiplyOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateMultiplyOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateMultiplyOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateMultiplyOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateMultiplyOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_templateMultiplyOperationAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateMultiplyOperationAST ("templateMultiplyOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateMultiplyOperationAST::
GGS_templateMultiplyOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateMultiplyOperationAST::
GGS_templateMultiplyOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateMultiplyOperationAST GGS_templateMultiplyOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateMultiplyOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateMultiplyOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateMultiplyOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateMultiplyOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateMultiplyOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateMultiplyOperationAST GGS_templateMultiplyOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateMultiplyOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateMultiplyOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateMultiplyOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateMultiplyOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateMultiplyOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateMultiplyOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateMultiplyOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateMultiplyOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateMultiplyOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateMultiplyOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateMultiplyOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateMultiplyOperationAST::actualTypeName (void) const {
  return "templateMultiplyOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateMultiplyOperationAST ("templateMultiplyOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateMultiplyOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateMultiplyOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateMultiplyOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateMultiplyOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateMultiplyOperationAST GGS_templateMultiplyOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateMultiplyOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateMultiplyOperationAST * p = dynamic_cast <const GGS_templateMultiplyOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateMultiplyOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateMultiplyOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateMultiplyOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_templateDivideOperationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateDivideOperationAST::
cPtr_templateDivideOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateDivideOperationAST * GGS_templateDivideOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateDivideOperationAST) ;
    return (cPtr_templateDivideOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateDivideOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateDivideOperationAST * ptr = dynamic_cast <const cPtr_templateDivideOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateDivideOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateDivideOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateDivideOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateDivideOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateDivideOperationAST (& typeid (cPtr_templateDivideOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateDivideOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateDivideOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateDivideOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateDivideOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_templateDivideOperationAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateDivideOperationAST ("templateDivideOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateDivideOperationAST::
GGS_templateDivideOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateDivideOperationAST::
GGS_templateDivideOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateDivideOperationAST GGS_templateDivideOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateDivideOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateDivideOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateDivideOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateDivideOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateDivideOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateDivideOperationAST GGS_templateDivideOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateDivideOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateDivideOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateDivideOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateDivideOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateDivideOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateDivideOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateDivideOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateDivideOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateDivideOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateDivideOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateDivideOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateDivideOperationAST::actualTypeName (void) const {
  return "templateDivideOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateDivideOperationAST ("templateDivideOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateDivideOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateDivideOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateDivideOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateDivideOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateDivideOperationAST GGS_templateDivideOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateDivideOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateDivideOperationAST * p = dynamic_cast <const GGS_templateDivideOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateDivideOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateDivideOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateDivideOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_templateModuloOperationAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateModuloOperationAST::
cPtr_templateModuloOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateModuloOperationAST * GGS_templateModuloOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateModuloOperationAST) ;
    return (cPtr_templateModuloOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateModuloOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateModuloOperationAST * ptr = dynamic_cast <const cPtr_templateModuloOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateModuloOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateModuloOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateModuloOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateModuloOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateModuloOperationAST (& typeid (cPtr_templateModuloOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateModuloOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateModuloOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateModuloOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateModuloOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_templateModuloOperationAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateModuloOperationAST ("templateModuloOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateModuloOperationAST::
GGS_templateModuloOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateModuloOperationAST::
GGS_templateModuloOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateModuloOperationAST GGS_templateModuloOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateModuloOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateModuloOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateModuloOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateModuloOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateModuloOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateModuloOperationAST GGS_templateModuloOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateModuloOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateModuloOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateModuloOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateModuloOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateModuloOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateModuloOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateModuloOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateModuloOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateModuloOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateModuloOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateModuloOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateModuloOperationAST::actualTypeName (void) const {
  return "templateModuloOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateModuloOperationAST ("templateModuloOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateModuloOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateModuloOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateModuloOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateModuloOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateModuloOperationAST GGS_templateModuloOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateModuloOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateModuloOperationAST * p = dynamic_cast <const GGS_templateModuloOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateModuloOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateModuloOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateModuloOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_templateUnaryMinusOperationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateUnaryMinusOperationAST::
cPtr_templateUnaryMinusOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mExpression (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateUnaryMinusOperationAST * GGS_templateUnaryMinusOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateUnaryMinusOperationAST) ;
    return (cPtr_templateUnaryMinusOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateUnaryMinusOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateUnaryMinusOperationAST * ptr = dynamic_cast <const cPtr_templateUnaryMinusOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateUnaryMinusOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateUnaryMinusOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateUnaryMinusOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateUnaryMinusOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateUnaryMinusOperationAST (& typeid (cPtr_templateUnaryMinusOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateUnaryMinusOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateUnaryMinusOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateUnaryMinusOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateUnaryMinusOperationAST (mOperatorLocation, mExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_templateUnaryMinusOperationAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateUnaryMinusOperationAST ("templateUnaryMinusOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateUnaryMinusOperationAST::
GGS_templateUnaryMinusOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateUnaryMinusOperationAST::
GGS_templateUnaryMinusOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateUnaryMinusOperationAST GGS_templateUnaryMinusOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateUnaryMinusOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateUnaryMinusOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateUnaryMinusOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateUnaryMinusOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateUnaryMinusOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateUnaryMinusOperationAST GGS_templateUnaryMinusOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateUnaryMinusOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateUnaryMinusOperationAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateUnaryMinusOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateUnaryMinusOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateUnaryMinusOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateUnaryMinusOperationAST::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateUnaryMinusOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateUnaryMinusOperationAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateUnaryMinusOperationAST::actualTypeName (void) const {
  return "templateUnaryMinusOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateUnaryMinusOperationAST ("templateUnaryMinusOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateUnaryMinusOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateUnaryMinusOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateUnaryMinusOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateUnaryMinusOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateUnaryMinusOperationAST GGS_templateUnaryMinusOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateUnaryMinusOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateUnaryMinusOperationAST * p = dynamic_cast <const GGS_templateUnaryMinusOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateUnaryMinusOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateUnaryMinusOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateUnaryMinusOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                    class 'cPtr_templateEqualTestAST'                      *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateEqualTestAST::
cPtr_templateEqualTestAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateEqualTestAST * GGS_templateEqualTestAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateEqualTestAST) ;
    return (cPtr_templateEqualTestAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateEqualTestAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateEqualTestAST * ptr = dynamic_cast <const cPtr_templateEqualTestAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateEqualTestAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateEqualTestAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateEqualTestAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateEqualTestAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateEqualTestAST (& typeid (cPtr_templateEqualTestAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateEqualTestAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateEqualTestAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateEqualTestAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateEqualTestAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 GALGAS class 'GGS_templateEqualTestAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateEqualTestAST ("templateEqualTestAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateEqualTestAST::
GGS_templateEqualTestAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateEqualTestAST::
GGS_templateEqualTestAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateEqualTestAST GGS_templateEqualTestAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateEqualTestAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateEqualTestAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateEqualTestAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateEqualTestAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateEqualTestAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateEqualTestAST GGS_templateEqualTestAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateEqualTestAST result ;
  macroMyNew (result.mPointer, cPtr_templateEqualTestAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateEqualTestAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateEqualTestAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateEqualTestAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateEqualTestAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateEqualTestAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateEqualTestAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateEqualTestAST::actualTypeName (void) const {
  return "templateEqualTestAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateEqualTestAST ("templateEqualTestAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateEqualTestAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateEqualTestAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateEqualTestAST * p = NULL ;
    macroMyNew (p, GGS_templateEqualTestAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateEqualTestAST GGS_templateEqualTestAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateEqualTestAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateEqualTestAST * p = dynamic_cast <const GGS_templateEqualTestAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateEqualTestAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateEqualTestAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateEqualTestAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   class 'cPtr_templateNonEqualTestAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateNonEqualTestAST::
cPtr_templateNonEqualTestAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateNonEqualTestAST * GGS_templateNonEqualTestAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateNonEqualTestAST) ;
    return (cPtr_templateNonEqualTestAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateNonEqualTestAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateNonEqualTestAST * ptr = dynamic_cast <const cPtr_templateNonEqualTestAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateNonEqualTestAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateNonEqualTestAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateNonEqualTestAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateNonEqualTestAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateNonEqualTestAST (& typeid (cPtr_templateNonEqualTestAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateNonEqualTestAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateNonEqualTestAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateNonEqualTestAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateNonEqualTestAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                GALGAS class 'GGS_templateNonEqualTestAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateNonEqualTestAST ("templateNonEqualTestAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateNonEqualTestAST::
GGS_templateNonEqualTestAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateNonEqualTestAST::
GGS_templateNonEqualTestAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateNonEqualTestAST GGS_templateNonEqualTestAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateNonEqualTestAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateNonEqualTestAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateNonEqualTestAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateNonEqualTestAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateNonEqualTestAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateNonEqualTestAST GGS_templateNonEqualTestAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateNonEqualTestAST result ;
  macroMyNew (result.mPointer, cPtr_templateNonEqualTestAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateNonEqualTestAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateNonEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateNonEqualTestAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateNonEqualTestAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateNonEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateNonEqualTestAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateNonEqualTestAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateNonEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateNonEqualTestAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateNonEqualTestAST::actualTypeName (void) const {
  return "templateNonEqualTestAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateNonEqualTestAST ("templateNonEqualTestAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateNonEqualTestAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateNonEqualTestAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateNonEqualTestAST * p = NULL ;
    macroMyNew (p, GGS_templateNonEqualTestAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateNonEqualTestAST GGS_templateNonEqualTestAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateNonEqualTestAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateNonEqualTestAST * p = dynamic_cast <const GGS_templateNonEqualTestAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateNonEqualTestAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateNonEqualTestAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateNonEqualTestAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateStrictInfTestAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateStrictInfTestAST::
cPtr_templateStrictInfTestAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateStrictInfTestAST * GGS_templateStrictInfTestAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateStrictInfTestAST) ;
    return (cPtr_templateStrictInfTestAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateStrictInfTestAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateStrictInfTestAST * ptr = dynamic_cast <const cPtr_templateStrictInfTestAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateStrictInfTestAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateStrictInfTestAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateStrictInfTestAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateStrictInfTestAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateStrictInfTestAST (& typeid (cPtr_templateStrictInfTestAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateStrictInfTestAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateStrictInfTestAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateStrictInfTestAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateStrictInfTestAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateStrictInfTestAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateStrictInfTestAST ("templateStrictInfTestAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateStrictInfTestAST::
GGS_templateStrictInfTestAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateStrictInfTestAST::
GGS_templateStrictInfTestAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateStrictInfTestAST GGS_templateStrictInfTestAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateStrictInfTestAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateStrictInfTestAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateStrictInfTestAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateStrictInfTestAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateStrictInfTestAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateStrictInfTestAST GGS_templateStrictInfTestAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateStrictInfTestAST result ;
  macroMyNew (result.mPointer, cPtr_templateStrictInfTestAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateStrictInfTestAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateStrictInfTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateStrictInfTestAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateStrictInfTestAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateStrictInfTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateStrictInfTestAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateStrictInfTestAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateStrictInfTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateStrictInfTestAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateStrictInfTestAST::actualTypeName (void) const {
  return "templateStrictInfTestAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateStrictInfTestAST ("templateStrictInfTestAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateStrictInfTestAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateStrictInfTestAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateStrictInfTestAST * p = NULL ;
    macroMyNew (p, GGS_templateStrictInfTestAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateStrictInfTestAST GGS_templateStrictInfTestAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateStrictInfTestAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateStrictInfTestAST * p = dynamic_cast <const GGS_templateStrictInfTestAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateStrictInfTestAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateStrictInfTestAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateStrictInfTestAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateInfOrEqualTestAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInfOrEqualTestAST::
cPtr_templateInfOrEqualTestAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInfOrEqualTestAST * GGS_templateInfOrEqualTestAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInfOrEqualTestAST) ;
    return (cPtr_templateInfOrEqualTestAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInfOrEqualTestAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInfOrEqualTestAST * ptr = dynamic_cast <const cPtr_templateInfOrEqualTestAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInfOrEqualTestAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInfOrEqualTestAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInfOrEqualTestAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInfOrEqualTestAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInfOrEqualTestAST (& typeid (cPtr_templateInfOrEqualTestAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInfOrEqualTestAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInfOrEqualTestAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInfOrEqualTestAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInfOrEqualTestAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateInfOrEqualTestAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInfOrEqualTestAST ("templateInfOrEqualTestAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateInfOrEqualTestAST::
GGS_templateInfOrEqualTestAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInfOrEqualTestAST::
GGS_templateInfOrEqualTestAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInfOrEqualTestAST GGS_templateInfOrEqualTestAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInfOrEqualTestAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInfOrEqualTestAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInfOrEqualTestAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInfOrEqualTestAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInfOrEqualTestAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInfOrEqualTestAST GGS_templateInfOrEqualTestAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateInfOrEqualTestAST result ;
  macroMyNew (result.mPointer, cPtr_templateInfOrEqualTestAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateInfOrEqualTestAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInfOrEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInfOrEqualTestAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateInfOrEqualTestAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInfOrEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInfOrEqualTestAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateInfOrEqualTestAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInfOrEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInfOrEqualTestAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInfOrEqualTestAST::actualTypeName (void) const {
  return "templateInfOrEqualTestAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInfOrEqualTestAST ("templateInfOrEqualTestAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateInfOrEqualTestAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInfOrEqualTestAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInfOrEqualTestAST * p = NULL ;
    macroMyNew (p, GGS_templateInfOrEqualTestAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInfOrEqualTestAST GGS_templateInfOrEqualTestAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInfOrEqualTestAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInfOrEqualTestAST * p = dynamic_cast <const GGS_templateInfOrEqualTestAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInfOrEqualTestAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInfOrEqualTestAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInfOrEqualTestAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateStrictSupTestAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateStrictSupTestAST::
cPtr_templateStrictSupTestAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateStrictSupTestAST * GGS_templateStrictSupTestAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateStrictSupTestAST) ;
    return (cPtr_templateStrictSupTestAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateStrictSupTestAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateStrictSupTestAST * ptr = dynamic_cast <const cPtr_templateStrictSupTestAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateStrictSupTestAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateStrictSupTestAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateStrictSupTestAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateStrictSupTestAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateStrictSupTestAST (& typeid (cPtr_templateStrictSupTestAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateStrictSupTestAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateStrictSupTestAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateStrictSupTestAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateStrictSupTestAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateStrictSupTestAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateStrictSupTestAST ("templateStrictSupTestAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateStrictSupTestAST::
GGS_templateStrictSupTestAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateStrictSupTestAST::
GGS_templateStrictSupTestAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateStrictSupTestAST GGS_templateStrictSupTestAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateStrictSupTestAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateStrictSupTestAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateStrictSupTestAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateStrictSupTestAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateStrictSupTestAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateStrictSupTestAST GGS_templateStrictSupTestAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateStrictSupTestAST result ;
  macroMyNew (result.mPointer, cPtr_templateStrictSupTestAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateStrictSupTestAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateStrictSupTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateStrictSupTestAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateStrictSupTestAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateStrictSupTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateStrictSupTestAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateStrictSupTestAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateStrictSupTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateStrictSupTestAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateStrictSupTestAST::actualTypeName (void) const {
  return "templateStrictSupTestAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateStrictSupTestAST ("templateStrictSupTestAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateStrictSupTestAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateStrictSupTestAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateStrictSupTestAST * p = NULL ;
    macroMyNew (p, GGS_templateStrictSupTestAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateStrictSupTestAST GGS_templateStrictSupTestAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateStrictSupTestAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateStrictSupTestAST * p = dynamic_cast <const GGS_templateStrictSupTestAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateStrictSupTestAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateStrictSupTestAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateStrictSupTestAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateSupOrEqualTestAST'                   *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateSupOrEqualTestAST::
cPtr_templateSupOrEqualTestAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateSupOrEqualTestAST * GGS_templateSupOrEqualTestAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateSupOrEqualTestAST) ;
    return (cPtr_templateSupOrEqualTestAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateSupOrEqualTestAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateSupOrEqualTestAST * ptr = dynamic_cast <const cPtr_templateSupOrEqualTestAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateSupOrEqualTestAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateSupOrEqualTestAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateSupOrEqualTestAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateSupOrEqualTestAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateSupOrEqualTestAST (& typeid (cPtr_templateSupOrEqualTestAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateSupOrEqualTestAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateSupOrEqualTestAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateSupOrEqualTestAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateSupOrEqualTestAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateSupOrEqualTestAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateSupOrEqualTestAST ("templateSupOrEqualTestAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateSupOrEqualTestAST::
GGS_templateSupOrEqualTestAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateSupOrEqualTestAST::
GGS_templateSupOrEqualTestAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateSupOrEqualTestAST GGS_templateSupOrEqualTestAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateSupOrEqualTestAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateSupOrEqualTestAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateSupOrEqualTestAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateSupOrEqualTestAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateSupOrEqualTestAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateSupOrEqualTestAST GGS_templateSupOrEqualTestAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateSupOrEqualTestAST result ;
  macroMyNew (result.mPointer, cPtr_templateSupOrEqualTestAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateSupOrEqualTestAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateSupOrEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateSupOrEqualTestAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateSupOrEqualTestAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateSupOrEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateSupOrEqualTestAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateSupOrEqualTestAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateSupOrEqualTestAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateSupOrEqualTestAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateSupOrEqualTestAST::actualTypeName (void) const {
  return "templateSupOrEqualTestAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateSupOrEqualTestAST ("templateSupOrEqualTestAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateSupOrEqualTestAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateSupOrEqualTestAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateSupOrEqualTestAST * p = NULL ;
    macroMyNew (p, GGS_templateSupOrEqualTestAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateSupOrEqualTestAST GGS_templateSupOrEqualTestAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateSupOrEqualTestAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateSupOrEqualTestAST * p = dynamic_cast <const GGS_templateSupOrEqualTestAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateSupOrEqualTestAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateSupOrEqualTestAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateSupOrEqualTestAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_templateLeftShiftOperationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateLeftShiftOperationAST::
cPtr_templateLeftShiftOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateLeftShiftOperationAST * GGS_templateLeftShiftOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateLeftShiftOperationAST) ;
    return (cPtr_templateLeftShiftOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateLeftShiftOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateLeftShiftOperationAST * ptr = dynamic_cast <const cPtr_templateLeftShiftOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateLeftShiftOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateLeftShiftOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateLeftShiftOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateLeftShiftOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateLeftShiftOperationAST (& typeid (cPtr_templateLeftShiftOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateLeftShiftOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateLeftShiftOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateLeftShiftOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateLeftShiftOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_templateLeftShiftOperationAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateLeftShiftOperationAST ("templateLeftShiftOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateLeftShiftOperationAST::
GGS_templateLeftShiftOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateLeftShiftOperationAST::
GGS_templateLeftShiftOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateLeftShiftOperationAST GGS_templateLeftShiftOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateLeftShiftOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateLeftShiftOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateLeftShiftOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateLeftShiftOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateLeftShiftOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLeftShiftOperationAST GGS_templateLeftShiftOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateLeftShiftOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateLeftShiftOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateLeftShiftOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLeftShiftOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLeftShiftOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateLeftShiftOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLeftShiftOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLeftShiftOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateLeftShiftOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateLeftShiftOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateLeftShiftOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateLeftShiftOperationAST::actualTypeName (void) const {
  return "templateLeftShiftOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateLeftShiftOperationAST ("templateLeftShiftOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateLeftShiftOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateLeftShiftOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateLeftShiftOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateLeftShiftOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateLeftShiftOperationAST GGS_templateLeftShiftOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateLeftShiftOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateLeftShiftOperationAST * p = dynamic_cast <const GGS_templateLeftShiftOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateLeftShiftOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateLeftShiftOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateLeftShiftOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               class 'cPtr_templateRightShiftOperationAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateRightShiftOperationAST::
cPtr_templateRightShiftOperationAST (const GGS_location & argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mOperatorLocation (argument_0),
mLeftExpression (argument_1),
mRightExpression (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateRightShiftOperationAST * GGS_templateRightShiftOperationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateRightShiftOperationAST) ;
    return (cPtr_templateRightShiftOperationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateRightShiftOperationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateRightShiftOperationAST * ptr = dynamic_cast <const cPtr_templateRightShiftOperationAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mOperatorLocation.operator_isEqual (ptr->mOperatorLocation).boolValue ()
         && mLeftExpression.operator_isEqual (ptr->mLeftExpression).boolValue ()
         && mRightExpression.operator_isEqual (ptr->mRightExpression).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateRightShiftOperationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateRightShiftOperationAST:"
           << mOperatorLocation.reader_description (inIndentation + 1)
           << mLeftExpression.reader_description (inIndentation + 1)
           << mRightExpression.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateRightShiftOperationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateRightShiftOperationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateRightShiftOperationAST (& typeid (cPtr_templateRightShiftOperationAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateRightShiftOperationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateRightShiftOperationAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateRightShiftOperationAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateRightShiftOperationAST (mOperatorLocation, mLeftExpression, mRightExpression COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//            GALGAS class 'GGS_templateRightShiftOperationAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateRightShiftOperationAST ("templateRightShiftOperationAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateRightShiftOperationAST::
GGS_templateRightShiftOperationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateRightShiftOperationAST::
GGS_templateRightShiftOperationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateRightShiftOperationAST GGS_templateRightShiftOperationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateRightShiftOperationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateRightShiftOperationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateRightShiftOperationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateRightShiftOperationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateRightShiftOperationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateRightShiftOperationAST GGS_templateRightShiftOperationAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_location & argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_templateExpressionAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateRightShiftOperationAST result ;
  macroMyNew (result.mPointer, cPtr_templateRightShiftOperationAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateRightShiftOperationAST::
reader_mOperatorLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateRightShiftOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateRightShiftOperationAST *) mPointer)->mOperatorLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateRightShiftOperationAST::
reader_mLeftExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateRightShiftOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateRightShiftOperationAST *) mPointer)->mLeftExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateRightShiftOperationAST::
reader_mRightExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateRightShiftOperationAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateRightShiftOperationAST *) mPointer)->mRightExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateRightShiftOperationAST::actualTypeName (void) const {
  return "templateRightShiftOperationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateRightShiftOperationAST ("templateRightShiftOperationAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateRightShiftOperationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateRightShiftOperationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateRightShiftOperationAST * p = NULL ;
    macroMyNew (p, GGS_templateRightShiftOperationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateRightShiftOperationAST GGS_templateRightShiftOperationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateRightShiftOperationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateRightShiftOperationAST * p = dynamic_cast <const GGS_templateRightShiftOperationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateRightShiftOperationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateRightShiftOperationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateRightShiftOperationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_templateClassToTypeOperandAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateClassToTypeOperandAST::
cPtr_templateClassToTypeOperandAST (const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateExpressionAST (THERE),
mTypeName (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateClassToTypeOperandAST * GGS_templateClassToTypeOperandAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateClassToTypeOperandAST) ;
    return (cPtr_templateClassToTypeOperandAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateClassToTypeOperandAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateClassToTypeOperandAST * ptr = dynamic_cast <const cPtr_templateClassToTypeOperandAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTypeName.operator_isEqual (ptr->mTypeName).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateClassToTypeOperandAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateClassToTypeOperandAST:"
           << mTypeName.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateClassToTypeOperandAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateClassToTypeOperandAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateClassToTypeOperandAST (& typeid (cPtr_templateClassToTypeOperandAST), & typeid (cPtr_templateExpressionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateClassToTypeOperandAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateClassToTypeOperandAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateClassToTypeOperandAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateClassToTypeOperandAST (mTypeName COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_templateClassToTypeOperandAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateClassToTypeOperandAST ("templateClassToTypeOperandAST", true, & kTypeDescriptor_GGS_templateExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_templateClassToTypeOperandAST::
GGS_templateClassToTypeOperandAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateClassToTypeOperandAST::
GGS_templateClassToTypeOperandAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateClassToTypeOperandAST GGS_templateClassToTypeOperandAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateClassToTypeOperandAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateClassToTypeOperandAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateClassToTypeOperandAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateClassToTypeOperandAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateClassToTypeOperandAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateClassToTypeOperandAST GGS_templateClassToTypeOperandAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_lstring & argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateClassToTypeOperandAST result ;
  macroMyNew (result.mPointer, cPtr_templateClassToTypeOperandAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateClassToTypeOperandAST::
reader_mTypeName (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateClassToTypeOperandAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateClassToTypeOperandAST *) mPointer)->mTypeName ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateClassToTypeOperandAST::actualTypeName (void) const {
  return "templateClassToTypeOperandAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateClassToTypeOperandAST ("templateClassToTypeOperandAST", gClassInfoFor__templateExpressionAST, & kTypeDescriptor_GGS_templateClassToTypeOperandAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateClassToTypeOperandAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateClassToTypeOperandAST * p = NULL ;
    macroMyNew (p, GGS_templateClassToTypeOperandAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateClassToTypeOperandAST GGS_templateClassToTypeOperandAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateClassToTypeOperandAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateClassToTypeOperandAST * p = dynamic_cast <const GGS_templateClassToTypeOperandAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateClassToTypeOperandAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateClassToTypeOperandAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateClassToTypeOperandAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_templateInstructionStringAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionStringAST::
cPtr_templateInstructionStringAST (const GGS_string& argument_0
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionAST (THERE),
mTemplateString (argument_0) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionStringAST * GGS_templateInstructionStringAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionStringAST) ;
    return (cPtr_templateInstructionStringAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionStringAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionStringAST * ptr = dynamic_cast <const cPtr_templateInstructionStringAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTemplateString.operator_isEqual (ptr->mTemplateString).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionStringAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionStringAST:"
           << mTemplateString.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionStringAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionStringAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionStringAST (& typeid (cPtr_templateInstructionStringAST), & typeid (cPtr_templateInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionStringAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionStringAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionStringAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionStringAST (mTemplateString COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_templateInstructionStringAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionStringAST ("templateInstructionStringAST", true, & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionStringAST::
GGS_templateInstructionStringAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionStringAST::
GGS_templateInstructionStringAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionStringAST GGS_templateInstructionStringAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionStringAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionStringAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionStringAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionStringAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionStringAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionStringAST GGS_templateInstructionStringAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_string& argument_0
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionStringAST result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionStringAST (argument_0 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionStringAST::
reader_mTemplateString (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionStringAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionStringAST *) mPointer)->mTemplateString ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionStringAST::actualTypeName (void) const {
  return "templateInstructionStringAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionStringAST ("templateInstructionStringAST", gClassInfoFor__templateInstructionAST, & kTypeDescriptor_GGS_templateInstructionStringAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionStringAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionStringAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionStringAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionStringAST GGS_templateInstructionStringAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionStringAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionStringAST * p = dynamic_cast <const GGS_templateInstructionStringAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionStringAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionStringAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionStringAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              class 'cPtr_templateInstructionExpressionAST'                *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionExpressionAST::
cPtr_templateInstructionExpressionAST (const GGS_templateExpressionAST & argument_0,
                                const GGS_location & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionAST (THERE),
mExpression (argument_0),
mLocation (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionExpressionAST * GGS_templateInstructionExpressionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionExpressionAST) ;
    return (cPtr_templateInstructionExpressionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionExpressionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionExpressionAST * ptr = dynamic_cast <const cPtr_templateInstructionExpressionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionExpressionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionExpressionAST:"
           << mExpression.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionExpressionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionExpressionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionExpressionAST (& typeid (cPtr_templateInstructionExpressionAST), & typeid (cPtr_templateInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionExpressionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionExpressionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionExpressionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionExpressionAST (mExpression, mLocation COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           GALGAS class 'GGS_templateInstructionExpressionAST'             *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionExpressionAST ("templateInstructionExpressionAST", true, & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionExpressionAST::
GGS_templateInstructionExpressionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpressionAST::
GGS_templateInstructionExpressionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionExpressionAST GGS_templateInstructionExpressionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpressionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionExpressionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionExpressionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionExpressionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionExpressionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpressionAST GGS_templateInstructionExpressionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_templateExpressionAST & argument_0,
                 const GGS_location & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpressionAST result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionExpressionAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateInstructionExpressionAST::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionExpressionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateInstructionExpressionAST::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionExpressionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionExpressionAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionExpressionAST::actualTypeName (void) const {
  return "templateInstructionExpressionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionExpressionAST ("templateInstructionExpressionAST", gClassInfoFor__templateInstructionAST, & kTypeDescriptor_GGS_templateInstructionExpressionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionExpressionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionExpressionAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionExpressionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionExpressionAST GGS_templateInstructionExpressionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionExpressionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionExpressionAST * p = dynamic_cast <const GGS_templateInstructionExpressionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionExpressionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionExpressionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionExpressionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                 class 'cPtr_templateBlockInstructionAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateBlockInstructionAST::
cPtr_templateBlockInstructionAST (const GGS_templateExpressionAST & argument_0,
                                const GGS_location & argument_1,
                                const GGS_templateInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionAST (THERE),
mExpression (argument_0),
mLocation (argument_1),
mBlockInstructionList (argument_2) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateBlockInstructionAST * GGS_templateBlockInstructionAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateBlockInstructionAST) ;
    return (cPtr_templateBlockInstructionAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateBlockInstructionAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateBlockInstructionAST * ptr = dynamic_cast <const cPtr_templateBlockInstructionAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mLocation.operator_isEqual (ptr->mLocation).boolValue ()
         && mBlockInstructionList.operator_isEqual (ptr->mBlockInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateBlockInstructionAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateBlockInstructionAST:"
           << mExpression.reader_description (inIndentation + 1)
           << mLocation.reader_description (inIndentation + 1)
           << mBlockInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateBlockInstructionAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateBlockInstructionAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateBlockInstructionAST (& typeid (cPtr_templateBlockInstructionAST), & typeid (cPtr_templateInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateBlockInstructionAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateBlockInstructionAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateBlockInstructionAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateBlockInstructionAST (mExpression, mLocation, mBlockInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              GALGAS class 'GGS_templateBlockInstructionAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateBlockInstructionAST ("templateBlockInstructionAST", true, & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_templateBlockInstructionAST::
GGS_templateBlockInstructionAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstructionAST::
GGS_templateBlockInstructionAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateBlockInstructionAST GGS_templateBlockInstructionAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstructionAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateBlockInstructionAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateBlockInstructionAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateBlockInstructionAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateBlockInstructionAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstructionAST GGS_templateBlockInstructionAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_templateExpressionAST & argument_0,
                 const GGS_location & argument_1,
                 const GGS_templateInstructionListAST & argument_2
                                COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstructionAST result ;
  macroMyNew (result.mPointer, cPtr_templateBlockInstructionAST (argument_0,
                                argument_1,
                                argument_2 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateBlockInstructionAST::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateBlockInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateBlockInstructionAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_location  GGS_templateBlockInstructionAST::
reader_mLocation (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_location   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateBlockInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateBlockInstructionAST *) mPointer)->mLocation ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateBlockInstructionAST::
reader_mBlockInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateBlockInstructionAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateBlockInstructionAST *) mPointer)->mBlockInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateBlockInstructionAST::actualTypeName (void) const {
  return "templateBlockInstructionAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateBlockInstructionAST ("templateBlockInstructionAST", gClassInfoFor__templateInstructionAST, & kTypeDescriptor_GGS_templateBlockInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateBlockInstructionAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateBlockInstructionAST * p = NULL ;
    macroMyNew (p, GGS_templateBlockInstructionAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateBlockInstructionAST GGS_templateBlockInstructionAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateBlockInstructionAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateBlockInstructionAST * p = dynamic_cast <const GGS_templateBlockInstructionAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateBlockInstructionAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateBlockInstructionAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateBlockInstructionAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//           class 'cPtr_templateInstructionGetColumnLocationAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionGetColumnLocationAST::
cPtr_templateInstructionGetColumnLocationAST (LOCATION_ARGS)
:cPtr_templateInstructionAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionGetColumnLocationAST * GGS_templateInstructionGetColumnLocationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionGetColumnLocationAST) ;
    return (cPtr_templateInstructionGetColumnLocationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionGetColumnLocationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionGetColumnLocationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@templateInstructionGetColumnLocationAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionGetColumnLocationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionGetColumnLocationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionGetColumnLocationAST (& typeid (cPtr_templateInstructionGetColumnLocationAST), & typeid (cPtr_templateInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionGetColumnLocationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionGetColumnLocationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        GALGAS class 'GGS_templateInstructionGetColumnLocationAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionGetColumnLocationAST ("templateInstructionGetColumnLocationAST", true, & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionGetColumnLocationAST::
GGS_templateInstructionGetColumnLocationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionGetColumnLocationAST::
GGS_templateInstructionGetColumnLocationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionGetColumnLocationAST GGS_templateInstructionGetColumnLocationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGetColumnLocationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionGetColumnLocationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionGetColumnLocationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionGetColumnLocationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionGetColumnLocationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_templateInstructionGetColumnLocationAST * gSingleton_templateInstructionGetColumnLocationAST = NULL ;

//---------------------------------------------------------------------------*

GGS_templateInstructionGetColumnLocationAST GGS_templateInstructionGetColumnLocationAST::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGetColumnLocationAST result ;
  if (NULL == gSingleton_templateInstructionGetColumnLocationAST) {
    macroMyNew (gSingleton_templateInstructionGetColumnLocationAST, cPtr_templateInstructionGetColumnLocationAST (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_templateInstructionGetColumnLocationAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionGetColumnLocationAST::actualTypeName (void) const {
  return "templateInstructionGetColumnLocationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionGetColumnLocationAST ("templateInstructionGetColumnLocationAST", gClassInfoFor__templateInstructionAST, & kTypeDescriptor_GGS_templateInstructionGetColumnLocationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionGetColumnLocationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionGetColumnLocationAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionGetColumnLocationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionGetColumnLocationAST GGS_templateInstructionGetColumnLocationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGetColumnLocationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionGetColumnLocationAST * p = dynamic_cast <const GGS_templateInstructionGetColumnLocationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionGetColumnLocationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionGetColumnLocationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionGetColumnLocationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          class 'cPtr_templateInstructionGotoColumnLocationAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionGotoColumnLocationAST::
cPtr_templateInstructionGotoColumnLocationAST (LOCATION_ARGS)
:cPtr_templateInstructionAST (THERE) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionGotoColumnLocationAST * GGS_templateInstructionGotoColumnLocationAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionGotoColumnLocationAST) ;
    return (cPtr_templateInstructionGotoColumnLocationAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionGotoColumnLocationAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  return typeid (this) == typeid (inOperand) ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionGotoColumnLocationAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 /* inIndentation */) const {
  ioString << "->@templateInstructionGotoColumnLocationAST:" ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionGotoColumnLocationAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionGotoColumnLocationAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionGotoColumnLocationAST (& typeid (cPtr_templateInstructionGotoColumnLocationAST), & typeid (cPtr_templateInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionGotoColumnLocationAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionGotoColumnLocationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//       GALGAS class 'GGS_templateInstructionGotoColumnLocationAST'         *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionGotoColumnLocationAST ("templateInstructionGotoColumnLocationAST", true, & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionGotoColumnLocationAST::
GGS_templateInstructionGotoColumnLocationAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionGotoColumnLocationAST::
GGS_templateInstructionGotoColumnLocationAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionGotoColumnLocationAST GGS_templateInstructionGotoColumnLocationAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGotoColumnLocationAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionGotoColumnLocationAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionGotoColumnLocationAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionGotoColumnLocationAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionGotoColumnLocationAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

static cPtr_templateInstructionGotoColumnLocationAST * gSingleton_templateInstructionGotoColumnLocationAST = NULL ;

//---------------------------------------------------------------------------*

GGS_templateInstructionGotoColumnLocationAST GGS_templateInstructionGotoColumnLocationAST::
constructor_new (C_CompilerEx & /* inLexique */
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGotoColumnLocationAST result ;
  if (NULL == gSingleton_templateInstructionGotoColumnLocationAST) {
    macroMyNew (gSingleton_templateInstructionGotoColumnLocationAST, cPtr_templateInstructionGotoColumnLocationAST (THERE)) ;
  }
  macroAssignObject (result.mPointer, gSingleton_templateInstructionGotoColumnLocationAST) ;
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionGotoColumnLocationAST::actualTypeName (void) const {
  return "templateInstructionGotoColumnLocationAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionGotoColumnLocationAST ("templateInstructionGotoColumnLocationAST", gClassInfoFor__templateInstructionAST, & kTypeDescriptor_GGS_templateInstructionGotoColumnLocationAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionGotoColumnLocationAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionGotoColumnLocationAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionGotoColumnLocationAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionGotoColumnLocationAST GGS_templateInstructionGotoColumnLocationAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionGotoColumnLocationAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionGotoColumnLocationAST * p = dynamic_cast <const GGS_templateInstructionGotoColumnLocationAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionGotoColumnLocationAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionGotoColumnLocationAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionGotoColumnLocationAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_templateInstructionForeachAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionForeachAST::
cPtr_templateInstructionForeachAST (const GGS_bool& argument_0,
                                const GGS_templateExpressionAST & argument_1,
                                const GGS_string& argument_2,
                                const GGS_templateInstructionListAST & argument_3,
                                const GGS_templateInstructionListAST & argument_4,
                                const GGS_lstring & argument_5,
                                const GGS_templateInstructionListAST & argument_6,
                                const GGS_templateInstructionListAST & argument_7
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionAST (THERE),
mIsAscending (argument_0),
mExpression (argument_1),
mPrefix (argument_2),
mBeforeInstructionList (argument_3),
mDoInstructionList (argument_4),
mIndexIdentifier (argument_5),
mBetweenInstructionList (argument_6),
mAfterInstructionList (argument_7) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionForeachAST * GGS_templateInstructionForeachAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionForeachAST) ;
    return (cPtr_templateInstructionForeachAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionForeachAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionForeachAST * ptr = dynamic_cast <const cPtr_templateInstructionForeachAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mIsAscending.operator_isEqual (ptr->mIsAscending).boolValue ()
         && mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mPrefix.operator_isEqual (ptr->mPrefix).boolValue ()
         && mBeforeInstructionList.operator_isEqual (ptr->mBeforeInstructionList).boolValue ()
         && mDoInstructionList.operator_isEqual (ptr->mDoInstructionList).boolValue ()
         && mIndexIdentifier.operator_isEqual (ptr->mIndexIdentifier).boolValue ()
         && mBetweenInstructionList.operator_isEqual (ptr->mBetweenInstructionList).boolValue ()
         && mAfterInstructionList.operator_isEqual (ptr->mAfterInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionForeachAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionForeachAST:"
           << mIsAscending.reader_description (inIndentation + 1)
           << mExpression.reader_description (inIndentation + 1)
           << mPrefix.reader_description (inIndentation + 1)
           << mBeforeInstructionList.reader_description (inIndentation + 1)
           << mDoInstructionList.reader_description (inIndentation + 1)
           << mIndexIdentifier.reader_description (inIndentation + 1)
           << mBetweenInstructionList.reader_description (inIndentation + 1)
           << mAfterInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionForeachAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionForeachAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionForeachAST (& typeid (cPtr_templateInstructionForeachAST), & typeid (cPtr_templateInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionForeachAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionForeachAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionForeachAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionForeachAST (mIsAscending, mExpression, mPrefix, mBeforeInstructionList, mDoInstructionList, mIndexIdentifier, mBetweenInstructionList, mAfterInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_templateInstructionForeachAST'              *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionForeachAST ("templateInstructionForeachAST", true, & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionForeachAST::
GGS_templateInstructionForeachAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeachAST::
GGS_templateInstructionForeachAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionForeachAST GGS_templateInstructionForeachAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeachAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionForeachAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionForeachAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionForeachAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionForeachAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeachAST GGS_templateInstructionForeachAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_bool& argument_0,
                 const GGS_templateExpressionAST & argument_1,
                 const GGS_string& argument_2,
                 const GGS_templateInstructionListAST & argument_3,
                 const GGS_templateInstructionListAST & argument_4,
                 const GGS_lstring & argument_5,
                 const GGS_templateInstructionListAST & argument_6,
                 const GGS_templateInstructionListAST & argument_7
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeachAST result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionForeachAST (argument_0,
                                argument_1,
                                argument_2,
                                argument_3,
                                argument_4,
                                argument_5,
                                argument_6,
                                argument_7 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_bool GGS_templateInstructionForeachAST::
reader_mIsAscending (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_bool  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachAST *) mPointer)->mIsAscending ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateInstructionForeachAST::
reader_mExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachAST *) mPointer)->mExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionForeachAST::
reader_mPrefix (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_string  result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachAST *) mPointer)->mPrefix ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionForeachAST::
reader_mBeforeInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachAST *) mPointer)->mBeforeInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionForeachAST::
reader_mDoInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachAST *) mPointer)->mDoInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_lstring  GGS_templateInstructionForeachAST::
reader_mIndexIdentifier (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_lstring   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachAST *) mPointer)->mIndexIdentifier ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionForeachAST::
reader_mBetweenInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachAST *) mPointer)->mBetweenInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionForeachAST::
reader_mAfterInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionForeachAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionForeachAST *) mPointer)->mAfterInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionForeachAST::actualTypeName (void) const {
  return "templateInstructionForeachAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionForeachAST ("templateInstructionForeachAST", gClassInfoFor__templateInstructionAST, & kTypeDescriptor_GGS_templateInstructionForeachAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionForeachAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionForeachAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionForeachAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionForeachAST GGS_templateInstructionForeachAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionForeachAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionForeachAST * p = dynamic_cast <const GGS_templateInstructionForeachAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionForeachAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionForeachAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionForeachAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//          Element of list '@templateInstructionIfBranchListAST'            *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionIfBranchListAST::
elementOf_GGS_templateInstructionIfBranchListAST (const GGS_templateExpressionAST & argument_0,
                                const GGS_templateInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mExpression (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionIfBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionIfBranchListAST * ptr = dynamic_cast <const elementOf_GGS_templateInstructionIfBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mExpression.operator_isEqual (ptr->mExpression).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionIfBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mExpression.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                List '@templateInstructionIfBranchListAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionIfBranchListAST ("templateInstructionIfBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
internalAppendValues (const GGS_templateExpressionAST & argument_0,
                    const GGS_templateInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
internalPrependValues (const GGS_templateExpressionAST & argument_0,
                    const GGS_templateInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
addAssign_operation (const GGS_templateExpressionAST & argument_0,
                                const GGS_templateInstructionListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListAST GGS_templateInstructionIfBranchListAST::
operator_concat (const GGS_templateInstructionIfBranchListAST & inOperand) const {
  GGS_templateInstructionIfBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
dotAssign_operation (const GGS_templateInstructionIfBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateInstructionIfBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_templateExpressionAST  p_0 = p->mExpression ;
          GGS_templateInstructionListAST  p_1 = p->mInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_templateExpressionAST & argument_0,
                     const GGS_templateInstructionListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mExpression,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListAST  GGS_templateInstructionIfBranchListAST::
constructor_emptyList (void) {
  GGS_templateInstructionIfBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListAST  GGS_templateInstructionIfBranchListAST::
constructor_listWithValue (const GGS_templateExpressionAST & argument_0,
                                const GGS_templateInstructionListAST & argument_1) {
  GGS_templateInstructionIfBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
internalSubListWithRange (GGS_templateInstructionIfBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mExpression, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListAST GGS_templateInstructionIfBranchListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionIfBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListAST GGS_templateInstructionIfBranchListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionIfBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionIfBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateInstructionIfBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
method_first (C_CompilerEx & inLexique,
              GGS_templateExpressionAST & _out_0,
              GGS_templateInstructionListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
method_last (C_CompilerEx & inLexique,
             GGS_templateExpressionAST & _out_0,
             GGS_templateInstructionListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_templateExpressionAST & _out_0,
                 GGS_templateInstructionListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_templateExpressionAST & _out_0,
                GGS_templateInstructionListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mExpression ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateInstructionIfBranchListAST::
reader_mExpressionAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateExpressionAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mExpression ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionIfBranchListAST::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
modifier_setMExpressionAtIndex (C_CompilerEx & inLexique,
                              const GGS_templateExpressionAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mExpression = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionIfBranchListAST::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_templateInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateExpressionAST  & GGS_templateInstructionIfBranchListAST::cEnumerator::_mExpression (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mExpression ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstructionListAST  & GGS_templateInstructionIfBranchListAST::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionIfBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionIfBranchListAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionIfBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListAST GGS_templateInstructionIfBranchListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionIfBranchListAST * p = dynamic_cast <const GGS_templateInstructionIfBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionIfBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionIfBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionIfBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                  class 'cPtr_templateInstructionIfAST'                    *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionIfAST::
cPtr_templateInstructionIfAST (const GGS_templateInstructionIfBranchListAST & argument_0,
                                const GGS_templateInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionAST (THERE),
mTemplateInstructionIfBranchList (argument_0),
mElseInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionIfAST * GGS_templateInstructionIfAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionIfAST) ;
    return (cPtr_templateInstructionIfAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionIfAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionIfAST * ptr = dynamic_cast <const cPtr_templateInstructionIfAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mTemplateInstructionIfBranchList.operator_isEqual (ptr->mTemplateInstructionIfBranchList).boolValue ()
         && mElseInstructionList.operator_isEqual (ptr->mElseInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionIfAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionIfAST:"
           << mTemplateInstructionIfBranchList.reader_description (inIndentation + 1)
           << mElseInstructionList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionIfAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionIfAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionIfAST (& typeid (cPtr_templateInstructionIfAST), & typeid (cPtr_templateInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionIfAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionIfAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionIfAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionIfAST (mTemplateInstructionIfBranchList, mElseInstructionList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//               GALGAS class 'GGS_templateInstructionIfAST'                 *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionIfAST ("templateInstructionIfAST", true, & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionIfAST::
GGS_templateInstructionIfAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfAST::
GGS_templateInstructionIfAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionIfAST GGS_templateInstructionIfAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionIfAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionIfAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionIfAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionIfAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfAST GGS_templateInstructionIfAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_templateInstructionIfBranchListAST & argument_0,
                 const GGS_templateInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfAST result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionIfAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfBranchListAST  GGS_templateInstructionIfAST::
reader_mTemplateInstructionIfBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionIfBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionIfAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionIfAST *) mPointer)->mTemplateInstructionIfBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionIfAST::
reader_mElseInstructionList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionIfAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionIfAST *) mPointer)->mElseInstructionList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionIfAST::actualTypeName (void) const {
  return "templateInstructionIfAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionIfAST ("templateInstructionIfAST", gClassInfoFor__templateInstructionAST, & kTypeDescriptor_GGS_templateInstructionIfAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionIfAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionIfAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionIfAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionIfAST GGS_templateInstructionIfAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionIfAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionIfAST * p = dynamic_cast <const GGS_templateInstructionIfAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionIfAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionIfAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionIfAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//        Element of list '@templateInstructionSwitchBranchListAST'          *
//                                                                           *
//---------------------------------------------------------------------------*

elementOf_GGS_templateInstructionSwitchBranchListAST::
elementOf_GGS_templateInstructionSwitchBranchListAST (const GGS_lstringlist & argument_0,
                                const GGS_templateInstructionListAST & argument_1
                                COMMA_LOCATION_ARGS) :
AC_GGS_list::cListElement (THERE),
mConstantList (argument_0),
mInstructionList (argument_1) {
}

//---------------------------------------------------------------------------*

bool elementOf_GGS_templateInstructionSwitchBranchListAST::
isEqualToObject (const cListElement * inOperand) const {
  bool equal = inOperand == this ;
  if (! equal) {
    const elementOf_GGS_templateInstructionSwitchBranchListAST * ptr = dynamic_cast <const elementOf_GGS_templateInstructionSwitchBranchListAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mConstantList.operator_isEqual (ptr->mConstantList).boolValue ()
         && mInstructionList.operator_isEqual (ptr->mInstructionList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void elementOf_GGS_templateInstructionSwitchBranchListAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mConstantList.reader_description (inIndentation) ;
  ioString << "\n" ;
  ioString.writeStringMultiple ("| ", inIndentation) ;
  ioString << "|-" ;
  ioString << mInstructionList.reader_description (inIndentation) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//              List '@templateInstructionSwitchBranchListAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionSwitchBranchListAST ("templateInstructionSwitchBranchListAST", false, NULL) ;

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
internalAppendValues (const GGS_lstringlist & argument_0,
                    const GGS_templateInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalAppendItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
internalPrependValues (const GGS_lstringlist & argument_0,
                    const GGS_templateInstructionListAST & argument_1
                    COMMA_LOCATION_ARGS) {
  cElement * newElement = (cElement *) NULL ;
  macroMyNew (newElement, cElement (argument_0,
                                argument_1
                                COMMA_THERE)) ;
  internalPrependItem (newElement) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
addAssign_operation (const GGS_lstringlist & argument_0,
                                const GGS_templateInstructionListAST & argument_1) {
  if (isBuilt ()&& argument_0.isBuilt ()&& argument_1.isBuilt ()) {
    insulateList () ;
    internalAppendValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListAST GGS_templateInstructionSwitchBranchListAST::
operator_concat (const GGS_templateInstructionSwitchBranchListAST & inOperand) const {
  GGS_templateInstructionSwitchBranchListAST result = * this ;
  result.dotAssign_operation (inOperand) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
dotAssign_operation (const GGS_templateInstructionSwitchBranchListAST inOperand) {
  if (isBuilt () && inOperand.isBuilt ()) {
    if (count () == 0) {
      * this = inOperand ;
    }else{
      if (inOperand.count () > 0) {
        insulateList () ;
        elementOf_GGS_templateInstructionSwitchBranchListAST * p = inOperand.firstObject () ;
        while (p != NULL) {
          macroValidPointer (p) ;
          GGS_lstringlist  p_0 = p->mConstantList ;
          GGS_templateInstructionListAST  p_1 = p->mInstructionList ;
          internalAppendValues (p_0, p_1 COMMA_HERE) ;
          p = p->nextObject () ;
        }
      }
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
modifier_prependValue (C_CompilerEx & /* inLexique */,
                     const GGS_lstringlist & argument_0,
                     const GGS_templateInstructionListAST & argument_1
                     COMMA_UNUSED_LOCATION_ARGS) {
  if (isBuilt ()) {
    insulateList () ;
    internalPrependValues (argument_0,
                                argument_1
                                COMMA_HERE) ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
insulateList (void) {
  if (isShared ()) {
    cElement * ptr = firstObject () ;
    alloc () ;
    while (ptr != NULL) {
      macroValidPointer (ptr) ;
      internalAppendValues (ptr->mConstantList,
                                ptr->mInstructionList
                                COMMA_HERE) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListAST  GGS_templateInstructionSwitchBranchListAST::
constructor_emptyList (void) {
  GGS_templateInstructionSwitchBranchListAST result ;
  result.alloc () ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListAST  GGS_templateInstructionSwitchBranchListAST::
constructor_listWithValue (const GGS_lstringlist & argument_0,
                                const GGS_templateInstructionListAST & argument_1) {
  GGS_templateInstructionSwitchBranchListAST result ;
  result.alloc () ;
  result.addAssign_operation (argument_0, argument_1) ;
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
internalSubListWithRange (GGS_templateInstructionSwitchBranchListAST & ioList,
                          const PMSInt32 inFirstIndex,
                          const PMSInt32 inCount) const {
  ioList.alloc () ;
  if (inCount > 0) {
    cElement * ptr = firstObject () ;
    for (PMSInt32 i=0 ; i<inFirstIndex ; i++) {
      macroValidPointer (ptr) ;
      ptr = ptr->nextObject () ;
    }
    for (PMSInt32 i=0 ; i<inCount ; i++) {
      macroValidPointer (ptr) ;
      ioList.addAssign_operation (ptr->mConstantList, ptr->mInstructionList) ;
      ptr = ptr->nextObject () ;
    }
  }
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListAST GGS_templateInstructionSwitchBranchListAST::
reader_subListWithRange (C_CompilerEx & inLexique,
                         const GGS_uint & inFirstIndex,
                         const GGS_uint & inCount
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionSwitchBranchListAST result ;
  if (isBuilt () && inFirstIndex.isBuilt () && inCount.isBuilt ()) {
    const PMSInt32 firstIndex = (PMSInt32) inFirstIndex.uintValue () ;
    const PMSInt32 rangeCount = (PMSInt32) inCount.uintValue () ;
    if ((firstIndex + rangeCount) > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListWithRange' method invoked with upper bound greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, firstIndex, rangeCount) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListAST GGS_templateInstructionSwitchBranchListAST::
reader_subListFromIndex (C_CompilerEx & inLexique,
                         const GGS_uint & inIndex
                         COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionSwitchBranchListAST result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    const PMSInt32 startIndex = (PMSInt32) inIndex.uintValue () ;
    if (startIndex > count ()) {
      inLexique.onTheFlyRunTimeError ("'subListFromIndex' method invoked with start index greater than list object count" COMMA_THERE) ;
    }else{
      internalSubListWithRange (result, startIndex, count () - startIndex) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_string GGS_templateInstructionSwitchBranchListAST::
reader_description (const PMSInt32 inIndentation) const {
  return performDescription ("@templateInstructionSwitchBranchListAST", inIndentation) ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
method_first (C_CompilerEx & inLexique,
              GGS_lstringlist & _out_0,
              GGS_templateInstructionListAST & _out_1
              COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'first' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantList ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
method_last (C_CompilerEx & inLexique,
             GGS_lstringlist & _out_0,
             GGS_templateInstructionListAST & _out_1
             COMMA_LOCATION_ARGS) const {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'last' method invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantList ;
    _out_1 = ptr->mInstructionList ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
modifier_popFirst (C_CompilerEx & inLexique,
                 GGS_lstringlist & _out_0,
                 GGS_templateInstructionListAST & _out_1
                 COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = firstObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popFirst' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantList ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveFirst () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
modifier_popLast (C_CompilerEx & inLexique,
                GGS_lstringlist & _out_0,
                GGS_templateInstructionListAST & _out_1
                COMMA_LOCATION_ARGS) {
  cElement * ptr = NULL ;
  if (isBuilt ()) {
    ptr = lastObject () ;
    if (ptr == NULL) {
      inLexique.onTheFlyRunTimeError ("'popLast' modifier invoked on an empty list" COMMA_THERE) ;
    }
  }
  if (ptr != NULL) {
    _out_0 = ptr->mConstantList ;
    _out_1 = ptr->mInstructionList ;
    insulateList () ;
    internalRemoveLast () ;
  }else{
    _out_0.drop () ;
    _out_1.drop () ;
  }
}

//---------------------------------------------------------------------------*

GGS_lstringlist  GGS_templateInstructionSwitchBranchListAST::
reader_mConstantListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_lstringlist  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mConstantList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionListAST  GGS_templateInstructionSwitchBranchListAST::
reader_mInstructionListAtIndex (C_CompilerEx & inLexique, const GGS_uint & inIndex COMMA_LOCATION_ARGS) const {
  GGS_templateInstructionListAST  result ;
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      result = object->mInstructionList ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
modifier_setMConstantListAtIndex (C_CompilerEx & inLexique,
                              const GGS_lstringlist  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mConstantList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

void GGS_templateInstructionSwitchBranchListAST::
modifier_setMInstructionListAtIndex (C_CompilerEx & inLexique,
                              const GGS_templateInstructionListAST  & inObject,
                              const GGS_uint & inIndex
                              COMMA_LOCATION_ARGS) const {
  if (isBuilt () && inIndex.isBuilt ()) {
    cElement * object = (cElement *) objectAtIndex (inLexique, inIndex.uintValue () COMMA_THERE) ;
    if (object != NULL) {
      object->mInstructionList = inObject ;
    }
  }
}

//---------------------------------------------------------------------------*

/* const */ GGS_lstringlist  & GGS_templateInstructionSwitchBranchListAST::cEnumerator::_mConstantList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mConstantList ;
}

//---------------------------------------------------------------------------*

/* const */ GGS_templateInstructionListAST  & GGS_templateInstructionSwitchBranchListAST::cEnumerator::_mInstructionList (LOCATION_ARGS) const {
  macroValidPointerThere (mCurrentEnumeratedObject) ;
  return ((/* const */ cElement *) mCurrentEnumeratedObject)->mInstructionList ;
}

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionSwitchBranchListAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionSwitchBranchListAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionSwitchBranchListAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListAST GGS_templateInstructionSwitchBranchListAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionSwitchBranchListAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionSwitchBranchListAST * p = dynamic_cast <const GGS_templateInstructionSwitchBranchListAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionSwitchBranchListAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionSwitchBranchListAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionSwitchBranchListAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                class 'cPtr_templateInstructionSwitchAST'                  *
//                                                                           *
//---------------------------------------------------------------------------*

cPtr_templateInstructionSwitchAST::
cPtr_templateInstructionSwitchAST (const GGS_templateExpressionAST & argument_0,
                                const GGS_templateInstructionSwitchBranchListAST & argument_1
                                COMMA_LOCATION_ARGS)
:cPtr_templateInstructionAST (THERE),
mSwitchExpression (argument_0),
mTemplateInstructionSwitchBranchList (argument_1) {
}

//---------------------------------------------------------------------------*

#ifndef DO_NOT_GENERATE_CHECKINGS
  cPtr_templateInstructionSwitchAST * GGS_templateInstructionSwitchAST::
  operator () (LOCATION_ARGS) const {
    macroValidObjectThere (mPointer, cPtr_templateInstructionSwitchAST) ;
    return (cPtr_templateInstructionSwitchAST *) mPointer ;
  }
#endif

//---------------------------------------------------------------------------*

bool cPtr_templateInstructionSwitchAST::
isEqualToObject (const cPtr__AC_galgas_class * inOperand) const {
  bool equal = typeid (this) == typeid (inOperand) ;
  if (equal) {
    const cPtr_templateInstructionSwitchAST * ptr = dynamic_cast <const cPtr_templateInstructionSwitchAST *> (inOperand) ;
    macroValidPointer (ptr) ;
    equal = mSwitchExpression.operator_isEqual (ptr->mSwitchExpression).boolValue ()
         && mTemplateInstructionSwitchBranchList.operator_isEqual (ptr->mTemplateInstructionSwitchBranchList).boolValue () ;
  }
  return equal ;
}

//---------------------------------------------------------------------------*

void cPtr_templateInstructionSwitchAST::
appendForDescription (C_String & ioString,
                      const PMSInt32 inIndentation) const {
  ioString << "->@templateInstructionSwitchAST:"
           << mSwitchExpression.reader_description (inIndentation + 1)
           << mTemplateInstructionSwitchBranchList.reader_description (inIndentation + 1) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                              Class message                                *
//                                                                           *
//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionSwitchAST::
instanceMessage (void) const {
  return "" ;
}

//---------------------------------------------------------------------------*

const char * cPtr_templateInstructionSwitchAST::
_static_message (void) {
  return "" ;
}

//---------------------------------------------------------------------------*

C_galgas_class_inspector _gInspectorFor_templateInstructionSwitchAST (& typeid (cPtr_templateInstructionSwitchAST), & typeid (cPtr_templateInstructionAST), "") ;

//---------------------------------------------------------------------------*

AC_galgasClassRunTimeInformationEX * cPtr_templateInstructionSwitchAST::galgasRTTI (void) const {
  return & gClassInfoFor__templateInstructionSwitchAST ;
}

//---------------------------------------------------------------------------*

cPtr__AC_galgas_class * cPtr_templateInstructionSwitchAST::makeClone (void) const {
  cPtr__AC_galgas_class * result = NULL ;
  macroMyNew (result, cPtr_templateInstructionSwitchAST (mSwitchExpression, mTemplateInstructionSwitchBranchList COMMA_HERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//             GALGAS class 'GGS_templateInstructionSwitchAST'               *
//                                                                           *
//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX kTypeDescriptor_GGS_templateInstructionSwitchAST ("templateInstructionSwitchAST", true, & kTypeDescriptor_GGS_templateInstructionAST) ;

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchAST::
GGS_templateInstructionSwitchAST (const cPtr__AC_galgas_class * inPointer) {
  macroAssignObject (mPointer, (cPtr__AC_galgas_class *) inPointer) ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchAST::
GGS_templateInstructionSwitchAST (cPtr__AC_galgas_class & inObject) {
  macroAssignObject (mPointer, & inObject) ;
}

//---------------------------------------------------------------------------*

//--- castFrom class method (implements cast expression)
GGS_templateInstructionSwitchAST GGS_templateInstructionSwitchAST::
castFrom (C_CompilerEx & inLexique,
           cPtr__AC_galgas_class * inPointer,
           const bool inUseKindOfClass,
           const GGS_location & inErrorLocation
           COMMA_LOCATION_ARGS) {
  GGS_templateInstructionSwitchAST result ;
  if (inPointer != NULL) {
    macroValidPointer (inPointer) ;
    const bool ok = inUseKindOfClass
      ? (dynamic_cast <cPtr_templateInstructionSwitchAST *> (inPointer) != NULL)
      : (typeid (cPtr_templateInstructionSwitchAST) == typeid (*inPointer)) ;
    if (ok) {
      result = GGS_templateInstructionSwitchAST (inPointer) ;
    }else{
      inErrorLocation.signalCastError (inLexique,
                                       & typeid (cPtr_templateInstructionSwitchAST),
                                       inUseKindOfClass,
                                       inPointer->instanceMessage ()
                                       COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchAST GGS_templateInstructionSwitchAST::
constructor_new (C_CompilerEx & /* inLexique */,
                 const GGS_templateExpressionAST & argument_0,
                 const GGS_templateInstructionSwitchBranchListAST & argument_1
                                COMMA_LOCATION_ARGS) {
  GGS_templateInstructionSwitchAST result ;
  macroMyNew (result.mPointer, cPtr_templateInstructionSwitchAST (argument_0,
                                argument_1 COMMA_THERE)) ;
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateExpressionAST  GGS_templateInstructionSwitchAST::
reader_mSwitchExpression (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateExpressionAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionSwitchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionSwitchAST *) mPointer)->mSwitchExpression ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchBranchListAST  GGS_templateInstructionSwitchAST::
reader_mTemplateInstructionSwitchBranchList (C_CompilerEx & /* inLexique */ COMMA_UNUSED_LOCATION_ARGS) const {
  GGS_templateInstructionSwitchBranchListAST   result ;
  if (mPointer != NULL) {
    macroValidPointer (mPointer) ;
    MF_Assert (dynamic_cast <cPtr_templateInstructionSwitchAST *> (mPointer) != NULL,
               "dynamic cast error", 0, 0) ;
    result = ((cPtr_templateInstructionSwitchAST *) mPointer)->mTemplateInstructionSwitchBranchList ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

const char * GGS_templateInstructionSwitchAST::actualTypeName (void) const {
  return "templateInstructionSwitchAST" ;
}

//---------------------------------------------------------------------------*

C_galgasClassRunTimeInformationEX gClassInfoFor__templateInstructionSwitchAST ("templateInstructionSwitchAST", gClassInfoFor__templateInstructionAST, & kTypeDescriptor_GGS_templateInstructionSwitchAST) ;

//---------------------------------------------------------------------------*

GGS_object GGS_templateInstructionSwitchAST::reader_object (void) const {
  GGS_object result ;
  if (isBuilt ()) {
    GGS_templateInstructionSwitchAST * p = NULL ;
    macroMyNew (p, GGS_templateInstructionSwitchAST (*this)) ;
    result = GGS_object (p) ;
  }
  return result ;
}

//---------------------------------------------------------------------------*

GGS_templateInstructionSwitchAST GGS_templateInstructionSwitchAST::castFromObject (C_CompilerEx & inLexique,
                                   const GGS_object & inObject,
                                   const GGS_location & inErrorLocation
                                   COMMA_LOCATION_ARGS) {
  GGS_templateInstructionSwitchAST result ;
  const GGS__root * embeddedObject = inObject.embeddedObject () ;
  if (NULL != embeddedObject) {
    const GGS_templateInstructionSwitchAST * p = dynamic_cast <const GGS_templateInstructionSwitchAST *> (embeddedObject) ;
    if (NULL != p) {
      result = * p ;
    }else{
      castFromObjectErrorSignaling (inLexique, inErrorLocation, & kTypeDescriptor_GGS_templateInstructionSwitchAST, embeddedObject COMMA_THERE) ;
    }
  }
  return result ;
}

//---------------------------------------------------------------------------*

const C_galgas_type_descriptorEX * GGS_templateInstructionSwitchAST::typeDescriptor (void) const {
  return & kTypeDescriptor_GGS_templateInstructionSwitchAST ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                      Prologue and epilogue actions                        *
//                                                                           *
//---------------------------------------------------------------------------*

static void epilogueRoutineFor_templateTypesForAST (void) {
  macroReleaseObject (gSingleton_templateInstructionGetColumnLocationAST) ;
  macroReleaseObject (gSingleton_templateInstructionGotoColumnLocationAST) ;
}

//---------------------------------------------------------------------------*

C_PrologueEpilogue prologueEpilogueObjectFor_templateTypesForAST (NULL, epilogueRoutineFor_templateTypesForAST) ;

//---------------------------------------------------------------------------*

