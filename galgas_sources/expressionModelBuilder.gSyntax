#---------------------------------------------------------------------------*
#                                                                           *
#  'expression' component parser, as model builder                          *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax expressionModelBuilder :
import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import semantics commonSemantics in "commonSemantics.gSemantics" ;
import semantics expressionMetamodel in "expressionMetamodel.gSemantics" ;
import semantics parameterArgumentMetamodel in "parameterArgumentMetamodel.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression> !@semanticExpression outExpression ;

nonterminal <concatenation_term> !@semanticExpression outExpression ;

nonterminal <relation_term> !@semanticExpression outExpression ;

nonterminal <relation_factor> !@semanticExpression outExpression ;

nonterminal <simple_expression> !@semanticExpression outExpression ;

nonterminal <term> !@semanticExpression outExpression ;

nonterminal <factor> !@semanticExpression outExpression ;

nonterminal <output_expression_list> !@outExpressionList outExpressionList ;

#------------------------------------------------------------------------------*
#                                                                              *
#   E X P R E S S I O N                                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression> !@semanticExpression outExpression :
  <concatenation_term> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $.$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <concatenation_term> ? rightOperand ;
    outExpression := [@concatExpression new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   C O N C A T E N A T I O N    T E R M                                       *
#                                                                              *
#------------------------------------------------------------------------------*

rule <concatenation_term> !@semanticExpression outExpression :
  <relation_term> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $|$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <relation_term> ? rightOperand ;
    outExpression := [@orExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $^$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <relation_term> ? rightOperand ;
    outExpression := [@xorExpression new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    T E R M                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_term> !@semanticExpression outExpression :
  <relation_factor> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $&$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <relation_factor> ? rightOperand ;
    outExpression := [@andExpression new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    F A C T O R                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_factor> !@semanticExpression outExpression :
  <simple_expression> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $==$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@equalExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $!=$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@notEqualExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $<=$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@lowerOrEqualExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $>=$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@greaterOrEqualExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $>$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@strictGreaterExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $<$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@strictLowerExpression new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   S I M P L E    E X P R E S S I O N                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <simple_expression> !@semanticExpression outExpression :
  <term> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $<<$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <term> ? rightOperand ;
    outExpression := [@leftShiftExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $>>$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <term> ? rightOperand ;
    outExpression := [@rightShiftExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $+$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <term> ? rightOperand ;
    outExpression := [@addExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $-$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <term> ? rightOperand ;
    outExpression := [@subExpression new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   T E R M                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <term> !@semanticExpression outExpression :
  <factor> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $*$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <factor> ? rightOperand ;
    outExpression := [@multiplicationExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $/$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <factor> ? rightOperand ;
    outExpression := [@divisionExpression new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $mod$ ;
    @semanticExpression leftOperand := outExpression ;
    @semanticExpression rightOperand ;
    <factor> ? rightOperand ;
    outExpression := [@moduloExpression new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    - factor                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @location operatorLocation := here ;
  $-$ ;
  <factor> ? outExpression ;
  outExpression := [@unaryMinusExpression new !operatorLocation !outExpression] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    <var>                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @lstring identifier ;
  $identifier$ ? identifier ;
  outExpression := [@varInExpression new !identifier] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    S E L F                                                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  $self$ ;
  outExpression := [@selfInExpression new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ( EXPRESSION )                                         *
#                       (cast EXP if >= @T else error ERROR_LOCATION_EXP)      *
#                       (cast EXP if == @T else error ERROR_LOCATION_EXP)      *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  $($ ;
  select
    <expression> ? outExpression ;
  or
    $cast$ ;
    @semanticExpression receiverExpression ;
    <expression> ? receiverExpression ;
    $if$ ;
    @bool useKindOfClass ;
    select
      $>=$ ;
      useKindOfClass := true ;
    or
      $==$ ;
      useKindOfClass := false ;
    end select ;
    @lstring typeName ;
    $type_name$ ? typeName ;
    $else$ ;
    $error$ ;
    @semanticExpression errorLocationExpression ;
    <expression> ? errorLocationExpression ;
    outExpression := [@castInExpression new
      !receiverExpression
      !useKindOfClass
      !typeName
      !errorLocationExpression
    ] ;
  end select ;
  $)$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    not FACTOR                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @location operatorLocation := here ;
  $not$ ;
  <factor> ? outExpression ;
  outExpression := [@notExpression new !operatorLocation !outExpression] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ~ FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @location operatorLocation := here ;
  $~$ ;
  <factor> ? outExpression ;
  outExpression := [@negateExpression new !operatorLocation !outExpression] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    true                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  $true$ ;
  outExpression := [@trueExpression new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    false                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  $false$ ;
  outExpression := [@falseExpression new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :   literal string sequence "..."  "..."  "..."             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @stringlist literalStringList [emptyList] ;
  repeat
    @lstring literalString ;
    $literal_string$ ?literalString ;
    literalStringList += ![literalString string] ;
  while
  end repeat ;
  outExpression := [@literalStringExpression new !literalStringList] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 32-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @luint literalInt ;
  $unsigned_literal_integer$ ?literalInt ;
  outExpression := [@literalUIntExpression new !literalInt] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 32-bit signed literal integer value                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @lsint literalInt ;
  $signed_literal_integer$ ?literalInt ;
  outExpression := [@literalSIntExpression new !literalInt] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @luint64 literalInt ;
  $unsigned_literal_integer64$ ?literalInt ;
  outExpression := [@literalUInt64Expression new !literalInt] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit signed literal integer value                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @lsint64 literalInt ;
  $signed_literal_integer64$ ?literalInt ;
  outExpression := [@literalSInt64Expression new !literalInt] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a literal character value                              *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @lchar literalChar ;
  $literal_char$ ?literalChar ;
  outExpression := [@literalCharExpression new !literalChar] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a double value                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  @ldouble literalDouble ;
  $literal_double$ ? literalDouble ?* ;
  outExpression := [@literalDoubleExpression new !literalDouble] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    here                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  $here$ ;
  outExpression := [@hereExpression new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   description         :   [expression description]                           *
#   reader call         :   [expression reader !... ]                          *
#   constructor call    :   [@class method !... ]                              *
#   option value        :   [option option_component_name.option_name]         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpression outExpression :
  $[$ ;
  select
  #--- Get source identity characteristics
    @semanticExpression receiverExpression ;
    <expression> ? receiverExpression ;
    select
      $description$ ;
      outExpression := [@descriptionInExpression new !receiverExpression !here] ;
    or
    #--- Get reader name
      @lstring readerName ;
      $identifier$ ? readerName ;
    #--- Actual parameters
      @outExpressionList expressionList ;
      <output_expression_list> ? expressionList ;
      outExpression := [@readerCallExpression new !receiverExpression !readerName !expressionList] ;
    end select ;
  or
  #--- Class name
    @lstring className ;
    $type_name$ ?className ;
  #--- Constructor name
    @lstring constructorName ;
    $identifier$ ? constructorName ;
  #--- Actual arguments
    @outExpressionList expressionList ;
    <output_expression_list> ? expressionList ;
    outExpression := [@constructorExpression new
      !className
      !constructorName
      !expressionList
    ] ;
  or
    $option$ ;
    select
      $.$ ;
      @lstring optionName ;
      $identifier$ ?optionName ;
      outExpression := [@optionExpression new ![@lstring new !"generic_galgas_cli_options" !here] !optionName] ;
    or
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      $.$ ;
      @lstring optionName ;
      $identifier$ ?optionName ;
      outExpression := [@optionExpression new !optionComponentName !optionName] ;
    end select ;
  or
    $filewrapper$ ;
    @lstring filewrapperName ;
    $identifier$ ? filewrapperName ;
    $.$ ;
    select
      @lstring filePath ;
      $literal_string$ ? filePath ;
      outExpression := [@filewrapperInExpression new
        !filewrapperName
        !filePath
      ] ;
    or
      @lstring filewrapperTemplateName ;
      $identifier$ ? filewrapperTemplateName ;
      @outExpressionList expressionList ;
      <output_expression_list> ? expressionList ;
      outExpression := [@filewrapperTemplateInExpression new
        !filewrapperName
        !filewrapperTemplateName
        !expressionList
      ] ;
    end select ;
  end select ;
  $]$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   O U T P U T    E X P R E S S I O N    L I S T                              *
#                                                                              *
#------------------------------------------------------------------------------*

rule <output_expression_list>  !@outExpressionList outExpressionList:
  @semanticExpressionList expressionList [emptyList] ;
  repeat
  while
    $!$ ;
    @semanticExpression expression ;
    <expression> ? expression ;
    expressionList += !expression ;
  end repeat ;
  outExpressionList := [@outExpressionList new
    !expressionList
    !here
  ] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
