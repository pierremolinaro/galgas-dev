#---------------------------------------------------------------------------*
#                                                                           *
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax galgas3LexiqueComponentSyntax ("galgas_scanner.gLexique") :

import "semanticsTypesForAST.gSemantics" ;

#---------------------------------------------------------------------------*

rule <declaration>
 ?!@semanticDeclarationListAST ioDeclarations
:
  @bool isTemplate ;
  select
    isTemplate := true ;
    $template$ ;
  or
    isTemplate := false ;
  end select ;
  $lexique$ ;
#--- Lexique Component Name
  $identifier$ ??@lstring lexiqueComponentName ;
#--- Enable indexing ?
  @lstring indexingDirectory ;
  select
    indexingDirectory := ["" nowhere] ;
  or
    $indexing$ ;
    $in$ ;
    $literal_string$ ? indexingDirectory ;
  end select ;
  $:$ ;
#--- Parse lexique body
  @metamodelTemplateDelimitorListAST templateDelimitorList [emptyList] ;
  @templateReplacementListAST templateReplacementList [emptyList] ;
  @lexicalAttributeListAST lexicalAttributeList [emptyList] ;
  @lexicalStyleListAST lexicalStyleList [emptyList] ;
  @terminalDeclarationListAST terminalDeclarationList [emptyList] ;
  @lexicalMessageDeclarationListAST lexicalMessageDeclarationList [emptyList] ;
  @lexicalListDeclarationListAST lexicalListDeclarationList [emptyList] ;
  @lexicalRuleListAST lexicalRuleList [emptyList] ;
  @externRoutineListAST externRoutineList [emptyList] ;
  @externFunctionListAST externFunctionList [emptyList] ;
  @indexingListAST indexingListAST [emptyList] ;
  repeat
  while 
    <extern_routine_or_function_declaration> !? externRoutineList !? externFunctionList ;
  while 
    <template_delimitor> !? templateDelimitorList ;
  while 
    <template_replacement> !? templateReplacementList ;
  while 
    <lexical_attribute_declaration> !? lexicalAttributeList ;
  while 
    <style_declaration> !? lexicalStyleList ;
  while 
    <terminal_declaration> !? terminalDeclarationList ;
  while 
    <lexical_list_declaration> !? lexicalListDeclarationList ;
  while
    $rule$ ;
    select
      <lexical_explicit_rule> !? lexicalRuleList ;
    or
      <lexical_implicit_rule> !? lexicalRuleList ;
    end select ;
    $;$ ;
  while
    <lexical_message_declaration> !? lexicalMessageDeclarationList ;
  while
    $indexing$ ;
    $identifier$ ?@lstring indexName indexing indexingNameDefinition ;
    $:$ ;
    $literal_string$ ?@lstring indexComment ;
    indexingListAST += !indexName !indexComment ;
    $;$ ;
  end repeat ;
  $end$ ;
  ioDeclarations += ![@galgas3LexiqueComponentAST new
    !true
    !lexiqueComponentName
    !isTemplate
    !templateDelimitorList
    !templateReplacementList
    !lexicalAttributeList
    !lexicalStyleList
    !terminalDeclarationList
    !lexicalMessageDeclarationList
    !lexicalListDeclarationList
    !lexicalRuleList
    !externRoutineList
    !externFunctionList
    !indexingListAST
    !indexingDirectory
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_delimitor> ?!@metamodelTemplateDelimitorListAST ioTemplateDelimitorList :
  $template$ ;
  $literal_string$ ??@lstring startString ;
  @lstringlist optionList [emptyList] ;
  select
  or
    $feature$ ;
    repeat
      $identifier$ ? @lstring optionName ;
      optionList += !optionName ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $...$ ;
  $literal_string$ ??@lstring endString ;
  $;$ ;
  ioTemplateDelimitorList += !startString !optionList !endString ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_replacement> ?!@templateReplacementListAST ioTemplateReplacement :
  $replace$ ;
  $literal_string$ ?@lstring matchString ;
  @lstring replacementString ;
  @lstring replacementFunction ;
  select
    $...$ ;
    $literal_string$ ?replacementString ;
    $:$ ;
    $identifier$ ?replacementFunction ;
  or
    $->$ ;
    $literal_string$ ?replacementString ;
    replacementFunction := [@lstring new !"" !here] ;
  end select ;
  $;$ ;
  ioTemplateReplacement += !matchString !replacementString !replacementFunction ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_message_declaration>
  ?!@lexicalMessageDeclarationListAST ioLexicalMessageDeclarationList
:
  $message$ ;
  $identifier$ ??@lstring messageName ;
  $:$ ;
  $literal_string$ ??@lstring messageValue ;
  $;$ ;
  ioLexicalMessageDeclarationList += !messageName !messageValue ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_implicit_rule> ?!@lexicalRuleListAST ioLexicalImplicitRuleList :
  $list$ ;
  $identifier$ ??@lstring listName ;
  ioLexicalImplicitRuleList += ![@lexicalImplicitRuleAST new !listName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_explicit_rule> ?!@lexicalRuleListAST ioLexicalExplicitRuleList :
  <lexical_expression> ??@lexicalExpressionAST lexicalRuleExpression ;
  $:$ ;
  @lexicalInstructionListAST instructionList [emptyList] ;
  repeat
  while
    <lexical_instruction> !?instructionList ;
  end repeat ;
  $end$ ;
  $rule$ ;
  ioLexicalExplicitRuleList += ![@lexicalExplicitRuleAST new !lexicalRuleExpression !instructionList] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $send$ ;
  <lexical_send_instruction> ??@lexicalInstructionAST instruction ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_send_instruction> !@lexicalInstructionAST outInstruction :
  $terminal$ ??@lstring sentTerminal ;
  outInstruction := [@lexicalSimpleSendInstructionAST new !sentTerminal] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_send_instruction> !@lexicalInstructionAST outInstruction :
  @lexicalSendSearchListAST lexicalSendSearchList [emptyList] ;
  $search$ ;
  repeat
    $identifier$ ??@lstring attributeName ;
    $in$ ;
    $identifier$ ??@lstring searchListName ;
    lexicalSendSearchList += !attributeName !searchListName ;
    $default$ ;
  while
    $search$ ;
  end repeat ;
  @lexicalSendDefaultActionAST lexicalSendDefaultAction ;
  select
    $terminal$ ??@lstring defaultSentTerminal ;
    lexicalSendDefaultAction := [@lexicalSendTerminalByDefaultAST new !defaultSentTerminal] ;
  or
    $error$ ;
    $identifier$ ??@lstring defaultErrorMessageName ;
    lexicalSendDefaultAction := [@lexicalErrorByDefaultAST new !defaultErrorMessageName] ;
  end select ;
  outInstruction := [@lexicalStructuredSendInstructionAST new
    !lexicalSendSearchList
    !lexicalSendDefaultAction
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $repeat$ ;
  @lexicalInstructionListAST repeatedInstructionList [emptyList] ;
  repeat
  while
    <lexical_instruction> !?repeatedInstructionList ;
  end repeat ;
  @lexicalWhileBranchListAST lexicalWhileBranchList [emptyList] ;
  repeat
    <repeat_while_branch> !?lexicalWhileBranchList ;
  while
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  @lexicalInstructionAST i := [@lexicalRepeatInstructionAST new
    !repeatedInstructionList
    !lexicalWhileBranchList
  ] ;
  ioInstructionList += !i ;
end rule ;

#---------------------------------------------------------------------------*

rule <repeat_while_branch> ?!@lexicalWhileBranchListAST ioLexicalWhileBranchList :
  $while$ ;
  @lexicalExpressionAST whileExpression ;
  <lexical_expression> ?whileExpression ;
  $:$ ;
  @lexicalInstructionListAST whileInstructionList [emptyList] ;
  repeat
  while
    <lexical_instruction> !?whileInstructionList ;
  end repeat ;
  ioLexicalWhileBranchList += !whileExpression !whileInstructionList ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $select$ ;
  @lexicalSelectBranchListAST lexicalWhileBranchList [emptyList] ;
  repeat
    @lexicalExpressionAST selectExpression ;
    $when$ ;
    <lexical_expression> ?selectExpression ;
    $:$ ;
    @lexicalInstructionListAST selectInstructionList [emptyList] ;
    repeat
    while
      <lexical_instruction> !?selectInstructionList ;
    end repeat ;
    lexicalWhileBranchList += !selectExpression !selectInstructionList ;
  while
  end repeat ;
  $default$ ;
  @lexicalInstructionListAST defaultInstructionList [emptyList] ;
  repeat
  while
    <lexical_instruction> !?defaultInstructionList ;
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  @lexicalInstructionAST i := [@lexicalSelectInstructionAST new
    !lexicalWhileBranchList
    !defaultInstructionList
  ] ;
  ioInstructionList += !i ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  @lstring actionName ;
  $identifier$ ? actionName ;
  @lexicalRoutineCallActualArgumentListAST actualArgumentList [emptyList] ;
  repeat
  while
    $!$ ;
    @location passingModeLocation := here ;
    @lexicalRoutineOrFunctionFormalInputArgumentAST arg ;
    <lexical_output_effective_argument> ?arg ;
    actualArgumentList += ![@lexicalFormalInputArgumentAST new !passingModeLocation !arg] ;
  while
    $!?$ ;
    @location passingModeLocation := here ;
    $identifier$ ?@lstring attributeName ;
    @lexicalAttributeInputOutputArgumentAST arg [new !passingModeLocation !attributeName] ;
    actualArgumentList += !arg ;
  end repeat ;
  @lstringlist errorMessageList := [@lstringlist emptyList] ;
  select
  or
    $error$ ;
    repeat
      @lstring errorMessageName ;
      $identifier$ ? errorMessageName ;
      errorMessageList += !errorMessageName ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $;$ ;
  @lexicalInstructionAST i := [@lexicalRoutineInstructionAST new
    !actionName
    !actualArgumentList
    !errorMessageList
  ] ;
  ioInstructionList += !i ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_output_effective_argument>
  !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument
:
  $literal_char$ ?@lchar character ;
  outEffectiveArgument := [@lexicalCharacterInputArgumentAST new !character] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_output_effective_argument>
  !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument
:
  $unsigned_literal_integer$ ?@luint unsignedValue ;
  outEffectiveArgument := [@lexicalUnsignedInputArgumentAST new !unsignedValue] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_output_effective_argument>
  !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument
:
  @location currentLocation := here ;
  $*$ ;
  outEffectiveArgument := [@lexicalCurrentCharacterInputArgumentAST new !currentLocation] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_output_effective_argument>
  !@lexicalRoutineOrFunctionFormalInputArgumentAST outEffectiveArgument
:
  $identifier$ ?@lstring idf ;
  <function_call_or_attribute> !idf ?outEffectiveArgument ;
end rule ;

#---------------------------------------------------------------------------*

rule <function_call_or_attribute> ??@lstring inIdf !@lexicalRoutineOrFunctionFormalInputArgumentAST outArgument :
  outArgument := [@lexicalAttributeInputArgumentAST new !inIdf] ;
end rule ;

#---------------------------------------------------------------------------*

rule <function_call_or_attribute> ??@lstring inIdf !@lexicalRoutineOrFunctionFormalInputArgumentAST outArgument :
  $($ ;
  @lexicalFunctionCallActualArgumentListAST functionActualArgumentList [emptyList] ;
  repeat
  while
    $!$ ;
    @lexicalRoutineOrFunctionFormalInputArgumentAST arg ;
    <lexical_output_effective_argument> ?arg ;
    functionActualArgumentList += !arg ;
  end repeat ;
  $)$ ;
  outArgument := [@lexicalFunctionInputArgumentAST new !inIdf !functionActualArgumentList] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $error$ ;
  @lstring errorMessageName ;
  $identifier$ ? errorMessageName ;
  $;$ ;
  ioInstructionList += ![@lexicalErrorInstructionAST new !errorMessageName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $warning$ ;
  $identifier$ ? @lstring warningMessageName ;
  $;$ ;
  ioInstructionList += ![@lexicalWarningInstructionAST new !warningMessageName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $drop$ ;
  @lstring terminalName ;
  $terminal$ ? terminalName ;
  $;$ ;
  ioInstructionList += ![@lexicalDropInstructionAST new !terminalName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $tag$ ;
  @lstring tagName ;
  $identifier$ ? tagName ;
  $;$ ;
  ioInstructionList += ![@lexicalTagInstructionAST new !tagName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $rewind$ ;
  @lstring tagName ;
  $identifier$ ? tagName ;
  $send$ ;
  @lstring terminalName ;
  $terminal$ ? terminalName ;
  $;$ ;
  ioInstructionList += ![@lexicalRewindInstructionAST new !tagName !terminalName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_instruction> ?!@lexicalInstructionListAST ioInstructionList :
  $log$ ;
  $;$ ;
  ioInstructionList += ![@lexicalLogInstructionAST new] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_expression> !@lexicalExpressionAST outExpression :
  <lexical_term> ?outExpression ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_term> !@lexicalExpressionAST outExpression :
  <lexical_factor> ?outExpression ;
  repeat
  while
    $|$ ;
    @lexicalExpressionAST rightExpression ;
    <lexical_factor> ?rightExpression ;
    outExpression := [@lexicalOrExpressionAST new !outExpression !rightExpression] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_factor>!@lexicalExpressionAST outExpression :
  $literal_string$ ??@lstring string ;
  outExpression := [@lexicalStringMatchAST new !string] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_factor> !@lexicalExpressionAST outExpression :
  $~$ ;
  $literal_string$ ??@lstring string ;
  $error$ ;
  $identifier$ ??@lstring errorMessage ;
  outExpression := [@lexicalStringNotMatchAST new !string !errorMessage] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_factor> !@lexicalExpressionAST outExpression :
  $literal_char$ ??@lchar character ;
  select
    outExpression := [@lexicalCharacterMatchAST new !character] ;
  or
    $->$ ;
    $literal_char$ ??@lchar upperBound ;
    outExpression := [@lexicalCharacterIntervalMatchAST new !character !upperBound] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_factor> !@lexicalExpressionAST outExpression :
  $identifier$ ??@lstring characterSet ;
  outExpression := [@lexicalCharacterSetMatchAST new !characterSet] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_list_declaration> ?!@lexicalListDeclarationListAST ioLexicalListDeclarationList :
  $list$ ;
  $identifier$ ??@lstring name ;
  @lstringlist sentAttributeList [emptyList] ;
  repeat
  while
    $!$ ;
    $identifier$ ??@lstring sentAttribute ;
    sentAttributeList += ! sentAttribute ;
  end repeat ;
  $error$ ;
  $message$ ;
  $literal_string$ ??@lstring errorMessage ;
  @lstring theStyle ; # Empty string if no style
  select
    $style$ ;
    $identifier$ ? theStyle ;
  or
    theStyle := [@lstring new !"" !here] ;
  end select ;
  $:$ ;
  @lexicalListEntryListAST entryList [emptyList] ;
  repeat
    <lexical_list_entry> !?entryList ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
  ioLexicalListDeclarationList += !name !theStyle !errorMessage !sentAttributeList !entryList ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_list_entry> ?!@lexicalListEntryListAST ioLexicalListEntryList :
  $literal_string$ ?@lstring entrySpelling ;
  @lstringlist optionList [emptyList] ;
  select
  or
    $feature$ ;
    $identifier$ ? @lstring optionName ;
    optionList += !optionName ;
  end select ;
  @lstring terminalSpelling ;
  select
    $->$ ;
    $terminal$ ? terminalSpelling ;
  or
    terminalSpelling := entrySpelling ;
  end select ;
  ioLexicalListEntryList += !entrySpelling !terminalSpelling !optionList ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexical_attribute_declaration> ?!@lexicalAttributeListAST ioLexicalAttributeList :
  $type_name$ ??@lstring typeName  ;
  $identifier$ ??@lstring name ;
  $;$ ;
  ioLexicalAttributeList += !typeName !name ;
end rule ;

#---------------------------------------------------------------------------*

rule <terminal_declaration> ?!@terminalDeclarationListAST ioTerminalDeclarationList :
  $terminal$ ??@lstring name indexing terminalDeclaration ;
  @lstringlist sentAttributeList [emptyList] ;
  repeat
  while
    $!$ ;
    $identifier$ ??@lstring sentAttribute ;
    sentAttributeList += ! sentAttribute ;
  end repeat ;
  $error$ ;
  $message$ ;
  $literal_string$ ??@lstring errorMessage ;
  @lstring theStyle ; # Empty string if no style
  select
    $style$ ;
    $identifier$ ? theStyle ;
  or
    theStyle := [@lstring new !"" !here] ;
  end select ;
  @lstringlist optionList [emptyList] ;
  select
  or
    $feature$ ;
    repeat
      $identifier$ ?? @lstring optionName ;
      optionList += !optionName ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $;$ ;
  ioTerminalDeclarationList += !name !sentAttributeList !errorMessage !theStyle !optionList ;
end rule ;

#---------------------------------------------------------------------------*

rule <style_declaration> ?!@lexicalStyleListAST ioLexicalStyleList :
  $style$ ;
  $identifier$ ?@lstring name  ;
  $->$ ;
  $literal_string$ ?@lstring comment ;
  $;$ ;
  ioLexicalStyleList += !name !comment ;
end rule ;

#---------------------------------------------------------------------------*

rule <extern_routine_or_function_declaration>
  ?!@externRoutineListAST ioExternRoutineList
  ?!@externFunctionListAST ioExternFunctionList
:
  $extern$ ;
  select
    $routine$ ;
    $identifier$ ?@lstring routineName ;
    @lexicalExternRoutineFormalArgumentListAST lexicalRoutineFormalArgumentList [emptyList] ;
    repeat
    while
      @lexicalArgumentModeAST lexicalArgumentMode ;
      select
        $?!$ ;
        lexicalArgumentMode := [@lexicalArgumentModeAST lexicalInputOutputMode] ;
      or
        $?$ ;
        lexicalArgumentMode := [@lexicalArgumentModeAST lexicalInputMode] ;
      end select ;
      $type_name$ ?@lstring lexicalTypeName ;
      $identifier$ ?@lstring formalArgumentName ;
      lexicalRoutineFormalArgumentList += !lexicalArgumentMode !lexicalTypeName !formalArgumentName ;
    end repeat ;
    @stringlist errorMessageList [emptyList] ;
    select
    or
      $error$ ;
      repeat
        $identifier$ ?@lstring errorMessageName ;
        errorMessageList += ![errorMessageName string] ;
      while
        $,$ ;
      end repeat ;
    end select ;
    $;$ ;      
    ioExternRoutineList += !routineName !lexicalRoutineFormalArgumentList !errorMessageList ;
  or
    $function$ ;
    $identifier$ ?@lstring functionName ;
    @lexicalExternFunctionFormalArgumentListAST lexicalFunctionFormalArgumentList [emptyList] ;
    repeat
    while
      $?$ ;
      $type_name$ ?@lstring lexicalTypeName ;
      $identifier$ ?@lstring formalArgumentName ;
      lexicalFunctionFormalArgumentList += !lexicalTypeName !formalArgumentName ;
    end repeat ;
    $->$ ;
    $type_name$ ?@lstring returnedTypeName ;
    $;$ ;      
    ioExternFunctionList += !functionName !lexicalFunctionFormalArgumentList !returnedTypeName ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
