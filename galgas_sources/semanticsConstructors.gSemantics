#---------------------------------------------------------------------------*
#                                                                           *
#  semantics definitions for semantics component                            *
#                                                                           *
#  Copyright (C) 2009, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticsConstructors :
  import "semanticsTypes.gSemantics" ;
  import semantics semanticsTypes in "semanticsTypes.gSemantics" ;

#---------------------------------------------------------------------------*

routine enterConstructorWithoutArgument
  ?!@constructorMap ioConstructorMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ??@string inConstructorName
  ??@string inReturnedTypeName
  ??@bool inHasLexiqueAndLocationArguments
:
  @unifiedTypeMapIndex returnedTypeIndex ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inReturnedTypeName !here] !?ioUnifiedTypeMap ?returnedTypeIndex] ;
  [!?ioConstructorMap insertKey
    ![@lstring new !inConstructorName !here]
    ![@unifiedTypeMapIndexList emptyList]
    !inHasLexiqueAndLocationArguments
    !returnedTypeIndex
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterConstructorWithArgument
  ?!@constructorMap ioConstructorMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ??@string inConstructorName
  ??@string inArgument1TypeName
  ??@string inReturnedTypeName
  ??@bool inHasLexiqueAndLocationArguments
:
  @unifiedTypeMapIndex returnedTypeIndex ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inReturnedTypeName !here] !?ioUnifiedTypeMap ?returnedTypeIndex] ;
  @unifiedTypeMapIndex t ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inArgument1TypeName !here] !?ioUnifiedTypeMap ?t] ;
  [!?ioConstructorMap insertKey
    ![@lstring new !inConstructorName !here]
    ![@unifiedTypeMapIndexList listWithValue !t]
    !inHasLexiqueAndLocationArguments
    !returnedTypeIndex
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterConstructorWith2Arguments
  ?!@constructorMap ioConstructorMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ??@string inConstructorName
  ??@string inArgument1TypeName
  ??@string inArgument2TypeName
  ??@string inReturnedTypeName
  ??@bool inHasLexiqueAndLocationArguments
:
  @unifiedTypeMapIndex returnedTypeIndex ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inReturnedTypeName !here] !?ioUnifiedTypeMap ?returnedTypeIndex] ;
  @unifiedTypeMapIndexList argumentTypeList [emptyList] ;
  @unifiedTypeMapIndex t ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inArgument1TypeName !here] !?ioUnifiedTypeMap ?t] ;
  argumentTypeList += !t ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inArgument2TypeName !here] !?ioUnifiedTypeMap ?t] ;
  argumentTypeList += !t ;
  [!?ioConstructorMap insertKey
    ![@lstring new !inConstructorName !here]
    !argumentTypeList
    !inHasLexiqueAndLocationArguments
    !returnedTypeIndex
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterConstructorWith3Arguments
  ?!@constructorMap ioConstructorMap
  ?!@unifiedTypeMap ioUnifiedTypeMap
  ??@string inConstructorName
  ??@string inArgument1TypeName
  ??@string inArgument2TypeName
  ??@string inArgument3TypeName
  ??@string inReturnedTypeName
  ??@bool inHasLexiqueAndLocationArguments
:
  @unifiedTypeMapIndex returnedTypeIndex ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inReturnedTypeName !here] !?ioUnifiedTypeMap ?returnedTypeIndex] ;
  @unifiedTypeMapIndex t ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inArgument1TypeName !here] !?ioUnifiedTypeMap ?t] ;
  @unifiedTypeMapIndexList argumentTypeList [emptyList] ;
  argumentTypeList += !t ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inArgument2TypeName !here] !?ioUnifiedTypeMap ?t] ;
  argumentTypeList += !t ;
  [@unifiedTypeMapIndex makeRegularIndex ![@lstring new !inArgument3TypeName !here] !?ioUnifiedTypeMap ?t] ;
  argumentTypeList += !t ;
  [!?ioConstructorMap insertKey
    ![@lstring new !inConstructorName !here]
    !argumentTypeList
    !inHasLexiqueAndLocationArguments
    !returnedTypeIndex
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_string
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"stringWithVersionString" !"string" !false ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"stringWithSourceFilePath" !"string" !true ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"stringWithCurrentDirectory" !"string" !false ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"stringWithMainFirstArgument" !"string" !false ;
#  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"stringWithContentsOfFile" !"char" !"uint" !"string" !true ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"stringWithContentsOfFile" !"string" !"string" !true ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"stringWithCurrentDateTime" !"string" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"stringWithEnvironmentVariable" !"string" !"string" !true ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"stringWithEnvironmentVariableOrEmpty" !"string" !"string" !false ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"CppLineComment" !"string" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"CppTitleComment" !"string" !"string" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"CppString" !"string" !"string" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"CppChar" !"char" !"string" !false ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"componentsJoinedByString" !"stringlist" !"string" !"string" !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_char
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"replacementCharacter" !"char" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"unicodeCharacterWithUnsigned" !"uint" !"char" !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_uint
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"max" !"uint" !false ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"errorCount" !"uint" !true ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"warningCount" !"uint" !true ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"valueWithMask" !"uint" !"uint" !"uint" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_sint
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"max" !"sint" !false ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"min" !"sint" !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_uint64
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"max" !"uint64" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"uint64MaskWithCompressedBitString" !"string" !"uint64" !true ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"uint64BaseValueWithCompressedBitString" !"string"  !"uint64" !true ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"uint64WithBitString" !"string"  !"uint64" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_sint64
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"max" !"sint64" !false ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"min" !"sint64" !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_lstring
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"new" !"string" !"location" !"lstring" !true ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"retrieveAndResetTemplateString" !"lstring" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_lchar
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"new" !"char" !"location" !"lchar" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_lbool
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"new" !"bool" !"location" !"lbool" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_luint
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"new" !"uint" !"location" !"luint" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_lsint
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"new" !"sint" !"location" !"lsint" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_luint64
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"new" !"uint64" !"location" !"luint64" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_lsint64
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"new" !"sint64" !"location" !"lsint64" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_ldouble
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWith2Arguments !?outMap !?ioUnifiedTypeMap !"new" !"double" !"location" !"ldouble" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_stringset
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"emptySet" !"stringset" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"setWithString" !"string" !"stringset" !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_binaryset
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"binarySetWithBit" !"uint" !"binaryset" !true ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"emptyBinarySet" !"binaryset" !false ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"fullBinarySet" !"binaryset" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"binarySetWithPredicateString" !"string" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithNotEqualComparison" !"uint" !"uint" !"uint" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithEqualComparison" !"uint" !"uint" !"uint" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithStrictLowerComparison" !"uint" !"uint" !"uint" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithStrictGreaterComparison" !"uint" !"uint" !"uint" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithLowerOrEqualComparison" !"uint" !"uint" !"uint" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithGreaterOrEqualComparison" !"uint" !"uint" !"uint" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithEqualToConstant" !"uint" !"uint" !"uint64" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithNotEqualToConstant" !"uint" !"uint" !"uint64" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithStrictLowerThanConstant" !"uint" !"uint" !"uint64" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithStrictGreaterThanConstant" !"uint" !"uint" !"uint64" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithLowerOrEqualToConstant" !"uint" !"uint" !"uint64" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithGreaterOrEqualToConstant" !"uint" !"uint" !"uint64" !"binaryset" !true ;
  enterConstructorWith3Arguments !?outMap !?ioUnifiedTypeMap !"binarySetWithITE" !"binaryset" !"binaryset" !"binaryset" !"binaryset" !true ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_type
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"typeList" !"typelist" !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_data
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"emptyData" !"data" !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_function
  ?!@unifiedTypeMap ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"functionList" !"functionlist" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"functionWithName" !"string" !"function" !false ;
  enterConstructorWithArgument !?outMap !?ioUnifiedTypeMap !"isFunctionDefined" !"string" !"bool" !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_class
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
#  @ACGalgasType selfType := self ; # Astuce car self n'est pas défini dans un contexte emboîté (BUG)
#  if not mIsAbstract then
#    @typeList typeList [emptyList] ;
#    foreach mAttributeList do
#      typeList += ![mAttributeTypeIndex mType] ;
#    end foreach ;
#    [!?outMap insertKey ![@lstring new !"new" !here] !typeList !false !selfType] ;
#  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_listmap
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
#  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"emptyList" !self !false ;
#  @typeList typeList [emptyList] ;
#  foreach mAttributeList do
#    typeList += ![mAttributeTypeIndex mType] ;
#  end foreach ;
#  [!?outMap insertKey ![@lstring new !"listWithValue" !here] !typeList !false !self] ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_struct
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
#  @typeList typeList [emptyList] ;
#  foreach mAttributeList do
#    typeList += ![mAttributeTypeIndex mType] ;
#  end foreach ;
#  [!?outMap insertKey ![@lstring new !"new" !here] !typeList !false !self] ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_sortedlist
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
#  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"emptySortedList" !self !false ;
#  @typeList typeList [emptyList] ;
#  foreach mAttributeList do
#    typeList += ![mAttributeTypeIndex mType] ;
#  end foreach ;
#  [!?outMap insertKey ![@lstring new !"sortedListWithValue" !here] !typeList !false !self] ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_map
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
#  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"emptyMap" !self !false ;
#  [!?outMap insertKey ![@lstring new !"mapWithMapToOverride" !here] ![@typeList listWithValue !self] !false !self] ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_mapindex
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
#  enterConstructorWithoutArgument !?outMap !?ioUnifiedTypeMap !"null" !self !false ;
end routine ;

#---------------------------------------------------------------------------*

routine constructorMapFor_enum
  ?!@unifiedTypeMap unused ioUnifiedTypeMap
  !@constructorMap outMap
:
  outMap := [@constructorMap emptyMap] ;
#  @ACGalgasType selfType := self ; # Astuce car self n'est pas défini dans un contexte emboîté (BUG)
#  foreach mEnumConstructorMap do
#    enterConstructorWithoutArgument !?outMap ![key string] !selfType !false ;
#  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
