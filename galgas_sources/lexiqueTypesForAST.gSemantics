#---------------------------------------------------------------------------*
#                                                                           *
#  'lexique' component metamodel                                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics lexiqueTypesForAST :

#---------------------------------------------------------------------------*

abstract class @lexicalExpressionAST {
}

#---------------------------------------------------------------------------*

abstract class @lexicalInstructionAST {
}

#---------------------------------------------------------------------------*

list @lexicalInstructionListAST {
  @lexicalInstructionAST mInstruction feature nogetter ;
}

#---------------------------------------------------------------------------*

list @metamodelTemplateDelimitorListAST {
  @lstring mStartString feature nogetter ;
  @lstringlist mOptionList feature nogetter ;
  @lstring mEndString feature nogetter ;
}

#---------------------------------------------------------------------------*

list @templateReplacementListAST {
  @lstring mMatchString feature nogetter ;
  @lstring mReplacementString feature nogetter ;
  @lstring mReplacementFunction feature nogetter ;
}

#---------------------------------------------------------------------------*

abstract class @abstractLexicalRuleAST {
}

#---------------------------------------------------------------------------*

list @lexicalRuleListAST {
  @abstractLexicalRuleAST mLexicalRule feature nogetter ;
}

#---------------------------------------------------------------------------*

class @lexicalImplicitRuleAST extends @abstractLexicalRuleAST {
  @lstring mListName ;
}

#---------------------------------------------------------------------------*

class @lexicalExplicitRuleAST extends @abstractLexicalRuleAST {
  @lexicalExpressionAST mLexicalRuleExpression ;
  @lexicalInstructionListAST mInstructionList ;
}

#---------------------------------------------------------------------------*

list @lexicalMessageDeclarationListAST {
  @lstring mMessageName feature nogetter ;
  @lstring mMessageValue feature nogetter ;
}

#---------------------------------------------------------------------------*

list @lexicalAttributeListAST {
  @lstring mTypeName feature nogetter ;
  @lstring mName feature nogetter ;
}

#---------------------------------------------------------------------------*

list @lexicalStyleListAST {
  @lstring mName feature nogetter ;
  @lstring mComment feature nogetter ;
}

#---------------------------------------------------------------------------*

list @terminalDeclarationListAST {
  @lstring mName feature nogetter ;
  @lstringlist mSentAttributeList feature nogetter ;
  @lstring mSyntaxErrorMessage feature nogetter ;
  @lstring mStyle feature nogetter ; # Empty string if no style
  @lstringlist mOptionList feature nogetter ;
}

#---------------------------------------------------------------------------*

list @lexicalListEntryListAST {
  @lstring mEntrySpelling feature nogetter ;
  @lstring mTerminalSpelling feature nogetter ;
  @lstringlist mFeatureList feature nogetter ;
}

#---------------------------------------------------------------------------*

list @lexicalListDeclarationListAST {
  @lstring mName feature nogetter ;
  @lstring mStyle feature nogetter ; # Empty string if no style
  @lstring mSyntaxErrorMessage feature nogetter ;
  @lstringlist mSentAttributeList feature nogetter ;
  @lexicalListEntryListAST mEntryList feature nogetter ;  
}

#---------------------------------------------------------------------------*

class @lexicalOrExpressionAST extends @lexicalExpressionAST {
  @lexicalExpressionAST mLeftOperand ;
  @lexicalExpressionAST mRightOperand ;
}

#---------------------------------------------------------------------------*

class @lexicalCharacterSetMatchAST extends @lexicalExpressionAST {
  @lstring mCharacterSetName ;
}

#---------------------------------------------------------------------------*

class @lexicalCharacterMatchAST extends @lexicalExpressionAST {
  @lchar mCharacter ;
}

#---------------------------------------------------------------------------*

class @lexicalCharacterIntervalMatchAST extends @lexicalExpressionAST {
  @lchar mLowerBound ;
  @lchar mUpperBound ;
}

#---------------------------------------------------------------------------*

class @lexicalStringMatchAST extends @lexicalExpressionAST {
  @lstring mString ;
}

#---------------------------------------------------------------------------*

class @lexicalStringNotMatchAST extends @lexicalExpressionAST {
  @lstring mString ;
  @lstring mErrorMessage ;
}

#---------------------------------------------------------------------------*

list @lexicalSendSearchListAST {
  @lstring mAttributeName feature nogetter ;
  @lstring mSearchListName feature nogetter ;
}

#---------------------------------------------------------------------------*

abstract class @lexicalSendDefaultActionAST {
}

#---------------------------------------------------------------------------*

class @lexicalStructuredSendInstructionAST extends @lexicalInstructionAST {
  @lexicalSendSearchListAST mLexicalSendSearchList ;
  @lexicalSendDefaultActionAST mLexicalSendDefaultAction ;
}

#---------------------------------------------------------------------------*

class @lexicalSimpleSendInstructionAST extends @lexicalInstructionAST {
  @lstring mSentTerminal ;
}

#---------------------------------------------------------------------------*

class @lexicalSendTerminalByDefaultAST extends @lexicalSendDefaultActionAST {
  @lstring mDefaultSentTerminal ;
}

#---------------------------------------------------------------------------*

class @lexicalErrorByDefaultAST extends @lexicalSendDefaultActionAST {
  @lstring mDefaultErrorMessageName ;
}

#---------------------------------------------------------------------------*

list @lexicalWhileBranchListAST {
  @lexicalExpressionAST mWhileExpression feature nogetter ;
  @lexicalInstructionListAST mWhileInstructionList feature nogetter ;
}

#---------------------------------------------------------------------------*

class @lexicalRepeatInstructionAST extends @lexicalInstructionAST {
  @lexicalInstructionListAST mRepeatedInstructionList ;
  @lexicalWhileBranchListAST mLexicalWhileBranchList ;
}

#---------------------------------------------------------------------------*

list @lexicalSelectBranchListAST {
  @lexicalExpressionAST mSelectExpression feature nogetter ;
  @lexicalInstructionListAST mSelectInstructionList feature nogetter ;
}

#---------------------------------------------------------------------------*

class @lexicalSelectInstructionAST extends @lexicalInstructionAST {
  @lexicalSelectBranchListAST mLexicalSelectBranchList ;
  @lexicalInstructionListAST mDefaultInstructionList ;
}

#---------------------------------------------------------------------------*

abstract class @abstractLexicalRoutineActualArgumentAST {
  @location mActualPassingModeLocation ;
}

#---------------------------------------------------------------------------*

list @lexicalRoutineCallActualArgumentListAST {
  @abstractLexicalRoutineActualArgumentAST mLexicalRoutineActualArgument feature nogetter ;
}

#---------------------------------------------------------------------------*

class @lexicalRoutineInstructionAST extends @lexicalInstructionAST {
  @lstring mRoutineName ;
  @lexicalRoutineCallActualArgumentListAST mActualArgumentList ;
  @lstringlist mErrorMessageList ;
}

#---------------------------------------------------------------------------*

class @lexicalAttributeInputOutputArgumentAST extends @abstractLexicalRoutineActualArgumentAST {
  @lstring mAttributeName ;
}

#---------------------------------------------------------------------------*

abstract class @lexicalRoutineOrFunctionFormalInputArgumentAST {
}

#---------------------------------------------------------------------------*

class @lexicalFormalInputArgumentAST extends @abstractLexicalRoutineActualArgumentAST {
  @lexicalRoutineOrFunctionFormalInputArgumentAST mRoutineOrFunctionFormalInputArgument ;
}

#---------------------------------------------------------------------------*

list @lexicalFunctionCallActualArgumentListAST {
  @lexicalRoutineOrFunctionFormalInputArgumentAST mLexicalActualInputArgument feature nogetter ;
}

#---------------------------------------------------------------------------*

class @lexicalAttributeInputArgumentAST extends @lexicalRoutineOrFunctionFormalInputArgumentAST {
  @lstring mAttributeName ;
}

#---------------------------------------------------------------------------*

class @lexicalCharacterInputArgumentAST extends @lexicalRoutineOrFunctionFormalInputArgumentAST {
  @lchar mCharacter ;
}

#---------------------------------------------------------------------------*

class @lexicalUnsignedInputArgumentAST extends @lexicalRoutineOrFunctionFormalInputArgumentAST {
  @luint mUnsigned ;
}

#---------------------------------------------------------------------------*

class @lexicalCurrentCharacterInputArgumentAST extends @lexicalRoutineOrFunctionFormalInputArgumentAST {
  @location mLocation ;
}

#---------------------------------------------------------------------------*

class @lexicalFunctionInputArgumentAST extends @lexicalRoutineOrFunctionFormalInputArgumentAST {
  @lstring mFunctionName ;
  @lexicalFunctionCallActualArgumentListAST mFunctionActualArgumentList ;
}

#---------------------------------------------------------------------------*

class @lexicalDropInstructionAST extends @lexicalInstructionAST {
  @lstring mTerminalName ;
}

#---------------------------------------------------------------------------*

class @lexicalErrorInstructionAST extends @lexicalInstructionAST {
  @lstring mErrorMessageName ;
}

#---------------------------------------------------------------------------*

class @lexicalWarningInstructionAST extends @lexicalInstructionAST {
  @lstring mWarningMessageName ;
}

#---------------------------------------------------------------------------*

class @lexicalTagInstructionAST extends @lexicalInstructionAST {
  @lstring mLexicalTagName ;
}

#---------------------------------------------------------------------------*

class @lexicalRewindInstructionAST extends @lexicalInstructionAST {
  @lstring mLexicalTagName ;
  @lstring mTerminalName ;
}

#---------------------------------------------------------------------------*

class @lexicalLogInstructionAST extends @lexicalInstructionAST {
}

#---------------------------------------------------------------------------*

enum @lexicalArgumentModeAST {
  lexicalInputMode, lexicalInputOutputMode
}

reader @lexicalArgumentModeAST lexicalFormalModeName -> @string outResult :
  switch selfcopy
  when lexicalInputMode       : outResult := "!" ;
  when lexicalInputOutputMode : outResult := "?!" ;
  end switch ;
end reader ;

reader @lexicalArgumentModeAST cppConstInFormalArgument -> @string outResult :
  switch selfcopy
  when lexicalInputMode       : outResult := "const " ;
  when lexicalInputOutputMode : outResult := "" ;
  end switch ;
end reader ;

reader @lexicalArgumentModeAST cppReferenceInFormalArgument -> @string outResult :
  switch selfcopy
  when lexicalInputMode       : outResult := "" ;
  when lexicalInputOutputMode : outResult := " &" ;
  end switch ;
end reader ;

reader @lexicalArgumentModeAST cocoaPointerInFormalArgument -> @string outResult :
  switch selfcopy
  when lexicalInputMode       : outResult := "" ;
  when lexicalInputOutputMode : outResult := " *" ;
  end switch ;
end reader ;

#---------------------------------------------------------------------------*

list @lexicalExternRoutineFormalArgumentListAST {
  @lexicalArgumentModeAST mPassingMode feature nogetter ;
  @lstring mLexicalTypeName feature nogetter ;
  @lstring mFormalArgumentName feature nogetter ;
}

#---------------------------------------------------------------------------*

list @externRoutineListAST {
  @lstring mRoutineName feature nogetter ;
  @lexicalExternRoutineFormalArgumentListAST mLexicalRoutineFormalArgumentList feature nogetter ;
  @stringlist mErrorMessageList feature nogetter ;
}

#---------------------------------------------------------------------------*

list @lexicalExternFunctionFormalArgumentListAST {
  @lstring mLexicalTypeName feature nogetter ;
  @lstring mFormalArgumentName feature nogetter ;
}

#---------------------------------------------------------------------------*

list @externFunctionListAST {
  @lstring mFunctionName feature nogetter ;
  @lexicalExternFunctionFormalArgumentListAST mLexicalFunctionFormalArgumentList feature nogetter ;
  @lstring mReturnedTypeName feature nogetter ;
}

#---------------------------------------------------------------------------*

list @indexingListAST {
  @lstring mIndexName feature nogetter ;
  @lstring mIndexComment feature nogetter ;
}

#---------------------------------------------------------------------------*

list @galgas3LexiqueComponentListAST {
  @lstring mLexiqueComponentName  ;
  @bool mIsTemplate ;
  @metamodelTemplateDelimitorListAST mTemplateDelimitorList ;
  @templateReplacementListAST mTemplateReplacementList ;
  @lexicalAttributeListAST mLexicalAttributeList ;
  @lexicalStyleListAST mLexicalStyleList ;
  @terminalDeclarationListAST mTerminalDeclarationList  ;
  @lexicalMessageDeclarationListAST mLexicalMessageDeclarationList ;
  @lexicalListDeclarationListAST mLexicalListDeclarationList  ;
  @lexicalRuleListAST mLexicalRuleList ;
  @externRoutineListAST mExternRoutineList ;
  @externFunctionListAST mExternFunctionList  ;
  @indexingListAST mIndexingListAST ;
  @lstring mIndexingDirectory ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    T E R M I N A L    M A P                           *
#                                                                           *
#---------------------------------------------------------------------------*

enum @lexicalTypeEnum {
  lexicalType_string, lexicalType_char, lexicalType_uint,
  lexicalType_uint64, lexicalType_sint, lexicalType_sint64,
  lexicalType_double
}

#---------------------------------------------------------------------------*

list @lexicalSentValueList {
  @string mLexicalAttributeName ;
  @lexicalTypeEnum mLexicalType ;
}

#---------------------------------------------------------------------------*

map @terminalMap {
  @lexicalSentValueList mSentAttributeList ;
  insert insertKey error message "the '%K' terminal has been already declared in %L" ;
  search searchKey error message "the '%K' terminal is not declared" ;
}

#---------------------------------------------------------------------------*
#          B U I L D    L E X I C A L    T Y P E    M A P                   *
#---------------------------------------------------------------------------*

map @lexicalTypeMap {
  @lexicalTypeEnum mLexicalType ;
  insert insertKey error message "the '@%K' lexical type is already declared in %L" ;
  search searchKey error message "there is no '@%K' lexical type" ;
}

#---------------------------------------------------------------------------*

once buildLexicalTypeMap
  ->@lexicalTypeMap outLexicalTypeMap
:
  outLexicalTypeMap := [@lexicalTypeMap emptyMap] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"string" !here] ![@lexicalTypeEnum lexicalType_string]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"char"   !here] ![@lexicalTypeEnum lexicalType_char]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"uint"   !here] ![@lexicalTypeEnum lexicalType_uint]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"uint64" !here] ![@lexicalTypeEnum lexicalType_uint64]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"sint"   !here] ![@lexicalTypeEnum lexicalType_sint]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"sint64" !here] ![@lexicalTypeEnum lexicalType_sint64]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"double" !here] ![@lexicalTypeEnum lexicalType_double]] ;
end once ;

#---------------------------------------------------------------------------*

map @lexicalAttributeMap {
  @lexicalTypeEnum mLexicalType ;
  insert insertKey error message "the '%K' lexical attribute has been already declared in %L" ;
  search searchKey error message "the '%K' lexical attribute is not declared" ;
}

#---------------------------------------------------------------------------*
#   B U I L D    L E X I C A L    A T T R I B U T E    M A P                *
#---------------------------------------------------------------------------*

routine buildLexicalAttributeMap
  ??@lexicalTypeMap inLexicalTypeMap
  ??@lexicalAttributeListAST inLexicalAttributeList
  ?!@lexicalAttributeMap ioLexicalAttributeMap
:
  foreach inLexicalAttributeList do
    if [inLexicalTypeMap hasKey ![mTypeName string]] then
      @lexicalTypeEnum lexicalType ;
      [inLexicalTypeMap searchKey !mTypeName ?lexicalType] ;
      [!?ioLexicalAttributeMap insertKey !mName !lexicalType] ;
    else
      @string m := "" ;
      m .= "the @" . mTypeName . " type is not a valid lexical attribute type; are allowed:" ;
      @bool firstLoop := true ;
      foreach inLexicalTypeMap do
        m .= " @" . lkey ;
      between
        m .= "," ;
      end foreach ;
      error mTypeName: m ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine buildTerminalMap
  ??@galgas3LexiqueComponentListAST.element inLexiqueComponentRoot
  !@terminalMap outTerminalMap
:
#--------------------------------------- Build lexical attribute map
  const @lexicalTypeMap lexicalTypeMap := buildLexicalTypeMap [] ;
  @lexicalAttributeMap lexicalAttributeMap [emptyMap] ;
  buildLexicalAttributeMap
   !lexicalTypeMap
   ![inLexiqueComponentRoot mLexicalAttributeList]
   !?lexicalAttributeMap
  ;
#--------------------------------------- 
  outTerminalMap := [@terminalMap emptyMap] ;
  foreach [inLexiqueComponentRoot mTerminalDeclarationList] do
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType ;
      [lexicalAttributeMap searchKey !mValue ?attributeLexicalType] ;
      argumentTypeList += ![mValue string] !attributeLexicalType ;
    end foreach ;
    [!?outTerminalMap insertKey !mName !argumentTypeList] ;
  end foreach ;
#---
  foreach [inLexiqueComponentRoot mLexicalListDeclarationList] do
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType ;
      [lexicalAttributeMap searchKey !mValue ?attributeLexicalType] ;
      argumentTypeList += ![mValue string] !attributeLexicalType ;
    end foreach ;
    foreach mEntryList do
      [!?outTerminalMap insertKey !mTerminalSpelling !argumentTypeList] ;
    end foreach ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;