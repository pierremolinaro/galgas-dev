#---------------------------------------------------------------------------*
#                                                                           *
#  Generate predefined types                                                *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics predefinedTypes :
  import "semanticGeneration.gSemantics" ;

  import semantics semanticGeneration in "semanticGeneration.gSemantics" ;

#---------------------------------------------------------------------------*

routine appendPredefinedListTypeAST
  ?!@semanticDeclarationListAST ioDeclarationListASTs
  ??@string inElementTypeName
:
  @attributeInCollectionListAST attributeList [emptyList] ;
  @lstringlist featureList [emptyList] ;
  featureList += ![@lstring new !"setter" !here] ;
  attributeList +=
    ![@lstring new !inElementTypeName !here]
    ![@lstring new !"mValue" !here]
    !featureList
  ;
  ioDeclarationListASTs += ![@listDeclarationAST new
    ![@lstring new !inElementTypeName . "list" !here]
    !attributeList
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine appendPredefined2StringListTypeAST
  ?!@semanticDeclarationListAST ioDeclarationListASTs
:
  @attributeInCollectionListAST attributeList [emptyList] ;
  @lstringlist featureList [emptyList] ;
  featureList += ![@lstring new !"setter" !here] ;
  attributeList +=
    ![@lstring new !"string" !here]
    ![@lstring new !"mValue0" !here]
    !featureList
  ;
  attributeList +=
    ![@lstring new !"string" !here]
    ![@lstring new !"mValue1" !here]
    !featureList
  ;
  ioDeclarationListASTs += ![@listDeclarationAST new
    ![@lstring new !"2stringlist" !here]
    !attributeList
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine appendStructASTForTypeWithLocation
  ?!@semanticDeclarationListAST ioDeclarationListASTs
  ??@string inElementTypeName
:
  @lstringlist featureList [emptyList] ;
  featureList += ![@lstring new !"setter" !here] ;
  @attributeInCollectionListAST attributeList [emptyList] ;
  attributeList += ![@lstring new !inElementTypeName !here] ![@lstring new !inElementTypeName !here] !featureList ;
  attributeList += ![@lstring new !"location" !here] ![@lstring new !"location" !here] !featureList ;
  ioDeclarationListASTs += ![@structDeclarationAST new
    ![@lstring new !"l" . inElementTypeName !here]
    !attributeList
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine appendPredefinedTypesASTs
  ?!@semanticDeclarationListAST ioDeclarationListASTs
:
  ioDeclarationListASTs += ![@applicationPredefinedTypeAST new !"application" ![@predefinedTypeKindEnum predefined_application]] ;
  ioDeclarationListASTs += ![@filewrapperPredefinedTypeAST new !"filewrapper" ![@predefinedTypeKindEnum predefined_filewrapper]] ;
  ioDeclarationListASTs += ![@objectPredefinedTypeAST new !"object" ![@predefinedTypeKindEnum predefined_object]] ;
  ioDeclarationListASTs += ![@boolPredefinedTypeAST new !"bool" ![@predefinedTypeKindEnum predefined_bool]] ;
  ioDeclarationListASTs += ![@uintPredefinedTypeAST new !"uint" ![@predefinedTypeKindEnum predefined_uint]] ;
  ioDeclarationListASTs += ![@uint64PredefinedTypeAST new !"uint64" ![@predefinedTypeKindEnum predefined_uint64]] ;
  ioDeclarationListASTs += ![@sintPredefinedTypeAST new !"sint" ![@predefinedTypeKindEnum predefined_sint]] ;
  ioDeclarationListASTs += ![@sint64PredefinedTypeAST new !"sint64" ![@predefinedTypeKindEnum predefined_sint64]] ;
  ioDeclarationListASTs += ![@charPredefinedTypeAST new !"char" ![@predefinedTypeKindEnum predefined_char]] ;
  ioDeclarationListASTs += ![@doublePredefinedTypeAST new !"double" ![@predefinedTypeKindEnum predefined_double]] ;
  ioDeclarationListASTs += ![@stringPredefinedTypeAST new !"string" ![@predefinedTypeKindEnum predefined_string]] ;
  ioDeclarationListASTs += ![@locationPredefinedTypeAST new !"location" ![@predefinedTypeKindEnum predefined_location]] ;
  ioDeclarationListASTs += ![@stringsetPredefinedTypeAST new !"stringset" ![@predefinedTypeKindEnum predefined_stringset]] ;
  ioDeclarationListASTs += ![@functionPredefinedTypeAST new !"function" ![@predefinedTypeKindEnum predefined_function]] ;
  ioDeclarationListASTs += ![@typePredefinedTypeAST new !"type" ![@predefinedTypeKindEnum predefined_type]] ;
  ioDeclarationListASTs += ![@binarysetPredefinedTypeAST new !"binaryset" ![@predefinedTypeKindEnum predefined_binaryset]] ;
  ioDeclarationListASTs += ![@dataPredefinedTypeAST new !"data" ![@predefinedTypeKindEnum predefined_data]] ;

  appendPredefinedListTypeAST !?ioDeclarationListASTs !"luint" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"uint" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"uint64" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"function" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"string" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"lstring" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"type" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"object" ;

  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"bool" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"uint" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"uint64" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"sint" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"sint64" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"char" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"double" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"string" ;

  appendPredefined2StringListTypeAST !?ioDeclarationListASTs ;

#--- Enumeration predefined type (used only for testing type generation)
#  @lstringlist constantList [emptyList] ;
#  constantList += ![@lstring new !"zero" !here] ;
#  constantList += ![@lstring new !"un" !here] ;
#  constantList += ![@lstring new !"deux" !here] ;
#  @enumMessageAssociationListAST enumMessageAssociationListAST [emptyList] ;
#  enumMessageAssociationListAST += ![@lstring new !"deux" !here] ![@lstring new !"message deux" !here] ;
#  enumMessageAssociationListAST += ![@lstring new !"un" !here] ![@lstring new !"message un" !here] ;
#  enumMessageAssociationListAST += ![@lstring new !"zero" !here] ![@lstring new !"message zero" !here]  ;
#  @enumMessageListAST enumMessageListAST [emptyList] ;
#  enumMessageListAST += ![@lstring new !"test" !here] !enumMessageAssociationListAST ;
#  ioDeclarationListASTs += ![@enumDeclarationAST new
#    ![@lstring new !"0enum" !here]
#    !constantList
#    !enumMessageListAST
#  ] ;

#--- Sorted list predefined type (used only for testing type generation)
#  @attributeInCollectionListAST sortedListAttributeList [emptyList] ;
#  sortedListAttributeList += ![@lstring new !"uint" !here] ![@lstring new !"mFirst" !here] ;
#  sortedListAttributeList += ![@lstring new !"char" !here]  ![@lstring new !"mSecond" !here] ;
#  sortedListAttributeList += ![@lstring new !"string" !here]  ![@lstring new !"mThird" !here] ;
#  @sortedListSortDescriptorListAST sortDescriptorList [emptyList] ;
#  sortDescriptorList += ![@lstring new !"mThird" !here] !true ;
#  sortDescriptorList += ![@lstring new !"mFirst" !here] !false ;
#  ioDeclarationListASTs += ![@sortedListDeclarationAST new
#    ![@lstring new !"0sortedlist" !here]
#    !sortedListAttributeList
#    !sortDescriptorList
#  ] ;

#--- Map predefined type (used only for testing type generation)
#  @attributeInCollectionListAST mapAttributeList [emptyList] ;
#  mapAttributeList += ![@lstring new !"uint" !here] ![@lstring new !"mFirst" !here] ;
#  mapAttributeList += ![@lstring new !"char" !here]  ![@lstring new !"mSecond" !here] ;
#  mapAttributeList += ![@lstring new !"string" !here]  ![@lstring new !"mThird" !here] ;
#  @insertMethodListAST insertMethodList [emptyList] ;
#  insertMethodList +=
#    ![@lstring new !"insert" !here]
#    ![@lstring new !"insert error message" !here]
#    ![@lstring new !"shadow error message" !here]
#    ![@lstring new !"" !here]
#  ;
#  @mapSearchMethodListAST mapSearchMethodListAST [emptyList] ;
#  mapSearchMethodListAST +=
#    ![@lstring new !"search" !here]
#    ![@lstring new !"search error message" !here]
#    ![@lstring new !"" !here]
#  ;
#  @mapRemoveMethodListAST mapRemoveMethodListAST [emptyList] ;
#  mapRemoveMethodListAST +=
#    ![@lstring new !"remove" !here]
#    ![@lstring new !"remove error message" !here]
#  ;
#  @insertOrReplaceDeclarationListAST insertOrReplaceDeclarationListAST [listWithValue !here] ;
#  ioDeclarationListASTs += ![@mapDeclarationAST new
#    ![@lstring new !"0map" !here]
#    !mapAttributeList
#    !insertMethodList
#    !mapSearchMethodListAST
#    !mapRemoveMethodListAST
#    !insertOrReplaceDeclarationListAST
#    ![@mapStateList emptyList]
#  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper predefinedTypeGenerationTemplate in "../generation_templates/type_generation" {
} {
  template predefinedTypesImplementation "predefined_types.cpp.gTemplate" ;


  template primitiveTypesHeaderPrologue "predefined-types-file-header.h.gTemplate"
    ?@stringset TYPE_LIST
  ;

  template predefinedTypeSeparation "predefined-types-separation.h.gTemplate"  ;

  template sint_type "sint-type.h.gTemplate" ;
  
  template sint64_type "sint64-type.h.gTemplate" ;
  
  template object_type "object-type.h.gTemplate" ;
  
  template uint_type "uint-type.h.gTemplate" ;
  
  template uint64_type "uint64-type.h.gTemplate" ;
  
  template bool_type "bool-type.h.gTemplate" ;
  
  template binaryset_type "binaryset-type.h.gTemplate" ;
  
  template function_type "function-type.h.gTemplate" ;
  
  template type_type "type-type.h.gTemplate" ;
  
  template location_type "location-type.h.gTemplate" ;
  
  template data_type "data-type.h.gTemplate" ;
  
  template char_type "char-type.h.gTemplate" ;
  
  template double_type "double-type.h.gTemplate" ;
  
  template string_type "string-type.h.gTemplate" ;
  
  template stringset_type "stringset-type.h.gTemplate" ;

  template filewrapper_type "filewrapper-type.h.gTemplate" ;

  template application_type "application-type.h.gTemplate" ;
}

#---------------------------------------------------------------------------*

reader @semanticDeclarationForGeneration appendPrimitiveTypeDeclaration -> @string outHeader :
  outHeader := "" ;end reader ;

#---------------------------------------------------------------------------*

override reader @primitiveTypeForGeneration appendPrimitiveTypeDeclaration -> @string outHeader :
  switch mKind
  when predefined_object :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.object_type] ;
  when predefined_uint :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.uint_type] ;
  when predefined_uint64 :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.uint64_type] ;
  when predefined_sint :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.sint_type] ;
  when predefined_sint64 :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.sint64_type] ;
  when predefined_char :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.char_type] ;
  when predefined_double :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.double_type] ;
  when predefined_string :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.string_type] ;
  when predefined_stringset :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.stringset_type] ;
  when predefined_bool :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.bool_type] ;
  when predefined_binaryset :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.binaryset_type] ;
  when predefined_function :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.function_type] ;
  when predefined_location :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.location_type] ;
  when predefined_type :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.type_type] ;
  when predefined_data :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.data_type] ;
  when predefined_filewrapper :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.filewrapper_type] ;
  when predefined_application :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.application_type] ;
  end switch ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mWithAccessorMap]
  ] ;
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
# G E N E R A T E    P R E D E F I N E D    T Y P E    F I L E S            *
#                                                                           *
#---------------------------------------------------------------------------*

routine generatePredefinedTypeFiles ??@string inDirectory :
  if inDirectory != "" then
    if not [inDirectory directoryExists] then
      error here : "the '" . inDirectory . "' directory does not exist" ;
    else
    #------ Add predefined types to semantics declarations
      @semanticDeclarationListAST predefinedTypeASTlist [emptyList] ;
      appendPredefinedTypesASTs !?predefinedTypeASTlist ;
    #------ Build Semantic Context
      @semanticContext semanticContext ;
      buildSemanticContext
        !""
        !predefinedTypeASTlist
        !here
        ?semanticContext
      ;
    #------ Semantic Analysis
      @semanticDeclarationSortedListForGeneration decoratedDeclarationListForGeneration ;
      performSemanticAnalysis
        !predefinedTypeASTlist
        !semanticContext
        ?decoratedDeclarationListForGeneration
      ;
    #------ Generate primitive types declaration file
      @string generatedCode := [filewrapper predefinedTypeGenerationTemplate.primitiveTypesHeaderPrologue
        ![semanticContext->mTypeMap allKeys]
      ] ;
      foreach decoratedDeclarationListForGeneration do
        generatedCode .= [mDeclaration appendPrimitiveTypeDeclaration] ;
      end foreach ;
      foreach decoratedDeclarationListForGeneration do
        generatedCode .= [mDeclaration appendDeclaration1] ;
      end foreach ;
      generatedCode .= [filewrapper predefinedTypeGenerationTemplate.predefinedTypeSeparation] ;
      foreach decoratedDeclarationListForGeneration do
        generatedCode .= [mDeclaration appendDeclaration2 !inDirectory] ;
      end foreach ;
      if [@uint errorCount] == 0 then
        [@string generateFile
          !inDirectory
          !"predefined-types.h"
          !"//"
          !"\n\n" # Defaut user zone1
          !generatedCode
          !"\n\n" # Defaut user zone2
          !"#endif\n"
        ] ;
      end if ;
    #------ Generate predefined types implementation
      generatedCode := [filewrapper predefinedTypeGenerationTemplate.predefinedTypesImplementation] ;
      foreach decoratedDeclarationListForGeneration do
        generatedCode .= [mDeclaration appendTypeGenericImplementation] ;
        generatedCode .= [mDeclaration appendSpecificImplementation] ;
      end foreach ;
      if [@uint errorCount] == 0 then
        [@string generateFile
          !inDirectory
          !"predefined-types.cpp"
          !"//"
          !"\n\n" # Defaut user zone1
          !generatedCode
          !"\n\n" # Defaut user zone2
          !""
        ] ;
      end if ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
