#---------------------------------------------------------------------------*
#                                                                           *
#  Generate predefined types                                                *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics predefinedTypes :
  import "semanticGeneration.gSemantics" ;

  import semantics semanticGeneration in "semanticGeneration.gSemantics" ;

#---------------------------------------------------------------------------*

routine appendPredefinedListTypeAST
  ?!@semanticDeclarationListAST ioDeclarationListASTs
  ??@string inElementTypeName
:
  @attributeInCollectionListAST attributeList [emptyList] ;
  attributeList +=
    ![@lstring new !inElementTypeName !here]
    ![@lstring new !"mValue" !here]
  ;
  ioDeclarationListASTs += ![@listDeclarationAST new
    ![@lstring new !inElementTypeName . "list" !here]
    !attributeList
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine appendStructASTForTypeWithLocation
  ?!@semanticDeclarationListAST ioDeclarationListASTs
  ??@string inElementTypeName
:
  @attributeInCollectionListAST attributeList [emptyList] ;
  attributeList += ![@lstring new !inElementTypeName !here] ![@lstring new !inElementTypeName !here] ;
  attributeList += ![@lstring new !"location" !here] ![@lstring new !"location" !here] ;
  ioDeclarationListASTs += ![@structDeclarationAST new
    ![@lstring new !"l" . inElementTypeName !here]
    !attributeList
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine appendPredefinedTypesASTs
  ?!@semanticDeclarationListAST ioDeclarationListASTs
:
  ioDeclarationListASTs += ![@objectPredefinedTypeAST new] ; # Type, super type
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"enumerable" !"object"] ;
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"class" !"object"] ;
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"struct" !"object"] ;
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"enum" !"object"] ;
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"mapproxy" !"object"] ;
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"list" !"enumerable"] ;
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"sortedlist" !"enumerable"] ;
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"map" !"enumerable"] ;
  ioDeclarationListASTs += ![@genericTypeTypeAST new !"listmap" !"enumerable"] ;

  ioDeclarationListASTs += ![@boolPredefinedTypeAST new !"bool" ![@typeKindEnum predefined_bool]] ;
  ioDeclarationListASTs += ![@uintPredefinedTypeAST new !"uint" ![@typeKindEnum predefined_uint]] ;
  ioDeclarationListASTs += ![@uint64PredefinedTypeAST new !"uint64" ![@typeKindEnum predefined_uint64]] ;
  ioDeclarationListASTs += ![@sintPredefinedTypeAST new !"sint" ![@typeKindEnum predefined_sint]] ;
  ioDeclarationListASTs += ![@sint64PredefinedTypeAST new !"sint64" ![@typeKindEnum predefined_sint64]] ;
  ioDeclarationListASTs += ![@charPredefinedTypeAST new !"char" ![@typeKindEnum predefined_char]] ;
  ioDeclarationListASTs += ![@doublePredefinedTypeAST new !"double" ![@typeKindEnum predefined_double]] ;
  ioDeclarationListASTs += ![@stringPredefinedTypeAST new !"string" ![@typeKindEnum predefined_string]] ;
  ioDeclarationListASTs += ![@locationPredefinedTypeAST new !"location" ![@typeKindEnum predefined_location]] ;
  ioDeclarationListASTs += ![@stringsetPredefinedTypeAST new !"stringset" ![@typeKindEnum predefined_stringset]] ;
  ioDeclarationListASTs += ![@functionPredefinedTypeAST new !"function" ![@typeKindEnum predefined_function]] ;
  ioDeclarationListASTs += ![@typePredefinedTypeAST new !"type" ![@typeKindEnum predefined_type]] ;
  ioDeclarationListASTs += ![@binarysetPredefinedTypeAST new !"binaryset" ![@typeKindEnum predefined_binaryset]] ;
  ioDeclarationListASTs += ![@dataPredefinedTypeAST new !"data" ![@typeKindEnum predefined_data]] ;

  appendPredefinedListTypeAST !?ioDeclarationListASTs !"luint" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"uint" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"uint64" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"function" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"string" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"lstring" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"type" ;
  appendPredefinedListTypeAST !?ioDeclarationListASTs !"object" ;

  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"bool" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"uint" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"uint64" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"sint" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"sint64" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"char" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"double" ;
  appendStructASTForTypeWithLocation !?ioDeclarationListASTs !"string" ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper predefinedTypeGenerationTemplateEX in "../generation_templates/ex_type_generation" {
} {
#  template predefinedAPTypesHeaderPrologue "types-ap-predeclaration-prologue.h.gTemplate"
#    ?@stringset TYPE_LIST
#  ;
#  template predefinedTypesHeaderPrologue "types-predeclaration-prologue.h.gTemplate"
#    ?@stringset TYPE_LIST
#  ;
  template predefinedTypesImplementation "predefined_types.cpp.gTemplate"
  ;
}

#---------------------------------------------------------------------------*

filewrapper predefinedTypeGenerationTemplate in "../generation_templates/type_generation" {
} {
#  template predefinedAPTypesHeaderPrologue "types-ap-predeclaration-prologue.h.gTemplate"
#    ?@stringset TYPE_LIST
#  ;
  template predefinedTypesHeaderPrologue "types-predeclaration-prologue.h.gTemplate"
    ?@stringset TYPE_LIST
  ;
#  template predefinedTypesImplementation "predefined_types.cpp.gTemplate"
#  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# G E N E R A T E    P R E D E F I N E D    T Y P E    F I L E S            *
#                                                                           *
#---------------------------------------------------------------------------*

routine generatePredefinedTypeFiles ??@string inDirectory :
  if inDirectory != "" then
    if not [inDirectory directoryExists] then
      error here : "the '" . inDirectory . "' directory does not exist" ;
    else
    #------ Add predefined types to semantics declarations
      @semanticDeclarationListAST predefinedTypeASTlist [emptyList] ;
      appendPredefinedTypesASTs !?predefinedTypeASTlist ;
    #------ Build Semantic Context
      @semanticContext semanticContext ;
      buildSemanticContext
        !predefinedTypeASTlist
        !here
        ?semanticContext
      ;
    #------ Semantic Analysis
      @semanticDeclarationListForGeneration decoratedDeclarationListForGeneration ;
      performSemanticAnalysis
        !predefinedTypeASTlist
        !semanticContext
        ?decoratedDeclarationListForGeneration
      ;
    #------ Generate predefined auto pointer types declaration file
#      @string generatedCode := [filewrapper predefinedTypeGenerationTemplateEX.predefinedAPTypesHeaderPrologue
#        ![semanticContext->mTypeMap allKeys]
#      ] ;
#      foreach decoratedDeclarationListForGeneration do
#        generatedCode .= [mDeclaration appendAutoPointerClassDeclaration] ;
#        generatedCode .= [mDeclaration appendSpecificDeclaration] ;
#      end foreach ;
#      if [@uint errorCount] == 0 then
#        [@string generateFile
#          !inDirectory
#          !"predefined-ap-types.h"
#          !"//"
#          !"\n\n" # Defaut user zone1
#          !generatedCode
#          !"\n\n" # Defaut user zone2
#          !"#endif\n"
#        ] ;
#      end if ;
    #------ Generate predefined types declaration file
      @string generatedCode := [filewrapper predefinedTypeGenerationTemplate.predefinedTypesHeaderPrologue
        ![semanticContext->mTypeMap allKeys]
      ] ;
      foreach decoratedDeclarationListForGeneration do
        generatedCode .= [mDeclaration appendDeclaration] ;
      end foreach ;
      if [@uint errorCount] == 0 then
        [@string generateFile
          !inDirectory
          !"predefined-types.h"
          !"//"
          !"\n\n" # Defaut user zone1
          !generatedCode
          !"\n\n" # Defaut user zone2
          !"#endif\n"
        ] ;
      end if ;
    #------ Generate predefined types implementation
      generatedCode := [filewrapper predefinedTypeGenerationTemplateEX.predefinedTypesImplementation] ;
      foreach decoratedDeclarationListForGeneration do
        generatedCode .= [mDeclaration appendAutoPointerClassImplementation] ;
        generatedCode .= [mDeclaration appendSpecificImplementation] ;
        generatedCode .= [mDeclaration appendTypeGenericImplementation] ;
      end foreach ;
      if [@uint errorCount] == 0 then
        [@string generateFile
          !inDirectory
          !"predefined-types.cpp"
          !"//"
          !"\n\n" # Defaut user zone1
          !generatedCode
          !"\n\n" # Defaut user zone2
          !""
        ] ;
      end if ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
