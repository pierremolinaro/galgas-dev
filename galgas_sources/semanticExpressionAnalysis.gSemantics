#---------------------------------------------------------------------------*
#                                                                           *
#  Semantic Analysis of expression                                          *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticExpressionAnalysis :
  import "semanticsDecoratedTypes.gSemantics" ;
  import semantics semanticsDecoratedTypes in "semanticsDecoratedTypes.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    V A R I A B L E    M A P                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @variableMap {
  @unifiedTypeMapProxy mTypeProxy ;
  @string mCppName ;

#--- Used local constant
  state usedLocalConstant {
    readAccess      -> usedLocalConstant
    writeAccess     -> usedLocalConstant error "a constant cannot be written"
    readWriteAccess -> usedLocalConstant error "a constant cannot be written"
    dropAccess      -> usedLocalConstant error "a constant cannot be drop"
  }

#--- Local constant
  state localConstant warning "the '%K' constant value is unused" {
    readAccess      -> usedLocalConstant
    writeAccess     -> usedLocalConstant error "a constant cannot be written"
    readWriteAccess -> usedLocalConstant error "a constant cannot be written"
    dropAccess      -> usedLocalConstant error "a constant cannot be drop"
  }

#--- Local variable
  state undefinedLocalVariable warning "the '%K' local variable is unused" {
    readAccess      -> undefinedLocalVariable error "an undefined local variable cannot be read"
    writeAccess     -> definedLocalVariable
    readWriteAccess -> undefinedLocalVariable error "an undefined local variable cannot be read"
    dropAccess      -> undefinedLocalVariable warning "the local variable has no value"
  }
  state definedLocalVariable warning "the '%K' local variable value is unused" {
    readAccess      -> usedLocalVariable
    writeAccess     -> definedLocalVariable warning "the value has been changed without any read"
    readWriteAccess -> usedLocalVariable
    dropAccess      -> droppedLocalVariable warning "the local variable has been dropped without any read"
  }
  state usedLocalVariable {
    readAccess      -> usedLocalVariable
    writeAccess     -> definedLocalVariable
    readWriteAccess -> definedLocalVariable
    dropAccess      -> droppedLocalVariable
  }
  state droppedLocalVariable {
    readAccess      -> droppedLocalVariable error "a dropped local variable cannot be read"
    writeAccess     -> definedLocalVariable
    readWriteAccess -> definedLocalVariable error "a dropped local variable cannot be read"
    dropAccess      -> droppedLocalVariable warning "the local variable is already dropped"
  }

#--- Output formal parameter
  state undefinedOutputFormalParameter error "the '%K' output formal parameter is undefined" {
    readAccess      -> undefinedOutputFormalParameter error "an undefined output formal parameter cannot be read"
    writeAccess     -> definedOutputFormalParameter
    readWriteAccess -> undefinedOutputFormalParameter error "an undefined output formal parameter cannot be read"
    dropAccess      -> undefinedOutputFormalParameter warning "the output formal parameter has no value"
  }
  state definedOutputFormalParameter {
    readAccess      -> definedOutputFormalParameter
    writeAccess     -> definedOutputFormalParameter
    readWriteAccess -> definedOutputFormalParameter
    dropAccess      -> undefinedOutputFormalParameter
  }

#--- Input/Output formal parameter
  state unusedInputOutputFormalParameter warning "the '%K' input/output formal parameter is unused" {
    readAccess      -> usedInputOutputFormalParameter
    writeAccess     -> usedInputOutputFormalParameter
    readWriteAccess -> usedInputOutputFormalParameter
    dropAccess      -> droppedInputOutputFormalParameter
  }
  state usedInputOutputFormalParameter {
    readAccess      -> usedInputOutputFormalParameter
    writeAccess     -> usedInputOutputFormalParameter
    readWriteAccess -> usedInputOutputFormalParameter
    dropAccess      -> droppedInputOutputFormalParameter
  }
  state droppedInputOutputFormalParameter error "the '%K' input/ouput formal argument should be valuated at the end of the routine" {
    readAccess      -> droppedInputOutputFormalParameter error "a dropped input/output formal argument cannot be read"
    writeAccess     -> usedInputOutputFormalParameter
    readWriteAccess -> droppedInputOutputFormalParameter error "a dropped input/output formal argument cannot be read"
    dropAccess      -> droppedInputOutputFormalParameter warning "the input/output formal argument is already dropped"
  }

#--- Input/Output formal parameter declared as unused
  state inputOutputFormalParameterDeclaredAsUnused {
    readAccess      -> usedInputOutputFormalParameter warning "the input/output formal parameter has been declared as unused"
    writeAccess     -> usedInputOutputFormalParameter warning "the input/output formal parameter has been declared as unused"
    readWriteAccess -> usedInputOutputFormalParameter warning "the input/output formal parameter has been declared as unused"
    dropAccess      -> droppedInputOutputFormalParameter warning "the input/output formal parameter has been declared as unused"
  }

#--- Constant input formal parameter
  state constantInputFormalParameter warning "the constant '%K' input formal parameter is not used and is not declared as unused" {
    readAccess      -> usedConstantInputFormalParameter
    writeAccess     -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be written"
    readWriteAccess -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be written"
    dropAccess      -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be dropped"
  }
  state usedConstantInputFormalParameter {
    readAccess      -> usedConstantInputFormalParameter
    writeAccess     -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be written"
    readWriteAccess -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be written"
    dropAccess      -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be dropped"
  }

#--- Constant input formal parameter declared as unused
  state constantInputFormalParameterDeclaredAsUnused {
    readAccess      -> usedConstantInputFormalParameter warning "the constant input formal parameter is declared as unused"
    writeAccess     -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be written"
    readWriteAccess -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be written"
    dropAccess      -> usedConstantInputFormalParameter error "a constant input formal parameter cannot be dropped"
  }

#--- Input formal parameter
  state inputFormalParameter warning "the '%K' input formal parameter is not used and is not declared as unused" {
    readAccess      -> usedInputFormalParameter
    writeAccess     -> usedInputFormalParameter
    readWriteAccess -> usedInputFormalParameter
    dropAccess      -> droppedInputFormalParameter
  }
  state usedInputFormalParameter {
    readAccess      -> usedInputFormalParameter
    writeAccess     -> usedInputFormalParameter
    readWriteAccess -> usedInputFormalParameter
    dropAccess      -> droppedInputFormalParameter
  }
  state droppedInputFormalParameter {
    readAccess      -> droppedInputFormalParameter error "a dropped input formal parameter cannot be read"
    writeAccess     -> usedInputFormalParameter
    readWriteAccess -> droppedInputFormalParameter error "a dropped input formal parameter cannot be read"
    dropAccess      -> droppedInputFormalParameter warning "the input formal parameter is already dropped"
  }

#--- Input formal parameter declared as unused
  state inputFormalParameterDeclaredAsUnused {
    readAccess      -> usedInputFormalParameter warning "the input formal parameter is declared as unused"
    writeAccess     -> usedInputFormalParameter warning "the input formal parameter is declared as unused"
    readWriteAccess -> usedInputFormalParameter warning "the input formal parameter is declared as unused"
    dropAccess      -> droppedInputFormalParameter warning "the input formal parameter is declared as unused"
  }

#--- Insert methods 
  insert insertUndefinedLocalVariable state undefinedLocalVariable error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertDefinedLocalVariable state definedLocalVariable error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertLocalConstant state localConstant error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertUsedLocalConstant state usedLocalConstant error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertInputFormalArgument state inputFormalParameter error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertInputFormalArgumentDeclaredAsUnused state inputFormalParameterDeclaredAsUnused error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertConstantInputFormalArgument state constantInputFormalParameter error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertConstantInputFormalArgumentDeclaredAsUnused state constantInputFormalParameterDeclaredAsUnused error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertOutputFormalArgument state undefinedOutputFormalParameter error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertInputOutputFormalArgument state unusedInputOutputFormalParameter error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertInputOutputFormalArgumentDeclaredAsUnused state inputOutputFormalParameterDeclaredAsUnused error message "redefinition of '%K' variable (previous declaration was in %L)" ;


#--- Search methods
  search searchForReadAccess do readAccess error message "the '%K' variable is not declared" ;
  search searchForWriteAccess do writeAccess error message "the '%K' variable is not declared" ;
  search searchForReadWriteAccess do readWriteAccess error message "the '%K' variable is not declared" ;
  search searchForDropAccess do dropAccess error message "the '%K' variable is not declared" ;
}

#---------------------------------------------------------------------------*

routine checkAssignmentTypes
  ??@unifiedTypeMapProxy inTargetType
  ??@unifiedTypeMapProxy inSourceType
  ??@location inErrorLocation
:
  @unifiedTypeMapProxy sourceType := inSourceType ;
  @bool ok := inTargetType == inSourceType ;
  loop [@uint max] : while (not ok) & (not [[sourceType mSuperType] isNull]) do
    sourceType := [sourceType mSuperType] ;
    ok := inTargetType == inSourceType ;
  end loop ;
  if not ok then
    error inErrorLocation : "target object type is '@" . [inTargetType key] . "' and cannot be assigned by an '@" . [inSourceType key] . "' object" ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E M A N T I C    C O N T E X T    F O R    A N A L Y S I S           *
#                                                                           *
#---------------------------------------------------------------------------*

struct @predefinedTypes {
  @unifiedTypeMapProxy mLocationType ;
  @unifiedTypeMapProxy mBoolType ;
  @unifiedTypeMapProxy mCharType ;
  @unifiedTypeMapProxy mStringType ;
  @unifiedTypeMapProxy mUIntType ;
  @unifiedTypeMapProxy mSIntType ;
  @unifiedTypeMapProxy mUInt64Type ;
  @unifiedTypeMapProxy mSInt64Type ;
  @unifiedTypeMapProxy mDoubleType ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    E X P R E S S I O N    A N A L Y S I S                                 *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @semanticExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
;

#---------------------------------------------------------------------------*

override method @selfInExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  if [ioVariableMap hasKey !"self"] then
    @string selfCppName ;
    @unifiedTypeMapProxy selfType ;
    [!?ioVariableMap searchForReadAccess ![@lstring new !"self" !here] ?selfType ?selfCppName] ;
    outExpression := [@selfInExpressionForGeneration new !selfType !selfCppName] ;
  else
    error mSelfLocation: "'self' cannot be used in this context" : outExpression ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @hereExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@trueExpressionForGeneration new !inPredefinedTypes->mLocationType] ;
end method ;

#---------------------------------------------------------------------------*

override method @trueExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@trueExpressionForGeneration new !inPredefinedTypes->mBoolType] ;
end method ;

#---------------------------------------------------------------------------*

override method @falseExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@falseExpressionForGeneration new !inPredefinedTypes->mBoolType] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalCharExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalCharExpressionForGeneration new !inPredefinedTypes->mCharType !mCharacter] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalStringExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalStringExpressionForGeneration new !inPredefinedTypes->mStringType !mStringSequence] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalDoubleExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalDoubleExpressionForGeneration new !inPredefinedTypes->mDoubleType !mValue] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalUIntExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalUIntExpressionForGeneration new !inPredefinedTypes->mDoubleType !mValue] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalUInt64ExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalUInt64ExpressionForGeneration new !inPredefinedTypes->mUInt64Type !mValue] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalSIntExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalSIntExpressionForGeneration new !inPredefinedTypes->mSIntType !mValue] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalSInt64ExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalSInt64ExpressionForGeneration new !inPredefinedTypes->mSInt64Type !mValue] ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeConstructorInvocation
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  ??@lstring inTypeName
  ??@lstring inConstructorName
  ??@semanticExpressionListAST inConstuctorEffectiveParameterExpressions
  !@unifiedTypeMapProxy outReturnedType
  !@semanticExpressionListForGeneration outConstructorEffectiveParameterList 
:
#--- Get constructor map from type map
  @constructorMap constructorMap ;
  [inSemanticContext->mTypeMap searchKey !inTypeName ?6* ?constructorMap ?12*] ;
#--- Search contructor
  @unifiedTypeMapProxyList constructorFormalArgumentTypeList ;
  @bool hasCompilerArgument ;
  with constructorMap hasKey ![inConstructorName string] do
    constructorFormalArgumentTypeList := mArgumentTypeList ;
    hasCompilerArgument := mHasCompilerArgument ;
    outReturnedType := mReturnedType ;
  else
    @string s := "" ;
    foreach constructorMap do
      s .= "\n  - " . lkey ;
      foreach mArgumentTypeList do
        s .= " ?@" . [mType key] ;
      end foreach ;
      s .= " -> @" . [mReturnedType key] ;
    end foreach ;
    error inConstructorName
    : "the '@". inTypeName . "' type does not define the '" . inConstructorName . "' constructor; available constructors are:" . s
    : constructorFormalArgumentTypeList, hasCompilerArgument, outReturnedType
    ;
  end with ;
#--- Analysis arguments
  if [inConstuctorEffectiveParameterExpressions length] != [constructorFormalArgumentTypeList length] then
    error inConstructorName
    : "calling the '" . inConstructorName . "' constructor of '@" . inTypeName . "' requires "
    . [[constructorFormalArgumentTypeList length] string] . " parameter(s), while this call has "
    . [[inConstuctorEffectiveParameterExpressions length] string] . " parameter(s)" 
    : outConstructorEffectiveParameterList ;
  else
    outConstructorEffectiveParameterList := [@semanticExpressionListForGeneration emptyList] ;
    foreach inConstuctorEffectiveParameterExpressions, constructorFormalArgumentTypeList do
      @semanticExpressionForGeneration exp ;
      [mExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?exp] ;
      checkAssignmentTypes !mType ![exp mType] !mEndOfExpressionLocation ;
      outConstructorEffectiveParameterList += !exp ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @constructorExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  @unifiedTypeMapProxy returnedType ;
  @semanticExpressionListForGeneration constructorEffectiveParameterList ;
  analyzeConstructorInvocation
    !inSemanticContext
    !inPredefinedTypes
    !?ioVariableMap
    !mTypeName
    !mConstructorName
    !mExpressions
    ?returnedType
    ?constructorEffectiveParameterList
  ;
#--
  outExpression := [@constructorExpressionForGeneration new !returnedType !mConstructorName !constructorEffectiveParameterList] ;
end method ;

#---------------------------------------------------------------------------*

override method @readerCallExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration receiverExpression ;
  [mReceiver analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?receiverExpression] ;
  const @unifiedTypeMapProxy receiverType := [receiverExpression mType] ;
#--- Get reader map
  const @readerMap readerMap := [receiverType mReaderMap] ;
#--- Search contructor
  @unifiedTypeMapProxyList readerFormalArgumentTypeList ;
  @bool hasCompilerArgument ;
  @unifiedTypeMapProxy returnedType ;
  @string implicitConversionReader ;
  with readerMap hasKey ![mReaderName string] do
    readerFormalArgumentTypeList := mArgumentTypeList ;
    hasCompilerArgument := mHasCompilerArgument ;
    returnedType := mReturnedType ;
    implicitConversionReader := mImplicitConversionReader ;
  else
    @string s := "" ;
    foreach readerMap do
      s .= "\n  - " . lkey ;
      foreach mArgumentTypeList do
        s .= " ?@" . [mType key] ;
      end foreach ;
      s .= " -> @" . [mReturnedType key] ;
    end foreach ;
    error mReaderName
    : "the '@". [receiverType key] . "' type does not define the '" . mReaderName . "' reader; available readers are:" . s
    : readerFormalArgumentTypeList, hasCompilerArgument, returnedType, implicitConversionReader
    ;
  end with ;
#--- Analysis arguments
  if [mExpressions length] != [readerFormalArgumentTypeList length] then
    error mReaderName: "calling the '" . mReaderName . "' reader of '@" . [receiverType key] . "' requires "
    . [[readerFormalArgumentTypeList length] string] . " parameter(s), while this call has "
    . [[mExpressions length] string] . " parameter(s)" : outExpression ;
  else
    @semanticExpressionListForGeneration constructorEffectiveParameterList [emptyList] ;
    foreach mExpressions, readerFormalArgumentTypeList do
      @semanticExpressionForGeneration exp ;
      [mExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?exp] ;
      checkAssignmentTypes !mType ![exp mType] !mEndOfExpressionLocation ;
      constructorEffectiveParameterList += !exp ;
    end foreach ;
    outExpression := [@readerCallExpressionForGeneration new
      ![receiverExpression mType]
      !receiverExpression
      !mReaderName
      !constructorEffectiveParameterList
      !returnedType
      !implicitConversionReader
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @optionExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  @commandLineOptionMap boolOptionMap ;
  @commandLineOptionMap uintOptionMap ;
  @commandLineOptionMap stringOptionMap ;
  [inSemanticContext->mOptionComponentMapForSemanticAnalysis searchKey
    !mOptionComponentName
    ?boolOptionMap
    ?uintOptionMap
    ?stringOptionMap
  ] ;
  @bool found := [boolOptionMap hasKey ![mOptionEntryName string]] ;
  @unifiedTypeMapProxy returnedType := inPredefinedTypes->mBoolType ;
  if not found then
    found := [uintOptionMap hasKey ![mOptionEntryName string]] ;
    returnedType := inPredefinedTypes->mUIntType ;
  end if ;
  if not found then
    found := [stringOptionMap hasKey ![mOptionEntryName string]] ;
    returnedType := inPredefinedTypes->mStringType ;
  end if ;
  if found then
    if [mOptionReaderName string] == "value" then
      outExpression := [@optionValueExpressionForGeneration new
        !returnedType
        !mOptionComponentName
        !mOptionEntryName
      ] ;
    elsif [mOptionReaderName string] == "char" then
      outExpression := [@optionCharExpressionForGeneration new
        !inPredefinedTypes->mCharType
        !mOptionComponentName
        !mOptionEntryName
      ] ;
    elsif [mOptionReaderName string] == "string" then
      outExpression := [@optionStringExpressionForGeneration new
        !inPredefinedTypes->mStringType
        !mOptionComponentName
        !mOptionEntryName
      ] ;
    elsif [mOptionReaderName string] == "comment" then
      outExpression := [@optionCommentExpressionForGeneration new
        !inPredefinedTypes->mStringType
        !mOptionComponentName
        !mOptionEntryName
      ] ;
    else
      error mOptionReaderName:"only the 'value', 'char', 'string' and 'comment' readers are defined for an option" :outExpression ;
    end if ;
  else
    @string s := "" ;
    foreach boolOptionMap do
      s .= "\n-  '" . lkey . "' @bool option;" ;
    end foreach ;
    foreach uintOptionMap do
      s .= "\n-  '" . lkey . "' @uint option;" ;
    end foreach ;
    foreach stringOptionMap do
      s .= "\n-  '" . lkey . "' @string option;" ;
    end foreach ;
    error mOptionEntryName
    : "the '" . mOptionComponentName . "' option component does not define the '" . mOptionEntryName . "' option; available options:" . s
    : outExpression
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

routine checkDiadicOperator
  ??@unifiedTypeMapProxy inLeftType
  ??@unifiedTypeMapProxy inRightType
  ??@bool inOperandIsHandled
  ??@string inOperatorNameForErrorMessage
  ??@location inErrorLocation
:
  if not inOperandIsHandled then
    error inErrorLocation
    : "left operand type is '@" . [inLeftType key] . "' and does not accept '" . inOperatorNameForErrorMessage . "' operator (right operand type is '@" . [inRightType key] . ")"
    ;
  elsif inLeftType != inRightType then
    error inErrorLocation
    : "left operand type of '" . inOperatorNameForErrorMessage . "' operator is '@" . [inLeftType key] . "', right operand type is '@" . [inRightType key] . "'; they should be the same"
    ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @concatExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binaryConcatOperator []) != 0
    !"."
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@concatExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @orExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binaryOrOperator []) != 0
    !"|"
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@orExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @andExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binaryAndOperator []) != 0
    !"&"
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@andExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @xorExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binaryXorOperator []) != 0
    !"^"
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@xorExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @equalExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mType] ;
  if [[leftType lkey] string] != [[rightType lkey] string] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType lkey] . "', right operand type is '@" . [rightType lkey] . "': '==' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@equalExpressionForGeneration new
      !inPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @notEqualExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mType] ;
  if [[leftType lkey] string] != [[rightType lkey] string] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '!=' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@notEqualExpressionForGeneration new
      !inPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lowerOrEqualExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mType] ;
  if ([leftType mHandledOperatorFlags] & doNotGenererateObjectCompare []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support the '<=' operator"
    :outExpression
    ;
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '<=' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@lowerOrEqualExpressionForGeneration new
      !inPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @greaterOrEqualExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mType] ;
  if ([leftType mHandledOperatorFlags] & doNotGenererateObjectCompare []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support the '>=' operator"
    :outExpression
    ;
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '>=' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@greaterOrEqualExpressionForGeneration new
      !inPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @strictGreaterExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mType] ;
  if ([leftType mHandledOperatorFlags] & doNotGenererateObjectCompare []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support the '>' operator"
    :outExpression
    ;
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '>' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@strictGreaterExpressionForGeneration new
      !inPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @strictLowerExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mType] ;
  if ([leftType mHandledOperatorFlags] & doNotGenererateObjectCompare []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support the '<' operator"
    :outExpression
    ;
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '<' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@strictLowerExpressionForGeneration new
      !inPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @rightShiftExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mType] ;
  if ([leftType mHandledOperatorFlags] & binaryShiftOperator []) != 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support a shift operator"
    :outExpression
    ;
  elsif [rightType key] != "uint" then
    error mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" . [rightType key] . "'"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@rightShiftExpressionForGeneration new
      !leftType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @leftShiftExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mType] ;
  if ([leftType mHandledOperatorFlags] & binaryShiftOperator []) != 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support a shift operator"
    :outExpression
    ;
  elsif [rightType key] != "uint" then
    error mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" . [rightType key] . "'"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@rightShiftExpressionForGeneration new
      !leftType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @addExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binaryAddOperator []) != 0
    !"+"
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@addExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @subExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binarySubOperator []) != 0
    !"-"
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@subExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @multiplicationExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binaryMulOperator []) != 0
    !"*"
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@multiplicationExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @divisionExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binaryDivOperator []) != 0
    !"/"
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@divisionExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @moduloExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mType]
    !([leftType mHandledOperatorFlags] & binaryModOperator []) != 0
    !"mod"
    !mOperatorLocation
  ;  
#--- Generate expression
  outExpression := [@moduloExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @unaryMinusExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?expression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy type := [expression mType] ;
  if ([type mHandledOperatorFlags] & unaryMinusOperator []) != 0 then
    error mOperatorLocation
    : "operand type is '@" . [type key] . "' and does not support the unary minus operator"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@unaryMinusExpressionForGeneration new
      !type
      !mOperatorLocation
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @notExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?expression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy type := [expression mType] ;
  if ([type mHandledOperatorFlags] & unaryNotOperator []) != 0 then
    error mOperatorLocation
    : "operand type is '@" . [type key] . "' and does not support the 'not' operator"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@notExpressionForGeneration new
      !type
      !mOperatorLocation
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @complementExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?expression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy type := [expression mType] ;
  if ([type mHandledOperatorFlags] & unaryTildeOperator []) != 0 then
    error mOperatorLocation
    : "operand type is '@" . [type key] . "' and does not support the '~' operator"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@complementExpressionForGeneration new
      !type
      !mOperatorLocation
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @ifExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- 'if' expression analysis
  @semanticExpressionForGeneration if_expression ;
  [mIfExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?if_expression] ;
#--- 'then' expression analysis
  @semanticExpressionForGeneration then_expression ;
  [mThenExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?then_expression] ;
#--- 'else' expression analysis
  @semanticExpressionForGeneration else_expression ;
  [mElseExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?else_expression] ;
#--- Check 'if' expression is boolean
  if [[if_expression mType] key] != "bool" then
    error mOperatorLocation
    :"the test expression type is '@" . [[if_expression mType] key] . "', it should be '@bool'"
    :outExpression
    ;
  elsif [then_expression mType] != [else_expression mType] then
    error mOperatorLocation
    :"operand expression types are '@" . [[then_expression mType] key] . "' and '@". [[else_expression mType] key] . "': they should be the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@ifExpressionForGeneration new
      ![then_expression mType]
      !mOperatorLocation
      !if_expression
      !then_expression
      !else_expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @functionCallExpressionAST analyzeSemanticExpression
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Retrieve function features
  @unifiedTypeMapProxyList functionSignature ;
  @unifiedTypeMapProxy resultType ;
  [inSemanticContext->mFunctionMap searchKey !mFunctionName ?functionSignature ?resultType] ;
#--- Analyze effective parameters
  if [functionSignature length] != [mExpressions length] then
    error mFunctionName
    :"the '" . mFunctionName . "' function header declares " . [[functionSignature length] string]
      . " formal parameter(s), but this function call names " . [[mExpressions length] string]
      . " effective argument(s)"
    : outExpression
    ;
  else
    @semanticExpressionListForGeneration semanticExpressionListForGeneration [emptyList] ;
    foreach functionSignature, mExpressions do
      @semanticExpressionForGeneration expression ;
      [mExpression analyzeSemanticExpression !inSemanticContext !inPredefinedTypes !?ioVariableMap ?expression] ;
      checkAssignmentTypes !mType ![expression mType] !mEndOfExpressionLocation ;
      semanticExpressionListForGeneration += !expression ;
    end foreach ;
    outExpression := [@functionCallExpressionForGeneration new
      !resultType
      !mFunctionName
      !semanticExpressionListForGeneration
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @varInExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  @unifiedTypeMapProxy type ;
  @string sourceVariableCppName ;
  [!?ioVariableMap searchForReadAccess !mVarName ?type ?sourceVariableCppName] ;
  foreach mStructFieldList do
    const @attributeMap attributeMap := [type mAttributeMap] ;
    [attributeMap searchKey !mValue ?type] ;
  end foreach ;
  outExpression := [@varInExpressionForGeneration new
    !type
    !sourceVariableCppName
    !mStructFieldList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalTypeInExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  error mLiteralTypeName
  : "unhandled expression"
  : outExpression
  ;
end method ;

#---------------------------------------------------------------------------*

override method @castInExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  error mEndOfReceiverExpression
  : "unhandled expression"
  : outExpression
  ;
end method ;

#---------------------------------------------------------------------------*

override method @filewrapperObjectInstanciationInExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused  inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  error mFilewrapperName
  : "unhandled expression"
  : outExpression
  ;
end method ;

#---------------------------------------------------------------------------*

override method @filewrapperInExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  error mFilewrapperName
  : "unhandled expression"
  : outExpression
  ;
end method ;

#---------------------------------------------------------------------------*

override method @filewrapperTemplateInExpressionAST analyzeSemanticExpression
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  error mFilewrapperName
  : "unhandled expression"
  : outExpression
  ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
