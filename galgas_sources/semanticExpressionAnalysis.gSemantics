#---------------------------------------------------------------------------*
#                                                                           *
#  Semantic Analysis of expression                                          *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticExpressionAnalysis :
  import "semanticsDecoratedTypes.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    V A R I A B L E    M A P                                               *
#                                                                           *
#---------------------------------------------------------------------------*

uniquemap @variableMap @variableMapProxy {
  @unifiedTypeMapProxy mTypeProxy ;
  @string mCppName ;
  @string mNameForCheckingFormalParameterUsing ;

#--- Used local constant
  state usedLocalConstant {
    readAccess      -> usedLocalConstant
    writeAccess     -> usedLocalConstant error "a constant cannot be written"
    readWriteAccess -> usedLocalConstant error "a constant cannot be written"
    dropAccess      -> usedLocalConstant error "a constant cannot be drop"
  }

#--- Local constant
  state localConstant warning "the '%K' constant value is unused" {
    readAccess      -> usedLocalConstant
    writeAccess     -> usedLocalConstant error "a constant cannot be written"
    readWriteAccess -> usedLocalConstant error "a constant cannot be written"
    dropAccess      -> usedLocalConstant error "a constant cannot be drop"
  }

#--- Undefined Local constant
  state undefinedLocalConstant warning "the '%K' constant value is unused" {
    readAccess      -> undefinedLocalConstant error "the constant is undefined"
    writeAccess     -> localConstant
    readWriteAccess -> undefinedLocalConstant error "the constant is undefined"
    dropAccess      -> undefinedLocalConstant error "the constant is undefined"
  }

#--- Local variable
  state undefinedLocalVariable warning "the '%K' local variable is unused" {
    readAccess      -> undefinedLocalVariable error "an undefined local variable cannot be read"
    writeAccess     -> definedLocalVariable
    readWriteAccess -> undefinedLocalVariable error "an undefined local variable cannot be read"
    dropAccess      -> undefinedLocalVariable warning "the local variable has no value"
  }
  state definedLocalVariable { # warning "the '%K' local variable value is unused" {
    readAccess      -> usedLocalVariable
    writeAccess     -> definedLocalVariable # warning "the value has been changed without any read"
    readWriteAccess -> usedLocalVariable
    dropAccess      -> droppedLocalVariable warning "the local variable has been dropped without any read"
  }
  state usedLocalVariable {
    readAccess      -> usedLocalVariable
    writeAccess     -> definedLocalVariable
    readWriteAccess -> definedLocalVariable
    dropAccess      -> droppedLocalVariable
  }
  state droppedLocalVariable {
    readAccess      -> droppedLocalVariable error "a dropped local variable cannot be read"
    writeAccess     -> definedLocalVariable
    readWriteAccess -> definedLocalVariable error "a dropped local variable cannot be read"
    dropAccess      -> droppedLocalVariable warning "the local variable is already dropped"
  }

#--- Output formal parameter
  state undefinedOutputFormalArgument error "the '%K' output formal parameter is undefined" {
    readAccess      -> undefinedOutputFormalArgument error "an undefined output formal parameter cannot be read"
    writeAccess     -> definedOutputFormalArgument
    readWriteAccess -> undefinedOutputFormalArgument error "an undefined output formal parameter cannot be read"
    dropAccess      -> undefinedOutputFormalArgument warning "the output formal parameter has no value"
  }
  state definedOutputFormalArgument {
    readAccess      -> definedOutputFormalArgument
    writeAccess     -> definedOutputFormalArgument
    readWriteAccess -> definedOutputFormalArgument
    dropAccess      -> undefinedOutputFormalArgument
  }

#--- Input/Output formal parameter
  state unusedInputOutputFormalArgument warning "the '%K' input/output formal parameter is unused" {
    readAccess      -> usedInputOutputFormalArgument
    writeAccess     -> usedInputOutputFormalArgument
    readWriteAccess -> usedInputOutputFormalArgument
    dropAccess      -> droppedInputOutputFormalArgument
  }
  state usedInputOutputFormalArgument {
    readAccess      -> usedInputOutputFormalArgument
    writeAccess     -> usedInputOutputFormalArgument
    readWriteAccess -> usedInputOutputFormalArgument
    dropAccess      -> droppedInputOutputFormalArgument
  }
  state droppedInputOutputFormalArgument error "the '%K' input/ouput formal argument should be valuated at the end of the routine" {
    readAccess      -> droppedInputOutputFormalArgument error "a dropped input/output formal argument cannot be read"
    writeAccess     -> usedInputOutputFormalArgument
    readWriteAccess -> droppedInputOutputFormalArgument error "a dropped input/output formal argument cannot be read"
    dropAccess      -> droppedInputOutputFormalArgument warning "the input/output formal argument is already dropped"
  }

#--- Input/Output formal parameter declared as unused
  state inputOutputFormalArgumentDeclaredAsUnused {
    readAccess      -> usedInputOutputFormalArgument warning "the input/output formal parameter has been declared as unused"
    writeAccess     -> usedInputOutputFormalArgument warning "the input/output formal parameter has been declared as unused"
    readWriteAccess -> usedInputOutputFormalArgument warning "the input/output formal parameter has been declared as unused"
    dropAccess      -> droppedInputOutputFormalArgument warning "the input/output formal parameter has been declared as unused"
  }

#--- Constant input formal parameter
  state constantInputFormalArgument warning "the constant '%K' input formal parameter is not used and is not declared as unused" {
    readAccess      -> usedConstantInputFormalArgument
    writeAccess     -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be written"
    readWriteAccess -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be written"
    dropAccess      -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be dropped"
  }
  state usedConstantInputFormalArgument {
    readAccess      -> usedConstantInputFormalArgument
    writeAccess     -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be written"
    readWriteAccess -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be written"
    dropAccess      -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be dropped"
  }

#--- Constant input formal parameter declared as unused
  state constantInputFormalArgumentDeclaredAsUnused {
    readAccess      -> usedConstantInputFormalArgument warning "the constant input formal parameter is declared as unused"
    writeAccess     -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be written"
    readWriteAccess -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be written"
    dropAccess      -> usedConstantInputFormalArgument error "a constant input formal parameter cannot be dropped"
  }

#--- Input formal parameter
  state inputFormalParameter warning "the '%K' input formal parameter is not used and is not declared as unused" {
    readAccess      -> usedInputFormalArgument
    writeAccess     -> usedInputFormalArgument
    readWriteAccess -> usedInputFormalArgument
    dropAccess      -> droppedInputFormalArgument
  }
  state usedInputFormalArgument {
    readAccess      -> usedInputFormalArgument
    writeAccess     -> usedInputFormalArgument
    readWriteAccess -> usedInputFormalArgument
    dropAccess      -> droppedInputFormalArgument
  }
  state droppedInputFormalArgument {
    readAccess      -> droppedInputFormalArgument error "a dropped input formal parameter cannot be read"
    writeAccess     -> usedInputFormalArgument
    readWriteAccess -> droppedInputFormalArgument error "a dropped input formal parameter cannot be read"
    dropAccess      -> droppedInputFormalArgument warning "the input formal parameter is already dropped"
  }

#--- Input formal parameter declared as unused
  state inputFormalArgumentDeclaredAsUnused {
    readAccess      -> usedInputFormalArgument warning "the input formal parameter is declared as unused"
    writeAccess     -> usedInputFormalArgument warning "the input formal parameter is declared as unused"
    readWriteAccess -> usedInputFormalArgument warning "the input formal parameter is declared as unused"
    dropAccess      -> droppedInputFormalArgument warning "the input formal parameter is declared as unused"
  }

#--- Current instance attribute in a method or a reader
  state currentInstanceAttribute {
    readAccess      -> currentInstanceAttribute
    writeAccess     -> currentInstanceAttribute error "an attribute cannot be written within a method or a reader"
    readWriteAccess -> currentInstanceAttribute error "an attribute cannot be modified within a method or a reader"
    dropAccess      -> currentInstanceAttribute error "an attribute cannot be dropped within a method or a reader"
  }

#--- Current instance attribute in a modifier
  state currentInstanceAttributeInModifier {
    readAccess      -> currentInstanceAttributeInModifier
    writeAccess     -> currentInstanceAttributeInModifier
    readWriteAccess -> currentInstanceAttributeInModifier
    dropAccess      -> currentInstanceDroppedAttributeInModifier
  }

  state currentInstanceDroppedAttributeInModifier warning "the '%K' attribute is in the dropped state at the end of the modifier" {
    readAccess      -> currentInstanceDroppedAttributeInModifier error "the attribute cannot be read, it has been dropped"
    writeAccess     -> currentInstanceAttributeInModifier
    readWriteAccess -> currentInstanceDroppedAttributeInModifier error "the attribute cannot be read/written, it has been dropped"
    dropAccess      -> currentInstanceDroppedAttributeInModifier  warning "the attribute is already dropped"
  }

#--- Insert methods 
  insert insertMutableAttribute state currentInstanceAttributeInModifier error message "redefinition of '%K' attribute (previous declaration was in %L)" ;
  insert insertNonMutableAttribute state currentInstanceAttribute error message "redefinition of '%K' attribute (previous declaration was in %L)" ;
  insert insertUndefinedLocalVariable state undefinedLocalVariable error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertDefinedLocalVariable state definedLocalVariable error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertUndefinedLocalConstant state undefinedLocalConstant error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertLocalConstant state localConstant error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertUsedLocalConstant state usedLocalConstant error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertInputFormalArgument state inputFormalParameter error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertInputFormalArgumentDeclaredAsUnused state inputFormalArgumentDeclaredAsUnused error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertConstantInputFormalArgument state constantInputFormalArgument error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertConstantInputFormalArgumentDeclaredAsUnused state constantInputFormalArgumentDeclaredAsUnused error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertOutputFormalArgument state undefinedOutputFormalArgument error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertInputOutputFormalArgument state unusedInputOutputFormalArgument error message "redefinition of '%K' variable (previous declaration was in %L)" ;
  insert insertInputOutputFormalArgumentDeclaredAsUnused state inputOutputFormalArgumentDeclaredAsUnused error message "redefinition of '%K' variable (previous declaration was in %L)" ;

#--- Search methods
  search searchForReadAccess do readAccess error message "the '%K' variable is not declared" ;
  search searchForWriteAccess do writeAccess error message "the '%K' variable is not declared" ;
  search searchForReadWriteAccess do readWriteAccess error message "the '%K' variable is not declared" ;
  search searchForDropAccess do dropAccess error message "the '%K' variable is not declared" ;

#--- 'selectBlock' override definitions
  override selectBlock {
    currentInstanceAttributeInModifier:currentInstanceDroppedAttributeInModifier -> currentInstanceDroppedAttributeInModifier
    currentInstanceDroppedAttributeInModifier:currentInstanceAttributeInModifier -> currentInstanceAttributeInModifier
    constantInputFormalArgument:usedConstantInputFormalArgument -> usedConstantInputFormalArgument
    constantInputFormalArgumentDeclaredAsUnused:usedConstantInputFormalArgument -> usedConstantInputFormalArgument
    definedLocalVariable:droppedLocalVariable -> droppedLocalVariable
    definedLocalVariable:usedLocalVariable -> usedLocalVariable
    definedOutputFormalArgument:undefinedOutputFormalArgument -> undefinedOutputFormalArgument
    droppedInputFormalArgument:usedInputFormalArgument -> usedInputFormalArgument
    droppedInputOutputFormalArgument:usedInputOutputFormalArgument -> usedInputOutputFormalArgument
    droppedLocalVariable:definedLocalVariable -> definedLocalVariable
    inputFormalParameter:droppedInputFormalArgument -> droppedInputFormalArgument
    inputFormalParameter:usedInputFormalArgument -> usedInputFormalArgument
    inputFormalArgumentDeclaredAsUnused:droppedInputFormalArgument -> droppedInputFormalArgument
    inputFormalArgumentDeclaredAsUnused:usedInputFormalArgument -> usedInputFormalArgument
    inputOutputFormalArgumentDeclaredAsUnused:droppedInputOutputFormalArgument -> droppedInputOutputFormalArgument
    inputOutputFormalArgumentDeclaredAsUnused:usedInputOutputFormalArgument -> usedInputOutputFormalArgument
    localConstant:usedLocalConstant -> usedLocalConstant
    undefinedLocalVariable:definedLocalVariable -> definedLocalVariable
    undefinedOutputFormalArgument:definedOutputFormalArgument -> definedOutputFormalArgument
    unusedInputOutputFormalArgument:droppedInputOutputFormalArgument -> droppedInputOutputFormalArgument
    unusedInputOutputFormalArgument:usedInputOutputFormalArgument -> usedInputOutputFormalArgument
    usedInputFormalArgument:droppedInputFormalArgument -> droppedInputFormalArgument
    usedInputOutputFormalArgument:droppedInputOutputFormalArgument -> droppedInputOutputFormalArgument
    usedLocalVariable:definedLocalVariable -> definedLocalVariable
    usedLocalVariable:droppedLocalVariable -> droppedLocalVariable
    droppedLocalVariable:usedLocalVariable -> usedLocalVariable
    undefinedLocalVariable:droppedLocalVariable -> droppedLocalVariable
    undefinedLocalVariable:usedLocalVariable -> usedLocalVariable
    undefinedLocalConstant:localConstant -> undefinedLocalConstant error "this branch defines the '%K' variable, while previous ones let it undefined"
    undefinedLocalConstant:usedLocalConstant -> undefinedLocalConstant error "this branch defines the '%K' variable, while previous ones let it undefined"
  }{
    currentInstanceAttributeInModifier:currentInstanceDroppedAttributeInModifier -> currentInstanceAttributeInModifier error "this branch drops the '%K' attribute, while previous ones let it defined"
    currentInstanceDroppedAttributeInModifier:currentInstanceAttributeInModifier -> currentInstanceAttributeInModifier error "this branch lets the '%K' attribute defined, while previous ones drop it"
    constantInputFormalArgument:usedConstantInputFormalArgument -> usedConstantInputFormalArgument
    constantInputFormalArgumentDeclaredAsUnused:usedConstantInputFormalArgument -> usedConstantInputFormalArgument
    definedLocalVariable:droppedLocalVariable -> definedLocalVariable error "this branch drops the '%K' variable, while previous ones let it defined"
    definedLocalVariable:undefinedLocalVariable -> definedLocalVariable error "this branch lets the '%K' variable undefined, while previous ones define it"
    definedLocalVariable:usedLocalVariable -> usedLocalVariable
    definedOutputFormalArgument:undefinedOutputFormalArgument -> definedOutputFormalArgument error "this branch lets the '%K' variable undefined, while previous ones define it"
    droppedInputFormalArgument:inputFormalParameter -> droppedInputFormalArgument error "this branch drops the '%K' input formal argument, while previous ones let it defined"
    droppedInputFormalArgument:inputFormalArgumentDeclaredAsUnused -> droppedInputFormalArgument
    droppedInputFormalArgument:usedInputFormalArgument -> usedInputFormalArgument error "this branch defines the '%K' input formal argument, while previous ones let it dropped"
    droppedInputOutputFormalArgument:inputOutputFormalArgumentDeclaredAsUnused -> inputOutputFormalArgumentDeclaredAsUnused error "this branch lets the '%K' input formal argument defined, while previous ones drop it"
    droppedInputOutputFormalArgument:unusedInputOutputFormalArgument -> unusedInputOutputFormalArgument error "this branch lets the '%K' input/output formal argument defined, while previous ones drop it"
    droppedInputOutputFormalArgument:usedInputOutputFormalArgument -> usedInputOutputFormalArgument error "this branch lets the '%K' input/output formal argument defined, while previous ones drop it"
    droppedLocalVariable:definedLocalVariable -> droppedLocalVariable error "this branch defines the '%K' variable, while previous ones drop it"
    droppedLocalVariable:usedLocalVariable -> droppedLocalVariable error "this branch defines the '%K' variable, while previous ones drop it"
    inputFormalParameter:droppedInputFormalArgument ->inputFormalParameter error "this branch drops the '%K' input formal argument, while previous let it defined"
    inputFormalParameter:usedInputFormalArgument -> usedInputFormalArgument
    inputFormalArgumentDeclaredAsUnused:usedInputFormalArgument -> usedInputFormalArgument
    inputOutputFormalArgumentDeclaredAsUnused:droppedInputOutputFormalArgument -> inputOutputFormalArgumentDeclaredAsUnused error "this branch drops the '%K' input formal argument defined, while previous ones let it defined"
    inputOutputFormalArgumentDeclaredAsUnused:usedInputOutputFormalArgument -> inputOutputFormalArgumentDeclaredAsUnused
    localConstant:usedLocalConstant -> usedLocalConstant
    undefinedLocalVariable:definedLocalVariable -> definedLocalVariable error "this branch defines the '%K' variable, while previous ones let it undefined"
    undefinedOutputFormalArgument:definedOutputFormalArgument -> definedOutputFormalArgument error "this branch defines the '%K' output formal argument, while previous ones let it undefined"
    unusedInputOutputFormalArgument:droppedInputOutputFormalArgument -> unusedInputOutputFormalArgument error "this branch drops the '%K' input/output formal argument, while previous ones let it undefined"
    unusedInputOutputFormalArgument:usedInputOutputFormalArgument -> usedInputOutputFormalArgument
    usedInputFormalArgument:droppedInputFormalArgument -> usedInputFormalArgument error "this branch drops the '%K' input formal argument, while previous ones let it defined"
    usedInputOutputFormalArgument:droppedInputOutputFormalArgument -> usedInputOutputFormalArgument error "this branch drops the '%K' input/output formal argument, while previous ones let it defined"
    usedLocalVariable:droppedLocalVariable -> usedLocalVariable error "this branch drops the '%K' variable, while previous ones let it defined"
    droppedLocalVariable:undefinedLocalVariable -> droppedLocalVariable
    undefinedLocalVariable:usedLocalVariable -> undefinedLocalVariable error "this branch defines the '%K' variable, while previous ones let it undefined"
    usedLocalVariable:undefinedLocalVariable -> usedLocalVariable error "this branch lets the '%K' variable undefined, while previous defines let it"
  }

#--- 'repeatBlock' override definitions
  override repeatBlock {
    undefinedLocalConstant:localConstant -> undefinedLocalConstant error "the repeated branch should not define the '%K' variable"
    undefinedLocalConstant:usedLocalConstant -> undefinedLocalConstant error "the repeated branch should not define the '%K' variable"
    currentInstanceAttributeInModifier:currentInstanceDroppedAttributeInModifier -> currentInstanceAttributeInModifier error "the repeated branch should not drop the '%K' attribute"
    currentInstanceDroppedAttributeInModifier:currentInstanceAttributeInModifier -> currentInstanceAttributeInModifier
    constantInputFormalArgument:usedConstantInputFormalArgument -> usedConstantInputFormalArgument
    constantInputFormalArgumentDeclaredAsUnused:usedConstantInputFormalArgument -> usedConstantInputFormalArgument
    definedLocalVariable:droppedLocalVariable -> definedLocalVariable error "the repeated branch should not drop the '%K' variable"
    definedLocalVariable:usedLocalVariable -> usedLocalVariable
    definedOutputFormalArgument:undefinedOutputFormalArgument -> definedOutputFormalArgument error "the repeated branch should not drop the '%K' output formal argument"
    droppedInputFormalArgument:usedInputFormalArgument -> droppedInputFormalArgument error "the repeated branch should not drop the '%K' input formal argument"
    droppedInputOutputFormalArgument:usedInputOutputFormalArgument -> droppedInputOutputFormalArgument error "the repeated branch should define the '%K' input formal argument"
    droppedLocalVariable:definedLocalVariable -> droppedLocalVariable error "the repeated branch should not drop the '%K' variable"
    inputFormalArgumentDeclaredAsUnused:droppedInputFormalArgument -> inputFormalArgumentDeclaredAsUnused error "the repeated branch should not drop the '%K' input formal argument"
    inputFormalArgumentDeclaredAsUnused:usedInputFormalArgument -> usedInputFormalArgument
    inputFormalParameter:droppedInputFormalArgument -> inputFormalParameter error "the repeated branch should not drop the '%K' input formal argument"
    inputFormalParameter:usedInputFormalArgument -> usedInputFormalArgument
    inputOutputFormalArgumentDeclaredAsUnused:droppedInputOutputFormalArgument -> inputOutputFormalArgumentDeclaredAsUnused error "the repeated branch should not drop the '%K' input/output formal argument"
    inputOutputFormalArgumentDeclaredAsUnused:usedInputOutputFormalArgument -> usedInputOutputFormalArgument
    localConstant:usedLocalConstant -> usedLocalConstant
    undefinedLocalVariable:definedLocalVariable -> undefinedLocalVariable error "the repeated branch should not define the '%K' variable"
    undefinedOutputFormalArgument:definedOutputFormalArgument -> undefinedOutputFormalArgument error "the repeated branch should not define the '%K' output formal argument"
    unusedInputOutputFormalArgument:droppedInputOutputFormalArgument -> unusedInputOutputFormalArgument error "the repeated branch should not drop the '%K' input/output formal argument"
    unusedInputOutputFormalArgument:usedInputOutputFormalArgument -> usedInputOutputFormalArgument
    usedInputFormalArgument:droppedInputFormalArgument -> usedInputFormalArgument error "the repeated branch should not drop the '%K' input formal argument"
    usedInputOutputFormalArgument:droppedInputOutputFormalArgument -> usedInputOutputFormalArgument error "the repeated branch should not drop the '%K' input/output formal argument"
    usedLocalVariable:definedLocalVariable -> definedLocalVariable
    usedLocalVariable:droppedLocalVariable -> usedLocalVariable error "the repeated branch should not drop the '%K' variable"
    droppedLocalVariable:usedLocalVariable -> droppedLocalVariable error "the repeated branch should not define the dropped '%K' variable"
    undefinedLocalVariable:droppedLocalVariable -> droppedLocalVariable
    undefinedLocalVariable:usedLocalVariable -> undefinedLocalVariable error "the repeated branch should not define the '%K' variable"
  }{
    currentInstanceAttributeInModifier:currentInstanceDroppedAttributeInModifier -> currentInstanceAttributeInModifier
    constantInputFormalArgument:usedConstantInputFormalArgument -> usedConstantInputFormalArgument
    constantInputFormalArgumentDeclaredAsUnused:usedConstantInputFormalArgument -> usedConstantInputFormalArgument
    definedLocalVariable:usedLocalVariable -> usedLocalVariable
    inputFormalArgumentDeclaredAsUnused:usedInputFormalArgument -> usedInputFormalArgument
    inputFormalParameter:usedInputFormalArgument -> usedInputFormalArgument
    localConstant:usedLocalConstant -> usedLocalConstant
    inputOutputFormalArgumentDeclaredAsUnused:usedInputOutputFormalArgument -> usedInputOutputFormalArgument
    usedInputOutputFormalArgument:unusedInputOutputFormalArgument -> usedInputOutputFormalArgument
    droppedLocalVariable:undefinedLocalVariable -> droppedLocalVariable
  }
}

#---------------------------------------------------------------------------*

routine checkAssignmentTypes
  ??@unifiedTypeMapProxy inTargetType
  ??@unifiedTypeMapProxy inSourceType
  ??@location inErrorLocation
:
  @unifiedTypeMapProxy sourceType := inSourceType ;
  @bool ok := inTargetType == inSourceType ;
  loop [@uint max] : while (not ok) & (not [[sourceType mSuperType] isNull]) do
    sourceType := [sourceType mSuperType] ;
    ok := inTargetType == sourceType ;
  end loop ;
  if not ok then
    error inErrorLocation : "target object type is '@" . [inTargetType key] . "' and cannot be assigned from an '@" . [inSourceType key] . "' object" ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E M A N T I C    C O N T E X T    F O R    A N A L Y S I S           *
#                                                                           *
#---------------------------------------------------------------------------*

struct @predefinedTypes {
  @unifiedTypeMapProxy mLocationType ;
  @unifiedTypeMapProxy mBoolType ;
  @unifiedTypeMapProxy mCharType ;
  @unifiedTypeMapProxy mStringType ;
  @unifiedTypeMapProxy mUIntType ;
  @unifiedTypeMapProxy mSIntType ;
  @unifiedTypeMapProxy mUInt64Type ;
  @unifiedTypeMapProxy mSInt64Type ;
  @unifiedTypeMapProxy mDoubleType ;
  @unifiedTypeMapProxy mLBoolType ;
  @unifiedTypeMapProxy mLCharType ;
  @unifiedTypeMapProxy mLStringType ;
  @unifiedTypeMapProxy mLUIntType ;
  @unifiedTypeMapProxy mLSIntType ;
  @unifiedTypeMapProxy mLUInt64Type ;
  @unifiedTypeMapProxy mLSInt64Type ;
  @unifiedTypeMapProxy mLDoubleType ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    A N A L Y S I S    C O N T E X T                                       *
#                                                                           *
#---------------------------------------------------------------------------*

struct @analysisContext {
  @semanticContext mSemanticContext ;
  @predefinedTypes mPredefinedTypes ;
  @unifiedTypeMapProxy mSelfCopyTypeProxy ; # isNull if outside a category
  @string mSelfObjectCppName ;
  @unifiedTypeMapProxy mSelfTypeProxy ; # isNull if outside a modifier category
}

#---------------------------------------------------------------------------*
#                                                                           *
#    E X P R E S S I O N    A N A L Y S I S                                 *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @semanticExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
;

#---------------------------------------------------------------------------*
#! Literal

override method @selfCopyInExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  if [inAnalysisContext->mSelfCopyTypeProxy isNull] then
    error mSelfLocation: "'selfcopy' cannot be used in this context" : outExpression ;
  else
    const @string selfCppName := inAnalysisContext->mSelfObjectCppName ;
    outExpression := [@selfCopyInExpressionForGeneration new !inAnalysisContext->mSelfCopyTypeProxy !mSelfLocation !selfCppName] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @hereExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@hereExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mLocationType !mLocation] ;
end method ;

#---------------------------------------------------------------------------*

override method @trueExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@trueExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mBoolType !mLocation] ;
end method ;

#---------------------------------------------------------------------------*

override method @falseExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@falseExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mBoolType !mLocation] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalCharExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalCharExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mCharType ![mCharacter location] ![mCharacter char]] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalStringExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  @string s := "" ;
  foreach mStringSequence do
    s .= mValue ;
  end foreach ;
  outExpression := [@literalStringExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mStringType !mLocation !s] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalDoubleExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalDoubleExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mDoubleType ![mValue location] ![mValue double]] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalUIntExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalUIntExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mUIntType ![mValue location] ![mValue uint]] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalUInt64ExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalUInt64ExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mUInt64Type ![mValue location] ![mValue uint64]] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalSIntExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalSIntExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mSIntType ![mValue location] ![mValue sint]] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalSInt64ExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  outExpression := [@literalSInt64ExpressionForGeneration new !inAnalysisContext->mPredefinedTypes->mSInt64Type ![mValue location] ![mValue sint64]] ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeConstructorInvocation
  ??@unifiedTypeMapProxy inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  ??@lstring inTypeName
  ??@lstring inConstructorName
  ??@actualOutputExpressionList inConstuctorEffectiveParameterExpressions
  !@unifiedTypeMapProxy outReturnedType
  !@unifiedTypeMapProxy outConstructorType
  !@semanticExpressionListForGeneration outConstructorEffectiveParameterList
  !@bool outHasCompilerArgument
:
  outConstructorType := inType ;
  if inTypeName->string != "" then
    outConstructorType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !inTypeName] ;
  end if ;
  if [outConstructorType isNull] then
    error inTypeName : "cannot infer type" : outReturnedType, outConstructorType, outConstructorEffectiveParameterList, outHasCompilerArgument ;
  else
  #--- Get constructor map from type map
    const @constructorMap constructorMap := [outConstructorType mConstructorMap] ;
  #--- Search contructor
    @functionSignature constructorFormalArgumentTypeList ;
    with constructorMap hasKey ![inConstructorName string] do
      constructorFormalArgumentTypeList := mArgumentTypeList ;
      outHasCompilerArgument := mHasCompilerArgument ;
      outReturnedType := mReturnedType ;
    else
      if [constructorMap count] == 0 then
        error inConstructorName
        : "the '@". [outConstructorType key] . "' type does not define any constructor"
        : constructorFormalArgumentTypeList, outHasCompilerArgument, outReturnedType
        ;
      else
        @string s := "" ;
        foreach constructorMap do
          s .= "\n  - " . lkey ;
          foreach mArgumentTypeList do
            s .= " ?" + if mFormalSelector->string != "" then mFormalSelector->string + ":" else "" end + "@" . [mFormalArgumentType key] ;
          end foreach ;
          s .= " -> @" . [mReturnedType key] ;
        end foreach ;
        error inConstructorName
        : "the '@". inTypeName . "' type does not define the '" . inConstructorName . "' constructor; "
        . if [constructorMap count] > 1 then "available constructors are" else "available constructor is" end
        . ":" . s
        : constructorFormalArgumentTypeList, outHasCompilerArgument, outReturnedType
        ;
      end if ;
    end with ;
  #--- Analysis arguments
    if [inConstuctorEffectiveParameterExpressions length] != [constructorFormalArgumentTypeList length] then
      error inConstructorName
      : "calling the '" . inConstructorName . "' constructor of '@" . inTypeName . "' requires "
      . [[constructorFormalArgumentTypeList length] string] . " parameter(s), while this call has "
      . [[inConstuctorEffectiveParameterExpressions length] string] . " parameter(s)" ;
    end if ;
    outConstructorEffectiveParameterList := [@semanticExpressionListForGeneration emptyList] ;
    foreach inConstuctorEffectiveParameterExpressions, constructorFormalArgumentTypeList do
      @semanticExpressionForGeneration exp ;
      [mExpression analyzeSemanticExpression !mFormalArgumentType !inAnalysisContext !?ioVariableMap ?exp] ;
      checkAssignmentTypes !mFormalArgumentType ![exp mResultType] !mEndOfExpressionLocation ;
      if mFormalSelector->string != mActualSelector->string then
        error mActualSelector : "the selector should be '!" . if mFormalSelector->string != "" then mFormalSelector->string + ":" else "" end + "'" ;
      end if ;
      outConstructorEffectiveParameterList += !exp ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @defaultConstructorExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  var type := inType ;
  if mTypeName->string != "" then
    type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
  end if ;
  if [type isNull] then
    error mTypeName : "cannot infer type" : outExpression ;
  else
  #--- Check type accepts default constructor
    if not [type mIsConcrete] then
      error mTypeName: "an abstract class does not support the default constructor" ;
    elsif [type mDefaultConstructorName] == "" then
      error mTypeName: "this class does not support the default constructor" ;
    end if ;
  #---
    outExpression := [@defaultConstructorExpressionForGeneration new
      !type
      !mTypeName->location
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @constructorExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  analyzeConstructorInvocation
    !inType
    !inAnalysisContext
    !?ioVariableMap
    !mTypeName
    !mConstructorName
    !mExpressions
    ??@unifiedTypeMapProxy returnedType
    ??@unifiedTypeMapProxy constructorType
    ??@semanticExpressionListForGeneration constructorEffectiveParameterList
    ??@bool hasCompilerArgument
  ;
#---
  outExpression := [@constructorExpressionForGeneration new
    !returnedType
    ![mConstructorName location]
    !constructorType
    ![mConstructorName string]
    !constructorEffectiveParameterList
    !hasCompilerArgument
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @readerCallExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration receiverExpression ;
  [mReceiver analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?receiverExpression] ;
  const @unifiedTypeMapProxy receiverType := [receiverExpression mResultType] ;
#--- Get reader map
  const @readerMap readerMap := [receiverType mReaderMap] ;
#--- Search reader
  @functionSignature readerFormalArgumentTypeList ;
  @methodKind kind ;
  @bool hasCompilerArgument ;
  @unifiedTypeMapProxy returnedType ;
  @stringlist fieldList [emptyList] ;
  with readerMap hasKey ![mReaderName string] do
    readerFormalArgumentTypeList := mArgumentTypeList ;
    hasCompilerArgument := mHasCompilerArgument ;
    returnedType := mReturnedType ;
    kind := mKind ;
    if mErrorMessage != "" then
      error mReaderName : mErrorMessage ;
    end if ;
  else
    @uint matchingReaderCount := 0 ;
    if [receiverType mTypeKindEnum] == [@typeKindEnum structType] then
      readerFormalArgumentTypeList := {} ;
      hasCompilerArgument := true ;
      returnedType := [@unifiedTypeMapProxy null] ;
      kind := [@methodKind definedAsCategory] ;
      foreach [receiverType mCurrentTypedAttributeList] do
        const attributeType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap ![@lstring new ![mAttributeTypeProxy key] !here]] ;
        const aMap := [attributeType mReaderMap] ;
        with aMap hasKey ![mReaderName string] do
          matchingReaderCount ++ ;
          readerFormalArgumentTypeList := mArgumentTypeList ;
          hasCompilerArgument := mHasCompilerArgument ;
          returnedType := mReturnedType ;
          kind := mKind ;
          fieldList += ![mAttributeName string] ;
          if mErrorMessage != "" then
            error mReaderName : mErrorMessage ;
          end if ;
        end with ;
      end foreach ;
      if matchingReaderCount == 0 then
        error mReaderName
        : "the '@". [receiverType key] . "' struct type does not define the '" . [mReaderName string]
        . "' reader, and none of its fields defines it"
        : readerFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        ;
      elsif matchingReaderCount > 1 then
        @string s := "" ;
        foreach fieldList
          do s .= mValue ;
          between s .= ", " ;
        end foreach ;
        error mReaderName
        : "the '@". [receiverType key] . "' struct type does not define the '" . [mReaderName string]
        . "' reader, and several of its fields defines it:" . s . " (exactly one field should define it)"
        : readerFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
        ;
      end if ;
    elsif [readerMap count] == 0 then
      error mReaderName
      : "the '@". [receiverType key] . "' type does not define any reader"
      : readerFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      ;
    else
      @string s := "" ;
      foreach readerMap do
        s .= "\n  - " . lkey ;
        foreach mArgumentTypeList do
          s .= " ?" + if mFormalSelector->string != "" then mFormalSelector->string + ":" else "" end + "@" . [mFormalArgumentType key] ;
        end foreach ;
        s .= " -> @" . [mReturnedType key] ;
      end foreach ;
      error mReaderName
      : "the '@". [receiverType key] . "' type does not define the '" . mReaderName . "' reader; available "
      . if [readerMap count] > 1 then "readers are" else "reader is" end
      . ":" . s
      : readerFormalArgumentTypeList, hasCompilerArgument, returnedType, kind
      ;
    end if ;
  end with ;
#--- Analysis arguments
  if [mExpressions length] != [readerFormalArgumentTypeList length] then
    error mReaderName: "calling the '" . mReaderName . "' reader of '@" . [receiverType key] . "' requires "
    . [[readerFormalArgumentTypeList length] string] . " parameter(s), while this call has "
    . [[mExpressions length] string] . " parameter(s)" : outExpression ;
  else
    @semanticExpressionListForGeneration constructorEffectiveParameterList [emptyList] ;
    foreach mExpressions, readerFormalArgumentTypeList do
      [mExpression analyzeSemanticExpression !mFormalArgumentType !inAnalysisContext !?ioVariableMap ??@semanticExpressionForGeneration exp] ;
      if mFormalSelector->string != mActualSelector->string then
        error mActualSelector : "the selector should be '!" . mFormalSelector . if mFormalSelector->string != "" then ":" else "" end + "'" ;
      end if ;
      checkAssignmentTypes !mFormalArgumentType ![exp mResultType] !mEndOfExpressionLocation ;
      constructorEffectiveParameterList += !exp ;
    end foreach ;
    outExpression := [@readerCallExpressionForGeneration new
      !returnedType
      ![mReaderName location]
      !kind
      !receiverExpression
      !fieldList
      ![mReaderName string]
      !constructorEffectiveParameterList
      !hasCompilerArgument
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

function checkReaderImplementationInSuperClasses
  ??@lstring inReaderName
  ??@unifiedTypeMapProxy inSuperClass
  -> @string outResult {
  if [inSuperClass isNull] then
    outResult := "" ;
  else
    @methodQualifier qualifier ;
    [[inSuperClass mReaderMap] searchKey !inReaderName ?5* ?qualifier ?*] ;
    switch qualifier
    when isAbstract :
      outResult := "" ;
    when isBasic, isBasicFinal, isOverriding : # Ok
      outResult := [inSuperClass key] ;
    when isInherited, isOverridingAbstract :
      outResult := checkReaderImplementationInSuperClasses [!inReaderName ![inSuperClass mSuperType]] ;
    end switch ;
  end if ;
}

#---------------------------------------------------------------------------*

override method @optionExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  @commandLineOptionMap boolOptionMap ;
  @commandLineOptionMap uintOptionMap ;
  @commandLineOptionMap stringOptionMap ;
  [inAnalysisContext->mSemanticContext->mOptionComponentMapForSemanticAnalysis searchKey
    !mOptionComponentName
    ??@bool optionComponentIsPredefined
    ?boolOptionMap
    ?uintOptionMap
    ?stringOptionMap
  ] ;
  @bool found := [boolOptionMap hasKey ![mOptionEntryName string]] ;
  @unifiedTypeMapProxy returnedType := inAnalysisContext->mPredefinedTypes->mBoolType ;
  if not found then
    found := [uintOptionMap hasKey ![mOptionEntryName string]] ;
    returnedType := inAnalysisContext->mPredefinedTypes->mUIntType ;
  end if ;
  if not found then
    found := [stringOptionMap hasKey ![mOptionEntryName string]] ;
    returnedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  end if ;
  if found then
    if [mOptionReaderName string] == "value" then
      outExpression := [@optionValueExpressionForGeneration new
        !returnedType
        ![mOptionComponentName location]
        !optionComponentIsPredefined
        ![mOptionComponentName string]
        ![mOptionEntryName string]
      ] ;
    elsif [mOptionReaderName string] == "char" then
      outExpression := [@optionCharExpressionForGeneration new
        !inAnalysisContext->mPredefinedTypes->mCharType
        ![mOptionComponentName location]
        !optionComponentIsPredefined
        ![mOptionComponentName string]
        ![mOptionEntryName string]
      ] ;
    elsif [mOptionReaderName string] == "string" then
      outExpression := [@optionStringExpressionForGeneration new
        !inAnalysisContext->mPredefinedTypes->mStringType
        ![mOptionComponentName location]
        !optionComponentIsPredefined
        ![mOptionComponentName string]
        ![mOptionEntryName string]
      ] ;
    elsif [mOptionReaderName string] == "comment" then
      outExpression := [@optionCommentExpressionForGeneration new
        !inAnalysisContext->mPredefinedTypes->mStringType
        ![mOptionComponentName location]
        !optionComponentIsPredefined
        ![mOptionComponentName string]
        ![mOptionEntryName string]
      ] ;
    else
      error mOptionReaderName:"only the 'value', 'char', 'string' and 'comment' readers are defined for an option" :outExpression ;
    end if ;
  else
    @string s := "" ;
    foreach boolOptionMap do
      s .= "\n-  '" . lkey . "' @bool option;" ;
    end foreach ;
    foreach uintOptionMap do
      s .= "\n-  '" . lkey . "' @uint option;" ;
    end foreach ;
    foreach stringOptionMap do
      s .= "\n-  '" . lkey . "' @string option;" ;
    end foreach ;
    error mOptionEntryName
    : "the '" . mOptionComponentName . "' option component does not define the '" . mOptionEntryName . "' option; available options:" . s
    : outExpression
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

routine checkDiadicOperator
  ??@unifiedTypeMapProxy inLeftType
  ??@unifiedTypeMapProxy inRightType
  ??@bool inOperandIsHandled
  ??@string inOperatorNameForErrorMessage
  ??@location inErrorLocation
  ?!@semanticExpressionForGeneration ioRightExpression
:
  if not inOperandIsHandled then
    error inErrorLocation
    : "left operand type is '@" . [inLeftType key] . "' and does not accept '" . inOperatorNameForErrorMessage . "' operator (right operand type is '@" . [inRightType key] . ")"
    ;
  else
    @unifiedTypeMapProxy rightType := inRightType ;
    @bool ok := inLeftType == rightType ;
    loop [@uint max] : while (not ok) & (not [[rightType mSuperType] isNull]) do
      rightType := [rightType mSuperType] ;
      ok := inLeftType == rightType ;
    end loop ;
    
    if not ok then
    #--- Check if there is a conversion reader
      if [[inRightType mReaderMap] hasKey ![inLeftType key]] then
        @bool hasCompilerArgument ;
        @unifiedTypeMapProxy returnedType ;
        @methodKind kind ;
        [[inRightType mReaderMap] searchKey
          ![inLeftType lkey]
          ?kind
          ?@functionSignature argumentTypeList
          ?*
          ?hasCompilerArgument
          ?returnedType
          ?2*
        ] ;
        ok := ([argumentTypeList length] == 0) & (returnedType == inLeftType) ;
     #--- Add conversion expression
        @semanticExpressionForGeneration conversionExpression := [@readerCallExpressionForGeneration new
          !inLeftType
          !inErrorLocation
          !kind
          !ioRightExpression
          ![@stringlist emptyList]
          ![inLeftType key]
          ![@semanticExpressionListForGeneration emptyList]
          !hasCompilerArgument
        ] ;
        ioRightExpression := conversionExpression ;
      end if ;
      if not ok then
        error inErrorLocation
        : "left operand type of '" . inOperatorNameForErrorMessage . "' operator is '@" . [inLeftType key]
        . "', right operand type is '@" . [inRightType key]
        . "', it should be either the same, either inherits from left operand type, either have a '"
        . [inLeftType key] . "' reader without argument that returns a '@" . [inLeftType key] . "' object"
        ;
      end if ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

override method @concatExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binaryConcatOperator []) != 0
    !"."
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@concatExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @orExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binaryOrOperator []) != 0
    !"|"
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@orExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @andExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binaryAndOperator []) != 0
    !"&"
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@andExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @xorExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binaryXorOperator []) != 0
    !"^"
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@xorExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @equalExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mResultType] ;
  if [[leftType lkey] string] != [[rightType lkey] string] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType lkey] . "', right operand type is '@" . [rightType lkey] . "': '==' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@equalExpressionForGeneration new
      !inAnalysisContext->mPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @notEqualExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mResultType] ;
  if [[leftType lkey] string] != [[rightType lkey] string] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '!=' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@notEqualExpressionForGeneration new
      !inAnalysisContext->mPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lowerOrEqualExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mResultType] ;
  if ([leftType mHandledOperatorFlags] & isComparable []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support the '<=' operator"
    :outExpression
    ;
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '<=' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@lowerOrEqualExpressionForGeneration new
      !inAnalysisContext->mPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @greaterOrEqualExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mResultType] ;
  if ([leftType mHandledOperatorFlags] & isComparable []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support the '>=' operator"
    :outExpression
    ;
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '>=' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@greaterOrEqualExpressionForGeneration new
      !inAnalysisContext->mPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @strictGreaterExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mResultType] ;
  if ([leftType mHandledOperatorFlags] & isComparable []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support the '>' operator"
    :outExpression
    ;
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '>' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@strictGreaterExpressionForGeneration new
      !inAnalysisContext->mPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @strictLowerExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mResultType] ;
  if ([leftType mHandledOperatorFlags] & isComparable []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support the '<' operator"
    :outExpression
    ;
  elsif [leftType key] != [rightType key] then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "', right operand type is '@" . [rightType key] . "': '<' operator requires the types are the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@strictLowerExpressionForGeneration new
      !inAnalysisContext->mPredefinedTypes->mBoolType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @rightShiftExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mResultType] ;
  if ([leftType mHandledOperatorFlags] & binaryShiftOperator []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support a shift operator"
    :outExpression
    ;
  elsif [rightType key] != "uint" then
    error mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" . [rightType key] . "'"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@rightShiftExpressionForGeneration new
      !leftType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @leftShiftExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  const @unifiedTypeMapProxy rightType := [rightExpression mResultType] ;
  if ([leftType mHandledOperatorFlags] & binaryShiftOperator []) == 0 then
    error mOperatorLocation
    : "left operand type is '@" . [leftType key] . "' and does not support a shift operator"
    :outExpression
    ;
  elsif [rightType key] != "uint" then
    error mOperatorLocation
    : "for a shift operator, right operand type should be '@uint': it is '@" . [rightType key] . "'"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@leftShiftExpressionForGeneration new
      !leftType
      !mOperatorLocation
      !leftExpression
      !rightExpression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @addExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binaryAddOperator []) != 0
    !"+"
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@addExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @subExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binarySubOperator []) != 0
    !"-"
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@subExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @multiplicationExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binaryMulOperator []) != 0
    !"*"
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@multiplicationExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @divisionExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binaryDivOperator []) != 0
    !"/"
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@divisionExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @moduloExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Left expression analysis
  @semanticExpressionForGeneration leftExpression ;
  [mLeftExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?leftExpression] ;
#--- Right expression analysis
  @semanticExpressionForGeneration rightExpression ;
  [mRightExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?rightExpression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy leftType := [leftExpression mResultType] ;
  checkDiadicOperator
    !leftType
    ![rightExpression mResultType]
    !([leftType mHandledOperatorFlags] & binaryModOperator []) != 0
    !"mod"
    !mOperatorLocation
    !?rightExpression
  ;  
#--- Generate expression
  outExpression := [@moduloExpressionForGeneration new
    !leftType
    !mOperatorLocation
    !leftExpression
    !rightExpression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @unaryMinusExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?expression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy type := [expression mResultType] ;
  if ([type mHandledOperatorFlags] & unaryMinusOperator []) == 0 then
    error mOperatorLocation
    : "operand type is '@" . [type key] . "' and does not support the unary minus operator"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@unaryMinusExpressionForGeneration new
      !type
      !mOperatorLocation
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @notExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?expression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy type := [expression mResultType] ;
  if ([type mHandledOperatorFlags] & unaryNotOperator []) == 0 then
    error mOperatorLocation
    : "operand type is '@" . [type key] . "' and does not support the 'not' operator"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@notExpressionForGeneration new
      !type
      !mOperatorLocation
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @structFieldAccessExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?expression] ;
#--- Check field access availability
  @unifiedTypeMapProxy type := [expression mResultType] ;
  if [type mTypeKindEnum] != [@typeKindEnum structType] then
    error mStructFieldName:"the '->' operator requires the receiver to be a struct" ;
  end if ;
  const @attributeMap attributeMap := [type mAttributeMap] ;
  [attributeMap searchKey !mStructFieldName ?type] ;
#--- Generate expression
  outExpression := [@structFieldAccessExpressionForGeneration new
    !type
    !mOperatorLocation
    !expression
    !mStructFieldName->string
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @complementExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Expression analysis
  @semanticExpressionForGeneration expression ;
  [mExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?expression] ;
#--- Check operator availability
  const @unifiedTypeMapProxy type := [expression mResultType] ;
  if ([type mHandledOperatorFlags] & unaryTildeOperator []) == 0 then
    error mOperatorLocation
    : "operand type is '@" . [type key] . "' and does not support the '~' operator"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@tildeExpressionForGeneration new
      !type
      !mOperatorLocation
      !expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @ifExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- 'if' expression analysis
  @semanticExpressionForGeneration if_expression ;
  [mIfExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?if_expression] ;
#--- 'then' expression analysis
  @semanticExpressionForGeneration then_expression ;
  [mThenExpression analyzeSemanticExpression !inType !inAnalysisContext !?ioVariableMap ?then_expression] ;
#--- 'else' expression analysis
  @semanticExpressionForGeneration else_expression ;
  [mElseExpression analyzeSemanticExpression !inType !inAnalysisContext !?ioVariableMap ?else_expression] ;
#--- Check 'if' expression is boolean
  if [[if_expression mResultType] key] != "bool" then
    error mOperatorLocation
    :"the test expression type is '@" . [[if_expression mResultType] key] . "', it should be '@bool'"
    :outExpression
    ;
  elsif [then_expression mResultType] != [else_expression mResultType] then
    error mOperatorLocation
    :"operand expression types are '@" . [[then_expression mResultType] key] . "' and '@". [[else_expression mResultType] key] . "': they should be the same"
    :outExpression
    ;
  else
  #--- Generate expression
    outExpression := [@ifExpressionForGeneration new
      ![then_expression mResultType]
      !mOperatorLocation
      !if_expression
      !then_expression
      !else_expression
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @functionCallExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Retrieve function features
  [inAnalysisContext->mSemanticContext->mFunctionMap searchKey
    !mFunctionName
    ??@functionSignature functionSignature
    ??@unifiedTypeMapProxy resultType
    ??@bool isInternal
  ] ;
#--- Check internal
  if isInternal then
    const procDeclarationLocation := [inAnalysisContext->mSemanticContext->mFunctionMap locationForKey !mFunctionName->string] ;
    if [mFunctionName->location file] != [procDeclarationLocation file] then
      error mFunctionName : "this proc is internal to '" . [procDeclarationLocation file] . "' file" ;
    end if ;
  end if ;
#--- Analyze effective parameters
  if [functionSignature length] != [mExpressionList length] then
    error mFunctionName
    :"the '" . mFunctionName . "' function header declares " . [[functionSignature length] string]
      . " formal parameter(s), but this function call names " . [[mExpressionList length] string]
      . " effective argument(s)"
    : outExpression
    ;
  else
    @semanticExpressionListForGeneration semanticExpressionListForGeneration [emptyList] ;
    foreach functionSignature, mExpressionList do
      [mExpression analyzeSemanticExpression
        !mFormalArgumentType
        !inAnalysisContext
        !?ioVariableMap
        ??@semanticExpressionForGeneration expression
      ] ;
      checkAssignmentTypes !mFormalArgumentType ![expression mResultType] !mEndOfExpressionLocation ;
      if mFormalSelector->string != mActualSelector->string then
        error mActualSelector : "the selector should be '!" . if mFormalSelector->string != "" then mFormalSelector->string + ":" else "" end + "'" ;
      end if ;
      semanticExpressionListForGeneration += !expression ;
    end foreach ;
    outExpression := [@functionCallExpressionForGeneration new
      !resultType
      ![mFunctionName location]
      ![mFunctionName string]
      !semanticExpressionListForGeneration
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @varInExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext unused inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
  [!?ioVariableMap searchForReadAccess
    !mVarName
    ??@unifiedTypeMapProxy type
    ??@string sourceVariableCppName
    ??@string nameForCheckingFormalParameterUsing
  ] ;
  outExpression := [@varInExpressionForGeneration new
    !type
    ![mVarName location]
    !sourceVariableCppName
    !nameForCheckingFormalParameterUsing
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @literalTypeInExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Get constructor map from type map
  [inAnalysisContext->mSemanticContext->mTypeMap searchKey !mLiteralTypeName ?26*] ;
#---
  outExpression := [@literalTypeInExpressionForGeneration new
    ![@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap ![@lstring new !"type" !here]]
    ![mLiteralTypeName location]
    ![mLiteralTypeName string]
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @testDynamicClassInExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Receiver expression analysis
  @semanticExpressionForGeneration expression ;
  [mReceiverExpression analyzeSemanticExpression ![@unifiedTypeMapProxy null] !inAnalysisContext !?ioVariableMap ?expression] ;
#--- Get type information
   const castType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
#--- This type is either a class
  if [[expression mResultType] mTypeKindEnum] == [@typeKindEnum classType] then
  #--- Check expression type is a descendant of named type
    @unifiedTypeMapProxy t := castType ;
    @bool found := t == [expression mResultType] ;
    loop [inAnalysisContext->mSemanticContext->mTypeMap count] + 1 :
    while (not found) & not [[t mSuperType] isNull] do
      t := [t mSuperType] ;
      found := t == [expression mResultType] ;
    end loop ;
    if not found then
      error mTypeName
      :"the '@" . mTypeName . "' is not a descendant of the '@" . [[expression mResultType] key] . "' type of the cast expression"
      ;
    end if ;
  else
    error [expression mLocation]: "expression should be a class instance: it is an @"
     .  [[expression mResultType] key] . " instance" ;
  end if ;
#--- Generate expression
  outExpression := [@testDynamicClassInExpressionForGeneration new
    !inAnalysisContext->mPredefinedTypes->mBoolType
    ![mTypeName location]
    !expression
    !mTypeComparisonKind
    !castType
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @castInExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Receiver expression analysis
  [mReceiverExpression analyzeSemanticExpression
    ![@unifiedTypeMapProxy null]
    !inAnalysisContext 
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
   ] ;
#--- Get type information
   const type := [@unifiedTypeMapProxy searchKey
     !inAnalysisContext->mSemanticContext->mTypeMap
     !mTypeName
   ] ;
#--- This type is an @object type
  if [[expression mResultType] mTypeKindEnum] == [@typeKindEnum classType] then
  #--- Check expression type is a descendant of named type
    @unifiedTypeMapProxy t := type ;
    @bool found := t == [expression mResultType] ;
    loop [inAnalysisContext->mSemanticContext->mTypeMap count] + 1 :
    while (not found) & not [[t mSuperType] isNull] do
      t := [t mSuperType] ;
      found := t == [expression mResultType] ;
    end loop ;
    if not found then
      error mTypeName
      :"the '@" . mTypeName . "' is not a descendant of the '@"
      . [[expression mResultType] key] . "' type of the cast expression"
      ;
    end if ;
  elsif [[expression mResultType] key] != "object" then
#    error [expression mLocation]
#     : "cast expression should be an @object instance: it is an @"
#     .  [[expression mResultType] key] . " instance" ;
#  else
    error [expression mLocation]:
      "cast expression should be a class instance or an @object instance: it is an @"
     .  [[expression mResultType] key] . " instance" ;
  end if ;
#--- Generate expression
  if [[expression mResultType] key] == "object" then
    outExpression := [@extractObjectInExpressionForGeneration new
      !type
      !mEndOfReceiverExpression
      !expression
      ![mTypeName string]
    ] ;
  else
    outExpression := [@castInExpressionForGeneration new
      !type
      ![mTypeName location]
      !expression
      ![mTypeName string]
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @filewrapperObjectInstanciationInExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Search for filewrapper name in filewrapper map
  [inAnalysisContext->mSemanticContext->mFilewrapperMap searchKey
    !mFilewrapperName
    ??@lstring filewrapperPath
    ?4*
    ??@bool isInternal
  ] ;
#--- Check internal
  if isInternal then
    const filewrapperDeclarationLocation := [inAnalysisContext->mSemanticContext->mFilewrapperMap locationForKey !mFilewrapperName->string] ;
    if [mFilewrapperName->location file] != [filewrapperDeclarationLocation file] then
      error mFilewrapperName : "this filewrapper is internal to '" . [filewrapperDeclarationLocation file] . "' file" ;
    end if ;
  end if ;
#---
  outExpression := [@filewrapperInExpressionForGeneration new
    ![@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap ![@lstring new !"filewrapper" ![mFilewrapperName location]]]
    ![mFilewrapperName location]
    ![mFilewrapperName string]
    ![filewrapperPath string]
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @filewrapperTemplateInExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#---
  [inAnalysisContext->mSemanticContext->mFilewrapperMap searchKey
     !mFilewrapperName
     ?4*
     ??@filewrapperTemplateMap filewrapperTemplateMap
     ??@bool isInternal
   ] ;
#--- Check internal
  if isInternal then
    const filewrapperDeclarationLocation := [inAnalysisContext->mSemanticContext->mFilewrapperMap locationForKey !mFilewrapperName->string] ;
    if [mFilewrapperName->location file] != [filewrapperDeclarationLocation file] then
      error mFilewrapperName : "this filewrapper is internal to '" . [filewrapperDeclarationLocation file] . "' file" ;
    end if ;
  end if ;
#---
  [filewrapperTemplateMap searchKey !mFilewrapperTemplateName ??@functionSignature templateSignature ?*] ;
#--- Analysis arguments
  @semanticExpressionListForGeneration effectiveParameterList ;
  if [mExpressions length] != [templateSignature length] then
    error mFilewrapperTemplateName
    : "calling the '" . mFilewrapperTemplateName . "' template of '" . mFilewrapperName . "' filewrapper requires "
    . [[templateSignature length] string] . " parameter(s), while this call has "
    . [[mExpressions length] string] . " parameter(s)" 
    : effectiveParameterList ;
  else
    effectiveParameterList := [@semanticExpressionListForGeneration emptyList] ;
    foreach mExpressions, templateSignature do
      if mFormalSelector->string != mActualSelector->string then
        error mActualSelector : "the selector should be '!" . mFormalSelector . if mFormalSelector->string != "" then ":" else "" end + "'" ;
      end if ;
      [mExpression analyzeSemanticExpression !mFormalArgumentType !inAnalysisContext !?ioVariableMap ??@semanticExpressionForGeneration exp] ;
      checkAssignmentTypes !mFormalArgumentType ![exp mResultType] !mEndOfExpressionLocation ;
      effectiveParameterList += !exp ;
    end foreach ;
  end if ;
#---
  outExpression := [@filewrapperTemplateInExpressionForGeneration new
    !inAnalysisContext->mPredefinedTypes->mStringType
    ![mFilewrapperName location]
    ![mFilewrapperName string]
    ![mFilewrapperTemplateName string]
    !effectiveParameterList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @filewrapperInExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Parse filewrapper path
  @stringlist directoryList ;
  @string fileName ;
  if [mFilewrapperPath length] == 0 then
    error mFilewrapperPath : "path is empty" : directoryList, fileName ;
  elsif [mFilewrapperPath firstCharacterOrNul] == '/' then
    error mFilewrapperPath : "the path should not begin with '/'" : directoryList, fileName ;
  else
    directoryList := [mFilewrapperPath componentsSeparatedByString !"/"] ;
    [!?directoryList popLast ?fileName] ;
  end if ;
#--- Get filewrapper features
  [inAnalysisContext->mSemanticContext->mFilewrapperMap searchKey
    !mFilewrapperName
    ?*
    ?*
    ?@wrapperFileMap filewrapperFileMap
    ?@wrapperDirectoryMap filewrapperDirectoryMap
    ?*
    ??@bool isInternal
  ] ;
#--- Check internal
  if isInternal then
    const filewrapperDeclarationLocation := [inAnalysisContext->mSemanticContext->mFilewrapperMap locationForKey !mFilewrapperName->string] ;
    if [mFilewrapperName->location file] != [filewrapperDeclarationLocation file] then
      error mFilewrapperName : "this filewrapper is internal to '" . [filewrapperDeclarationLocation file] . "' file" ;
    end if ;
  end if ;
#--- Search for file
  @string builtPath := "" ;
  loop [filewrapperDirectoryMap count] + 1 :
  while [directoryList length] > 0 do
    @string directoryName ;
    [!?directoryList popFirst ?directoryName] ;
    builtPath .= directoryName . "/" ;
    if [filewrapperDirectoryMap hasKey !directoryName] then
      [filewrapperDirectoryMap searchKey
        ![@lstring new !directoryName !here]
        ?filewrapperFileMap
        ?filewrapperDirectoryMap
        ?*
      ] ;
    else
      error mFilewrapperPath : "the '" . builtPath . "' path does not exists for the '" . mFilewrapperName . "' filewrapper" : filewrapperFileMap ; 
      directoryList := [@stringlist emptyList] ; # For exiting loop
    end if ;
  end loop ;
  @uint fileIndex ;
  @bool isTextFile ;
  if [filewrapperFileMap hasKey !fileName] then
    [filewrapperFileMap searchKey ![@lstring new !fileName !here] ?* ?isTextFile ?* ?fileIndex] ;
  else
    error mFilewrapperPath
    : "the '" . fileName . "' file does not exist in the '" . builtPath . "' directory of '" . mFilewrapperName . "' filewrapper"
    : fileIndex, isTextFile
    ;
  end if ;
#---
  outExpression := [@filewrapperStaticPathInExpressionForGeneration new
    !if isTextFile
      then inAnalysisContext->mPredefinedTypes->mStringType
      else [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap ![@lstring new !"data" !here]]
     end
    ![mFilewrapperName location]
    ![mFilewrapperName string]
    !fileIndex
    !isTextFile
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexiqueIntrospectionExpressionAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy unused inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap unused ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Check  lexique is declared
  [inAnalysisContext->mSemanticContext->mLexiqueComponentMapForSemanticAnalysis searchKey
    !mLexiqueComponentName
    ?3*
  ] ;
#--- Check reader name
  if mLexiqueReaderName->string != "symbols" then
    error mLexiqueReaderName:"unknown reader" ;
  end if ;
#---
  outExpression := [@lexiqueIntrospectionForGeneration new
    ![@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !["stringlist" nowhere]]
    !mLexiqueComponentName->location
    !mLexiqueComponentName->string
    !mLexiqueReaderName->string
  ] ;
end method ;

#---------------------------------------------------------------------------*
#! Collection value
#---------------------------------------------------------------------------*

abstract method @abstractCollectionValueElement analyze
  ??@analysisContext inAnalysisContext
  ??@unifiedTypeMapProxy inElementType
  ?!@variableMap ioVariableMap
  ?!@collectionValueElementListForGeneration ioCollectionValueElementListForGeneration
;

#---------------------------------------------------------------------------*

override method @expressionCollectionValue analyze
  ??@analysisContext inAnalysisContext
  ??@unifiedTypeMapProxy inElementType
  ?!@variableMap ioVariableMap
  ?!@collectionValueElementListForGeneration ioCollectionValueElementListForGeneration
:
  [mExpression analyzeSemanticExpression
    !inElementType
    !inAnalysisContext
    !?ioVariableMap
    ??@semanticExpressionForGeneration expression
  ] ;
#--- Check assignment type compatibility
  checkAssignmentTypes !inElementType ![expression mResultType] !mExpressionLocation ;
#---
  ioCollectionValueElementListForGeneration += ![@expressionCollectionValueForGeneration new !mExpressionLocation !expression] ;
end method ;

#---------------------------------------------------------------------------*

override method @expressionListCollectionValue analyze
  ??@analysisContext inAnalysisContext
  ??@unifiedTypeMapProxy inElementType
  ?!@variableMap ioVariableMap
  ?!@collectionValueElementListForGeneration ioCollectionValueElementListForGeneration
:
  const @functionSignature formalParameterTypeList := [inElementType mAddAssignOperatorArguments] ;
  @semanticExpressionListForGeneration semanticExpressionListForGeneration ;
  if [formalParameterTypeList length] != [mExpressionList length] then
    error mEndOfExpressionLocation: "element of of '@" . [inElementType key] . "' requires "
    . [formalParameterTypeList length] . " parameter(s), while this list has "
    . [mExpressionList length] . " element(s)" : semanticExpressionListForGeneration ;
  else
    semanticExpressionListForGeneration := @semanticExpressionListForGeneration {} ;
    foreach mExpressionList, formalParameterTypeList do
      [mExpression analyzeSemanticExpression !mFormalArgumentType !inAnalysisContext !?ioVariableMap ??@semanticExpressionForGeneration exp] ;
      if mFormalSelector->string != mActualSelector->string then
        error mActualSelector : "the selector should be '!" . mFormalSelector . if mFormalSelector->string != "" then ":" else "" end + "'" ;
      end if ;
      checkAssignmentTypes !mFormalArgumentType ![exp mResultType] !mEndOfExpressionLocation ;
      semanticExpressionListForGeneration += !exp ;
    end foreach ;
    ioCollectionValueElementListForGeneration += ![@expressionListCollectionForGeneration new
      !mEndOfExpressionLocation
      !semanticExpressionListForGeneration
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

list @collectionValueElementListForGeneration {
  @abstractCollectionValueElementForGeneration mElement ;
}

#---------------------------------------------------------------------------*

abstract class @abstractCollectionValueElementForGeneration {
  @location mExpressionLocation ;
}

#---------------------------------------------------------------------------*

class @expressionCollectionValueForGeneration extends @abstractCollectionValueElementForGeneration {
  @semanticExpressionForGeneration mExpression ;
}

#---------------------------------------------------------------------------*

class @expressionListCollectionForGeneration extends @abstractCollectionValueElementForGeneration {
  @semanticExpressionListForGeneration mExpressionList ;
}

#---------------------------------------------------------------------------*

class @expressionCollectionForGeneration extends @semanticExpressionForGeneration {
  @collectionValueElementListForGeneration mElementList ;
}

#---------------------------------------------------------------------------*

override method @collectionValueAST analyzeSemanticExpression
  ??@unifiedTypeMapProxy inType
  ??@analysisContext inAnalysisContext
  ?!@variableMap ioVariableMap
  !@semanticExpressionForGeneration outExpression
:
#--- Type
  @unifiedTypeMapProxy targetType ;
  if mTypeName->string == "" then
    targetType := inType ;
  else
    targetType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mTypeName] ;
  end if ;
#---
  if targetType == [@unifiedTypeMapProxy null] then
    error mTypeName : "Cannot infer type" : outExpression ;
  elsif not [targetType mSupportCollectionValue] then
    error mTypeName : "the @" . mTypeName . " type does not support collection value" : outExpression ;
  else
    if [mElementList length] == 0 then
      outExpression := [@defaultConstructorExpressionForGeneration new
        !targetType
        !mTypeName->location
      ] ;
    else
      var collectionValueElementListForGeneration := @collectionValueElementListForGeneration {} ;
      for () in mElementList do
        [mElement analyze
          !inAnalysisContext
          !targetType
          !?ioVariableMap
          !?collectionValueElementListForGeneration
        ] ;
      end for ;
      outExpression := [@expressionCollectionForGeneration new
        !targetType
        !mEndOfCollectionValue
        !collectionValueElementListForGeneration
      ] ;
    end if ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

end semantics ;
