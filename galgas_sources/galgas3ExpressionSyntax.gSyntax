#---------------------------------------------------------------------------*
#                                                                           *
#  'expression' syntax                                                      *
#                                                                           *
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax galgas3ExpressionSyntax ("galgas3Scanner.gLexique") :

import "semanticsTypesForAST.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#   O U T P U T    E X P R E S S I O N    L I S T                              *
#                                                                              *
#------------------------------------------------------------------------------*

rule <output_expression_list>
  !@semanticExpressionListAST outExpressionList
:
  outExpressionList := [@semanticExpressionListAST emptyList] ;
  repeat
  while
    $!$ ;
    <expression> ??@semanticExpressionAST expression ;
    outExpressionList += !expression !here ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   C A S T                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression> !@semanticExpressionAST outExpression :
  <casted_expression> ?outExpression ;
  select
  or
    const @location endOfReceiverExpression := here ;
    $is$ ;
    @dynamicTypeComparisonKind kind ;
    select
      $==$ ; kind := [@dynamicTypeComparisonKind equal] ;
    or
      $>=$ ; kind := [@dynamicTypeComparisonKind inherited] ;
    or
      $>$ ; kind := [@dynamicTypeComparisonKind strictlyInherited] ;
    end select ;
    $type_name$ ?@lstring typeName ;
    outExpression := [@testDynamicClassInExpressionAST new
      !outExpression
      !endOfReceiverExpression
      !kind
      !typeName
    ] ;
  or
    const @location endOfReceiverExpression := here ;
    $as$ ;
    $type_name$ ?@lstring typeName ;
    outExpression := [@castInExpressionAST new
      !outExpression
      !endOfReceiverExpression
      !typeName
    ] ;
  end select ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   C O N C A T E N A T I O N    T E R M                                       *
#                                                                              *
#------------------------------------------------------------------------------*

rule <casted_expression> !@semanticExpressionAST outExpression :
  <relation_term> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $|$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <relation_term> ? rightOperand ;
    outExpression := [@orExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $^$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <relation_term> ? rightOperand ;
    outExpression := [@xorExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    T E R M                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_term> !@semanticExpressionAST outExpression :
  <relation_factor> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $&$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <relation_factor> ? rightOperand ;
    outExpression := [@andExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    F A C T O R                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_factor> !@semanticExpressionAST outExpression :
  <simple_expression> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $==$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@equalExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $!=$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@notEqualExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $<=$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@lowerOrEqualExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $>=$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@greaterOrEqualExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $>$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@strictGreaterExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $<$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <simple_expression> ? rightOperand ;
    outExpression := [@strictLowerExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   S I M P L E    E X P R E S S I O N                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <simple_expression> !@semanticExpressionAST outExpression :
  <term> ? outExpression ;
  repeat
  while
    @location operatorLocation := here ;
    $<<$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <term> ? rightOperand ;
    outExpression := [@leftShiftExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $>>$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <term> ? rightOperand ;
    outExpression := [@rightShiftExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $+$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <term> ? rightOperand ;
    outExpression := [@addExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $-$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <term> ? rightOperand ;
    outExpression := [@subExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   T E R M                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <term> !@semanticExpressionAST outExpression :
  <factor> ? outExpression ;
  repeat
  while
    const operatorLocation := here ;
    $*$ ;
    const leftOperand := outExpression ;
    <factor> ??@semanticExpressionAST rightOperand ;
    outExpression := [@multiplicationExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $/$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <factor> ? rightOperand ;
    outExpression := [@divisionExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  while
    @location operatorLocation := here ;
    $mod$ ;
    @semanticExpressionAST leftOperand := outExpression ;
    @semanticExpressionAST rightOperand ;
    <factor> ? rightOperand ;
    outExpression := [@moduloExpressionAST new !operatorLocation !leftOperand !rightOperand] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    - factor                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression :
  @location operatorLocation := here ;
  $-$ ;
  <factor> ? outExpression ;
  outExpression := [@unaryMinusExpressionAST new !operatorLocation !outExpression] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    not FACTOR                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression :
  @location operatorLocation := here ;
  $not$ ;
  <factor> ? outExpression ;
  outExpression := [@notExpressionAST new !operatorLocation !outExpression] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ~ FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression :
  @location operatorLocation := here ;
  $~$ ;
  <factor> ? outExpression ;
  outExpression := [@complementExpressionAST new !operatorLocation !outExpression] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    struct field access                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor> !@semanticExpressionAST outExpression :
  <primary> ? outExpression ;
  repeat
  while
    $.$ ;
    $identifier$ ? @lstring structFieldName ;
    outExpression := [@structFieldAccessExpressionAST new !structFieldName->location !outExpression !structFieldName] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    <var>                                                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $identifier$ ? @lstring identifier ;
  outExpression := [@varInExpressionAST new !identifier] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    S E L F C O P Y                                      *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $self$ ;
  outExpression := [@selfCopyInExpressionAST new !here] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y  :    (EXPRESSION)                                           *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $($ ;
  <expression> ? outExpression ;
  $)$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    true                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $true$ ;
  outExpression := [@trueExpressionAST new !here] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    false                                                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $false$ ;
  outExpression := [@falseExpressionAST new !here] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :   literal string sequence "..."  "..."  "..."           *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  @stringlist literalStringList [emptyList] ;
  repeat
    @lstring literalString ;
    $literal_string$ ?literalString ;
    literalStringList += ![literalString string] ;
  while
  end repeat ;
  outExpression := [@literalStringExpressionAST new !here !literalStringList] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    a 32-bit unsigned literal integer value              *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  @luint literalInt ;
  $unsigned_literal_integer$ ?literalInt ;
  outExpression := [@literalUIntExpressionAST new !literalInt] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    a 32-bit signed literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  @lsint literalInt ;
  $signed_literal_integer$ ?literalInt ;
  outExpression := [@literalSIntExpressionAST new !literalInt] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    a 64-bit unsigned literal integer value              *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  @luint64 literalInt ;
  $unsigned_literal_integer64$ ?literalInt ;
  outExpression := [@literalUInt64ExpressionAST new !literalInt] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    a 64-bit signed literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  @lsint64 literalInt ;
  $signed_literal_integer64$ ?literalInt ;
  outExpression := [@literalSInt64ExpressionAST new !literalInt] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    a literal character value                            *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  @lchar literalChar ;
  $literal_char$ ?literalChar ;
  outExpression := [@literalCharExpressionAST new !literalChar] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    a double value                                       *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  @ldouble literalDouble ;
  $literal_double$ ? literalDouble ?* ;
  outExpression := [@literalDoubleExpressionAST new !literalDouble] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    here                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $here$ ;
  outExpression := [@hereExpressionAST new !here] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   P R I M A R Y    :    if exp then exp else exp end                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $if$ ;
  @semanticExpressionAST ifExpression ;
  <expression> ? ifExpression ;
  const operatorLocation := here ;
  $then$ ;
  @semanticExpressionAST thenExpression ;
  <expression> ? thenExpression ;
  $else$ ;
  @semanticExpressionAST elseExpression ;
  <expression> ? elseExpression ;
  $end$ ;
  outExpression := [@ifExpressionAST new
    !operatorLocation
    !ifExpression
    !thenExpression
    !elseExpression
  ] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         P R I M A R Y                                        *
#   reader call           :   [expression reader !... ]                        *
#   constructor call      :   [@class constructor !... ]                       *
#   default constructor   :   [@class default]                                 *
#   lexique introspection :   [lexique lexique_component_name.name]            *
#   option value          :   [option option_component_name.option_name]       *
#   filewrapper object    :   [filewrapper filewrapper_name]                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $[$ ;
#--- Get source identity characteristics
  <expression> ??@semanticExpressionAST receiverExpression ;
#--- Get reader name
  $identifier$ ??@lstring readerName ;
#--- Actual parameters
  <output_expression_list> ??@semanticExpressionListAST expressionList ;
  outExpression := [@readerCallExpressionAST new !receiverExpression !readerName !expressionList] ;
  $]$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $[$ ;
#--- Class name
  $type_name$ ??@lstring className indexing typeReferenceInConstructor ;
#--- Constructor name
  $identifier$ ??@lstring constructorName ;
#--- Actual arguments
  <output_expression_list> ??@semanticExpressionListAST expressionList ;
  outExpression := [@constructorExpressionAST new
    !className
    !constructorName
    !expressionList
  ] ;
  $]$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $[$ ;
  $type_name$ ??@lstring className indexing typeReferenceInConstructor ;
  $default$ ;
  outExpression := [@defaultConstructorExpressionAST new !className] ;
  $]$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $[$ ;
  $option$ ;
  select
    $.$ ;
    $identifier$ ?@lstring optionName ;
    $identifier$ ?@lstring readerName ;
    outExpression := [@optionExpressionAST new ![@lstring new !"galgas_builtin_options" !here] !optionName !readerName] ;
  or
    $identifier$ ?@lstring optionComponentName indexing optionComponentReference ;
    $.$ ;
    $identifier$ ?@lstring optionName ;
    $identifier$ ?@lstring readerName ;
    outExpression := [@optionExpressionAST new !optionComponentName !optionName !readerName] ;
  end select ;
  $]$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $[$ ;
  $lexique$ ;
  $identifier$ ?@lstring lexiqueName ;
  $:$ ;
  $identifier$ ?@lstring readerName ;
  outExpression := [@lexiqueIntrospectionExpressionAST new !lexiqueName !readerName] ;
  $]$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $[$ ;
  $filewrapper$ ;
  $identifier$ ?@lstring filewrapperName indexing filewrapperReference ;
  select
    outExpression := [@filewrapperObjectInstanciationInExpressionAST new
      !filewrapperName
    ] ;
  or
    $.$ ;
    select
      $literal_string$ ??@lstring filePath ;
      outExpression := [@filewrapperInExpressionAST new
        !filewrapperName
        !filePath
      ] ;
    or
      $identifier$ ??@lstring filewrapperTemplateName ;
      <output_expression_list> ??@semanticExpressionListAST expressionList ;
      outExpression := [@filewrapperTemplateInExpressionAST new
        !filewrapperName
        !filewrapperTemplateName
        !expressionList
      ] ;
    end select ;
  end select ;
  $]$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         P R I M A R Y                                        *
#                                                                              *
#   function call        :   function_name (!... )                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $identifier$ ??@lstring functionName indexing functionCall ;
  $($ ;
  <output_expression_list> ??@semanticExpressionListAST expressionList ;
  $)$ ;
  outExpression := [@functionCallExpressionAST new
    !functionName
    !expressionList
  ] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         P R I M A R Y                                        *
#                                                                              *
#   literal type         :   `@type                                            *
#                                                                              *
#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $`$ ;
  $type_name$ ??@lstring typeName ;
  outExpression := [@literalTypeInExpressionAST new
    !typeName
  ] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         P R I M A R Y                                        *
#                                                                              *
#   Collection value                                                           *
#                                                                              *
#------------------------------------------------------------------------------*

rule <collection_value_element> 
  !@abstractCollectionValueElement outValueElement
:
  @semanticExpressionListAST expressionList [emptyList] ;
  repeat
    $!$ ;
    <expression> ??@semanticExpressionAST expression ;
    expressionList += !expression !here ;
  while
  end repeat ;
  outValueElement := [@expressionListCollectionValue new !expressionList !here] ;
end rule ;

#------------------------------------------------------------------------------*

rule <collection_value_element> 
  !@abstractCollectionValueElement outValueElement
:
  <expression> ??@semanticExpressionAST expression ;
  outValueElement := [@expressionCollectionValue new !expression !here] ;
end rule ;

#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  @lstring typeName ;
  select
    typeName := [@lstring new !"" !here] ;
  or
    $type_name$ ?typeName ;
  end select ;
  ${$ ;
  var elementList := @collectionValueElementList {} ;
  select
  or
    repeat
      <collection_value_element> ??@abstractCollectionValueElement element ;
      elementList += !element ;
    while
      $,$ ;
    end repeat ;
  end select ;
  outExpression := [@collectionValueAST new
    !typeName
    !elementList
    !here
  ] ;  
  $}$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         P R I M A R Y                                        *
#                                                                              *
#   Constructor call with infered type                                         *
#                                                                              *
#------------------------------------------------------------------------------*

#rule <primary> !@semanticExpressionAST outExpression :
#  $[$ ;
##--- Constructor name
##  $identifier$ ??@lstring constructorName ;
##--- Actual arguments
##  <output_expression_list> ??@semanticExpressionListAST expressionList ;
##  outExpression := [@constructorExpressionAST new
##    !className
##    !constructorName
##    !expressionList
##  ] ;
#  outExpression := [@trueExpressionAST new !here] ; # TEMPORARY !!!
#  $]$ ;
#end rule ;

#------------------------------------------------------------------------------*

rule <primary> !@semanticExpressionAST outExpression :
  $[$ ;
#--- Constructor name
  $default$ ;
#  outExpression := [@constructorExpressionAST new
#    !className
#    !constructorName
#    !expressionList
#  ] ;
  outExpression := [@trueExpressionAST new !here] ; # TEMPORARY !!!
  $]$ ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
