#---------------------------------------------------------------------------*
#                                                                           *
#  metamodel that defines expression                                        *
#                                                                           *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticAnalysis :
  import "semanticInstructionsAnalysis.gSemantics" ;
  import "templateGrammar.gGrammar" ;
  import "templateAnalysis.gSemantics" ;

  import semantics templateAnalysis in "templateAnalysis.gSemantics" ;
  import semantics semanticInstructionsAnalysis in "semanticInstructionsAnalysis.gSemantics" ;
  import semantics templateTypesForAST in "templateTypesForAST.gSemantics" ;
  import grammar templateGrammar in "templateGrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    C H E C K    M E T H O D    S I G N A T U R E                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkMethodSignatures
  ??@formalParameterListForGeneration inTestedSignature
  ??@location inErrorLocation
  ??@formalParameterSignature inReferenceSignature
  ??@location inReferenceLocation
:
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this method declares " . [[inTestedSignature length] string]
    . " formal parameter(s), but overriden method declares " . [[inReferenceSignature length] string]
    ;
    error inReferenceLocation:"overriden method is declared here" ;
  else
    foreach inReferenceSignature prefixedby ref_, inTestedSignature do
      if ref_mFormalArgumentPassingMode != mFormalArgumentPassingMode then
        error mFormalArgumentName : "the '" . mFormalArgumentName . "' formal parameter is declared as "
        . [mFormalArgumentPassingMode formalArgumentMessage] . ", but overriden method declares it as " 
        . [ref_mFormalArgumentPassingMode formalArgumentMessage] ;
        error inReferenceLocation:"overriden method is declared here" ;
      end if ;
      if [mFormalArgumentType key] != [ref_mFormalArgumentType key] then
        error mFormalArgumentName : "the '" . mFormalArgumentName . "' formal parameter has the '@"
        . [mFormalArgumentType key] . "' type, but overriden method declares with the '@" 
        . [ref_mFormalArgumentType key] . "' type" ;
        error inReferenceLocation:"overriden method is declared here" ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    C H E C K    R E A D E R    S I G N A T U R E                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkReaderSignatures
  ??@formalInputParameterListForGeneration inTestedSignature
  ??@unifiedTypeMapProxy inReturnType
  ??@location inErrorLocation
  ??@unifiedTypeMapProxyList inReferenceSignature
  ??@unifiedTypeMapProxy inInheritedReturnType
  ??@location inReferenceLocation
:
  if [inReturnType key] != [inInheritedReturnType key] then
    error inErrorLocation : "the return type is '@"
    . [inReturnType key] . "', but overriden reader names '@" 
    . [inInheritedReturnType key] . "' as return type" ;
    error inReferenceLocation:"overriden reader is declared here" ;
  end if ;
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this reader declares " . [[inTestedSignature length] string]
    . " formal parameter(s), but overriden reader declares " . [[inReferenceSignature length] string]
    ;
    error inReferenceLocation:"overriden reader is declared here" ;
  else
    foreach inReferenceSignature prefixedby ref_, inTestedSignature do
      if [mFormalArgumentType key] != [ref_mType key] then
        error mFormalArgumentName : "the '" . mFormalArgumentName . "' formal parameter has the '@"
        . [mFormalArgumentType key] . "' type, but overriden reader declares with the '@" 
        . [ref_mType key] . "' type" ;
        error inReferenceLocation:"overriden reader is declared here" ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    D E C L A R A T I O N    S E M A N T I C    A N A L Y S I S            *
#                                                                           *
#---------------------------------------------------------------------------*

method @semanticDeclarationAST performSemanticAnalysis
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration
:
end method ;

#---------------------------------------------------------------------------*

override method @predefinedTypeAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  ioSemanticDeclarationListForGeneration += ![@primitiveTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !mPredefinedTypeName !here]]
    !mPredefinedTypeName
    !mKind
  ]
  !""
  ;

end method ;

#---------------------------------------------------------------------------*

map @attributeIndexMap {
  @unifiedTypeMapProxy mAttributeTypeIndex ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#---------------------------------------------------------------------------*

override method @listDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    @bool hasGetter := true ;
    @bool hasSetter := true ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
  ioSemanticDeclarationListForGeneration += ![@listTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mListTypeName]
    !typedAttributeList
  ]
  !""
  ;

end method ;

#---------------------------------------------------------------------------*

override method @sortedListDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Attribute
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    @bool hasSetter := true ;
    @bool hasGetter := true ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
#--- Sort descriptor
  @stringset attributesUsedForSorting [emptySet] ;
  @sortDescriptorListForGeneration sortDescriptorList [emptyList] ;
  foreach mSortDescriptorList do
    @unifiedTypeMapProxy type ;
    [attributeMap searchKey !mSortedAttributeName ?type] ;
    sortDescriptorList += !type ![mSortedAttributeName string] !mAscending ;
    if [attributesUsedForSorting hasKey ![mSortedAttributeName string]] then
      error mSortedAttributeName : "the '" . mSortedAttributeName . "' is already used for sorting" ;
    end if ;
    attributesUsedForSorting += ![mSortedAttributeName string] ;
  end foreach ;
#--- Generate type
  ioSemanticDeclarationListForGeneration += ![@sortedListTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mSortedListTypeName]
    !typedAttributeList
    !sortDescriptorList
  ]
  !""
  ;

end method ;

#---------------------------------------------------------------------------*

override method @structDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    foreach mFeatureList do
      error mValue : "a struct attribute accepts no feature" ;
    end foreach ;
    @bool hasSetter := false ;
    @bool hasGetter := false ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
  ioSemanticDeclarationListForGeneration += ![@structTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mStructTypeName]
    !typedAttributeList
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

map @constantIndexMap {
  @uint mIndex ;
  insert insertKey error message "the '%K' constant is already declared" ;
  search searchKey error message "the '%K' constant is not declared" ;
}

#---------------------------------------------------------------------------*

override method @enumDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Constant list
  @stringlist constantList [emptyList] ;
  @constantIndexMap constantMap [emptyMap] ;
  foreach mConstantList do
    constantList += ![mValue string] ;
    [!?constantMap insertKey !mValue ![constantMap count]] ;
  end foreach ;
  const @stringset constantSet := [constantMap allKeys] ;
#--- Messages
  @enumMessageListForGeneration enumMessageList [emptyList] ;
  @stringset messageNameSet [emptySet] ;
  foreach mEnumMessageList do
    if [messageNameSet hasKey ![mEnumMessageName string]] then
      error mEnumMessageName : "this message is already declared for this enum type" ;
    end if ;
    messageNameSet += ![mEnumMessageName string] ;
    @enumMessageAssociationSortedListForGeneration enumMessageAssociationSortedListForGeneration [emptySortedList] ;
    @stringset usedConstantSet [emptySet] ; # For checking no constant is missed
    foreach mMessageAssociationList do
      @uint constantIndex ;
      [constantMap searchKey !mConstantName ?constantIndex] ;
      usedConstantSet += ![mConstantName string] ;
      enumMessageAssociationSortedListForGeneration +=
        !constantIndex
        ![mConstantName string]
        ![mMessage string]
      ;
    end foreach ;
    const @stringset missedConstantSet := constantSet - usedConstantSet ;
    foreach missedConstantSet do
      error mEnumMessageName : "the '" . mEnumMessageName . "' message definition does not name the '"
        . key . "' constant" ;
    end foreach ;
    enumMessageList += ![mEnumMessageName string] !enumMessageAssociationSortedListForGeneration ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration += ![@enumTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mEnumTypeName]
    !constantList
    !enumMessageList
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @listmapDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Check associated list is actually a list
  @typeKindEnum typeKindEnum ;
  @typedAttributeList listTypeAttributeList ;
  [inSemanticContext->mTypeMap searchKey !mAssociatedListTypeName ?2* ?typeKindEnum ?listTypeAttributeList ?18*] ;
#---
  ioSemanticDeclarationListForGeneration += ![@listmapTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mListmapTypeName]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAssociatedListTypeName]
    !listTypeAttributeList
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

map @insertMethodMap {
  insert insertKey error message "the '%K' insert modifier is already declared" ;
}

#---------------------------------------------------------------------------*

map @searchMethodMap {
  insert insertKey error message "the '%K' search method is already declared" ;
}

#---------------------------------------------------------------------------*
#         M A P                                                             *
#---------------------------------------------------------------------------*

routine check_K_escapeCharacters
 ?@lstring inString
:
#--- Check escape sequences : only %K or %%
  foreach [[inString string] componentsSeparatedByString !"%%"] do
    @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
    [!?explodedArray popFirst ?*] ;
    foreach explodedArray do
      if [mValue length] > 0 then
        const @char c := [mValue characterAtIndex !0] ;
        if c != 'K' then
          error inString: "only '%K' and '%%' escape sequences are allowed in this error message" ;
        end if ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

override method @mapDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Compute initial state set
  @stringset initialStateSet [emptySet] ;
  foreach mInsertMethodList do
    if [mMapStateList length] > 0 then
      if [mInitialStateName string] == "" then
        error mInsertMethodName: "the '" . mInsertMethodName . "' insert method should name an automaton state" ;
      else
        initialStateSet += ![mInitialStateName string] ;
      end if ;
    elsif [mInitialStateName string] != "" then
      error mInsertMethodName: "the '" . mInsertMethodName . "' insert method should not name an automaton state" ;
    end if ;
  end foreach ;
#--- Analyze map automation actions
  @mapAutomatonActionMap mapAutomatonActionMap [emptyMap] ;
  foreach mSearchMethodList do
    if [mMapStateList length] > 0 then
      if [mActionName string] == "" then
        error mSearchMethodName: "the '" . mSearchMethodName . "' search method should name an automaton action" ;
      elsif not [mapAutomatonActionMap hasKey ![mActionName string]] then
#        actionIndex := [mapAutomatonActionMap count] ;
        [!?mapAutomatonActionMap insertKey !mActionName ![mapAutomatonActionMap count]] ;
#      else
#        [mapAutomatonActionMap searchKey !mActionName ?actionIndex] ;
      end if ;
    elsif [mActionName string] != "" then
      error mSearchMethodName: "the '" . mSearchMethodName . "' search method should not name an automaton action" ;
    end if ;
  end foreach ;
#--- Analyze map automaton
  @mapAutomatonStateMap mapAutomatonStateMap [emptyMap] ;
  foreach mMapStateList do
    [!?mapAutomatonStateMap insertKey !mStateName ![mapAutomatonStateMap count]] ;
  end foreach ;
  foreach mMapStateList do
    foreach mTransitionList do
      [mapAutomatonStateMap searchKey !mTargetStateName ?*] ;
    end foreach ;
  end foreach ;
#--- Check automaton actions are all defined
  const @stringset allActions := [mapAutomatonActionMap allKeys] ;
  @mapStateSortedList mapStateSortedList [emptySortedList] ;
  foreach mMapStateList do
    @stringset actionsForCurrentState [emptySet] ;
    @mapStateTransitionSortedList mapStateTransitionSortedList [emptySortedList] ;
    foreach mTransitionList do
      @uint actionIndex ;
      [mapAutomatonActionMap searchKey !mActionName ?actionIndex] ;
      if [actionsForCurrentState hasKey ![mActionName string]] then
        error mActionName : "the '" . mActionName . "' action is already used for this state" ;
      end if ;
      actionsForCurrentState += ![mActionName string] ;
      @uint targetStateIndex ;
      [mapAutomatonStateMap searchKey !mTargetStateName ?targetStateIndex] ;
      mapStateTransitionSortedList +=
        !actionIndex
        ![mActionName string]
        !targetStateIndex
        ![mTargetStateName string]
        !mTransitionMessageKind
        ![mTransitionMessage string]
      ;
    end foreach ;
    @uint stateIndex ;
    [mapAutomatonStateMap searchKey !mStateName ?stateIndex] ;
    mapStateSortedList +=
      !stateIndex
      ![mStateName string]
      !mStateMessageKind
      ![mStateMessage string]
      !mapStateTransitionSortedList
    ;
    @stringset missingActions := allActions - actionsForCurrentState ;
    if [missingActions count] > 0 then
      @string s := "" ;
      foreach missingActions
        do s .= "'" . key . "'" ;
        between s .= ", " ;
      end foreach ;
      error mStateName : "the following actions are not named in a transition from this state: " . s ;
    end if ;
  end foreach ;
#--- Check for useful automaton states
  @stringset accessibleStates := initialStateSet ;
  @bool progress := true ;
  loop [mMapStateList length] + 1 : while progress do
    progress := false ;
    foreach mMapStateList do
      if [accessibleStates hasKey ![mStateName string]] then
        foreach mTransitionList do
          if not [accessibleStates hasKey ![mTargetStateName string]] then
            accessibleStates += ![mTargetStateName string] ;
            progress := true ;
          end if ;
        end foreach ;
      end if ;
    end foreach ;
  end loop ;
  const @stringset uselessStates := [mapAutomatonStateMap allKeys] - accessibleStates ;
  if [uselessStates count] > 0 then
    @string s := "" ;
    foreach uselessStates
      do s .= "'" . key . "'" ;
      between s .= ", " ;
    end foreach ;
    warning here : "the following map automaton states are useless: " . s ;
  end if ;
#---------------------------------- override methods
#--- Compute needed associations
  @stringset neededAssociations [emptySet] ;
  @stringset accessibilityGraph [emptySet] ;
  foreach mapAutomatonStateMap do
    @stringset reachableStates [emptySet] ;
    reachableStates += ![lkey string] ;
    @bool progress := true ;
    loop [mapAutomatonStateMap count] + 1 : while progress do
      progress := false ;
      foreach mMapStateList do
        if [reachableStates hasKey ![mStateName string]] then
          foreach mTransitionList do
            if not [reachableStates hasKey ![mTargetStateName string]] then
              reachableStates += ![mTargetStateName string] ;
              accessibilityGraph += ![lkey string] . ":" . [mTargetStateName string] ;
              progress := true ;
            end if ;
          end foreach ;
        end if ;
      end foreach ;
    end loop ;
    foreach reachableStates do
      if [lkey string] != key then
        neededAssociations += ![lkey string] . ":" . key ;
      end if ;
    end foreach ;
  end foreach ;
#---
  @mapOverrideList mapOverrideList [emptyList] ;
  foreach mMapOverrideBlockListAST do
    @stringset handledAssociations [emptySet] ;
    @stringset neededCombinaisons [emptySet] ;
    @branchBehaviourSortedListForMapOverride branchBehaviourSortedListForMapOverride1 [emptySortedList] ;
    foreach mMapOverrideBlockDescriptor1AST do
      @uint startStateNameIndex ;
      [mapAutomatonStateMap searchKey !mLeftState ?startStateNameIndex] ;
      @uint currentStateNameIndex ;
      [mapAutomatonStateMap searchKey !mRightState ?currentStateNameIndex] ;
      const @string association := [mLeftState string] . ":" . [mRightState string] ;
      if not [neededAssociations hasKey !association] then
        warning mRightState :"the '" . association . "' association is useless" ;
      end if ;
      if [handledAssociations hasKey !association] then
        error mRightState
        :"the '" . association . "' association is already defined" ;
      end if ;
      handledAssociations += !association ;
      @uint finalStateNameIndex ;
      [mapAutomatonStateMap searchKey !mResultingState ?finalStateNameIndex] ;
      if [mLeftState string] != [mResultingState string] then
        neededCombinaisons += ![mLeftState string] . ":" . [mResultingState string] ;
        neededCombinaisons += ![mResultingState string] . ":" . [mLeftState string] ;
        if not [accessibilityGraph hasKey ![mLeftState string] . ":" . [mRightState string]] then
          error mResultingState
          : "the '" . mResultingState . "' state is not reachable from '" . mLeftState . "' state"
          ;
        end if ;
      end if ;
      check_K_escapeCharacters !mTransitionMessage ;
      branchBehaviourSortedListForMapOverride1 +=
        !startStateNameIndex
        ![mLeftState string]
        !currentStateNameIndex
        ![mRightState string]
        !finalStateNameIndex
        ![mResultingState string]
        !mMessageKind
        ![mTransitionMessage string]
      ;
    end foreach ;
    @stringset forgottenAssociations := neededAssociations - handledAssociations ;
    if [forgottenAssociations count] > 0 then
      @string s := "" ;
      foreach forgottenAssociations do
        s .= "\n  - " . key ;
      end foreach ;
      error here: [[forgottenAssociations count] string] . " associations should be defined:" . s ;
    end if ;
    @stringset definedCombinaisons [emptySet] ;
    @branchBehaviourSortedListForMapOverride branchBehaviourSortedListForMapOverride2 [emptySortedList] ;
    foreach mMapOverrideBlockDescriptor2AST do
      @uint leftStateIndex ;
      [mapAutomatonStateMap searchKey !mLeftState ?leftStateIndex] ;
      @uint rightStateIndex ;
      [mapAutomatonStateMap searchKey !mRightState ?rightStateIndex] ;
      const @string combinaison := [mLeftState string] . ":" . [mRightState string] ;
      if not [neededCombinaisons hasKey !combinaison] then
        error mRightState
        :"the '" . mLeftState . ":" . mRightState . "' combinaison is useless" ;
      end if ;
      if [definedCombinaisons hasKey !combinaison] then
        error mRightState
        :"the '" . mLeftState . ":" . mRightState . "' combinaison is already defined" ;
      end if ;
      definedCombinaisons += !combinaison ;
      if mMessageKind == [@mapAutomatonMessageKind noMessage] then
        definedCombinaisons += ![mRightState string] . ":" . [mLeftState string] ;
      end if ;
      @uint resultingStateNameIndex ;
      [mapAutomatonStateMap searchKey !mResultingState ?resultingStateNameIndex] ;
      if ([mLeftState string] != [mResultingState string])
       & ([mRightState string] != [mResultingState string])
       & not [accessibilityGraph hasKey ![mLeftState string] . ":" . [mResultingState string]] then
        error mResultingState
        :"the '" . mResultingState . "' state cannot be reached from the '" . mResultingState . "' state" ;
      end if ;
      check_K_escapeCharacters !mTransitionMessage ;
      branchBehaviourSortedListForMapOverride2 +=
        !leftStateIndex
        ![mLeftState string]
        !rightStateIndex
        ![mRightState string]
        !resultingStateNameIndex
        ![mResultingState string]
        !mMessageKind
        ![mTransitionMessage string]
      ;
    end foreach ;
    if [forgottenAssociations count] == 0 then # Check only if all associations are defined
      @stringset forgottenCombinaisons := neededCombinaisons - definedCombinaisons ;
      if [forgottenCombinaisons count] > 0 then
        @string s := "" ;
        foreach forgottenCombinaisons do
          s .= "\n  - " . key ;
        end foreach ;
        error here: [[forgottenCombinaisons count] string] . " combinaisons are forgotten:" . s ;
      end if ;
    end if ;
    mapOverrideList +=
      ![mOverrideBlockName string]
      !branchBehaviourSortedListForMapOverride1
      !branchBehaviourSortedListForMapOverride2
    ;
  end foreach ;
#------ Enter attributes
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    @bool hasSetter := true ;
    @bool hasGetter := true ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
#--- Enter insert modifiers
  @insertMethodMap insertMethodMap [emptyMap] ;
  foreach mInsertMethodList do
    [!?insertMethodMap insertKey !mInsertMethodName] ;
  #--- Check error message escape sequences : only %K, %L or %%
    foreach [[mErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if (c != 'K') & (c != 'L') then
            error mErrorMessage: "only '%K', '%L' and '%%' escape sequences are allowed in an insert error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  #--- Check shadow error message escape sequences : only %K, %L or %%
    foreach [[mShadowErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if (c != 'K') & (c != 'L') then
            error mErrorMessage: "only '%K', '%L' and '%%' escape sequences are allowed in a shadow error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Enter search methods
  @searchMethodMap searchMethodMap [emptyMap] ;
  foreach mSearchMethodList do
    if [mMapStateList length] == 0 then # ยง
      [!?searchMethodMap insertKey !mSearchMethodName] ;
    else
      [!?searchMethodMap insertKey !mSearchMethodName] ;
    end if ;
  #--- Check error message escape sequences : only %K or %%
    foreach [[mErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if c != 'K' then
            error mErrorMessage: "only '%K' and '%%' escape sequences are allowed in a search error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Enter remove methods
  foreach mRemoveMethodList do
    [!?insertMethodMap insertKey !mMethodName] ;
  #--- Check error message escape sequences : only %K or %%
    foreach [[mErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if c != 'K' then
            error mErrorMessage: "only '%K' and '%%' escape sequences are allowed in a remove error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Warn for duplicated declarations or 'insertOrReplace' modifier
  foreach mInsertOrReplaceDeclarationListAST index IDX do
    if IDX > 0 then
      warning mInsertOrReplaceDeclarationLocation: "the 'insertOrReplace' modifier is already declared" ;
    end if ;
  end foreach ;
  const @bool hasInsertOrReplaceModifier := [mInsertOrReplaceDeclarationListAST length] > 0 ;
  if hasInsertOrReplaceModifier & [insertMethodMap hasKey !"insertOrReplace"] then
    @location insertOrReplaceDeclarationLocation ;
    [mInsertOrReplaceDeclarationListAST first ?insertOrReplaceDeclarationLocation] ;
    error insertOrReplaceDeclarationLocation : "the insertOrReplace' modifier cannot be declared : an insert modifier or a remove modifier has been declared with this name" ;
  end if ;
#--- Enter 'with' accessors
  @withAccessorMap withAccessorMap [emptyMap] ;
  [!?withAccessorMap insertKey ![@lstring new !"hasKey" !here] !inPredefinedTypes->mStringType] ;
  foreach mSearchMethodList do
    [!?withAccessorMap insertKey
      !mSearchMethodName
      !inPredefinedTypes->mLStringType
    ] ;
  end foreach ;
#--- Enter map declaration
  ioSemanticDeclarationListForGeneration += ![@mapTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mMapTypeName]
    !mMapTypeName
    !typedAttributeList
    !mInsertMethodList
    !mSearchMethodList
    !mRemoveMethodList
    !hasInsertOrReplaceModifier
    !withAccessorMap
    !mapAutomatonStateMap
    !mapAutomatonActionMap
    !mapStateSortedList
    !mapOverrideList
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @mapProxyDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Get attribute list of associated map
  @typedAttributeList listTypeAttributeList ;
  @mapSearchMethodListAST searchMethodList ;
  [inSemanticContext->mTypeMap searchKey !mAssociatedMapTypeName ?5* ?listTypeAttributeList ?12* ?searchMethodList ?3*] ;
#---
  ioSemanticDeclarationListForGeneration += ![@mapProxyTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mMapProxyTypeName]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAssociatedMapTypeName]
    !listTypeAttributeList
    !searchMethodList
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

map @declaredMethodMap { # This map is used for checking a method is declared once within a class
  insert insertKey error message "the '%K' method is already declared in %L for this class" ;
}

#---------------------------------------------------------------------------*

routine buildLocalVariableMapAndSignature
  ??@semanticContext inSemanticContext
  ??@formalParameterListAST inRoutineSignatureAST
  ?!@variableMap ioVariableMap
  !@formalParameterListForGeneration outRoutineSignature
:
  outRoutineSignature := [@formalParameterListForGeneration emptyList] ;
  foreach inRoutineSignatureAST do
    const @unifiedTypeMapProxy type [searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
    @string formalArgumentCppName ;
    switch mFormalArgumentPassingMode
    when argumentIn :
      formalArgumentCppName := "inArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      if mIsUnused then
        [!?ioVariableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      else
        [!?ioVariableMap insertInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      end if ;
    when argumentOut :
      formalArgumentCppName := "outArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      [!?ioVariableMap insertOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
    when argumentInOut :
      formalArgumentCppName := "ioArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      if mIsUnused then
        [!?ioVariableMap insertInputOutputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      else
        [!?ioVariableMap insertInputOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      end if ;
    when argumentConstantIn :
      formalArgumentCppName := "constinArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      if mIsUnused then
        [!?ioVariableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      else
        [!?ioVariableMap insertConstantInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      end if ;
    end switch ;
    outRoutineSignature += !mFormalArgumentPassingMode !type !mFormalArgumentName !formalArgumentCppName ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine analyzeRoutineBody
  ??@analysisContext inAnalysisContext
  ??@formalParameterListAST inRoutineSignatureAST
  ??@localConstantList inLocalConstantList
  ??@typedAttributeList inTypedAttributeList
  ??@string inAttributeVariableNamePrefix
  ??@semanticInstructionListAST inInstructionList
  ??@location inEndOfMethodLocation
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
  !@formalParameterListForGeneration outRoutineSignature
:
  @variableMap variableMap [emptyMap] ;
#--- Declare local constants
  foreach inLocalConstantList do
    if mNoWarningIfUnused then
      [!?variableMap insertUsedLocalConstant !mName !mType !mCppName !selfMarkName []] ;
    else
      [!?variableMap insertLocalConstant !mName !mType !mCppName !selfMarkName []] ;
    end if ;
  end foreach ;
#--- Enter instance attributes
  foreach inTypedAttributeList do
    [!?variableMap insertNonMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix . "mAttribute_". [[mAttributeName string] identifierRepresentation]
      !selfMarkName []
    ] ;
  end foreach ;
#--- Enter formal arguments
  buildLocalVariableMapAndSignature
    !inAnalysisContext->mSemanticContext
    !inRoutineSignatureAST
    !?variableMap
    ?outRoutineSignature
  ;
#---  Analyze instruction list
  outSemanticInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  foreach inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ] ;
   end foreach ;
#---
  [variableMap checkAutomatonStates !inEndOfMethodLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @externFunctionDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  @formalInputParameterListForGeneration formalArgumentList [emptyList] ;
  foreach mFormalArgumentList do
    formalArgumentList +=
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      ![mFormalArgumentName string]
      !mFormalArgumentName
      !mIsUnused
    ;
  end foreach ;
  ioSemanticDeclarationListForGeneration += ![@functionPrototypeDeclarationForGeneration new
    ![mFunctionName string]
    !formalArgumentList
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mResultTypeName]
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @externRoutineDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  @formalParameterListForGeneration formalArgumentList [emptyList] ;
  foreach mFormalArgumentList do
    formalArgumentList +=
      !mFormalArgumentPassingMode
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      !mFormalArgumentName
      ![mFormalArgumentName string]
    ;
  end foreach ;
  ioSemanticDeclarationListForGeneration += ![@routinePrototypeDeclarationForGeneration new
    ![mRoutineName string]
    !formalArgumentList
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @routineDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Instruction list
  @formalParameterListForGeneration formalArgumentList [emptyList] ;
  @semanticInstructionListForGeneration instructionList ;
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
  ] ;
  analyzeRoutineBody
    !analysisContext
    !mFormalArgumentList
    ![@localConstantList emptyList]
    ![@typedAttributeList emptyList]
    !""
    !mRoutineInstructionList
    !mEndOfRoutineInstructionList
    ?instructionList
    ?formalArgumentList
  ;
#---
  ioSemanticDeclarationListForGeneration += ![@routineImplementationForGeneration new
    ![mRoutineName string]
    !formalArgumentList
    !instructionList
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @classDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#------ Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mClassTypeName] ;
#------ Super type, and class features
# A class that has a super may not have any feature
# A class without a super class admits the 'generatedInSeparateFile' feature
  @unifiedTypeMapProxy superClassProxy ;
  @typedAttributeList allAttributeList ;
  @instanceMethodMap inheritedInstanceMethodMap ;
  if [mSuperClassName string] == "" then
    superClassProxy := [@unifiedTypeMapProxy null] ;
    allAttributeList := [@typedAttributeList emptyList] ;
    inheritedInstanceMethodMap := [@instanceMethodMap emptyMap] ;
    @bool generatedInSeparateFileFeature := false ;
    if [mClassFeatureList length] > 0 then
      foreach mClassFeatureList do
        if [mValue string] == "generatedInSeparateFile" then
          if generatedInSeparateFileFeature then
            error mValue:"the 'generatedInSeparateFile' is already named" ;
          end if ;
          generatedInSeparateFileFeature := true ;
        else
          error mValue:"only the 'generatedInSeparateFile' feature is allowed here" ;
        end if ;
      end foreach ;
    end if ;
  else
    superClassProxy := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mSuperClassName] ;
    allAttributeList := [superClassProxy mAllTypedAttributeList] ;
    inheritedInstanceMethodMap := [superClassProxy mInstanceMethodMap] ;
    if [mClassFeatureList length] > 0 then
      foreach mClassFeatureList do
        error mValue:"a class that has a super may not have any feature" ;
      end foreach ;
    end if ;
  end if ;
#------ Enter attributes
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    @bool hasSetter := false ;
    @bool hasGetter := true ;
    foreach mFeatureList do
      if [mValue string] == "setter" then
        if hasSetter then
          error mValue : "the 'setter' feature is already named" ;
        end if ;
        hasSetter := true ;
      elsif [mValue string] == "nogetter" then
        if not hasGetter then
          error mValue : "the 'nogetter' feature is already named" ;
        end if ;
        hasGetter := false ;
      else
        error mValue : "only the 'setter' or 'nogetter' are allowed here" ;
      end if ;
    end foreach ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    allAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
#------ Check a method is defined once within class
  @declaredMethodMap classMethodMap [emptyMap] ;
  foreach mAbstractMethodList do
   [!?classMethodMap insertKey !mMethodName] ;
  end foreach ;
  foreach mMethodList do
   [!?classMethodMap insertKey !mMethodName] ;
  end foreach ;
#------ Abstract methods
  @abstractMethodDefinitionListForGeneration abstractMethodList [emptyList] ;
  foreach mAbstractMethodList do
  #--- Check a concrete class does not declare an abstract method
    if not mIsAbstract then
      error mMethodName : "a concrete class cannot declare an abstract method" ;
    end if ;
  #--- Compute method signature
    @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
    foreach mSignature do
      formalParameterListForGeneration +=
        !mFormalArgumentPassingMode
        ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
        !mFormalArgumentName
        ![mFormalArgumentName string]
      ;
    end foreach ;
  #--- Check overriding status
    if mIsOverriding then
      @formalParameterSignature inheritedSignature ;
      @location inheritedDeclarationLocation ;
      [inheritedInstanceMethodMap searchInheritedKey !mMethodName ?* ?inheritedSignature ?inheritedDeclarationLocation ?2*] ;
      checkMethodSignatures
        !formalParameterListForGeneration
        ![mMethodName location]
        !inheritedSignature
        !inheritedDeclarationLocation
      ;
    elsif [inheritedInstanceMethodMap hasKey ![mMethodName string]] then
      error mMethodName : "this method cannot be declared as abstract, it is already declared in super class" ;
    end if ;
    abstractMethodList += !mIsOverriding !mMethodName !formalParameterListForGeneration ;
  end foreach ;
#------ Methods
  @methodDefinitionListForGeneration methodList [emptyList] ;
  @stringset definedMethodSet [emptySet] ;
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"this"
  ] ;
  foreach mMethodList do
  #---
    @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
    @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
    analyzeRoutineBody
      !analysisContext
      !mSignature
      ![@localConstantList emptyList]
      !allAttributeList
      !""
      !mInstructionList
      !mEndOfMethodLocation
      ?semanticInstructionListForGeneration
      ?formalParameterListForGeneration
    ;
  #--- Check overriding status
    if mIsOverriding then
      @formalParameterSignature inheritedSignature ;
      @location inheritedDeclarationLocation ;
      @bool inheritedIsCategory ;
      [inheritedInstanceMethodMap searchInheritedKey !mMethodName ?inheritedIsCategory ?inheritedSignature ?inheritedDeclarationLocation ?2*] ;
      checkMethodSignatures
        !formalParameterListForGeneration
        ![mMethodName location]
        !inheritedSignature
        !inheritedDeclarationLocation
      ;
      if inheritedIsCategory then
        error mMethodName : "this method is declared in class, but overriden method is declared as multi-method" ;
      end if ;
    elsif [inheritedInstanceMethodMap hasKey ![mMethodName string]] then
      error mMethodName : "this method should be declared as overridding, as it is already declared in super class" ;
    end if ;
  #---
    definedMethodSet += ![mMethodName string] ;
    methodList +=
      !mIsOverriding
      !mMethodName
      !formalParameterListForGeneration
      !semanticInstructionListForGeneration
    ;
  end foreach ;
#------ Check a concrete class has no abstract method
  if not mIsAbstract then
    foreach inheritedInstanceMethodMap do
      if (mQualifier == [@methodQualifier isAbstract]) | (mQualifier == [@methodQualifier isOverridingAbstract]) then
        if not [definedMethodSet hasKey ![lkey string]] then
          error lkey : "the '@" . mClassTypeName . "' class is declared concrete, but the '" . lkey . "' method declared in a super class is not implemented" ;
        end if ;    
      end if ;
    end foreach ;
  end if ;
#------ Compute sort string (used for sorting generated code)
  @string sortString := [selfType key] ;
  @unifiedTypeMapProxy t := [selfType mSuperType] ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while not [t isNull] do
    sortString := [t key] . "." . sortString ;
    t := [t mSuperType] ;
  end loop ;
#------
  ioSemanticDeclarationListForGeneration += ![@classTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mClassTypeName]
    !mIsAbstract
    !mClassTypeName
    !superClassProxy
    !allAttributeList
    !typedAttributeList
    !abstractMethodList
    !methodList
    ![selfType mInstanceMethodMap]
    ![selfType mGenerateHeaderInSeparateFile]
  ]
  !sortString
  ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeFunctionBody
  ??@analysisContext inAnalysisContext
  ??@formalInputParameterListAST inFunctionSignature
  ??@typedAttributeList inTypedAttributeList
  ??@string inAttributeVariableNamePrefix
  ??@semanticInstructionListAST inInstructionList
  ??@lstring inReturnVariableName
  ??@lstring inResultTypeName
  ??@location inEndOfFunctionLocation
  !@formalInputParameterListForGeneration outSignatureForGeneration
  !@unifiedTypeMapProxy outReturnedType
  !@string outResultVariableCppName
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
:
  @variableMap variableMap [emptyMap] ;
#--- Enter instance attributes
  foreach inTypedAttributeList do
    [!?variableMap insertNonMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix . "mAttribute_". [[mAttributeName string] identifierRepresentation]
      !selfMarkName []
    ] ;
  end foreach ;
#--- Enter formal parameters
  outSignatureForGeneration := [@formalInputParameterListForGeneration emptyList] ;
  foreach inFunctionSignature do
    const @unifiedTypeMapProxy parameterType [searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
    if mIsConstant then
      const @string cppName := "constinArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      outSignatureForGeneration +=
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsUnused
      ;
      if mIsUnused then
        [!?variableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName] ;
      else
        [!?variableMap insertConstantInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName] ;
      end if ;
    else
      const @string cppName := "inArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      outSignatureForGeneration +=
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsUnused
      ;
      if mIsUnused then
        [!?variableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName] ;
      else
        [!?variableMap insertInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName] ;
      end if ;
    end if ;
  end foreach ;
#--- Enter return variable
  outReturnedType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !inResultTypeName] ;
  outResultVariableCppName := "result_" . [[inResultTypeName string] identifierRepresentation] ;
  [!?variableMap insertOutputFormalArgument !inReturnVariableName !outReturnedType !outResultVariableCppName !outResultVariableCppName] ;
#---  Analyze instruction list
  outSemanticInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  foreach inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ] ;
   end foreach ;
#---
  [variableMap checkAutomatonStates !inEndOfFunctionLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @functionDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Analyse function body  
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  @formalInputParameterListForGeneration formalInputParameterList ;
  @unifiedTypeMapProxy returnType ;
  @string resultVariableCppName ;
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
  ] ;
  analyzeFunctionBody
    !analysisContext
    !mFormalArgumentList
    ![@typedAttributeList emptyList]
    !""
    !mFunctionInstructionList
    !mResultVariableName
    !mResultTypeName
    !mEndOfFunctionInstructionList
    ?formalInputParameterList
    ?returnType
    ?resultVariableCppName
    ?semanticInstructionListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration += ![@functionImplementationForGeneration new
    ![mFunctionName string]
    !formalInputParameterList
    !returnType
    !resultVariableCppName
    !semanticInstructionListForGeneration
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Analyse function body  
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  @unifiedTypeMapProxy returnType ;
  @string resultVariableCppName ;
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
  ] ;
  analyzeFunctionBody
    !analysisContext
    ![@formalInputParameterListAST emptyList]
    ![@typedAttributeList emptyList]
    !""
    !mFunctionInstructionList
    !mResultVariableName
    !mResultTypeName
    !mEndOfFunctionInstructionList
    ?*
    ?returnType
    ?resultVariableCppName
    ?semanticInstructionListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration += ![@onceFunctionDeclarationForGeneration new
    ![mFunctionName string]
    !returnType
    !resultVariableCppName
    !semanticInstructionListForGeneration
  ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#     F I L E W R A P P E R    A N A L Y S I S                              *
#                                                                           *
#---------------------------------------------------------------------------*

override method @filewrapperDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Get filewrapper features
  @wrapperFileMap wrapperFileMap ;
  @wrapperDirectoryMap wrapperDirectoryMap ;
  [inSemanticContext->mFilewrapperMap searchKey
    !mFilewrapperName
    ?*
    ?*
    ?wrapperFileMap
    ?wrapperDirectoryMap
    ?*
  ] ;
#--- Build absolute path
  @string absoluteSourcePath ;
  if [[mFilewrapperPath string] firstCharacterOrNul] == '/' then
    absoluteSourcePath := [mFilewrapperPath string] ;
  else
    absoluteSourcePath := [[inSemanticContext mSourceFileAbsolutePath] stringByDeletingLastPathComponent] . "/" . [mFilewrapperPath string] ;
  end if ;
  if not [absoluteSourcePath directoryExists] then
    error mFilewrapperPath: "The '" . absoluteSourcePath . "' directory does not exist" ;
  else
  #---- Analyze filewrapper templates
    @filewrapperTemplateListForGeneration filewrapperTemplateListForGeneration [emptyList] ;
    foreach mFilewrapperTemplateList do
      if [[mFilewrapperTemplatePath string] firstCharacterOrNul] == '/' then
        error mFilewrapperTemplatePath : "the path should not begin with a '/'; it is relative to filewrapper path '" . absoluteSourcePath . "'" ;
      end if ;
      const @string absoluteTemplatePath := absoluteSourcePath . "/" . mFilewrapperTemplatePath ;
      @templateInstructionListAST resultingInstructionList ;
    #--- Parse template
      grammar templateGrammar in [@lstring new !absoluteTemplatePath ![mFilewrapperTemplatePath location]] ?resultingInstructionList ;
    #--- Build template variable map
      @templateVariableMap templateVariableMap [emptyMap] ;
      @formalInputParameterListForGeneration filewrapperTemplateFormalInputParameters [emptyList] ;
      foreach mFilewrapperTemplateFormalInputParameters do
        @unifiedTypeMapProxy type [searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        const @string cppVarName := "in_" . [[mFormalArgumentName string] identifierRepresentation] ;
        [!?templateVariableMap insertKey !mFormalArgumentName !type !cppVarName] ;
        filewrapperTemplateFormalInputParameters += !type !cppVarName !mFormalArgumentName !true ;
      end foreach ;
    #--- Analyze template
      @templateInstructionListForGeneration templateInstructionListForGeneration [emptyList] ;
      const @templateAnalysisContext templateAnalysisContext [new
        !inSemanticContext
        !inPredefinedTypes
        !templateVariableMap
      ] ;
      templateInstructionListAnalysis !templateAnalysisContext !resultingInstructionList !?templateInstructionListForGeneration ;
    #--- Enter in generation list
      filewrapperTemplateListForGeneration +=
        ![mFilewrapperTemplateName string]
        !filewrapperTemplateFormalInputParameters
        !templateInstructionListForGeneration
      ;
    end foreach ;
  #---- Enter filewrapper in generated list
    ioSemanticDeclarationListForGeneration += ![@filewrapperDeclarationForGeneration new
      ![mFilewrapperName string]
      ![mFilewrapperPath string]
      !wrapperFileMap
      !wrapperDirectoryMap
      !filewrapperTemplateListForGeneration
    ]
  !""
  ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryMethodAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mAbstractCategoryMethodName: "cannot declare a category method: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryMethodName: "cannot declare an abstract category method: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Compute method signature
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  foreach mAbstractCategoryMethodFormalParameterList do
    formalParameterListForGeneration +=
      !mFormalArgumentPassingMode
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      !mFormalArgumentName
      ![mFormalArgumentName string]
    ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration += ![@abstractCategoryMethodForGeneration new
    ![mTypeName string]
    ![mAbstractCategoryMethodName string]
    !formalParameterListForGeneration
  ]
  !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @categoryMethodAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mCategoryMethodName: "cannot declare a category method: '@" . [selfType key] . "' is not a class" ;
  end if ;
#--- Analyze instruction list
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
  ] ;
  analyzeRoutineBody
    !analysisContext
    !mCategoryMethodFormalParameterList
    ![@localConstantList emptyList]
    ![selfType mAllTypedAttributeList]
    !"object->"
    !mCategoryMethodInstructionList
    !mEndOfMethodLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration += ![@categoryMethodForGeneration new
    ![mTypeName string]
    ![mCategoryMethodName string]
    !formalParameterListForGeneration
    ![selfType mAllTypedAttributeList]
    !semanticInstructionListForGeneration
  ]
  !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingCategoryMethodAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mOverridingCategoryMethodName: "cannot declare a category method: '@" . [selfType key] . "' is not a class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @formalParameterSignature inheritedSignature [emptyList] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mInstanceMethodMap] hasKey ![mOverridingCategoryMethodName string]] then
      @methodQualifier qualifier ;
      [[superType mInstanceMethodMap] searchKey !mOverridingCategoryMethodName ?* ?inheritedSignature ?inheritedDeclarationLocation ?* ?qualifier] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
#--- Analyze instruction list
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
  ] ;
  analyzeRoutineBody
    !analysisContext
    !mOverridingCategoryMethodFormalParameterList
    ![@localConstantList emptyList]
    ![selfType mAllTypedAttributeList]
    !"object->"
    !mOverridingCategoryMethodInstructionList
    !mEndOfMethodLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  ;
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures
      !formalParameterListForGeneration
      ![mOverridingCategoryMethodName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    ;
  end if ;
#---
  ioSemanticDeclarationListForGeneration += ![@overridingCategoryMethodForGeneration new
    ![mTypeName string]
    !baseTypeName
    ![mOverridingCategoryMethodName string]
    !formalParameterListForGeneration
    ![selfType mAllTypedAttributeList]
    !semanticInstructionListForGeneration
  ]
  !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingAbstractCategoryMethodAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mOverridingCategoryMethodName: "cannot declare a category method: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mOverridingCategoryMethodName: "cannot declare an abstract category method: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @formalParameterSignature inheritedSignature [emptyList] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mInstanceMethodMap] hasKey ![mOverridingCategoryMethodName string]] then
      @methodQualifier qualifier ;
      [[superType mInstanceMethodMap] searchKey !mOverridingCategoryMethodName ?* ?inheritedSignature ?inheritedDeclarationLocation ?* ?qualifier] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
#--- Analyze formal argument list
  @variableMap variableMap [emptyMap] ;
  @formalParameterListForGeneration formalParameterListForGeneration ;
  buildLocalVariableMapAndSignature
    !inSemanticContext
    !mOverridingCategoryMethodFormalParameterList
    !?variableMap
    ?formalParameterListForGeneration
  ;
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures
      !formalParameterListForGeneration
      ![mOverridingCategoryMethodName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryReaderAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mAbstractCategoryReaderName: "cannot declare a category reader: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryReaderName: "cannot declare an abstract category reader: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Compute method signature
  @formalInputParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  foreach mAbstractCategoryReaderFormalInputParameterList do
    formalParameterListForGeneration +=
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      ![mFormalArgumentName string]
      !mFormalArgumentName
      !mIsUnused
    ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration += ![@abstractCategoryReaderForGeneration new
    ![mTypeName string]
    ![mAbstractCategoryReaderName string]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAbstractCategoryReaderReturnedTypeName]
    !formalParameterListForGeneration
  ]
  !"~" # So that category are declared at the end of the file
  ;
end method ;


#---------------------------------------------------------------------------*

override method @categoryReaderAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:

#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mCategoryReaderName: "cannot declare a category reader: '@" . [selfType key] . "' is not a class" ;
  end if ;
#--- Analyze instruction list
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
  ] ;
  @unifiedTypeMapProxy returnType ;
  @string returnVariableCppName ;
  @formalInputParameterListForGeneration formalParameterListForGeneration ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  analyzeFunctionBody
    !analysisContext
    !mCategoryReaderFormalInputParameterList
    ![selfType mAllTypedAttributeList]
    !"object->"
    !mCategoryReaderInstructionList
    !mCategoryReaderReturnedVariableName
    !mCategoryReaderReturnedTypeName
    !mEndOfReaderLocation
    ?formalParameterListForGeneration
    ?returnType
    ?returnVariableCppName
    ?semanticInstructionListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration += ![@categoryReaderForGeneration new
    ![mTypeName string]
    ![mCategoryReaderName string]
    !returnType
    !returnVariableCppName
    !formalParameterListForGeneration
    ![selfType mAllTypedAttributeList]
    !semanticInstructionListForGeneration
  ]
  !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingCategoryReaderAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mOverridingCategoryReaderName: "cannot declare a category reader: '@" . [selfType key] . "' is not a class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @unifiedTypeMapProxyList inheritedSignature [emptyList] ;
  @unifiedTypeMapProxy inheritedReturnType [null] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mReaderMap] hasKey ![mOverridingCategoryReaderName string]] then
      @methodQualifier qualifier ;
      [[superType mReaderMap] searchKey
        !mOverridingCategoryReaderName
        ?*
        ?inheritedSignature
        ?inheritedDeclarationLocation
        ?*
        ?inheritedReturnType
        ?qualifier
      ] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
#--- Analyze instruction list
  const @analysisContext analysisContext [new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
  ] ;
  @unifiedTypeMapProxy returnType ;
  @string returnVariableCppName ;
  @formalInputParameterListForGeneration formalParameterListForGeneration ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  analyzeFunctionBody
    !analysisContext
    !mOverridingCategoryReaderFormalInputParameterList
    ![selfType mAllTypedAttributeList]
    !"object->"
    !mOverridingCategoryReaderInstructionList
    !mOverridingCategoryReaderReturnedVariableName
    !mOverridingCategoryReaderReturnedTypeName
    !mEndOfReaderLocation
    ?formalParameterListForGeneration
    ?returnType
    ?returnVariableCppName
    ?semanticInstructionListForGeneration
  ;
#--- Check Signature
  if baseTypeName != "" then
    checkReaderSignatures
      !formalParameterListForGeneration
      !returnType
      ![mOverridingCategoryReaderName location]
      !inheritedSignature
      !inheritedReturnType
      !inheritedDeclarationLocation
    ;
  end if ;
#---
  ioSemanticDeclarationListForGeneration += ![@overrideCategoryReaderForGeneration new
    ![mTypeName string]
    !baseTypeName
    ![mOverridingCategoryReaderName string]
    !returnType
    !returnVariableCppName
    !formalParameterListForGeneration
    ![selfType mAllTypedAttributeList]
    !semanticInstructionListForGeneration
  ]
  !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingAbstractCategoryReaderAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Return type
  const @unifiedTypeMapProxy returnType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAbstractCategoryReaderReturnedTypeName] ;
#--- Check type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mAbstractCategoryReaderName: "cannot declare a category reader: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryReaderName: "cannot declare an abstract category reader: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @unifiedTypeMapProxyList inheritedSignature [emptyList] ;
  @unifiedTypeMapProxy inheritedReturnType [null] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mReaderMap] hasKey ![mAbstractCategoryReaderName string]] then
      @methodQualifier qualifier ;
      [[superType mReaderMap] searchKey
        !mAbstractCategoryReaderName
        ?*
        ?inheritedSignature
        ?inheritedDeclarationLocation
        ?*
        ?inheritedReturnType
        ?qualifier] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
#--- Check Signature
  if baseTypeName != "" then
    @formalInputParameterListForGeneration formalParameterListForGeneration [emptyList] ;
    foreach mAbstractCategoryReaderFormalInputParameterList do
      formalParameterListForGeneration +=
        ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
        ![mFormalArgumentName string]
        !mFormalArgumentName
        !mIsUnused
      ;
    end foreach ;
    checkReaderSignatures
      !formalParameterListForGeneration
      !returnType
      ![mAbstractCategoryReaderName location]
      !inheritedSignature
      !inheritedReturnType
      !inheritedDeclarationLocation
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#    P R E D E F I N E D    T Y P E S                                       *
#                                                                           *
#---------------------------------------------------------------------------*

function buildPredefinedTypes
  ??@semanticContext inSemanticContext
  ->@predefinedTypes outPredefinedTypes
:
  outPredefinedTypes := [@predefinedTypes new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"location" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"bool" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"char" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"string" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"uint" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"sint" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"uint64" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"sint64" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"double" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lbool" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lchar" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lstring" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"luint" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lsint" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"luint64" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lsint64" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"ldouble" !here]]
  ] ;
end function ;

#---------------------------------------------------------------------------*
#                                                                           *
#    P E R F O R M     S E M A N T I C     A N A L Y S I S                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine performSemanticAnalysis
  ??@semanticDeclarationListAST inDeclarationList
  ??@semanticContext inSemanticContext
  !@semanticDeclarationSortedListForGeneration outDecoratedDeclarationListForGeneration
:
  const @predefinedTypes predefinedTypes := buildPredefinedTypes [!inSemanticContext] ;
  outDecoratedDeclarationListForGeneration := [@semanticDeclarationSortedListForGeneration emptySortedList] ;
  foreach inDeclarationList do
    [mSemanticDeclaration performSemanticAnalysis
      !inSemanticContext
      !predefinedTypes
      !?outDecoratedDeclarationListForGeneration
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
