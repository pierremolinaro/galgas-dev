#---------------------------------------------------------------------------*
#                                                                           *
#  metamodel that defines expression                                        *
#                                                                           *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticAnalysis :
  import "semanticInstructionsAnalysis.gSemantics" ;
  import "templateGrammar.gGrammar" ;
  import "templateAnalysis.gSemantics" ;
  import "lexiqueSemantics.gSemantics" ;
  import "grammarSemantics.gSemantics" ;
  import "lexiqueCompilation.gSemantics" ;
  import "syntaxSignature.gSemantics" ;

  import "grammarCompilation.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    C H E C K    M E T H O D    S I G N A T U R E                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkMethodSignatures
  ??@formalParameterListForGeneration inTestedSignature
  ??@location inErrorLocation
  ??@formalParameterSignature inReferenceSignature
  ??@location inReferenceLocation
:
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this method declares " . [[inTestedSignature length] string]
    . " formal parameter(s), but overriden method declares " . [[inReferenceSignature length] string]
    ;
    error inReferenceLocation:"overriden method is declared here" ;
  else
    foreach inReferenceSignature : ref_, inTestedSignature do
      if ref_mFormalArgumentPassingMode != mFormalArgumentPassingMode then
        error mFormalArgumentName : "the '" . mFormalArgumentName . "' formal parameter is declared as "
        . [mFormalArgumentPassingMode formalArgumentMessage] . ", but overriden method declares it as " 
        . [ref_mFormalArgumentPassingMode formalArgumentMessage] ;
        error inReferenceLocation:"overriden method is declared here" ;
      end if ;
      if mFormalSelector->string != ref_mFormalSelector->string then
        error mFormalSelector : "the selector should be '" . [ref_mFormalArgumentPassingMode string] . ref_mFormalSelector . if ref_mFormalSelector->string != "" then ":" else "" end + "'" ;
      end if ;
      if [mFormalArgumentType key] != [ref_mFormalArgumentType key] then
        error mFormalArgumentName : "the '" . mFormalArgumentName . "' formal parameter has the '@"
        . [mFormalArgumentType key] . "' type, but overriden method declares with the '@" 
        . [ref_mFormalArgumentType key] . "' type" ;
        error inReferenceLocation:"overriden method is declared here" ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    C H E C K    R E A D E R    S I G N A T U R E                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkReaderSignatures
  ??@formalInputParameterListForGeneration inTestedSignature
  ??@unifiedTypeMapProxy inReturnType
  ??@location inErrorLocation
  ??@functionSignature inReferenceSignature
  ??@unifiedTypeMapProxy inInheritedReturnType
  ??@location inReferenceLocation
:
  if [inReturnType key] != [inInheritedReturnType key] then
    error inErrorLocation : "the return type is '@"
    . [inReturnType key] . "', but overriden getter names '@" 
    . [inInheritedReturnType key] . "' as return type" ;
    error inReferenceLocation:"overriden getter is declared here" ;
  end if ;
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this getter declares " . [[inTestedSignature length] string]
    . " formal parameter(s), but overriden getter declares " . [[inReferenceSignature length] string]
    ;
    error inReferenceLocation:"overriden getter is declared here" ;
  else
    foreach inReferenceSignature : ref_, inTestedSignature do
      if mFormalSelector->string != ref_mFormalSelector->string then
        error mFormalSelector : "the selector should be '?" . ref_mFormalSelector . if ref_mFormalSelector->string != "" then ":" else "" end + "'" ;
      end if ;
      if [mFormalArgumentType key] != [ref_mFormalArgumentType key] then
        error mFormalArgumentName : "the '" . mFormalArgumentName . "' formal parameter has the '@"
        . [mFormalArgumentType key] . "' type, but overriden getter declares with the '@" 
        . [ref_mFormalArgumentType key] . "' type" ;
        error inReferenceLocation:"overriden getter is declared here" ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    D E C L A R A T I O N    S E M A N T I C    A N A L Y S I S            *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @semanticDeclarationAST semanticAnalysis
  ??@string inProductDirectory
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration
;

#---------------------------------------------------------------------------*

override method @predefinedTypeAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  ioSemanticDeclarationListForGeneration +=
    !"Predefined type " . mPredefinedTypeName
    ![@primitiveTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !mPredefinedTypeName !here]]
      !mPredefinedTypeName
      !mKind
    ]
    !""
  ;

end method ;

#---------------------------------------------------------------------------*

map @attributeIndexMap {
  @unifiedTypeMapProxy mAttributeTypeIndex ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#---------------------------------------------------------------------------*

override method @listDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    const @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    var hasGetter := true ;
    var hasSetter := false ;
    foreach mFeatureList do
      if mValue->string == "nogetter" then
        if not hasGetter then
          error mValue:"duplicate feature" ;
        end if ;
        hasGetter := false ;
      elsif mValue->string == "setter" then
        if hasSetter then
          error mValue:"duplicate feature" ;
        end if ;
        hasSetter := true ;
      else
        error mValue:"unknown feature; the features available here are: 'nogetter', 'setter'" ;
      end if ;
    end foreach ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"list type " . mListTypeName
    ![@listTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mListTypeName]
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !mListTypeName->string . elementTypeNameSuffix [] !mListTypeName->location]]
      !typedAttributeList
    ]
  !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @sortedListDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Attribute
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    const t := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    @bool hasSetter := true ;
    @bool hasGetter := true ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
#--- Sort descriptor
  @stringset attributesUsedForSorting [emptySet] ;
  @sortDescriptorListForGeneration sortDescriptorList [emptyList] ;
  foreach mSortDescriptorList do
    [attributeMap searchKey !mSortedAttributeName ??@unifiedTypeMapProxy type] ;
    sortDescriptorList += !type ![mSortedAttributeName string] !mAscending ;
    if [attributesUsedForSorting hasKey ![mSortedAttributeName string]] then
      error mSortedAttributeName : "the '" . mSortedAttributeName . "' is already used for sorting" ;
    end if ;
    attributesUsedForSorting += ![mSortedAttributeName string] ;
  end foreach ;
#--- Generate type
  ioSemanticDeclarationListForGeneration +=
    !"sorted list " . mSortedListTypeName
    ![@sortedListTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mSortedListTypeName]
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !mSortedListTypeName->string . elementTypeNameSuffix [] !mSortedListTypeName->location]]
      !typedAttributeList
      !sortDescriptorList
    ]
    !""
  ;

end method ;

#---------------------------------------------------------------------------*

once forbiddenKeysForStruct -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"description" ;
  outResult += !"object" ;
end once ;

#---------------------------------------------------------------------------*

override method @structDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  if [mAttributeList length] == 0 then
    error mStructTypeName: "a structure cannot be empty: it must have at least one field" ; 
  end if ;
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    const t := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    foreach mFeatureList do
      error mValue : "a struct attribute does not accept any feature" ;
    end foreach ;
    const @bool hasSetter := false ;
    const @bool hasGetter := false ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    if [forbiddenKeysForStruct [] hasKey !mAttributeName->string] then
      @string m := "an attribute cannot be named:"  ;
      for s in forbiddenKeysForStruct [] do
        m.= " " . s ;
      end for ;
      m .= "; theses names are reserved" ;
      error mAttributeName: m ;
    end if ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
  ioSemanticDeclarationListForGeneration +=
    !"struct " . mStructTypeName
    ![@structTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mStructTypeName]
      !typedAttributeList
    ]
    !"~"
  ;
end method ;

#---------------------------------------------------------------------------*

override method @graphDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  const graphTypeProxy := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mGraphTypeName] ;
  const associatedListTypeProxy := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAssociatedListTypeName] ;
  const associatedListElementTypeProxy := [@unifiedTypeMapProxy searchKey 
    !inSemanticContext->mTypeMap
    ![@lstring new !mAssociatedListTypeName->string .elementTypeNameSuffix [] !mAssociatedListTypeName->location]
  ] ;
  if [associatedListTypeProxy mTypeKindEnum] != [@typeKindEnum listType] then
    error mAssociatedListTypeName: "the '@" . mAssociatedListTypeName . "' type should be a list" ;
  end if ;
#--- Analyze insert methods
  @stringset reservedModifierNames [emptySet] ;
  reservedModifierNames += !"noteNode" ;
  reservedModifierNames += !"addArc" ;
  foreach mInsertModifierList do
    if [reservedModifierNames hasKey ![mInsertModifierName string]] then
      error mInsertModifierName : "the '" . mInsertModifierName . "' modifier name is reserved for a graph type" ;
    end if ;
    check_K_L_escapeCharacters !mInsertErrorMessage ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"graph " . mGraphTypeName
    ![@graphDeclarationForGeneration new
      !graphTypeProxy
      !associatedListTypeProxy
      !associatedListElementTypeProxy
      !mInsertModifierList
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @externTypeDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  const externTypeProxy := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mExternTypeName] ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"extern type " . mExternTypeName
    ![@externTypeDeclarationForGeneration new
      !externTypeProxy
      !mExternTypeName->string
      !mCppPreDeclarationCode
      !mCppClassCode
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @enumDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Constant list
  @stringlist constantList [emptyList] ;
  @enumConstantListForGeneration enumConstantListForGeneration := {} ;
  @constantIndexMap constantMap [emptyMap] ;
  foreach mConstantList do
    constantList += !mConstantName->string ;
    @unifiedTypeMapProxyList associatedTypeList := {} ;
    @stringset associatedValueNameSet := {} ;
    for () in mAssociatedValueDefinitionList do
      const associatedTypeProxy := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mValue0] ;
      associatedTypeList += !associatedTypeProxy ;
      if [associatedValueNameSet hasKey !mValue1->string] then
        error mValue1 : "duplicated name" ;
      end if ;
      associatedValueNameSet += !mValue1->string ;
    end for ;
    [!?constantMap insertKey !mConstantName ![constantMap count] !associatedTypeList] ;
    enumConstantListForGeneration += !mConstantName->string !associatedTypeList ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"enum " . mEnumTypeName
    ![@enumTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mEnumTypeName]
      !enumConstantListForGeneration
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @arrayDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#---
  ioSemanticDeclarationListForGeneration +=
    !"array " . mArrayTypeName
    ![@arrayTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mArrayTypeName]
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mElementTypeName]
      ![mDimension uint]
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*
#! Listmap
#---------------------------------------------------------------------------*

override method @listmapDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Check associated list is actually a list
  [inSemanticContext->mTypeMap searchKey
    !mAssociatedListTypeName
    ?3*
    ??@typeKindEnum typeKindEnum
    ?*
    ??@typedAttributeList listTypeAttributeList
    ?20*
  ] ;
#---
  if typeKindEnum != [@typeKindEnum listType] then
    error mAssociatedListTypeName : "associated type should be a list type" ;
  end if ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"list map " . mListmapTypeName
    ![@listmapTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mListmapTypeName]
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAssociatedListTypeName]
      !listTypeAttributeList
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !mListmapTypeName->string . elementTypeNameSuffix [] !mListmapTypeName->location]]
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*
#! Map
#---------------------------------------------------------------------------*

map @insertMethodMap {
  insert insertKey error message "the '%K' insert modifier is already declared" ;
}

#---------------------------------------------------------------------------*

map @searchMethodMap {
  insert insertKey error message "the '%K' search method is already declared" ;
}

#---------------------------------------------------------------------------*
#         M A P                                                             *
#---------------------------------------------------------------------------*

routine check_K_escapeCharacters
 ?@lstring inString
:
#--- Check escape sequences : only %K or %%
  foreach [[inString string] componentsSeparatedByString !"%%"] do
    @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
    [!?explodedArray popFirst ?*] ;
    foreach explodedArray do
      if [mValue length] > 0 then
        const @char c := [mValue characterAtIndex !0] ;
        if c != 'K' then
          error inString: "only '%K' and '%%' escape sequences are allowed in this error message" ;
        end if ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine check_K_L_escapeCharacters
 ?@lstring inString
:
#--- Check escape sequences : only %K, %L or %%
  foreach [[inString string] componentsSeparatedByString !"%%"] do
    @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
    [!?explodedArray popFirst ?*] ;
    foreach explodedArray do
      if [mValue length] > 0 then
        const @char c := [mValue characterAtIndex !0] ;
        if (c != 'K') & (c != 'L') then
          error inString: "only '%K', '%L' and '%%' escape sequences are allowed in this error message" ;
        end if ;
      end if ;
    end foreach ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

once forbiddenKeysForMap -> @stringset outResult :
  outResult := [@stringset emptySet] ;
  outResult += !"lkey" ;
  outResult += !"description" ;
  outResult += !"object" ;
end once ;

#---------------------------------------------------------------------------*

override method @mapDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#------ Enter attributes
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    @bool hasSetter := true ;
    @bool hasGetter := true ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    if [forbiddenKeysForMap [] hasKey !mAttributeName->string] then
      @string m := "an attribute cannot be named:"  ;
      for s in forbiddenKeysForMap [] do
        m.= " " . s ;
      end for ;
      m .= "; theses names are reserved" ;
      error mAttributeName: m ;
    end if ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
#--- Enter insert modifiers
  @insertMethodMap insertMethodMap [emptyMap] ;
  foreach mInsertMethodList do
    [!?insertMethodMap insertKey !mInsertMethodName] ;
    check_K_L_escapeCharacters !mErrorMessage ;
    check_K_L_escapeCharacters !mShadowErrorMessage ;
  end foreach ;
#--- Enter search methods
  @searchMethodMap searchMethodMap [emptyMap] ;
  foreach mSearchMethodList do
    [!?searchMethodMap insertKey !mSearchMethodName] ;
    check_K_escapeCharacters !mErrorMessage ;
  end foreach ;
#--- Enter remove methods
  foreach mRemoveMethodList do
    [!?insertMethodMap insertKey !mMethodName] ;
    check_K_escapeCharacters !mErrorMessage ;
  end foreach ;
#--- Warn for duplicated declarations or 'insertOrReplace' modifier
  foreach mInsertOrReplaceDeclarationListAST index IDX do
    if IDX > 0 then
      warning mInsertOrReplaceDeclarationLocation: "the 'insertOrReplace' modifier is already declared" ;
    end if ;
  end foreach ;
  const @bool hasInsertOrReplaceModifier := [mInsertOrReplaceDeclarationListAST length] > 0 ;
  if hasInsertOrReplaceModifier & [insertMethodMap hasKey !"insertOrReplace"] then
    @location insertOrReplaceDeclarationLocation ;
    [mInsertOrReplaceDeclarationListAST first ?insertOrReplaceDeclarationLocation] ;
    error insertOrReplaceDeclarationLocation : "the insertOrReplace' modifier cannot be declared : an insert modifier or a remove modifier has been declared with this name" ;
  end if ;
#--- Enter 'with' accessors
#  @withAccessorMap withAccessorMap [emptyMap] ;
#  [!?withAccessorMap insertKey ![@lstring new !"hasKey" !here] !inPredefinedTypes->mStringType] ;
#  foreach mSearchMethodList do
#    [!?withAccessorMap insertKey
#      !mSearchMethodName
#      !inPredefinedTypes->mLStringType
#    ] ;
#  end foreach ;
#--- Enter map declaration
  ioSemanticDeclarationListForGeneration +=
    !"map " . mMapTypeName
    ![@mapTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mMapTypeName]
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !mMapTypeName->string . elementTypeNameSuffix [] !mMapTypeName->location]]
      !mMapTypeName
      !typedAttributeList
      !mInsertMethodList
      !mSearchMethodList
      !mRemoveMethodList
      !hasInsertOrReplaceModifier
#      !withAccessorMap
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @uniqueMapDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Compute initial state set
  @stringset initialStateSet [emptySet] ;
  foreach mInsertMethodList do
    if [mMapStateList length] > 0 then
      if [mInitialStateName string] == "" then
        error mInsertMethodName: "the '" . mInsertMethodName . "' insert method should name an automaton state" ;
      else
        initialStateSet += ![mInitialStateName string] ;
      end if ;
    elsif [mInitialStateName string] != "" then
      error mInsertMethodName: "the '" . mInsertMethodName . "' insert method should not name an automaton state" ;
    end if ;
  end foreach ;
#--- Analyze map automation actions
  @mapAutomatonActionMap mapAutomatonActionMap [emptyMap] ;
  foreach mSearchMethodList do
    if [mMapStateList length] > 0 then
      if [mActionName string] == "" then
        error mSearchMethodName: "the '" . mSearchMethodName . "' search method should name an automaton action" ;
      elsif not [mapAutomatonActionMap hasKey ![mActionName string]] then
#        actionIndex := [mapAutomatonActionMap count] ;
        [!?mapAutomatonActionMap insertKey !mActionName ![mapAutomatonActionMap count]] ;
#      else
#        [mapAutomatonActionMap searchKey !mActionName ?actionIndex] ;
      end if ;
    elsif [mActionName string] != "" then
      error mSearchMethodName: "the '" . mSearchMethodName . "' search method should not name an automaton action" ;
    end if ;
  end foreach ;
#--- Analyze map automaton
  @mapAutomatonStateMap mapAutomatonStateMap [emptyMap] ;
  foreach mMapStateList do
    [!?mapAutomatonStateMap insertKey !mStateName ![mapAutomatonStateMap count]] ;
  end foreach ;
  foreach mMapStateList do
    foreach mTransitionList do
      [mapAutomatonStateMap searchKey !mTargetStateName ?*] ;
    end foreach ;
  end foreach ;
#--- Check automaton actions are all defined
  const @stringset allActions := [mapAutomatonActionMap keySet] ;
  @mapStateSortedList mapStateSortedList [emptySortedList] ;
  foreach mMapStateList do
    @stringset actionsForCurrentState [emptySet] ;
    @mapStateTransitionSortedList mapStateTransitionSortedList [emptySortedList] ;
    foreach mTransitionList do
      @uint actionIndex ;
      [mapAutomatonActionMap searchKey !mActionName ?actionIndex] ;
      if [actionsForCurrentState hasKey ![mActionName string]] then
        error mActionName : "the '" . mActionName . "' action is already used for this state" ;
      end if ;
      actionsForCurrentState += ![mActionName string] ;
      @uint targetStateIndex ;
      [mapAutomatonStateMap searchKey !mTargetStateName ?targetStateIndex] ;
      mapStateTransitionSortedList +=
        !actionIndex
        ![mActionName string]
        !targetStateIndex
        ![mTargetStateName string]
        !mTransitionMessageKind
        ![mTransitionMessage string]
      ;
    end foreach ;
    @uint stateIndex ;
    [mapAutomatonStateMap searchKey !mStateName ?stateIndex] ;
    mapStateSortedList +=
      !stateIndex
      ![mStateName string]
      !mStateMessageKind
      ![mStateMessage string]
      !mapStateTransitionSortedList
    ;
    @stringset missingActions := allActions - actionsForCurrentState ;
    if [missingActions count] > 0 then
      @string s := "" ;
      foreach missingActions
        do s .= "'" . key . "'" ;
        between s .= ", " ;
      end foreach ;
      error mStateName : "the following actions are not named in a transition from this state: " . s ;
    end if ;
  end foreach ;
#--- Check for useful automaton states
  @stringset accessibleStates := initialStateSet ;
  @bool progress := true ;
  loop [mMapStateList length] + 1 : while progress do
    progress := false ;
    foreach mMapStateList do
      if [accessibleStates hasKey ![mStateName string]] then
        foreach mTransitionList do
          if not [accessibleStates hasKey ![mTargetStateName string]] then
            accessibleStates += ![mTargetStateName string] ;
            progress := true ;
          end if ;
        end foreach ;
      end if ;
    end foreach ;
  end loop ;
  const @stringset uselessStates := [mapAutomatonStateMap keySet] - accessibleStates ;
  if [uselessStates count] > 0 then
    @string s := "" ;
    foreach uselessStates
      do s .= "'" . key . "'" ;
      between s .= ", " ;
    end foreach ;
    warning here : "the following map automaton states are useless: " . s ;
  end if ;
#---------------------------------- override methods
#--- Compute needed associations
  @stringset neededAssociations [emptySet] ;
  @stringset accessibilityGraph [emptySet] ;
  foreach mapAutomatonStateMap do
    @stringset reachableStates [emptySet] ;
    reachableStates += ![lkey string] ;
    @bool progress := true ;
    loop [mapAutomatonStateMap count] + 1 : while progress do
      progress := false ;
      foreach mMapStateList do
        if [reachableStates hasKey ![mStateName string]] then
          foreach mTransitionList do
            if not [reachableStates hasKey ![mTargetStateName string]] then
              reachableStates += ![mTargetStateName string] ;
              accessibilityGraph += ![lkey string] . ":" . [mTargetStateName string] ;
              progress := true ;
            end if ;
          end foreach ;
        end if ;
      end foreach ;
    end loop ;
    foreach reachableStates do
      if [lkey string] != key then
        neededAssociations += ![lkey string] . ":" . key ;
      end if ;
    end foreach ;
  end foreach ;
#---
  @mapOverrideList mapOverrideList [emptyList] ;
  foreach mMapOverrideBlockListAST do
    @stringset handledAssociations [emptySet] ;
    @stringset neededCombinaisons [emptySet] ;
    @branchBehaviourSortedListForMapOverride branchBehaviourSortedListForMapOverride1 [emptySortedList] ;
    foreach mMapOverrideBlockDescriptor1AST do
      @uint startStateNameIndex ;
      [mapAutomatonStateMap searchKey !mLeftState ?startStateNameIndex] ;
      @uint currentStateNameIndex ;
      [mapAutomatonStateMap searchKey !mRightState ?currentStateNameIndex] ;
      const @string association := [mLeftState string] . ":" . [mRightState string] ;
      if not [neededAssociations hasKey !association] then
        warning mRightState :"the '" . association . "' association is useless" ;
      end if ;
      if [handledAssociations hasKey !association] then
        error mRightState
        :"the '" . association . "' association is already defined" ;
      end if ;
      handledAssociations += !association ;
      @uint finalStateNameIndex ;
      [mapAutomatonStateMap searchKey !mResultingState ?finalStateNameIndex] ;
      if [mLeftState string] != [mResultingState string] then
        neededCombinaisons += ![mLeftState string] . ":" . [mResultingState string] ;
        neededCombinaisons += ![mResultingState string] . ":" . [mLeftState string] ;
        if not [accessibilityGraph hasKey ![mLeftState string] . ":" . [mRightState string]] then
          error mResultingState
          : "the '" . mResultingState . "' state is not reachable from '" . mLeftState . "' state"
          ;
        end if ;
      end if ;
      check_K_escapeCharacters !mTransitionMessage ;
      branchBehaviourSortedListForMapOverride1 +=
        !startStateNameIndex
        ![mLeftState string]
        !currentStateNameIndex
        ![mRightState string]
        !finalStateNameIndex
        ![mResultingState string]
        !mMessageKind
        ![mTransitionMessage string]
      ;
    end foreach ;
    @stringset forgottenAssociations := neededAssociations - handledAssociations ;
    if [forgottenAssociations count] > 0 then
      @string s := "" ;
      foreach forgottenAssociations do
        s .= "\n  - " . key ;
      end foreach ;
      error here: [[forgottenAssociations count] string] . " associations should be defined:" . s ;
    end if ;
    @stringset definedCombinaisons [emptySet] ;
    @branchBehaviourSortedListForMapOverride branchBehaviourSortedListForMapOverride2 [emptySortedList] ;
    foreach mMapOverrideBlockDescriptor2AST do
      @uint leftStateIndex ;
      [mapAutomatonStateMap searchKey !mLeftState ?leftStateIndex] ;
      @uint rightStateIndex ;
      [mapAutomatonStateMap searchKey !mRightState ?rightStateIndex] ;
      const @string combinaison := [mLeftState string] . ":" . [mRightState string] ;
      if not [neededCombinaisons hasKey !combinaison] then
        error mRightState
        :"the '" . mLeftState . ":" . mRightState . "' combinaison is useless" ;
      end if ;
      if [definedCombinaisons hasKey !combinaison] then
        error mRightState
        :"the '" . mLeftState . ":" . mRightState . "' combinaison is already defined" ;
      end if ;
      definedCombinaisons += !combinaison ;
      @uint resultingStateNameIndex ;
      [mapAutomatonStateMap searchKey !mResultingState ?resultingStateNameIndex] ;
      if ([mLeftState string] != [mResultingState string])
       & ([mRightState string] != [mResultingState string])
       & not [accessibilityGraph hasKey ![mLeftState string] . ":" . [mResultingState string]] then
        error mResultingState
        :"the '" . mResultingState . "' state cannot be reached from the '" . mResultingState . "' state" ;
      end if ;
      check_K_escapeCharacters !mTransitionMessage ;
      if mMessageKind == [@mapAutomatonMessageKind noMessage] then
        definedCombinaisons += ![mRightState string] . ":" . [mLeftState string] ;
        branchBehaviourSortedListForMapOverride2 +=
          !rightStateIndex
          ![mRightState string]
          !leftStateIndex
          ![mLeftState string]
          !resultingStateNameIndex
          ![mResultingState string]
          !mMessageKind
          ![mTransitionMessage string]
        ;
      end if ;
      branchBehaviourSortedListForMapOverride2 +=
        !leftStateIndex
        ![mLeftState string]
        !rightStateIndex
        ![mRightState string]
        !resultingStateNameIndex
        ![mResultingState string]
        !mMessageKind
        ![mTransitionMessage string]
      ;
    end foreach ;
    if [forgottenAssociations count] == 0 then # Check only if all associations are defined
      @stringset forgottenCombinaisons := neededCombinaisons - definedCombinaisons ;
      if [forgottenCombinaisons count] > 0 then
        @string s := "" ;
        foreach forgottenCombinaisons do
          s .= "\n  - " . key ;
        end foreach ;
        error here: [[forgottenCombinaisons count] string] . " combinaisons are forgotten:" . s ;
      end if ;
    end if ;
    mapOverrideList +=
      ![mOverrideBlockName string]
      !branchBehaviourSortedListForMapOverride1
      !branchBehaviourSortedListForMapOverride2
    ;
  end foreach ;
#------ Enter attributes
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    @unifiedTypeMapProxy t [searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    @bool hasSetter := true ;
    @bool hasGetter := true ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
#--- Enter insert modifiers
  @insertMethodMap insertMethodMap [emptyMap] ;
  foreach mInsertMethodList do
    [!?insertMethodMap insertKey !mInsertMethodName] ;
  #--- Check error message escape sequences : only %K, %L or %%
    foreach [[mErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if (c != 'K') & (c != 'L') then
            error mErrorMessage: "only '%K', '%L' and '%%' escape sequences are allowed in an insert error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  #--- Check shadow error message escape sequences : only %K, %L or %%
    foreach [[mShadowErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if (c != 'K') & (c != 'L') then
            error mErrorMessage: "only '%K', '%L' and '%%' escape sequences are allowed in a shadow error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Enter search methods
  @searchMethodMap searchMethodMap [emptyMap] ;
  foreach mSearchMethodList do
    if [mMapStateList length] == 0 then # §
      [!?searchMethodMap insertKey !mSearchMethodName] ;
    else
      [!?searchMethodMap insertKey !mSearchMethodName] ;
    end if ;
  #--- Check error message escape sequences : only %K or %%
    foreach [[mErrorMessage string] componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if c != 'K' then
            error mErrorMessage: "only '%K' and '%%' escape sequences are allowed in a search error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Enter 'with' accessors
#  @withAccessorMap withAccessorMap [emptyMap] ;
#  [!?withAccessorMap insertKey ![@lstring new !"hasKey" !here] !inPredefinedTypes->mStringType] ;
#  foreach mSearchMethodList do
#    [!?withAccessorMap insertKey
#      !mSearchMethodName
#      !inPredefinedTypes->mLStringType
#    ] ;
#  end foreach ;
#--- Enter map declaration
  ioSemanticDeclarationListForGeneration +=
    !"unique map " . mMapTypeName
    ![@uniqueMapTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mMapTypeName]
      !mMapTypeName
      !typedAttributeList
      !mInsertMethodList
      !mSearchMethodList
#      !withAccessorMap
      !mapAutomatonStateMap
      !mapAutomatonActionMap
      !mapStateSortedList
      !mapOverrideList
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @mapProxyDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Get attribute list of associated map
  [inSemanticContext->mTypeMap searchKey
    !mAssociatedMapTypeName
    ?7*
    ??@typedAttributeList listTypeAttributeList
    ?11*
    ??@mapSearchMethodListAST searchMethodList
    ?6*
  ] ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"map proxy " . mMapProxyTypeName
    ![@mapProxyTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mMapProxyTypeName]
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAssociatedMapTypeName]
      !listTypeAttributeList
      !searchMethodList
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

map @declaredMethodMap { # This map is used for checking a method is declared once within a class
  insert insertKey error message "the '%K' method is already declared in %L for this class" ;
}

#---------------------------------------------------------------------------*

routine buildLocalVariableMapAndSignature
  ??@semanticContext inSemanticContext
  ??@formalParameterListAST inRoutineSignatureAST
  ?!@variableMap ioVariableMap
  !@formalParameterListForGeneration outRoutineSignature
:
  outRoutineSignature := [@formalParameterListForGeneration emptyList] ;
  foreach inRoutineSignatureAST do
    const type := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
    @string formalArgumentCppName ;
    switch mFormalArgumentPassingMode
    when argumentIn :
      formalArgumentCppName := "inArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      if mIsUnused then
        [!?ioVariableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      else
        [!?ioVariableMap insertInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      end if ;
    when argumentOut :
      formalArgumentCppName := "outArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      [!?ioVariableMap insertOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
    when argumentInOut :
      formalArgumentCppName := "ioArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      if mIsUnused then
        [!?ioVariableMap insertInputOutputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      else
        [!?ioVariableMap insertInputOutputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      end if ;
    when argumentConstantIn :
      formalArgumentCppName := "constinArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      if mIsUnused then
        [!?ioVariableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      else
        [!?ioVariableMap insertConstantInputFormalArgument !mFormalArgumentName !type !formalArgumentCppName !formalArgumentCppName] ;
      end if ;
    end switch ;
    outRoutineSignature += !mFormalSelector !mFormalArgumentPassingMode !type !mFormalArgumentName !formalArgumentCppName ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine analyzeRoutineBody
  ??@analysisContext inAnalysisContext
  ??@formalParameterListAST inRoutineSignatureAST
  ??@localConstantList inLocalConstantList
  ??@typedAttributeList inNonMutableTypedAttributeList
  ??@typedAttributeList inMutableTypedAttributeList
  ??@string inAttributeVariableNamePrefix
  ??@semanticInstructionListAST inInstructionList
  ??@location inEndOfMethodLocation
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
  !@formalParameterListForGeneration outRoutineSignature
:
  @variableMap variableMap [emptyMap] ;
#--- Declare local constants
  foreach inLocalConstantList do
    if mNoWarningIfUnused then
      [!?variableMap insertUsedLocalConstant !mName !mType !mCppName !inAnalysisContext->mSelfObjectCppName] ;
    else
      [!?variableMap insertLocalConstant !mName !mType !mCppName !inAnalysisContext->mSelfObjectCppName] ;
    end if ;
  end foreach ;
#--- Enter non mutable instance attributes
  foreach inNonMutableTypedAttributeList do
    [!?variableMap insertNonMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix . "mAttribute_". [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext->mSelfObjectCppName
    ] ;
  end foreach ;
#--- Enter mutable instance attributes
  foreach inMutableTypedAttributeList do
    [!?variableMap insertMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix . "mAttribute_". [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext->mSelfObjectCppName
    ] ;
  end foreach ;
#--- Enter formal arguments
  buildLocalVariableMapAndSignature
    !inAnalysisContext->mSemanticContext
    !inRoutineSignatureAST
    !?variableMap
    ?outRoutineSignature
  ;
#---  Analyze instruction list
  outSemanticInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  foreach inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ] ;
   end foreach ;
#---
  [variableMap checkAutomatonStates !inEndOfMethodLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @externFunctionDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  @formalInputParameterListForGeneration formalArgumentList [emptyList] ;
  foreach mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      ![mFormalArgumentName string]
      !mFormalArgumentName
      !mIsConstant
    ;
  end foreach ;
  ioSemanticDeclarationListForGeneration +=
    !"extern func " . mFunctionName
    ![@functionPrototypeDeclarationForGeneration new
      !true # Generate Cpp header file
      !"func-" . mFunctionName
      ![mFunctionName string]
      !formalArgumentList
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mResultTypeName]
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @externRoutineDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  @formalParameterListForGeneration formalArgumentList [emptyList] ;
  foreach mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      !mFormalArgumentPassingMode
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      !mFormalArgumentName
      ![mFormalArgumentName string]
    ;
  end foreach ;
  ioSemanticDeclarationListForGeneration +=
    !"extern proc " . mRoutineName
    ![@routinePrototypeDeclarationForGeneration new
      !true # Generate Cpp header file
      !"proc-" . mRoutineName
      ![mRoutineName string]
      !formalArgumentList
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @routineDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Instruction list
  @formalParameterListForGeneration formalArgumentList [emptyList] ;
  @semanticInstructionListForGeneration instructionList ;
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
    ![@unifiedTypeMapProxy null]
  ] ;
  analyzeRoutineBody
    !analysisContext
    !mFormalArgumentList
    ![@localConstantList emptyList]
    ![@typedAttributeList emptyList]
    ![@typedAttributeList emptyList]
    !""
    !mRoutineInstructionList
    !mEndOfRoutineInstructionList
    ?instructionList
    ?formalArgumentList
  ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"proc " . mRoutineName
    ![@routineImplementationForGeneration new
      !true # Generate Cpp header file
      !"proc-" . mRoutineName
      ![mRoutineName string]
      !formalArgumentList
      !false # Do not generate static
      !instructionList
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @classDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#------ Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mClassTypeName] ;
#------ Super type, and class features
# A class that has a super may not have any feature
# A class without a super class admits the 'generatedInSeparateFile' feature
  @unifiedTypeMapProxy superClassProxy ;
  @typedAttributeList allAttributeList ;
  if [mSuperClassName string] == "" then
    superClassProxy := [@unifiedTypeMapProxy null] ;
    allAttributeList := [@typedAttributeList emptyList] ;
    @bool generatedInSeparateFileFeature := false ;
    if [mClassFeatureList length] > 0 then
      foreach mClassFeatureList do
        if [mValue string] == "generatedInSeparateFile" then
          if generatedInSeparateFileFeature then
            error mValue:"the 'generatedInSeparateFile' is already named" ;
          end if ;
          generatedInSeparateFileFeature := true ;
        else
          error mValue:"only the 'generatedInSeparateFile' feature is allowed here" ;
        end if ;
      end foreach ;
    end if ;
  else
    superClassProxy := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mSuperClassName] ;
    allAttributeList := [superClassProxy mAllTypedAttributeList] ;
    if [mClassFeatureList length] > 0 then
      foreach mClassFeatureList do
        error mValue:"a class that has a super class does not accept any feature" ;
      end foreach ;
    end if ;
  end if ;
#------ Enter attributes
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeMap [emptyMap] ;
  foreach mAttributeList do
    const t := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName] ;
    @bool hasSetter := false ;
    @bool hasGetter := true ;
    foreach mFeatureList do
      if [mValue string] == "setter" then
        if hasSetter then
          error mValue : "the 'setter' feature is already named" ;
        end if ;
        hasSetter := true ;
      elsif [mValue string] == "nogetter" then
        if not hasGetter then
          error mValue : "the 'nogetter' feature is already named" ;
        end if ;
        hasGetter := false ;
      else
        error mValue : "only the 'setter' or 'nogetter' are allowed here" ;
      end if ;
    end foreach ;
    typedAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    allAttributeList +=
      !t
      !mAttributeName
      !hasSetter
      !hasGetter
    ;
    [!?attributeMap insertKey !mAttributeName !t] ;
  end foreach ;
#------ Compute sort string (used for sorting generated code)
  @string sortString := [selfType key] ;
  @unifiedTypeMapProxy t := [selfType mSuperType] ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while not [t isNull] do
    sortString := [t key] . "." . sortString ;
    t := [t mSuperType] ;
  end loop ;
#------
  ioSemanticDeclarationListForGeneration +=
    !"class " . mClassTypeName
    ![@classTypeForGeneration new
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mClassTypeName]
      !mIsAbstract
      !mClassTypeName
      !superClassProxy
      !allAttributeList
      !typedAttributeList
      ![selfType mGenerateHeaderInSeparateFile]
    ]
    !sortString
  ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeFunctionBody
  ??@analysisContext inAnalysisContext
  ??@formalInputParameterListAST inFunctionSignature
  ??@typedAttributeList inTypedAttributeList
  ??@string inAttributeVariableNamePrefix
  ??@semanticInstructionListAST inInstructionList
  ??@lstring inReturnVariableName
  ??@lstring inResultTypeName
  ??@location inEndOfFunctionLocation
  !@formalInputParameterListForGeneration outSignatureForGeneration
  !@unifiedTypeMapProxy outReturnedType
  !@string outResultVariableCppName
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
:
  @variableMap variableMap [emptyMap] ;
#--- Enter instance attributes
  foreach inTypedAttributeList do
    [!?variableMap insertNonMutableAttribute
      !mAttributeName
      !mAttributeTypeProxy
      !inAttributeVariableNamePrefix . "mAttribute_". [[mAttributeName string] identifierRepresentation]
      !inAnalysisContext->mSelfObjectCppName
    ] ;
  end foreach ;
#--- Enter formal parameters
  outSignatureForGeneration := [@formalInputParameterListForGeneration emptyList] ;
  foreach inFunctionSignature do
    const parameterType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
    if mIsConstant then
      const @string cppName := "constinArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      outSignatureForGeneration +=
        !mFormalSelector
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsConstant
      ;
      if mIsUnused then
        [!?variableMap insertConstantInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName] ;
      else
        [!?variableMap insertConstantInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName] ;
      end if ;
    else
      const @string cppName := "inArgument_" . [[mFormalArgumentName string] identifierRepresentation] ;
      outSignatureForGeneration +=
        !mFormalSelector
        !parameterType
        !cppName
        !mFormalArgumentName
        !mIsConstant
      ;
      if mIsUnused then
        [!?variableMap insertInputFormalArgumentDeclaredAsUnused !mFormalArgumentName !parameterType !cppName !cppName] ;
      else
        [!?variableMap insertInputFormalArgument !mFormalArgumentName !parameterType !cppName !cppName] ;
      end if ;
    end if ;
  end foreach ;
#--- Enter return variable
  outReturnedType := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !inResultTypeName] ;
  outResultVariableCppName := "result_" . [inReturnVariableName identifierRepresentation] ;
  [!?variableMap insertOutputFormalArgument !inReturnVariableName !outReturnedType !outResultVariableCppName !outResultVariableCppName] ;
#---  Analyze instruction list
  outSemanticInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  foreach inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inAnalysisContext
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ] ;
   end foreach ;
#---
  [variableMap checkAutomatonStates !inEndOfFunctionLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @functionDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Analyse function body  
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  @formalInputParameterListForGeneration formalInputParameterList ;
  @unifiedTypeMapProxy returnType ;
  @string resultVariableCppName ;
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
    ![@unifiedTypeMapProxy null]
  ] ;
  analyzeFunctionBody
    !analysisContext
    !mFormalArgumentList
    ![@typedAttributeList emptyList]
    !""
    !mFunctionInstructionList
    !mResultVariableName
    !mResultTypeName
    !mEndOfFunctionInstructionList
    ?formalInputParameterList
    ?returnType
    ?resultVariableCppName
    ?semanticInstructionListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"function " . mFunctionName
    ![@functionImplementationForGeneration new
      !true # Generate Cpp header file
      !"func-" . mFunctionName
      ![mFunctionName string]
      !formalInputParameterList
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @onceFunctionDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Analyse function body  
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  @unifiedTypeMapProxy returnType ;
  @string resultVariableCppName ;
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
    ![@unifiedTypeMapProxy null]
  ] ;
  analyzeFunctionBody
    !analysisContext
    ![@formalInputParameterListAST emptyList]
    ![@typedAttributeList emptyList]
    !""
    !mFunctionInstructionList
    !mResultVariableName
    !mResultTypeName
    !mEndOfFunctionInstructionList
    ?*
    ?returnType
    ?resultVariableCppName
    ?semanticInstructionListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"once function " . mFunctionName
    ![@onceFunctionDeclarationForGeneration new
      !true # Generate Cpp header file
      !"func-" . mFunctionName
      ![mFunctionName string]
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#     F I L E W R A P P E R    A N A L Y S I S                              *
#                                                                           *
#---------------------------------------------------------------------------*

override method @filewrapperDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Get filewrapper features
  [inSemanticContext->mFilewrapperMap searchKey
    !mFilewrapperName
    ?*
    ?*
    ??@wrapperFileMap wrapperFileMap
    ??@wrapperDirectoryMap wrapperDirectoryMap
    ?2*
  ] ;
#--- Build absolute path
  @string absoluteSourcePath ;
  if [mFilewrapperPath->string firstCharacterOrNul] == '/' then
    absoluteSourcePath := mFilewrapperPath->string ;
  else
    absoluteSourcePath := [mSourceFileAbsolutePath stringByDeletingLastPathComponent] . "/" . [mFilewrapperPath string] ;
  end if ;
  if not [absoluteSourcePath directoryExists] then
    error mFilewrapperPath: "The '" . absoluteSourcePath . "' directory does not exist" ;
  else
  #---- Analyze filewrapper templates
    @filewrapperTemplateListForGeneration filewrapperTemplateListForGeneration [emptyList] ;
    foreach mFilewrapperTemplateList do
      if [[mFilewrapperTemplatePath string] firstCharacterOrNul] == '/' then
        error mFilewrapperTemplatePath : "the path should not begin with a '/'; it is relative to filewrapper path '" . absoluteSourcePath . "'" ;
      end if ;
      const @string absoluteTemplatePath := absoluteSourcePath . "/" . mFilewrapperTemplatePath ;
      @templateInstructionListAST resultingInstructionList ;
    #--- Parse template
      grammar templateGrammar in [@lstring new !absoluteTemplatePath ![mFilewrapperTemplatePath location]] ?resultingInstructionList ;
    #--- Build template variable map
      @templateVariableMap templateVariableMap := {} ;
      @formalInputParameterListForGeneration filewrapperTemplateFormalInputParameters [emptyList] ;
      foreach mFilewrapperTemplateFormalInputParameters do
        @unifiedTypeMapProxy type [searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        const @string cppVarName := "in_" . [[mFormalArgumentName string] identifierRepresentation] ;
        [!?templateVariableMap insertKey !mFormalArgumentName !type !cppVarName] ;
        filewrapperTemplateFormalInputParameters += !mFormalTemplateSelector !type !cppVarName !mFormalArgumentName !true ;
      end foreach ;
    #--- Analyze template
      @templateInstructionListForGeneration templateInstructionListForGeneration [emptyList] ;
      const templateAnalysisContext := [@templateAnalysisContext new
        !inSemanticContext
        !inPredefinedTypes
        !templateVariableMap
      ] ;
      templateInstructionListAnalysis !templateAnalysisContext !resultingInstructionList !?templateInstructionListForGeneration ;
    #--- Enter in generation list
      filewrapperTemplateListForGeneration +=
        ![mFilewrapperTemplateName string]
        !filewrapperTemplateFormalInputParameters
        !templateInstructionListForGeneration
      ;
    end foreach ;
  #---- Enter filewrapper in generated list
    ioSemanticDeclarationListForGeneration +=
      !"filewrapper " . mFilewrapperName
      ![@filewrapperDeclarationForGeneration new
        !true # Generate Cpp header file
        !"filewrapper-" . mFilewrapperName
        ![mFilewrapperName string]
        ![mFilewrapperPath string]
        !wrapperFileMap
        !wrapperDirectoryMap
        !filewrapperTemplateListForGeneration
      ]
    !""
  ;
  end if ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#     O P T I O N    C O M P O N E N T    A N A L Y S I S                   *
#                                                                           *
#---------------------------------------------------------------------------*

override method @optionComponentDeclarationAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  [inSemanticContext->mOptionComponentMapForSemanticAnalysis searchKey
    !mOptionComponentName
    ??@bool isPredefined
    ??@commandLineOptionMap boolOptionMap
    ??@commandLineOptionMap uintOptionMap
    ??@commandLineOptionMap stringOptionMap
  ] ; 
#---- Enter filewrapper in generated list
  ioSemanticDeclarationListForGeneration +=
    !"option " . mOptionComponentName
    ![@optionComponentForGeneration new
      !true # Generate Cpp header file
      !"option-" . mOptionComponentName
      !isPredefined
      !mOptionComponentName->string
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ]
    !""
  ;
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryMethodAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mAbstractCategoryMethodName: "cannot declare a category method: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryMethodName: "cannot declare an abstract category method: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Compute method signature
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  foreach mAbstractCategoryMethodFormalParameterList do
    formalParameterListForGeneration +=
      !mFormalSelector
      !mFormalArgumentPassingMode
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      !mFormalArgumentName
      ![mFormalArgumentName string]
    ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"abstract extension method " . mAbstractCategoryMethodName
    ![@abstractCategoryMethodForGeneration new
      !true # Generate Cpp header file
      !"method-" . [selfType key] . "-" . mAbstractCategoryMethodName
      !selfType
      ![mAbstractCategoryMethodName string]
      !formalParameterListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @categoryMethodAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  @string selfObjectName ;
  @string selfObjectAccessor ;
  @bool implementedAsFunction ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] == [@typeKindEnum classType] then
    selfObjectName := "object" ;
    selfObjectAccessor := "object->" ;
    implementedAsFunction := false ;
  else
    selfObjectName := "inObject" ;
    selfObjectAccessor := "inObject." ;
    implementedAsFunction := true ;
  end if ;
#--- Analyze instruction list
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !selfObjectName
    ![@unifiedTypeMapProxy null]
  ] ;
  analyzeRoutineBody
    !analysisContext
    !mCategoryMethodFormalParameterList
    ![@localConstantList emptyList]
    !if ([selfType mTypeKindEnum] == [@typeKindEnum classType]) | ([selfType mTypeKindEnum] == [@typeKindEnum structType])
       then [selfType mAllTypedAttributeList]
       else [@typedAttributeList emptyList]
     end
    ![@typedAttributeList emptyList]
    !selfObjectAccessor
    !mCategoryMethodInstructionList
    !mEndOfMethodLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"extension method " . mCategoryMethodName
    ![@categoryMethodForGeneration new
      !true # Generate Cpp header file
      !"method-" . [selfType key] . "-" . mCategoryMethodName
      !selfType
      ![mCategoryMethodName string]
      !implementedAsFunction
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingCategoryMethodAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mOverridingCategoryMethodName: "cannot declare a category method: '@" . [selfType key] . "' is not a class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @formalParameterSignature inheritedSignature [emptyList] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mInstanceMethodMap] hasKey ![mOverridingCategoryMethodName string]] then
      @methodQualifier qualifier ;
      [[superType mInstanceMethodMap] searchKey !mOverridingCategoryMethodName ?* ?inheritedSignature ?inheritedDeclarationLocation ?* ?qualifier ?*] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
  if baseTypeName == "" then
    error mOverridingCategoryMethodName:"this method is not declared by a super class" ;
  end if ;
#--- Analyze instruction list
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
    ![@unifiedTypeMapProxy null]
  ] ;
  analyzeRoutineBody
    !analysisContext
    !mOverridingCategoryMethodFormalParameterList
    ![@localConstantList emptyList]
    !if ([selfType mTypeKindEnum] == [@typeKindEnum classType]) | ([selfType mTypeKindEnum] == [@typeKindEnum structType])
       then [selfType mAllTypedAttributeList]
       else [@typedAttributeList emptyList]
     end
    ![@typedAttributeList emptyList]
    !"object->"
    !mOverridingCategoryMethodInstructionList
    !mEndOfMethodLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  ;
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures
      !formalParameterListForGeneration
      ![mOverridingCategoryMethodName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    ;
  end if ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"override extension method " . mOverridingCategoryMethodName
    ![@overridingCategoryMethodForGeneration new
      !false # Do not generate Cpp header file
      !"method-" . [selfType key] . "-" . mOverridingCategoryMethodName
      !selfType
      !baseTypeName
      ![mOverridingCategoryMethodName string]
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingAbstractCategoryMethodAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mOverridingCategoryMethodName: "cannot declare a category method: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mOverridingCategoryMethodName: "cannot declare an abstract category method: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @formalParameterSignature inheritedSignature [emptyList] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mInstanceMethodMap] hasKey ![mOverridingCategoryMethodName string]] then
      @methodQualifier qualifier ;
      [[superType mInstanceMethodMap] searchKey !mOverridingCategoryMethodName ?* ?inheritedSignature ?inheritedDeclarationLocation ?* ?qualifier ?*] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
  if baseTypeName == "" then
    error mOverridingCategoryMethodName:"this getter is not declared by a super class" ;
  end if ;
#--- Analyze formal argument list
  @variableMap variableMap [emptyMap] ;
  @formalParameterListForGeneration formalParameterListForGeneration ;
  buildLocalVariableMapAndSignature
    !inSemanticContext
    !mOverridingCategoryMethodFormalParameterList
    !?variableMap
    ?formalParameterListForGeneration
  ;
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures
      !formalParameterListForGeneration
      ![mOverridingCategoryMethodName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryModifierAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mAbstractCategoryModifierName: "cannot declare a category modifier: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryModifierName: "cannot declare an abstract category modifier: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Compute modifier signature
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  foreach mAbstractCategoryModifierFormalParameterList do
    formalParameterListForGeneration +=
      !mFormalSelector
      !mFormalArgumentPassingMode
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      !mFormalArgumentName
      ![mFormalArgumentName string]
    ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration +=
    !" abstract extension setter " . mAbstractCategoryModifierName
    ![@abstractCategoryModifierForGeneration new
      !true # Generate Cpp header file
      !"setter-" . mTypeName . "-" . mAbstractCategoryModifierName
      !selfType
      ![mAbstractCategoryModifierName string]
      !formalParameterListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @categoryModifierAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  @string selfObjectName ;
  @string selfObjectAccessor ;
  @bool implementedAsFunction ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] == [@typeKindEnum classType] then
    selfObjectName := "object" ;
    selfObjectAccessor := "object->" ;
    implementedAsFunction := false ;
  else
    selfObjectName := "ioObject" ;
    selfObjectAccessor := "ioObject." ;
    implementedAsFunction := true ;
  end if ;
#--- Analyze instruction list
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !selfObjectName
    !selfType
  ] ;
  analyzeRoutineBody
    !analysisContext
    !mCategoryModifierFormalParameterList
    ![@localConstantList emptyList]
    ![@typedAttributeList emptyList]
    ![selfType mAllTypedAttributeList]
    !selfObjectAccessor
    !mCategoryModifierInstructionList
    !mEndOfModifierLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"extension setter " . mCategoryModifierName
    ![@categoryModifierForGeneration new
      !true # Generate Cpp header file
      !"setter-" . [selfType key] . "-" . mCategoryModifierName
      !selfType
      ![mCategoryModifierName string]
      !implementedAsFunction
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingCategoryModifierAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mOverridingCategoryModifierName: "cannot declare a category modifier: '@" . [selfType key] . "' is not a class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @formalParameterSignature inheritedSignature [emptyList] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mModifierMap] hasKey ![mOverridingCategoryModifierName string]] then
      @methodQualifier qualifier ;
      [[superType mModifierMap] searchKey !mOverridingCategoryModifierName ?* ?inheritedSignature ?* ?qualifier ?*] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
  if baseTypeName == "" then
    error mOverridingCategoryModifierName:"this modifier is not declared by a super class" ;
  end if ;
#--- Analyze instruction list
  @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
    !selfType
  ] ;
  analyzeRoutineBody
    !analysisContext
    !mOverridingCategoryModifierFormalParameterList
    ![@localConstantList emptyList]
    ![@typedAttributeList emptyList]
    ![selfType mAllTypedAttributeList]
    !"object->"
    !mOverridingCategoryModifierInstructionList
    !mEndOfModifierLocation
    ?semanticInstructionListForGeneration
    ?formalParameterListForGeneration
  ;
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures
      !formalParameterListForGeneration
      ![mOverridingCategoryModifierName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    ;
  end if ;
#---
  ioSemanticDeclarationListForGeneration +=
    !" overriding extension setter " . mOverridingCategoryModifierName
    ![@overridingCategoryModifierForGeneration new
      !false # Do not generate Cpp header file
      !"setter-" . mTypeName . "-" . mOverridingCategoryModifierName
      !selfType
      !baseTypeName
      ![mOverridingCategoryModifierName string]
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingAbstractCategoryModifierAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mOverridingCategoryModifierName: "cannot declare a category modifier: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mOverridingCategoryModifierName: "cannot declare an abstract category modifier: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @formalParameterSignature inheritedSignature [emptyList] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mModifierMap] hasKey ![mOverridingCategoryModifierName string]] then
      @methodQualifier qualifier ;
      [[superType mModifierMap] searchKey !mOverridingCategoryModifierName ?* ?inheritedSignature ?* ?qualifier ?*] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
  if baseTypeName == "" then
    error mOverridingCategoryModifierName:"this modifier is not declared by a super class" ;
  end if ;
#--- Analyze formal argument list
  @variableMap variableMap [emptyMap] ;
  @formalParameterListForGeneration formalParameterListForGeneration ;
  buildLocalVariableMapAndSignature
    !inSemanticContext
    !mOverridingCategoryModifierFormalParameterList
    !?variableMap
    ?formalParameterListForGeneration
  ;
#--- Check Signature
  if baseTypeName != "" then
    checkMethodSignatures
      !formalParameterListForGeneration
      ![mOverridingCategoryModifierName location]
      !inheritedSignature
      !inheritedDeclarationLocation
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryReaderAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mAbstractCategoryReaderName: "cannot declare a category reader: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryReaderName: "cannot declare an abstract category reader: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Compute method signature
  @formalInputParameterListForGeneration formalParameterListForGeneration [emptyList] ;
  foreach mAbstractCategoryReaderFormalInputParameterList do
    formalParameterListForGeneration +=
      !mFormalSelector
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
      ![mFormalArgumentName string]
      !mFormalArgumentName
      !mIsConstant
    ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"abstract extension getter " . mAbstractCategoryReaderName
    ![@abstractCategoryReaderForGeneration new
      !true # Generate Cpp header file
      !"getter-" . mTypeName . "-" . mAbstractCategoryReaderName
      !selfType
      ![mAbstractCategoryReaderName string]
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAbstractCategoryReaderReturnedTypeName]
      !formalParameterListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;


#---------------------------------------------------------------------------*

override method @categoryReaderAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:

#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
  @string selfObjectName ;
  @string selfObjectAccessor ;
  @bool implementedAsFunction ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] == [@typeKindEnum classType] then
    selfObjectName := "object" ;
    selfObjectAccessor := "object->" ;
    implementedAsFunction := false ;
  else
    selfObjectName := "inObject" ;
    selfObjectAccessor := "inObject." ;
    implementedAsFunction := true ;
  end if ;
#--- Analyze instruction list
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !selfObjectName
    ![@unifiedTypeMapProxy null]
  ] ;
  @unifiedTypeMapProxy returnType ;
  @string returnVariableCppName ;
  @formalInputParameterListForGeneration formalParameterListForGeneration ;
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  analyzeFunctionBody
    !analysisContext
    !mCategoryReaderFormalInputParameterList
    !if ([selfType mTypeKindEnum] == [@typeKindEnum classType]) | ([selfType mTypeKindEnum] == [@typeKindEnum structType]) | ([selfType mTypeKindEnum] == [@typeKindEnum mapProxyType])
       then [selfType mAllTypedAttributeList]
       else [@typedAttributeList emptyList]
     end
    !selfObjectAccessor
    !mCategoryReaderInstructionList
    !mCategoryReaderReturnedVariableName
    !mCategoryReaderReturnedTypeName
    !mEndOfReaderLocation
    ?formalParameterListForGeneration
    ?returnType
    ?returnVariableCppName
    ?semanticInstructionListForGeneration
  ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"extension getter " . mCategoryReaderName
    ![@categoryReaderForGeneration new
      !true # Generate Cpp header file
      !"getter-" . [selfType key] . "-" . mCategoryReaderName
      !selfType
      ![mCategoryReaderName string]
      !implementedAsFunction
      !returnType
      !returnVariableCppName
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingCategoryReaderAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Check self type is a class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mOverridingCategoryReaderName: "cannot declare a category reader: '@" . [selfType key] . "' is not a class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @functionSignature inheritedSignature := {} ;
  @unifiedTypeMapProxy inheritedReturnType [null] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mReaderMap] hasKey ![mOverridingCategoryReaderName string]] then
      [[superType mReaderMap] searchKey
        !mOverridingCategoryReaderName
        ?*
        ?inheritedSignature
        ?inheritedDeclarationLocation
        ?*
        ?inheritedReturnType
        ??@methodQualifier qualifier
        ?*
      ] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
  if baseTypeName == "" then
    error mOverridingCategoryReaderName:"this getter is not declared by a super class" ;
  end if ;
#--- Analyze instruction list
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    !selfType
    !"object"
    ![@unifiedTypeMapProxy null]
  ] ;
  analyzeFunctionBody
    !analysisContext
    !mOverridingCategoryReaderFormalInputParameterList
    !if ([selfType mTypeKindEnum] == [@typeKindEnum classType]) | ([selfType mTypeKindEnum] == [@typeKindEnum structType])
       then [selfType mAllTypedAttributeList]
       else [@typedAttributeList emptyList]
     end
    !"object->"
    !mOverridingCategoryReaderInstructionList
    !mOverridingCategoryReaderReturnedVariableName
    !mOverridingCategoryReaderReturnedTypeName
    !mEndOfReaderLocation
    ??@formalInputParameterListForGeneration formalParameterListForGeneration
    ??@unifiedTypeMapProxy returnType
    ??@string returnVariableCppName
    ??@semanticInstructionListForGeneration semanticInstructionListForGeneration
  ;
#--- Check Signature
  if baseTypeName != "" then
    checkReaderSignatures
      !formalParameterListForGeneration
      !returnType
      ![mOverridingCategoryReaderName location]
      !inheritedSignature
      !inheritedReturnType
      !inheritedDeclarationLocation
    ;
  end if ;
#---
  ioSemanticDeclarationListForGeneration +=
    !"override extension getter " . mOverridingCategoryReaderName
    ![@overrideCategoryReaderForGeneration new
      !false # Do not generate Cpp header file
      !"getter-" . mTypeName . "-" . mOverridingCategoryReaderName
      !selfType
      !baseTypeName
      ![mOverridingCategoryReaderName string]
      !returnType
      !returnVariableCppName
      !formalParameterListForGeneration
      ![selfType mAllTypedAttributeList]
      !semanticInstructionListForGeneration
    ]
    !"~" # So that category are declared at the end of the file
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingAbstractCategoryReaderAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration unused ioSemanticDeclarationListForGeneration
:
#--- Self type
  const @unifiedTypeMapProxy selfType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mTypeName] ;
#--- Return type
  const @unifiedTypeMapProxy returnType := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAbstractCategoryReaderReturnedTypeName] ;
#--- Check type is an abstract class
  if [selfType mTypeKindEnum] != [@typeKindEnum classType] then
    error mAbstractCategoryReaderName: "cannot declare a category reader: '@" . [selfType key] . "' is not a class" ;
  elsif [selfType mIsConcrete] then
    error mAbstractCategoryReaderName: "cannot declare an abstract category reader: '@" . [selfType key] . "' is not an abstract class" ;
  end if ;
#--- Find base type name
  @string baseTypeName := "" ;
  @unifiedTypeMapProxy superType := [selfType mSuperType] ;
  @functionSignature inheritedSignature := {} ;
  @unifiedTypeMapProxy inheritedReturnType [null] ;
  @location inheritedDeclarationLocation := here ;
  loop [inSemanticContext->mTypeMap count] + 1 :
  while (not [superType isNull]) & (baseTypeName == "") do
    if [[superType mReaderMap] hasKey ![mAbstractCategoryReaderName string]] then
      @methodQualifier qualifier ;
      [[superType mReaderMap] searchKey
        !mAbstractCategoryReaderName
        ?*
        ?inheritedSignature
        ?inheritedDeclarationLocation
        ?*
        ?inheritedReturnType
        ?qualifier
        ?*
      ] ;
      if qualifier <= [@methodQualifier isBasicFinal] then
        baseTypeName := [superType key] ;
      end if ;
    end if ;
    superType := [superType mSuperType] ;
  end loop ;
  if baseTypeName == "" then
    error mAbstractCategoryReaderName:"this getter is not declared by a super class" ;
  end if ;
#--- Check Signature
  if baseTypeName != "" then
    @formalInputParameterListForGeneration formalParameterListForGeneration [emptyList] ;
    foreach mAbstractCategoryReaderFormalInputParameterList do
      formalParameterListForGeneration +=
        !mFormalSelector
        ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName]
        ![mFormalArgumentName string]
        !mFormalArgumentName
        !mIsConstant
      ;
    end foreach ;
    checkReaderSignatures
      !formalParameterListForGeneration
      !returnType
      ![mAbstractCategoryReaderName location]
      !inheritedSignature
      !inheritedReturnType
      !inheritedDeclarationLocation
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @galgas3SyntaxComponentAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  const componentName := mSyntaxComponentName->string ;
#--------------------------------------- Build terminal map
  [inSemanticContext->mLexiqueComponentMapForSemanticAnalysis searchKey
    !mLexiqueName
    ??@terminalMap terminalMap
    ??@indexingListAST indexingListAST
    ??@lstring indexingDirectory
  ] ;
#--------------------------------------- Build "indexing" set
  @stringset indexNameSet [emptySet] ;
  foreach indexingListAST do
    indexNameSet += !mIndexName->string ;
  end foreach ;
  const @bool hasIndexing := not [indexingDirectory isNowhere] ;
#--- Build semantic context from rule headers and non terminal declaration
  if [@uint errorCount] == 0 then
    const lexiqueName := mLexiqueName->string ;
    semanticAnalysisOfSyntaxComponent
      !mNonterminalDeclarationList
      !mRuleList
      !componentName
      !lexiqueName
      !inSemanticContext
      !inPredefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !mHasTranslateFeature
      ??@syntaxDeclarationForGeneration syntaxDeclarationForGeneration
    ;
    ioSemanticDeclarationListForGeneration +=
      !""
#      !inSyntaxComponentRoot
      !syntaxDeclarationForGeneration
#      !hasIndexing
      !""
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @galgas3GrammarComponentAST semanticAnalysis
  ??@string inProductDirectory
  ??@semanticContext inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
  if [option .verbose_output value] then
    message "*** Analyzing '" + mGrammarComponentName + "' grammar\n" ;
  end if ;
#---------------------------------------------------------- Parse syntax components
  @terminalSymbolsMapForGrammarAnalysis actuallyUsedTerminalSymbolMap [emptyMap] ;
  @nonTerminalSymbolMapForGrammarAnalysis nonTerminalMapForGrammarAnalysis [emptyMap] ;
  @lstring lexiqueComponentName :=  ["" nowhere] ; # Empty string means unknown
  @syntaxComponentListForGrammarAnalysis syntaxComponentListForGrammarAnalysis [emptyList] ;
  @nonTerminalToAddList nonTerminalToAddList [emptyList] ;
  @uint addedNonTerminalCount := 0 ;
  foreach mSyntaxComponents do
    const @uint addedNonTerminalCountRef := addedNonTerminalCount ;
    const syntaxComponentName := mValue->string ;
    [inSemanticContext->mSyntaxComponentMapForSemanticAnalysis searchKey
      !mValue
      ??@lstring lexiqueName
      ??@nonterminalDeclarationListAST nonterminalDeclarationList
      ??@syntaxRuleListAST ruleList
      ??@bool hasTranslateFeature
    ] ;
  #--- Check translate feature
    if mHasTranslateFeature & not hasTranslateFeature then
      error mValue : "as '" . mGrammarComponentName . "' grammar declares 'translate' feature, this syntax component should do so" ;
    elsif hasTranslateFeature & not mHasTranslateFeature then
      error mGrammarComponentName : "as '" . mValue . "' syntax component declares 'translate' feature, this grammar should do so" ;
    end if ;
  #--- Handle lexique component
    if lexiqueComponentName->string == "" then
      lexiqueComponentName := lexiqueName ;
    elsif lexiqueName->string != lexiqueComponentName->string then
      error mValue : "this syntax component uses '"
        . lexiqueName . "' lexique component, but the first syntax component uses the '"
        . lexiqueComponentName . "' lexique component (they should be the same)" ;
    end if ;
  #--- Handle non terminal declarations
    handleNonTerminalDeclarations
      !?nonTerminalMapForGrammarAnalysis
      !nonterminalDeclarationList
    ;
  #--- Enter non terminal definition from rule list
    handleNonTerminalDeclarationsFromRuleList
      !?nonTerminalMapForGrammarAnalysis
      !ruleList
    ;
  #--- Handle syntax rules
    buildRuleList
      !nonTerminalMapForGrammarAnalysis
      !mValue
      !ruleList
      !?actuallyUsedTerminalSymbolMap
      !?syntaxComponentListForGrammarAnalysis
      !?addedNonTerminalCount
    ;
    @uint i := 0 ;
    loop addedNonTerminalCount : while i < (addedNonTerminalCount - addedNonTerminalCountRef) do
      nonTerminalToAddList += !syntaxComponentName !i ;
      i++ ;
    end loop ;
  end foreach ;
#------------------------ Get lexique component, for knowing if there are "indexing" declaration
  var lexiqueComponentSet := [@stringset emptySet] ;
  [inSemanticContext->mLexiqueComponentMapForSemanticAnalysis searchKey
    !lexiqueComponentName
    ?* # @terminalMap inTerminalMap
    ?* # @indexingListAST inIndexingListAST
    ??@lstring inIndexingDirectory
  ] ;
  const @bool hasIndexing := not [inIndexingDirectory isNowhere] ;
  if hasIndexing & not mHasIndexing->bool then
    error mGrammarComponentName : "the grammar does not enable indexing, but the '" . lexiqueComponentName . "' does" ;
  elsif (not hasIndexing) & mHasIndexing->bool then
    error mHasIndexing : "the grammar enables indexing, but the '" . lexiqueComponentName . "' does not" ;
  end if ;
#---------------------------------------------------------- Start symbol
#--- Search start symbol in non terminal map
  @nonterminalSymbolLabelMapForGrammarAnalysis startSymbolAltMap ;
  @uint startSymbolIndex ;
  [nonTerminalMapForGrammarAnalysis searchKey !mStartSymbolName ?startSymbolIndex ?startSymbolAltMap] ;
#--- Check signatures
  checkLabelMap
    !mStartSymbolName->location
    !mStartSymbolLabelList
    ![nonTerminalMapForGrammarAnalysis locationForKey !mStartSymbolName->string]
    !startSymbolAltMap
  ;
#---------------------------------------------------------- Unused Non Terminal Symbols
  @unusedNonTerminalSymbolMapForGrammarAnalysis unusedNonTerminalSymbolsForGrammar [emptyMap] ;
  foreach mUnusedNonterminalList do
    @uint nonterminalIndex ;
    [nonTerminalMapForGrammarAnalysis searchKey !mValue ?nonterminalIndex ?*] ;
    [!?unusedNonTerminalSymbolsForGrammar insertKey !mValue !nonterminalIndex] ;
  end foreach ;
#---------------------------------------------------------- Non terminal symbols, sorted by index
  @nonTerminalSymbolSortedListForGrammarAnalysis nonTerminalSymbolSortedListForGrammarAnalysis [emptySortedList] ;
  foreach nonTerminalMapForGrammarAnalysis do
    nonTerminalSymbolSortedListForGrammarAnalysis += !lkey !mNonTerminalIndex !mNonterminalSymbolParametersMap ;
  end foreach ;
#---------------------------------------------------------- Header of implementation file
#  Loop throuht all rules for detecting input arguments: as the generated C++ code uses a copy constructor
# for these arguments, we need to include the corresponding type declaration.
  var implementationFileHeader := [@stringset emptySet] ;
  for () in nonTerminalMapForGrammarAnalysis do
    for () in mNonterminalSymbolParametersMap do
      for () in mFormalParametersList do
        switch mFormalArgumentPassingModeForGrammarAnalysis
        when argumentIn, argumentConstantIn :
          const t := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mGalgasTypeNameForGrammarAnalysis] ;
          [t addHeaderFileName !?implementationFileHeader] ;
        when argumentInOut, argumentOut :
        end switch ;
      end for ;
    end for ;
  end for ;
  if [option galgas_cli_options.generateOneHeader value] then
    implementationFileHeader := [@stringset emptySet] ;
  end if ;
  implementationFileHeader += !"grammar-" . mGrammarComponentName ;
  implementationFileHeader += !"lexique-" . lexiqueComponentName ;
#---------------------------------------------------------- Analyze grammar
  const HTMLFilePath := inProductDirectory . "/../helpers/" . mGrammarComponentName . ".html" ;
  grammarAnalysisAndGeneration
    !implementationFileHeader
    !mGrammarComponentName
    !mGrammarClass
    !startSymbolIndex
    !lexiqueComponentName->string
    !actuallyUsedTerminalSymbolMap
    !syntaxComponentListForGrammarAnalysis
    !unusedNonTerminalSymbolsForGrammar
    !HTMLFilePath
    !nonTerminalSymbolSortedListForGrammarAnalysis
    !hasIndexing
    !if mHasTranslateFeature then syntaxDirectedTranslationResultVarName [] else "" end
    ??@string grammarCppFile
    ??@string grammarHTMLHelperContents
  ;
#---
  ioSemanticDeclarationListForGeneration +=
    !""   
    ![@grammarForGeneration new
      !true # has header
      !"grammar-" + mGrammarComponentName    
      !mGrammarComponentName->string
      !lexiqueComponentName->string
      !nonTerminalMapForGrammarAnalysis
      !nonTerminalToAddList
      !hasIndexing
      !mSyntaxComponents
      !mStartSymbolName->string
      !mHasTranslateFeature
      !grammarCppFile
      !grammarHTMLHelperContents
     ]
    !"" ;
#---------------------------------------------------------- Build header contents
#  var headerContents := "" ;
#  if [@uint errorCount] == 0 then
#    headerContents := [filewrapper grammarGenerationTemplate.grammarZone2HeaderGalgas3
#      !inGrammarComponentRoot
#    ] ;
#    headerContents += [filewrapper grammarGenerationTemplate.grammarZone3HeaderGalgas3
#      ![lexiqueComponentName identifierRepresentation]
#      !inGrammarComponentRoot
#      !nonTerminalMapForGrammarAnalysis
#      !nonTerminalToAddList
#      !hasIndexing
#    ] ;
#  end if ;
##---------------------------------------------------------- Write HTML file
#  if [option galgas_cli_options.outputHTMLgrammarFile value] then
#    [grammarHTMLHelperContents writeToFileWhenDifferentContents !HTMLFilePath ?*] ;
#  else
#    [@string deleteFileIfExists !HTMLFilePath] ;
#  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader
:
  for (s) in mSyntaxComponents do
    ioInclusionSet += !"syntax-" + s ;
  end for ;
  outHeader := [filewrapper grammarGenerationTemplate.grammarZone3HeaderGalgas3
    ![mLexiqueName identifierRepresentation]
    !mNonTerminalMapForGrammarAnalysis
    !mNonTerminalToAddList
    !mHasIndexing
    !mStartSymbolName
    !mHasTranslateFeature
    !mGrammarName
    !mSyntaxComponents
   ] ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += !"grammar-" + mGrammarName ;
  outImplementation := mCppFileContents ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarForGeneration appendSpecificFiles
  ??@string inProductDirectory
  ?!@stringset unused ioAllProductFileSet
:
  const HTMLFilePath := inProductDirectory . "/../helpers/" . mGrammarName . ".html" ;
  if [option galgas_cli_options.outputHTMLgrammarFile value] then
    [mHTLMHelperContents writeToFileWhenDifferentContents !HTMLFilePath ?*] ;
  else
    [@string deleteFileIfExists !HTMLFilePath] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexiqueComponentAST semanticAnalysis
  ??@string unused inProductDirectory
  ??@semanticContext unused inSemanticContext
  ??@predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationSortedListForGeneration ioSemanticDeclarationListForGeneration
:
#--------------------------------------- Lexical attribute type name map
  const @lexicalTypeMap lexicalTypeMap := buildLexicalTypeMap [] ;
#--------------------------------------- Build lexical routine map
  @lexicalRoutineMap lexicalRoutineMap ;
  buildLexicalRoutineMap ?lexicalRoutineMap ;
#--------------------------------------- Add extern routines
  foreach mExternRoutineList do
    @lexicalRoutineFormalArgumentList lexicalRoutineFormalArgumentList [emptyList] ;
    foreach mLexicalRoutineFormalArgumentList do
      @lexicalTypeEnum lexicalFormalArgumentType ;
      [lexicalTypeMap searchKey !mLexicalTypeName ?lexicalFormalArgumentType] ;
      lexicalRoutineFormalArgumentList += !mPassingMode !lexicalFormalArgumentType ![mFormalArgumentName string] ;
    end foreach ;
    [!?lexicalRoutineMap insertKey !mRoutineName !lexicalRoutineFormalArgumentList !mErrorMessageList !true] ;
  end foreach ;
#--------------------------------------- Build lexical function map
  @lexicalFunctionMap lexicalFunctionMap ;
  buildLexicalFunctionMap ?lexicalFunctionMap ;
#--------------------------------------- Add extern functions
  foreach mExternFunctionList do
    @lexicalFunctionFormalArgumentList lexicalFunctionFormalArgumentList [emptyList] ;
    foreach mLexicalFunctionFormalArgumentList do
      @lexicalTypeEnum lexicalFormalArgumentType ;
      [lexicalTypeMap searchKey !mLexicalTypeName ?lexicalFormalArgumentType] ;
      lexicalFunctionFormalArgumentList += !lexicalFormalArgumentType ![mFormalArgumentName string] ;
    end foreach ;
    @lexicalTypeEnum returnedArgumentType ;
    [lexicalTypeMap searchKey !mReturnedTypeName ? returnedArgumentType] ;
    [!?lexicalFunctionMap insertKey !mFunctionName !lexicalFunctionFormalArgumentList !returnedArgumentType !"" !true] ;
  end foreach ;
#--------------------------------------- Unicode test functions
  const @stringset externUnicodeTestFunctions := {
   !"unicodeToLower",
   !"unicodeToUpper",
   !"unicodeToUpper",
   !"isUnicodeLetter",
   !"isUnicodeMark",
   !"isUnicodeNumber",
   !"isUnicodeDecimalDigit",
   !"isUnicodeASCIIHexDigit",
   !"isUnicodeSeparator",
   !"isUnicodeCommand",
   !"isUnicodePunctuation",
   !"isUnicodeSymbol"
  } ;
#---------------------------------------
  @lexiqueAnalysisContext lexiqueAnalysisContext [new
    !mLexiqueComponentName->string
    !lexicalRoutineMap
    !lexicalFunctionMap
    ![@lexicalMessageMap emptyMap]
    ![@terminalMap emptyMap]
    ![@terminalList emptyList]
    ![@lexicalAttributeMap emptyMap]
    ![@lexicalExplicitTokenListMapMap emptyMap]
    ![@stringset emptySet]
    ![@templateDelimitorList emptyList]
    ![@styleMap emptyMap]
    !externUnicodeTestFunctions
  ] ;
#--------------------------------------- Build style map
  @uint styleIndex := 1 ;
  foreach mLexicalStyleList do
    [!?lexiqueAnalysisContext->mStyleMap insertKey !mName !mComment !styleIndex] ;
    styleIndex ++ ;
  end foreach ;
#--------------------------------------- Build lexical attribute map
  buildLexicalAttributeMap
   !lexicalTypeMap
   !mLexicalAttributeList
   !?lexiqueAnalysisContext->mLexicalAttributeMap
  ;
#--------------------------------------- Build terminal map
  foreach mTerminalDeclarationList do
    @uint terminalStyleIndex := 0 ;
    if [[mStyle string] length] > 0 then
      [[lexiqueAnalysisContext mStyleMap] searchKey !mStyle ?* ?terminalStyleIndex] ;
    end if ;
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType ;
      [lexiqueAnalysisContext->mLexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType] ;
      argumentTypeList += !mFormalSelector !mAttributeName->string !attributeLexicalType ;
    end foreach ;
    [!?lexiqueAnalysisContext->mTerminalMap insertKey !mName !argumentTypeList] ;
    @bool isEndOfTemplateMark := false ;
    @bool atomicSelection := true ;
    foreach mOptionList do
      if [mValue string] == "nonAtomicSelection" then
        if atomicSelection then
          atomicSelection := false ;
        else
          error mValue: "the 'nonAtomicSelection' feature is already set" ;
        end if ;
      elsif [mValue string] != "templateEndMark" then
        error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' features are allowed here" ;
      elsif isEndOfTemplateMark then
        error mValue:"the 'templateEndMark' feature is already set" ;
      else
        isEndOfTemplateMark := true ;
      end if ;
    end foreach ;
    lexiqueAnalysisContext->mTerminalList +=
      !mName
      !argumentTypeList
      ![mSyntaxErrorMessage string]
      !isEndOfTemplateMark
      !atomicSelection
      !terminalStyleIndex
    ;
  end foreach ;
  foreach mLexicalListDeclarationList do
    @uint terminalStyleIndex := 0 ;
    if [[mStyle string] length] > 0 then
      [[lexiqueAnalysisContext mStyleMap] searchKey !mStyle ?* ?terminalStyleIndex] ;
    end if ;
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType ;
      [lexiqueAnalysisContext->mLexicalAttributeMap searchKey !mAttributeName ?attributeLexicalType] ;
      argumentTypeList += !mFormalSelector !mAttributeName->string !attributeLexicalType ;
    end foreach ;
    @lexicalExplicitTokenListMap lexicalTokenListMap [emptyMap] ;
    @tokenSortedlist tokenSortedlist [emptySortedList] ;
    foreach mEntryList do
      @string syntaxErrorMessage := [[mSyntaxErrorMessage string] stringByReplacingStringByString !"%K" ![mTerminalSpelling string]] ;
      @bool isEndOfTemplateMark := false ;
      @bool atomicSelection := true ;
      foreach mFeatureList do
        if [mValue string] == "nonAtomicSelection" then
          if atomicSelection then
            atomicSelection := false ;
          else
            error mValue: "the 'nonAtomicSelection' feature is already set" ;
          end if ;
        elsif [mValue string] != "templateEndMark" then
          error mValue:"only the 'templateEndMark' and 'nonAtomicSelection' features are allowed here" ;
        elsif isEndOfTemplateMark then
          error mValue:"the 'templateEndMark' feature is already set" ;
        else
          isEndOfTemplateMark := true ;
        end if ;
      end foreach ;
      lexiqueAnalysisContext->mTerminalList +=
        !mTerminalSpelling
        !argumentTypeList
        !syntaxErrorMessage
        !isEndOfTemplateMark
        !atomicSelection
        !terminalStyleIndex
      ;
      [!?lexiqueAnalysisContext->mTerminalMap insertKey !mTerminalSpelling !argumentTypeList] ;
      [!?lexicalTokenListMap insertKey !mEntrySpelling !mTerminalSpelling !mFeatureList] ;
      tokenSortedlist += ![[mEntrySpelling string] length] ![mEntrySpelling string] ![mTerminalSpelling string] ;
      lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mEntrySpelling string] ;
    end foreach ;
    [!?lexiqueAnalysisContext->mLexicalTokenListMap insertKey !mName !lexicalTokenListMap !tokenSortedlist !false] ;
  end foreach ;
#--------------------------------------- Build Message map
  foreach mLexicalMessageDeclarationList do
    [!?lexiqueAnalysisContext->mLexicalMessageMap insertKey !mMessageName !mMessageValue !false] ;
  end foreach ;
#--------------------------------------- Check rules
  foreach mLexicalRuleList do
    [mLexicalRule checkLexicalRule !?lexiqueAnalysisContext] ;
  end foreach ;
#--------------------------------------- Warn for unused messages
  foreach [lexiqueAnalysisContext mLexicalMessageMap] do
    if not mMessageIsUsed then
      warning lkey:"unused message" ;
    end if ;
  end foreach ;
#--------------------------------------- Template delimiters
  foreach mTemplateDelimitorList do
   lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mStartString string] ;
   lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mEndString string] ;
   @bool preservesStartDelimiter := false ;
   foreach mOptionList do
     if [mValue string] != "preserved" then
       error mValue:"only the 'preserved' feature is allowed here" ;
     elsif preservesStartDelimiter then
       error mValue:"the 'preserved' feature is already set" ;
     else
       preservesStartDelimiter := true ;
     end if ;
   end foreach ;
   lexiqueAnalysisContext->mTemplateDelimitorList += !mStartString !mEndString !preservesStartDelimiter ;
  end foreach ;
#--------------------------------------- Check "indexing" declarations
  if [mIndexingDirectory isNowhere] then
    foreach mIndexingListAST do
      error mIndexName : "indexing declaration requires one 'indexing in \"path\";' declaration" ;
    end foreach ;
  end if ;
  @stringset indexNameSet [emptySet] ;
  foreach mIndexingListAST do
    if [indexNameSet hasKey ![mIndexName string]] then
      error mIndexName : "the '" . mIndexName . "' index is already declared" ;
    end if ;
    indexNameSet += ![mIndexName string] ;
  end foreach ;
#--------------------------------------- Template replacements
  foreach mTemplateReplacementList do
   lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mMatchString string] ;
   lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mReplacementString string] ;
   # § TODO Check replacement function
  end foreach ;
#--------------------------------------- Build header and Cpp contents
  if [@uint errorCount] == 0 then
    const lexiqueClassName := mLexiqueComponentName->string ;
  #--- Header
    var headerContents := [filewrapper lexiqueGenerationTemplates.newHeaderZone2
       ![lexiqueClassName identifierRepresentation]
       !lexiqueAnalysisContext
       !mTemplateDelimitorList
    ] ;
    headerContents += [filewrapper lexiqueGenerationTemplates.newHeaderZone3
      ![lexiqueClassName identifierRepresentation]
      !mLexicalListDeclarationList
      !lexiqueAnalysisContext
      !mIndexingListAST
    ] ;
  #--- Cpp
    const cppContents :=  [filewrapper lexiqueGenerationTemplates.newImplementationZone2Galgas3
      ![lexiqueClassName identifierRepresentation]
      ![lexiqueAnalysisContext mLexicalAttributeMap]
      ![lexiqueAnalysisContext mLexicalMessageMap]
      ![lexiqueAnalysisContext mTerminalList]
      ![lexiqueAnalysisContext mLexicalTokenListMap]
      ![lexiqueAnalysisContext mUnicodeStringToGenerate]
      !mLexicalRuleList
      !lexiqueAnalysisContext
      !mIndexingDirectory->string
      !mTemplateDelimitorList
      !lexiqueClassName
      !mTemplateReplacementList
    ] ;
  #--- Cocoa header
    var cocoaHeader := [filewrapper lexiqueGenerationTemplates.cocoaHeaderZone2
         !lexiqueClassName
         !lexiqueAnalysisContext
    ] ;
    cocoaHeader += [filewrapper lexiqueGenerationTemplates.cocoaHeaderZone3
      !lexiqueClassName
      !lexiqueAnalysisContext
    ] ;
  #--- Cocoa implementation
    const cocoaImplementation := [filewrapper lexiqueGenerationTemplates.cocoaImplementationZone2
      !"lexique-" + lexiqueClassName + "-cocoa"
      !lexiqueClassName
      ![lexiqueAnalysisContext mLexicalAttributeMap]
      ![lexiqueAnalysisContext mLexicalMessageMap]
      ![lexiqueAnalysisContext mTerminalList]
      ![lexiqueAnalysisContext mUnicodeStringToGenerate]
      !mLexicalRuleList
      !lexiqueAnalysisContext
      !mTemplateReplacementList
      !mIndexingDirectory->string
      !mIndexingListAST
      !mLexicalStyleList
      !mTemplateDelimitorList
    ] ;
  #---
    ioSemanticDeclarationListForGeneration +=
      !""
      ![@lexiqueDeclarationForGeneration new
        !true # has header
        !"lexique-" + lexiqueClassName
        !lexiqueClassName
        !headerContents
        !cppContents
        !cocoaHeader
        !cocoaImplementation
      ]
      !""
    ;  
  end if ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#    P R E D E F I N E D    T Y P E S                                       *
#                                                                           *
#---------------------------------------------------------------------------*

function buildPredefinedTypes
  ??@semanticContext inSemanticContext
  ->@predefinedTypes outPredefinedTypes {
  outPredefinedTypes := [@predefinedTypes new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"location" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"bool" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"char" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"string" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"uint" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"sint" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"uint64" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"sint64" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"double" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lbool" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lchar" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lstring" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"luint" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lsint" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"luint64" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"lsint64" !here]]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"ldouble" !here]]
  ] ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    P E R F O R M     S E M A N T I C     A N A L Y S I S                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine performSemanticAnalysis
  ??@string inProductDirectory
  ??@semanticDeclarationListAST inDeclarationList
  ??@semanticContext inSemanticContext
  !@semanticDeclarationSortedListForGeneration outDecoratedDeclarationListForGeneration
:
#------ Check there is no undefined types
  foreach [inSemanticContext->mTypeMap unsolvedProxyList] do
    error mValue : "the '" . mValue . "' type is undefined" ;
  end foreach ;
#------ Create associated type (@TYPE:element) for lists, maps, ...
  @semanticDeclarationListAST semanticDeclarationList := inDeclarationList ;
  foreach inDeclarationList do
    [mSemanticDeclaration addAssociatedElement !?semanticDeclarationList] ;
  end foreach ;
#---
  outDecoratedDeclarationListForGeneration := [@semanticDeclarationSortedListForGeneration emptySortedList] ;
  if [@uint errorCount] == 0 then
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!inSemanticContext] ;
    foreach semanticDeclarationList do
      [mSemanticDeclaration semanticAnalysis
        !inProductDirectory
        !inSemanticContext
        !predefinedTypes
        !?outDecoratedDeclarationListForGeneration
      ] ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    D E C L A R A T I O N S                                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @nonterminalLabelMap {
  @formalParameterListForGeneration mSignatureForGeneration ;
  @formalParameterSignature mSignature ;
  @location mEndOfArgumentLocation ;
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal label is not declared" ;
}

#---------------------------------------------------------------------------*

map @nonterminalMap {
  @nonterminalLabelMap mLabelMap ;
  insert insertKey error message "the '%K' nonterminal has been already declared in %L" ;
  search searchKey error message "the '%K' nonterminal is not declared" ;
}

#---------------------------------------------------------------------------*

list @ruleLabelImplementationList {
  @lstring mLabelName ;
  @formalParameterListForGeneration mSignatureForGeneration ;
  @formalParameterSignature mSignature ;
  @location mEndOfArgumentLocation ;
  @semanticInstructionListForGeneration mInstructionListForGeneration ;
}

#---------------------------------------------------------------------------*

list @ruleDeclarationList {
  @string mNonterminalName ;
  @uint mRuleIndex ;
  @ruleLabelImplementationList mLabelImplementationList ;
}

#---------------------------------------------------------------------------*

list @syntaxListForGeneration {
  @galgas3SyntaxComponentListAST-element mSyntaxComponentRoot ;
  @syntaxDeclarationForGeneration mSyntaxGeneration ;
  @bool mHasIndexing ;
}

#---------------------------------------------------------------------------*

class @syntaxDeclarationForGeneration extends @semanticDeclarationForGeneration {
  @string mSyntaxComponentName ;
  @string mLexiqueName ;
  @nonterminalMap mNonterminalDeclarationMap ;
  @ruleDeclarationList mRuleDeclarationList ;
  @uint mSelectMethodCount ;
  @bool mHasIndexing ;
  @bool mHasTranslateFeature ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper syntaxFileGenerationTemplate in "../generation_templates/syntax_generation" {
}{
}{
  template syntaxFileHeader "syntax-file.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
  ;

  template syntaxFileHeaderGalgas3 "syntax-file-galgas3.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringset INCLUSION_SET
  ;

  template syntaxFileImplementationGalgas3 "syntax-file-galgas3.cpp.gTemplate"
    ?@stringset INCLUSION_SET
  ;

  template syntaxFileImplementation "syntax-file.cpp.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
  ;

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.gTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
    ?@uintlist SELECT_METHOD_LIST
    ?@bool HAS_INDEXING
    ?@bool HAS_TRANSLATE_FEATURE
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    N O N T E R M I N A L    M A P                     *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterNonterminalNonTerminalInMapAndCheck
  ??@lstring inNonTerminalName
  ??@nonterminalLabelMap inNonterminalLabelMap
  ?!@nonterminalMap ioNonterminalDeclarationMap 
:
  with ioNonterminalDeclarationMap hasKey ![inNonTerminalName string] do
    const @stringset firstDeclarationLabelSet := [mLabelMap keySet] ;
    const @stringset reDeclarationLabelSet := [inNonterminalLabelMap keySet] ;
    const @stringset missingLabelSet := firstDeclarationLabelSet - reDeclarationLabelSet ;
    if [missingLabelSet count] > 0 then
      @string s := "" ;
      foreach missingLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared without the following label(s):" . s
      ;
    end if ;
    const @stringset newLabelSet := reDeclarationLabelSet - firstDeclarationLabelSet ;
    if [newLabelSet count] > 0 then
      @string s := "" ;
      foreach newLabelSet do
        s .= "\n-  " . key ;
      end foreach ;
      error inNonTerminalName
      : "the '" . inNonTerminalName . "' nonterminal is redeclared with the new label(s):" . s
      ;
    end if ;
    if ([missingLabelSet count] == 0) & ([newLabelSet count] == 0) then
      foreach mLabelMap, inNonterminalLabelMap : new_ do
        @formalParameterSignature newSignature [emptyList] ;
        foreach new_mSignature do
          newSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName ;
        end foreach ;
        checkMethodSignatures
          !mSignatureForGeneration
          !mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        ;
      end foreach ;
    end if ;
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap] ;
  end with ;
end routine ;

#---------------------------------------------------------------------------*

routine buildNonterminalDeclarationsMap
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@semanticContext inSemanticContext
  !@nonterminalMap outNonterminalDeclarationMap
:
  outNonterminalDeclarationMap := [@nonterminalMap emptyMap] ;
#--- Nonterminal declaration list
  foreach inNonterminalDeclarationList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabels do
      @formalParameterListForGeneration signatureForGeneration [emptyList] ;
      @formalParameterSignature signature [emptyList] ;
      foreach mFormalArgumentList do
        const t := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signatureForGeneration += !mFormalSelector !mFormalArgumentPassingMode !t !mFormalArgumentName ![mFormalArgumentName string] ;
        signature += !mFormalSelector !t !mFormalArgumentPassingMode !mFormalArgumentName->string ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
    enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !?outNonterminalDeclarationMap ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S                *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
;

#---------------------------------------------------------------------------*

override method @semanticInstructionAST analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool unused inHasTranslateFeature
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ??@stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  [selfcopy analyzeSemanticInstruction
    !inAnalysisContext
    !?ioInstructionListForGeneration
    !?ioVariableMap
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string unused inComponentName
  ??@stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  @nonterminalLabelMap labelMap ;
  [inNonterminalMap searchKey !mNonterminalName ?labelMap] ;
  @formalParameterSignature signature ;
  if [mLabelName string] == "parse" then
    signature := [@formalParameterSignature emptyList] ;
  else
    [labelMap searchKey !mLabelName ?* ?signature ?*] ;
  end if ;
#--- call arguments
  var localVariableDeclarationList := @unifiedTypeMapProxyAndLocalVariableList {} ;
  analyzeRoutineArguments
    !inAnalysisContext
    !mNonterminalName
    !"'<" . mNonterminalName . ">' nonterminal declaration"
    !signature
    !mActualParameterList
    !?ioVariableMap
    !?localVariableDeclarationList
    ??@actualParameterListForGeneration actualParameterListForGeneration
  ;
#--- Check syntax directed translation destination variable
  [mGrammarInstructionSyntaxDirectedTranslationResult analyzeSDT
    !inAnalysisContext
    !inHasTranslateFeature
    !?ioVariableMap
  ] ;
#--- Generate instructions
  for () in localVariableDeclarationList do
    ioInstructionListForGeneration += ![@localVariableDeclarationForGeneration new
      !mType
      !mLocalVariableName
    ] ;
  end for ;
  ioInstructionListForGeneration += ![@nonterminalInstructionForGeneration new
    !mInstructionLocation
    ![mNonterminalName string]
    ![mLabelName string]
    !actualParameterListForGeneration
    !mGrammarInstructionSyntaxDirectedTranslationResult
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Parameters
  @stringlist parameterCppNameList [emptyList] ;
  @stringlist jokerParametersToReleaseList [emptyList] ;
  @stringlist inputVariableList [emptyList] ;
  foreach mActualParameterList do
    [mActualParameter generateActualParameter
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioGeneratedCode
      !?jokerParametersToReleaseList
      !?inputVariableList
      !?ioUnusedVariableCppNameSet
      ??@string parameterCppName
    ] ;
    parameterCppNameList += !parameterCppName ;
  end foreach ;
#--- Generate method call
  const sdtResultVarName := "syntaxDirectedTranslationResult_" . [mInstructionLocation locationIndex] ;
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode .= "C_String " . sdtResultVarName . " ;\n" ;
  end if ;
  ioGeneratedCode .= "nt_" . [mNonterminalName identifierRepresentation] . "_" . [mLabelName identifierRepresentation] . " (" ;
  foreach parameterCppNameList do
    ioGeneratedCode .= mValue . ", " ;
  end foreach ;
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode .= sdtResultVarName . ", " ;
  end if ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .=  compilerCppName [] . ") ;\n" ;
  [mGrammarInstructionSyntaxDirectedTranslationResult generateCode
    !inGenerateSyntaxDirectedTranslationString
    !sdtResultVarName
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ] ;
#--- Release temporary variables
  foreach jokerParametersToReleaseList do
    ioGeneratedCode .= mValue . ".drop () ; // Release temporary input variables (joker in source)\n" ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

#! Terminal instruction

#---------------------------------------------------------------------------*

abstract method @abstractInputParameter analyzeInputParameter
  ??@analysisContext inAnalysisContext
  ??@lexicalTypeEnum inRequiredLexicalType
  ??@string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap
;

#---------------------------------------------------------------------------*

override method @inputParameterAnonymousVariable analyzeInputParameter
  ??@analysisContext unused inAnalysisContext
  ??@lexicalTypeEnum unused inRequiredLexicalType
  ??@string unused inLexicalAttributeName
  ?!@terminalCheckAssignementList unused ioTerminalCheckAssignementList
  ?!@variableMap unused ioVariableMap
:
end method ;

#---------------------------------------------------------------------------*

override method @inputParameterVariable analyzeInputParameter
  ??@analysisContext inAnalysisContext
  ??@lexicalTypeEnum inRequiredLexicalType
  ??@string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap
:
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ??@unifiedTypeMapProxy type ??@string cppName ?*] ;
  @unifiedTypeMapProxy expectedType ;
  switch inRequiredLexicalType
  when lexicalType_string : expectedType := inAnalysisContext->mPredefinedTypes->mLStringType ;
  when lexicalType_char : expectedType := inAnalysisContext->mPredefinedTypes->mLCharType ;
  when lexicalType_uint : expectedType := inAnalysisContext->mPredefinedTypes->mLUIntType ;
  when lexicalType_uint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLUInt64Type ;
  when lexicalType_sint : expectedType := inAnalysisContext->mPredefinedTypes->mLSIntType ;
  when lexicalType_sint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLSInt64Type ;
  when lexicalType_double : expectedType := inAnalysisContext->mPredefinedTypes->mLDoubleType ;
  end switch ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
  ioTerminalCheckAssignementList +=
    !"" # Do not declare variable
    !cppName
    !inLexicalAttributeName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @inputParameterDeclaredVariable analyzeInputParameter
  ??@analysisContext inAnalysisContext
  ??@lexicalTypeEnum inRequiredLexicalType
  ??@string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap
:
#--- Expected type
  @unifiedTypeMapProxy expectedType ;
  switch inRequiredLexicalType
  when lexicalType_string : expectedType := inAnalysisContext->mPredefinedTypes->mLStringType ;
  when lexicalType_char : expectedType := inAnalysisContext->mPredefinedTypes->mLCharType ;
  when lexicalType_uint : expectedType := inAnalysisContext->mPredefinedTypes->mLUIntType ;
  when lexicalType_uint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLUInt64Type ;
  when lexicalType_sint : expectedType := inAnalysisContext->mPredefinedTypes->mLSIntType ;
  when lexicalType_sint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLSInt64Type ;
  when lexicalType_double : expectedType := inAnalysisContext->mPredefinedTypes->mLDoubleType ;
  end switch ;
#--- Type is named, or should be infered ?
  if mActualParameterTypeName->string != "" then
    const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
    if expectedType != type then
      error mActualParameterName
      : "the '" . mActualParameterName . "' formal argument has the '@" . [type key]
      . ", bit an '@" . [expectedType key] . "' parameter is required here"
      ;
    end if ;
  end if ;
#--- Create local variable
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !expectedType !cppName !cppName] ;
  ioTerminalCheckAssignementList +=
    ![expectedType key]
    !cppName
    !inLexicalAttributeName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @inputParameterDeclaredConstant analyzeInputParameter
  ??@analysisContext inAnalysisContext
  ??@lexicalTypeEnum inRequiredLexicalType
  ??@string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@variableMap ioVariableMap
:
#--- Expected type
  @unifiedTypeMapProxy expectedType ;
  switch inRequiredLexicalType
  when lexicalType_string : expectedType := inAnalysisContext->mPredefinedTypes->mLStringType ;
  when lexicalType_char : expectedType := inAnalysisContext->mPredefinedTypes->mLCharType ;
  when lexicalType_uint : expectedType := inAnalysisContext->mPredefinedTypes->mLUIntType ;
  when lexicalType_uint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLUInt64Type ;
  when lexicalType_sint : expectedType := inAnalysisContext->mPredefinedTypes->mLSIntType ;
  when lexicalType_sint64 : expectedType := inAnalysisContext->mPredefinedTypes->mLSInt64Type ;
  when lexicalType_double : expectedType := inAnalysisContext->mPredefinedTypes->mLDoubleType ;
  end switch ;
#--- Type is named, or should be infered ?
  if mActualParameterTypeName->string != "" then
    const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
    if expectedType != type then
      error mActualParameterName
      : "the '" . mActualParameterName . "' formal argument has the '@" . [type key]
      . ", bit an '@" . [expectedType key] . "' parameter is required here"
      ;
    end if ;
  end if ;
#--- Create local constant
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  [!?ioVariableMap insertLocalConstant !mActualParameterName !expectedType !cppName !cppName] ;
#---
  ioTerminalCheckAssignementList +=
    ![expectedType key]
    !cppName
    !inLexicalAttributeName
  ;
end method ;

#---------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap ioVariableMap
;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeSDT
  ??@analysisContext unused inAnalysisContext
  ??@bool unused inHasTranslateFeature
  ?!@variableMap unused ioVariableMap
:
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeSDT
  ??@analysisContext unused inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap unused ioVariableMap
:
  if not inHasTranslateFeature then
    error mLocation : "the ':>' construct requires the syntax component to be declared with 'translate' feature" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature" ;
  end if ;
  [!?ioVariableMap searchForWriteAccess !mActualParameterName ??@unifiedTypeMapProxy type ?* ?*] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature" ;
  end if ;
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
  [!?ioVariableMap insertDefinedLocalVariable !mActualParameterName !type !cppName !cppName] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeSDT
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ?!@variableMap ioVariableMap
:
  if not inHasTranslateFeature then
    error mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature" ;
  end if ;
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  const type := [@unifiedTypeMapProxy searchKey !inAnalysisContext->mSemanticContext->mTypeMap !mActualParameterTypeName] ;
  [!?ioVariableMap insertLocalConstant !mActualParameterName !type !cppName !cppName] ;
  const expectedType := inAnalysisContext->mPredefinedTypes->mStringType ;
  if expectedType != type then
    error mActualParameterName
    : "the '" . mActualParameterName . "' parameter has the '@" . [type identifierRepresentation]
    . ", bit an '@" . [expectedType identifierRepresentation] . "' parameter is required here"
    ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult generateCode
  ??@bool inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultNone generateCode
  ??@bool inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode .= syntaxDirectedTranslationResultVarName[] . " << " . inAccessMethodName . " ;\n" ;
    [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName []] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationDropResult  generateCode
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ??@string unused inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string unused ioGeneratedCode
:
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  generateCode
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  ioGeneratedCode .= cppName . " = GALGAS_string (" . inAccessMethodName . ") ;\n" ; 
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  generateCode
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  ioGeneratedCode .= "GALGAS_string " . cppName . " (" . inAccessMethodName . ") ;\n" ; 
end method ;

#---------------------------------------------------------------------------*

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  generateCode
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ??@string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode
:
  const cppName := "var_" . [mActualParameterName identifierRepresentation] ;
  ioGeneratedCode .= "const GALGAS_string " . cppName . " (" . inAccessMethodName . ") ;\n" ; 
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  [inTerminalMap searchKey !mTerminalName ??@lexicalSentValueList sentAttributeList] ;
#---
  if [mActualInputParameterList length] != [sentAttributeList length] then
    error mTerminalName
    : "naming the '$" . mTerminalName . "$' terminal requires " . [[sentAttributeList length] string]
    . " input parameter" . if [sentAttributeList length] > 1 then "s" else "" end
    . ", but this instruction names "
    . [[mActualInputParameterList length] string] . " input parameter" 
    . if [mActualInputParameterList length] > 1 then "s" else "" end
    ;
  end if ;
#---
  @terminalCheckAssignementList terminalCheckAssignementList [emptyList] ;
  foreach mActualInputParameterList, sentAttributeList do
    [mInputParameter analyzeInputParameter
      !inAnalysisContext
      !mLexicalType
      !mLexicalAttributeName
      !?terminalCheckAssignementList
      !?ioVariableMap
    ] ;
    if mLexicalFormalSelector->string != mActualSelector->string then
      error mActualSelector : "the actual selector should be '?" . mLexicalFormalSelector . if mLexicalFormalSelector->string != "" then ":" else "" end + "'" ;
      warning mLexicalFormalSelector : "the formal selector is declared here" ;
    end if ;
  end foreach ;
#---
  foreach mIndexingKeyList do
    if not [inIndexNameSet hasKey ![mValue string]] then
      var s := "" ;
      foreach inIndexNameSet do
        s .= "\n  - " . key  ;
      end foreach ;
      error mValue : "the '" . mValue . "' indexing name is not declared by the lexique; available names are:" . s ;
    end if ;
  end foreach ;
#--- Check syntax directed translation destination variable
  [mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor analyzeSDT
    !inAnalysisContext
    !inHasTranslateFeature
    !?ioVariableMap
  ] ;
  [mGrammarInstructionSyntaxDirectedTranslationToken analyzeSDT
    !inAnalysisContext
    !inHasTranslateFeature
    !?ioVariableMap
  ] ;
#---
  ioInstructionListForGeneration += ![@terminalCheckInstructionForGeneration new
    !mInstructionLocation
    !mTerminalName
    !inLexiqueName
    !terminalCheckAssignementList
    !mIndexingKeyList
    !mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor
    !mGrammarInstructionSyntaxDirectedTranslationToken
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstructionForGeneration generateInstruction
  ?!@stringset unused ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#--- Get synthetized attributes
  foreach mTerminalCheckAssignementList do
    if mTypeName != "" then
      ioGeneratedCode .= "GALGAS_" . [mTypeName identifierRepresentation] . " " ;
    else
    end if ;
    ioGeneratedCode .= mTargetVarCppName . " = " . compilerCppName [] . "->synthetizedAttribute_"
                    . [mSourceLexicalAttributeName identifierRepresentation]
                    . " () ;\n" ;
  end foreach ;
#--- Indexing
  foreach mIndexingKeyList do
    ioGeneratedCode .= compilerCppName [] . "->enterIndexing (C_Lexique_" . mLexiqueIdentifier . "::kIndexing_" . [mValue identifierRepresentation] . ") ;\n" ;
  end foreach ;
#--- Syntax directed translation
  [mGrammarInstructionSyntaxDirectedTranslationPreceedingDelimitor generateCode
    !inGenerateSyntaxDirectedTranslationString
    !"inCompiler->preceedingSeparatorString ()"
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ] ;
  [mGrammarInstructionSyntaxDirectedTranslationToken generateCode
    !inGenerateSyntaxDirectedTranslationString
    !"inCompiler->tokenString ()"
    !?ioUnusedVariableCppNameSet
    !?ioGeneratedCode
  ] ;
#--- Check terminal symbol
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= compilerCppName [] . "->acceptTerminal (ACCEPT_TERMINAL (C_Lexique_"
                  . mLexiqueIdentifier . "::kToken_" . [mTerminalName identifierRepresentation]
                  . ")" . [mInstructionLocation commaSourceFile] . ") ;\n" ;
end method ;

#---------------------------------------------------------------------------*

routine analyzeSyntaxInstructionList
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string  inComponentName
  ??@syntaxInstructionList inSyntaxInstructionListAST
  ??@location inEndOfBranchLocation
  ??@stringset inIndexNameSet
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
#--- Begin branch
  [!?ioVariableMap openBranch] ;
#--- Instruction list
  foreach inSyntaxInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?ioSelectMethodCount
    ] ;
  end foreach ;
#--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation] ;
end routine ;

#---------------------------------------------------------------------------*

override method @repeatInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
  const @uint choiceIndex := ioSelectMethodCount ;
  ioSelectMethodCount ++ ;
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock] ;
#--- Repeated instructions
  @semanticInstructionListForGeneration repeated_instructionList ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mRepeatedInstructionList
    !mEndOf_repeated_instructions_branch
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?repeated_instructionList
  ;
#--- 'while' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  foreach mRepeatBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !mSyntaxInstructionList
      !mEndOf_instructions
      !inIndexNameSet
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- End block
  [!?ioVariableMap closeOverride !mEndOf_repeat_instruction] ;
#---
  ioInstructionListForGeneration += ![@repeatInstructionForGeneration new
    !mInstructionLocation
    !inComponentName
    !choiceIndex
    !repeated_instructionList
    !mEndOf_repeat_instruction
    !listOfSemanticInstructionListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#  ioGeneratedCode .= "//-------- @repeatInstructionForGeneration\n" ;
  const @string repeatFlagCppName := "repeatFlag_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "bool " . repeatFlagCppName . " = true ;\n" ;
  ioGeneratedCode .= "while (" . repeatFlagCppName . ") {\n" ;
  generateInstructionList
    !?ioInclusionSet
    !m_repeated_instructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= "switch (select_" . [mSyntaxComponentName identifierRepresentation] . "_" . [mChoiceIndex string] . " (" . compilerCppName [] . ")) {\n" ;
  foreach mListOfSemanticInstructionListForGeneration index IDX do
    ioGeneratedCode .= "case " . [IDX + 2 string] . ": {\n" ;
    generateInstructionList
      !?ioInclusionSet
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
    ioGeneratedCode .= "} break ;\n" ;
  end foreach ;
  ioGeneratedCode .= "default:\n" ;
  ioGeneratedCode .= "  " . repeatFlagCppName . " = false ;\n" ;
  ioGeneratedCode .= "  break ;\n" ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string  inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
  const @uint choiceIndex := ioSelectMethodCount ;
  ioSelectMethodCount ++ ;
#--- Begin block
  [!?ioVariableMap openOverrideForSelectBlock] ;
#--- 'or' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  foreach mSelectBranchList do
    @semanticInstructionListForGeneration instructionList ;
    analyzeSyntaxInstructionList
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !mSyntaxInstructionList
      !mEndOf_instructions
      !inIndexNameSet
      !?ioVariableMap
      !?ioSelectMethodCount
      ?instructionList
    ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- End block
  [!?ioVariableMap closeOverride !mEndOf_select_instruction] ;
  ioInstructionListForGeneration += ![@selectInstructionForGeneration new
    !mInstructionLocation
    !inComponentName
    !choiceIndex
    !listOfSemanticInstructionListForGeneration
 ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#  ioGeneratedCode .= "//-------- @selectInstructionForGeneration\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  ioGeneratedCode .= "switch (select_" . [mSyntaxComponentName identifierRepresentation] . "_" . [mChoiceIndex string] . " (" . compilerCppName [] . ")) {\n" ;
  foreach mListOfSemanticInstructionListForGeneration index IDX do
    ioGeneratedCode .= "case " . [IDX + 1 string] . ": {\n" ;
    generateInstructionList
      !?ioInclusionSet
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
    ioGeneratedCode .= "} break ;\n" ;
  end foreach ;
  ioGeneratedCode .= "default:\n" ;
  ioGeneratedCode .= "  break ;\n" ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseRewindInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap  inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- 'Rewind' blocks
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  const @uint referenceSelectMethodCount := ioSelectMethodCount ;
  foreach mParseRewindBranchList do
    ioSelectMethodCount := referenceSelectMethodCount ;
    @semanticInstructionListForGeneration instructionList [emptyList] ;
    foreach mSyntaxInstructionList do
      [mInstruction analyzeSyntaxInstruction
        !inAnalysisContext
        !inHasTranslateFeature
        !inTerminalMap
        !inLexiqueName
        !inNonterminalMap
        !inComponentName
        !inIndexNameSet
        !?instructionList
        !?ioVariableMap
        !?ioSelectMethodCount
      ] ;
    end foreach ;
    listOfSemanticInstructionListForGeneration += !instructionList !mEndOf_instructions ;
  end foreach ;
#--- Check syntax signature of branches
  @listOfSemanticInstructionListForGeneration tempListOfBranches := listOfSemanticInstructionListForGeneration ;
  @semanticInstructionListForGeneration instructionList ;
  [!?tempListOfBranches popFirst ?instructionList ?*] ;
  const @semanticInstructionListForGeneration referenceSignature := syntaxSignatureOfInstructionList [!"parse" !instructionList] ;
  @bool ok := true ;
  foreach tempListOfBranches while ok do
    ok := compareSyntaxSignature [
      !referenceSignature
      !syntaxSignatureOfInstructionList [!"parse" !mInstructionList]
      !mEndOfInstructionList
    ] ;
  end foreach ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@parseRewindInstructionForGeneration new
    !mInstructionLocation
    !listOfSemanticInstructionListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseRewindInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#  ioGeneratedCode .= "//-------- @parseRewindInstructionForGeneration\n" ;
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
  const @string parsingContextVar := "parsingContext_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "const C_parsingContext " . parsingContextVar . " = " . compilerCppName [] . "->parsingContext () ;\n" ;
  foreach mListOfSemanticInstructionListForGeneration
  do
    generateInstructionList
      !?ioInclusionSet
      !mInstructionList
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?ioGeneratedCode
    ;
  between 
    ioGeneratedCode .= compilerCppName [] . "->setParsingContext (" . parsingContextVar . ") ; // rewind\n" ;
  end foreach ;
  ioGeneratedCode .= "//-------- END OF @parseRewindInstructionForGeneration\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- Variant expression
  @semanticExpressionForGeneration variant_expression ;
  [mVariantExpression analyzeSemanticExpression
    ![@unifiedTypeMapProxy null]
    !inAnalysisContext
    !?ioVariableMap
    ?variant_expression
  ] ;
  if [variant_expression mResultType] != inAnalysisContext->mPredefinedTypes->mUIntType then
    error mEndOfVariantExpression
    :"the variant expression type is '@" . [[variant_expression mResultType] key]
    . "', but it should be '@" . [inAnalysisContext->mPredefinedTypes->mUIntType key] . "' type"
    ;
  end if ;
#--- While expression
  @semanticExpressionForGeneration while_expression ;
  [mWhileExpression analyzeSemanticExpression
    ![@unifiedTypeMapProxy null]
    !inAnalysisContext
    !?ioVariableMap
    ?while_expression
  ] ;
  if [while_expression mResultType] != inAnalysisContext->mPredefinedTypes->mBoolType then
    error mEndOfWhileExpression
    :"the variant expression type is '@" . [[variant_expression mResultType] key]
    . "', but it should be '@" . [inAnalysisContext->mPredefinedTypes->mBoolType key] . "' type"
    ;
  end if ;
#--- 'do' instructions
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock] ;
#--- 'or' blocks
  @semanticInstructionListForGeneration instructionList ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mDoInstructionList
    !mEndOfInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?instructionList
  ;
#--- End block
  [!?ioVariableMap closeOverride !mEndOfInstructionList] ;
#--- Generate instruction
  ioInstructionListForGeneration += ![@parseLoopInstructionForGeneration new
    !mInstructionLocation
    !variant_expression
    !while_expression
    !instructionList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName []] ;
#  ioGeneratedCode .= "//-------- @parseLoopInstructionForGeneration\n" ;
#--- Variant
  @string variantVarCppName ;
  [mVariantExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?variantVarCppName] ;
#--- Loop variable
  ioGeneratedCode .= "if (" . variantVarCppName . ".isValid ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  const @string variantVar := "variant_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "uint32_t " . variantVar . " = " . variantVarCppName . ".uintValue () ;\n" ;
#--- loop
  const @string loopVar := "loop_" . [ioTemporaryVariableIndex string] ; ioTemporaryVariableIndex ++ ;
  ioGeneratedCode .= "bool " . loopVar . " = true ;\n" ;
  ioGeneratedCode .= "while (" . loopVar . ") {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= loopVar . " = false ;\n" ;
  @string whileVarCppName ;
  [mWhileExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?whileVarCppName] ;
  ioGeneratedCode .= "if (" . whileVarCppName . ".isValidAndTrue ()) {\n" ;
  [!?ioGeneratedCode incIndentation !2] ;
  ioGeneratedCode .= loopVar . " = true ;\n" ;
  ioGeneratedCode .= variantVar . " -- ; // Decrement variant\n" ;
  ioGeneratedCode .= "const C_parsingContext parsingContext = " . compilerCppName [] . "->parsingContext () ;\n" ;
  generateInstructionList
    !?ioInclusionSet
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= compilerCppName [] . "->setParsingContext (parsingContext) ;\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
  [!?ioGeneratedCode decIndentation !2] ;
  ioGeneratedCode .= "}\n" ;
#--- Execute 'parse' part
  ioGeneratedCode .= "//--- 'parse'\n" ;
  generateInstructionList
    !?ioInclusionSet
    !syntaxSignatureOfInstructionList [!"parse" !mInstructionList]
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= compilerCppName [] . "->resetTemplateString () ;\n" ;
  ioGeneratedCode .= "//-------- END OF @parseLoopInstructionForGeneration\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap inTerminalMap
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint ioSelectMethodCount
:
#--- When expression
  @semanticExpressionForGeneration when_expression ;
  [mWhenExpression analyzeSemanticExpression
    ![@unifiedTypeMapProxy null]
    !inAnalysisContext
    !?ioVariableMap
    ?when_expression
  ] ;
#--- Begin block
  [!?ioVariableMap openOverrideForRepeatBlock] ;
#--- 'when' branch
  @uint localSelectMethodCount := ioSelectMethodCount ;
  @semanticInstructionListForGeneration when_instructionListForGeneration ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mWhenInstructionList
    !mEndOfWhenInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?localSelectMethodCount
    ?when_instructionListForGeneration
  ;
#--- 'else' branch
  @semanticInstructionListForGeneration else_instructionListForGeneration ;
  analyzeSyntaxInstructionList
    !inAnalysisContext
    !inHasTranslateFeature
    !inTerminalMap
    !inLexiqueName
    !inNonterminalMap
    !inComponentName
    !mElseInstructionList
    !mEndOfElseInstructionList
    !inIndexNameSet
    !?ioVariableMap
    !?ioSelectMethodCount
    ?else_instructionListForGeneration
  ;
#--- End block
  [!?ioVariableMap closeOverride !mEndOfElseInstructionList] ;
#--- Check syntax signature
  const @bool ok := compareSyntaxSignature [
    !syntaxSignatureOfInstructionList [!"parse" !when_instructionListForGeneration]
    !syntaxSignatureOfInstructionList [!"parse" !else_instructionListForGeneration]
    !mEndOfElseInstructionList
  ] ;
#--- Generate instruction
  if ok then
    ioInstructionListForGeneration += ![@parseWhenInstructionForGeneration new
      !mInstructionLocation
      !when_expression
      !when_instructionListForGeneration
      !else_instructionListForGeneration
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
#  ioGeneratedCode .= "//--------- @parseWhenInstructionForGeneration\n" ;
  @string sourceVar ;
  [mWhenExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ?sourceVar] ;
  ioGeneratedCode .= "if (" . sourceVar . ".isValidAndTrue ()) {\n" ;
  generateInstructionList
    !?ioInclusionSet
    !mInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= "}else{\n" ;
  generateInstructionList
    !?ioInclusionSet
    !mElseInstructionList
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    !inGenerateSyntaxDirectedTranslationString
    !?ioGeneratedCode
  ;
  ioGeneratedCode .= "}\n" ;
end method ;

#---------------------------------------------------------------------------*

override method @syntaxSendInstruction analyzeSyntaxInstruction
  ??@analysisContext inAnalysisContext
  ??@bool inHasTranslateFeature
  ??@terminalMap unused inTerminalMap
  ??@string unused inLexiqueName
  ??@nonterminalMap unused inNonterminalMap
  ??@string unused inComponentName
  ??@stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
  ?!@uint unused ioSelectMethodCount
:
  if not inHasTranslateFeature then
    error mInstructionLocation : "'send' instruction is only allowed when syntax componant has 'translate' feature" ;
  end if ;
#--- Analyze source expression
  [mExpression analyzeSemanticExpression
    ![@unifiedTypeMapProxy null]
    !inAnalysisContext
    !?ioVariableMap
    ??@semanticExpressionForGeneration expression
  ] ;
#--- Check expression type
  if [expression mResultType] != inAnalysisContext->mPredefinedTypes->mStringType  then
    error mInstructionLocation: "'send' expresion should be an @string expression" ;
  end if ;
#---
  ioInstructionListForGeneration += ![@syntaxSendInstructionForGeneration new
    !mInstructionLocation
    !expression
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @syntaxSendInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ??@bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
:
  [mExpression generateExpression !?ioGeneratedCode !?ioInclusionSet !?ioTemporaryVariableIndex !?ioUnusedVariableCppNameSet ??@string sourceVar] ;
#---
  [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName []] ;
  ioGeneratedCode .= "if (" . sourceVar . ".isValid ()) {\n"
                   . "  " . syntaxDirectedTranslationResultVarName [] . " << " . sourceVar . ".stringValue () ;\n"
                   . "}\n" ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    C O N T E X T                                      *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfRuleLabel
  ??@formalParameterListAST inFormalArguments
  ??@syntaxInstructionList inSyntaxInstructionList
  ??@analysisContext inAnalysisContext
  ??@terminalMap inTerminalMap
  ??@bool inHasTranslateFeature
  ??@string inLexiqueName
  ??@nonterminalMap inNonterminalMap
  ??@string inComponentName
  ??@location inEndOfInstructionList
  ??@stringset inIndexNameSet
  ?!@uint ioSelectMethodCount
  !@formalParameterListForGeneration outSignatureForGeneration
  !@formalParameterSignature outSignature
  !@semanticInstructionListForGeneration outInstructionListForGeneration
:
  @variableMap variableMap [emptyMap] ;
  buildLocalVariableMapAndSignature
    !inAnalysisContext->mSemanticContext
    !inFormalArguments
    !?variableMap
    ?outSignatureForGeneration
  ;
#---
  outSignature := [@formalParameterSignature emptyList] ;
  foreach outSignatureForGeneration do
    outSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName->string ;
  end foreach ;
#--- Semantic analysis of instruction list
  outInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  @stringlist localVariableCppNameList [emptyList] ;
  foreach inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inAnalysisContext
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?variableMap
      !?ioSelectMethodCount
    ] ;
  end foreach ;
#---
  [variableMap checkAutomatonStates !inEndOfInstructionList] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           S E M A N T I C    A N A L Y S I S                              *
#                                                                           *
#---------------------------------------------------------------------------*

routine semanticAnalysisOfSyntaxComponent
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
  ??@syntaxRuleListAST inRuleList
  ??@string inComponentName
  ??@string inLexiqueName
  ??@semanticContext inSemanticContext
  ??@predefinedTypes inPredefinedTypes
  ??@terminalMap inTerminalMap
  ??@stringset inIndexNameSet
  ??@bool inHasIndexing
  ??@bool inHasTranslateFeature
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration
:
#------------ Build nonterminal map
  @nonterminalMap nonterminalMap [emptyMap] ;
  buildNonterminalDeclarationsMap
    !inNonterminalDeclarationList
    !inSemanticContext
    ?nonterminalMap
  ;
#------------ Build nonterminal map from rule headers
  foreach inRuleList do
    @nonterminalLabelMap nonterminalLabelMap [emptyMap] ;
    foreach mLabelList do
      @formalParameterListForGeneration signatureForGeneration [emptyList] ;
      @formalParameterSignature signature [emptyList] ;
      foreach mFormalArguments do
        const type := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalArgumentTypeName] ;
        signatureForGeneration += !mFormalSelector !mFormalArgumentPassingMode !type !mFormalArgumentName !"argument_" . mFormalArgumentName ;
        signature += !mFormalSelector !type !mFormalArgumentPassingMode !mFormalArgumentName->string ;
      end foreach ;
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation] ;
    end foreach ;
      enterNonterminalNonTerminalInMapAndCheck !mNonterminalName !nonterminalLabelMap !?nonterminalMap ;
  end foreach ;
#--- Analysis context
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !inPredefinedTypes
    ![@unifiedTypeMapProxy null]
    !""
    ![@unifiedTypeMapProxy null]
  ] ;
#--- Rule list
  @uint selectMethodCount := 0 ;
  @ruleDeclarationList ruleDeclarationList [emptyList] ;
  @uint newRuleIndex := 0 ;
  foreach inRuleList do
    @ruleLabelImplementationList ruleLabelImplementationList [emptyList] ;
    @uint localSelectMethodCount := selectMethodCount ;
    [nonterminalMap searchKey !mNonterminalName ?*] ;
    foreach mLabelList do
      localSelectMethodCount := selectMethodCount ;
      @formalParameterListForGeneration signatureForGeneration ;
      @formalParameterSignature signature ;
      @semanticInstructionListForGeneration instructionListForGeneration ;
      semanticAnalysisOfRuleLabel
        !mFormalArguments
        !mSyntaxInstructionList
        !analysisContext
        !inTerminalMap
        !inHasTranslateFeature
        ![inLexiqueName identifierRepresentation]
        !nonterminalMap
        !inComponentName
        !mEndOfInstructionList
        !inIndexNameSet
        !?localSelectMethodCount
        ?signatureForGeneration
        ?signature
        ?instructionListForGeneration
      ;
      ruleLabelImplementationList +=
        !mLabelName
        !signatureForGeneration
        !signature
        !mEndOfArgumentLocation
        !instructionListForGeneration
      ;
    end foreach ;
    selectMethodCount := localSelectMethodCount ;
    [nonterminalMap searchKey !mNonterminalName ?*] ;
    ruleDeclarationList +=
      ![mNonterminalName string]
      !newRuleIndex
      !ruleLabelImplementationList
    ;
    newRuleIndex ++ ;
  end foreach ;
#---
  outSyntaxDeclarationForGeneration := [@syntaxDeclarationForGeneration new
    !inComponentName
    !inLexiqueName
    !nonterminalMap
    !ruleDeclarationList
    !selectMethodCount
    !inHasIndexing
    !inHasTranslateFeature
  ] ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
