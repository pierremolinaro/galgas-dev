#---------------------------------------------------------------------------*
#                                                                           *
#  metamodel that defines expression                                        *
#                                                                           *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticAnalysis :
  import "semanticInstructionsAnalysis.gSemantics" ;
  import semantics semanticInstructionsAnalysis in "semanticInstructionsAnalysis.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    C H E C K    M E T H O D    S I G N A T U R E                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkMethodSignatures
  ??@formalParameterListForGeneration inTestedSignature
  ??@location inErrorLocation
  ??@formalParameterSignature inReferenceSignature
  ??@location inReferenceLocation
:
  if [inTestedSignature length] != [inReferenceSignature length] then
    error inErrorLocation:"this method declares " . [[inTestedSignature length] string]
    . " formal parameter(s), but overriden method declares " . [[inReferenceSignature length] string]
    ;
    error inReferenceLocation:"overriden method is declared here" ;
  else
    foreach inReferenceSignature prefixedby ref_, inTestedSignature do
      if ref_mFormalParameterPassingMode != mFormalParameterPassingMode then
        error mFormalParameterName : "the '" . mFormalParameterName . "' formal parameter is declared as "
        . [mFormalParameterPassingMode formalArgumentMessage] . ", but overriden method declares it as " 
        . [ref_mFormalParameterPassingMode formalArgumentMessage] ;
        error inReferenceLocation:"overriden method is declared here" ;
      end if ;
      if [[mFormalParameterType key] string] != [ref_mParameterType keyString] then
        error mFormalParameterName : "the '" . mFormalParameterName . "' formal parameter has the '@"
        . [mFormalParameterType key] . "' type, but overriden method declares with the '@" 
        . [ref_mParameterType keyString] . "' type" ;
        error inReferenceLocation:"overriden method is declared here" ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    D E C L A R A T I O N    S E M A N T I C    A N A L Y S I S            *
#                                                                           *
#---------------------------------------------------------------------------*

method @semanticDeclarationAST performSemanticAnalysis
  ??@semanticContext unused inSemanticContext
  ?!@semanticDeclarationListForGeneration unused ioSemanticDeclarationListForGeneration
:
end method ;

#---------------------------------------------------------------------------*

override method @predefinedTypeAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
  ioSemanticDeclarationListForGeneration += ![@primitiveTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !mPredefinedTypeName !here]]
  ] ;

end method ;

#---------------------------------------------------------------------------*

map @attributeIndexMap {
  @uint mIndex ;
  insert insertKey error message "the '%K' attribute is already declared" ;
  search searchKey error message "the '%K' attribute is not declared" ;
}

#---------------------------------------------------------------------------*

override method @listDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeIndexMap [emptyMap] ;
  foreach mAttributeList do
    typedAttributeList +=
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName]
      !mAttributeName
    ;
    [!?attributeIndexMap insertKey !mAttributeName ![attributeIndexMap count]] ;
  end foreach ;
  ioSemanticDeclarationListForGeneration += ![@listTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mListTypeName]
    !typedAttributeList
  ] ;

end method ;

#---------------------------------------------------------------------------*

override method @sortedListDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Attribute
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeIndexMap [emptyMap] ;
  foreach mAttributeList do
    typedAttributeList +=
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName]
      !mAttributeName
    ;
    [!?attributeIndexMap insertKey !mAttributeName ![attributeIndexMap count]] ;
  end foreach ;
#--- Sort descriptor
  @stringset attributesUsedForSorting [emptySet] ;
  @sortDescriptorListForGeneration sortDescriptorList [emptyList] ;
  foreach mSortDescriptorList do
    @uint attributeIndex ;
    [attributeIndexMap searchKey !mSortedAttributeName ?attributeIndex] ;
    sortDescriptorList += !attributeIndex !mAscending ;
    if [attributesUsedForSorting hasKey ![mSortedAttributeName string]] then
      error mSortedAttributeName : "the '" . mSortedAttributeName . "' is already used for sorting" ;
    end if ;
    attributesUsedForSorting += ![mSortedAttributeName string] ;
  end foreach ;
#--- Generate type
  ioSemanticDeclarationListForGeneration += ![@sortedListTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mSortedListTypeName]
    !typedAttributeList
    !sortDescriptorList
  ] ;

end method ;

#---------------------------------------------------------------------------*

override method @structDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeIndexMap [emptyMap] ;
  foreach mAttributeList do
    typedAttributeList +=
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName]
      !mAttributeName
    ;
    [!?attributeIndexMap insertKey !mAttributeName ![attributeIndexMap count]] ;
  end foreach ;
  ioSemanticDeclarationListForGeneration += ![@structTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mStructTypeName]
    !typedAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

map @constantIndexMap {
  @uint mIndex ;
  insert insertKey error message "the '%K' constant is already declared" ;
  search searchKey error message "the '%K' constant is not declared" ;
}

#---------------------------------------------------------------------------*

override method @enumDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Constant list
  @stringlist constantList [emptyList] ;
  @constantIndexMap constantMap [emptyMap] ;
  foreach mConstantList do
    constantList += ![mValue string] ;
    [!?constantMap insertKey !mValue ![constantMap count]] ;
  end foreach ;
  const @stringset constantSet := [constantMap allKeys] ;
#--- Messages
  @enumMessageListForGeneration enumMessageList [emptyList] ;
  @stringset messageNameSet [emptySet] ;
  foreach mEnumMessageList do
    if [messageNameSet hasKey ![mEnumMessageName string]] then
      error mEnumMessageName : "this message is already declared for this enum type" ;
    end if ;
    messageNameSet += ![mEnumMessageName string] ;
    @enumMessageAssociationSortedListForGeneration enumMessageAssociationSortedListForGeneration [emptySortedList] ;
    @stringset usedConstantSet [emptySet] ; # For checking no constant is missed
    foreach mMessageAssociationList do
      @uint constantIndex ;
      [constantMap searchKey !mConstantName ?constantIndex] ;
      usedConstantSet += ![mConstantName string] ;
      enumMessageAssociationSortedListForGeneration +=
        !constantIndex
        ![mConstantName string]
        ![mMessage string]
      ;
    end foreach ;
    const @stringset missedConstantSet := constantSet - usedConstantSet ;
    foreach missedConstantSet do
      error mEnumMessageName : "the '" . mEnumMessageName . "' message definition does not name the '"
        . key . "' constant" ;
    end foreach ;
    enumMessageList += ![mEnumMessageName string] !enumMessageAssociationSortedListForGeneration ;
  end foreach ;
#---
  ioSemanticDeclarationListForGeneration += ![@enumTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mEnumTypeName]
    !constantList
    !enumMessageList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @listmapDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Check associated list is actually a list
  @typeKindEnum typeKindEnum ;
  @typedAttributeList listTypeAttributeList ;
  [inSemanticContext->mTypeMap searchKey !mAssociatedListTypeName ?2* ?typeKindEnum ?listTypeAttributeList ?15*] ;
#---
  ioSemanticDeclarationListForGeneration += ![@listmapTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mListmapTypeName]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAssociatedListTypeName]
    !listTypeAttributeList
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @genericTypeTypeAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
  ioSemanticDeclarationListForGeneration += ![@genericTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !mTypeName !here]]
  ] ;
end method ;

#---------------------------------------------------------------------------*

map @insertMethodMap {
  insert insertKey error message "the '%K' insert modifier is already declared" ;
}

#---------------------------------------------------------------------------*

map @searchMethodMap {
  insert insertKey error message "the '%K' search method is already declared" ;
}

#---------------------------------------------------------------------------*

override method @mapDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
#------ Enter attributes
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeIndexMap [emptyMap] ;
  foreach mAttributeList do
    typedAttributeList +=
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName]
      !mAttributeName
    ;
    [!?attributeIndexMap insertKey !mAttributeName ![attributeIndexMap count]] ;
  end foreach ;
#--- Enter insert modifiers
  @insertMethodMap insertMethodMap [emptyMap] ;
  foreach mInsertMethodList do
    [!?insertMethodMap insertKey !mMethodName] ;
  #--- Check error message escape sequences : only %K, %L or %%
    foreach [mErrorMessage componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if (c != 'K') & (c != 'L') then
            error mErrorMessage: "only '%K', '%L' and '%%' escape sequences are allowed in an insert error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  #--- Check shadow error message escape sequences : only %K, %L or %%
    foreach [mShadowErrorMessage componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if (c != 'K') & (c != 'L') then
            error mErrorMessage: "only '%K', '%L' and '%%' escape sequences are allowed in a shadow error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Enter search methods
  @searchMethodMap searchMethodMap [emptyMap] ;
  foreach mSearchMethodList do
    [!?searchMethodMap insertKey !mMethodName] ;
  #--- Check error message escape sequences : only %K or %%
    foreach [mErrorMessage componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if c != 'K' then
            error mErrorMessage: "only '%K' and '%%' escape sequences are allowed in a search error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Enter remove methods
  foreach mRemoveMethodList do
    [!?insertMethodMap insertKey !mMethodName] ;
  #--- Check error message escape sequences : only %K or %%
    foreach [mErrorMessage componentsSeparatedByString !"%%"] do
      @stringlist explodedArray := [mValue componentsSeparatedByString !"%"] ;
      [!?explodedArray popFirst ?*] ;
      foreach explodedArray do
        if [mValue length] > 0 then
          const @char c := [mValue characterAtIndex !0] ;
          if c != 'K' then
            error mErrorMessage: "only '%K' and '%%' escape sequences are allowed in a remove error message" ;
          end if ;
        end if ;
      end foreach ;
    end foreach ;
  end foreach ;
#--- Warn for duplicated declarations or 'insertOrReplace' modifier
  foreach mInsertOrReplaceDeclarationListAST index IDX do
    if IDX > 0 then
      warning mInsertOrReplaceDeclarationLocation: "the 'insertOrReplace' modifier is already declared" ;
    end if ;
  end foreach ;
  const @bool hasInsertOrReplaceModifier := [mInsertOrReplaceDeclarationListAST length] > 0 ;
  if hasInsertOrReplaceModifier & [insertMethodMap hasKey !"insertOrReplace"] then
    @location insertOrReplaceDeclarationLocation ;
    [mInsertOrReplaceDeclarationListAST first ?insertOrReplaceDeclarationLocation] ;
    error insertOrReplaceDeclarationLocation : "the insertOrReplace' modifier cannot be declared : an insert modifier or a remove modifier has been declared with this name" ;
  end if ;
#--- Enter map declaration
  ioSemanticDeclarationListForGeneration += ![@mapTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mMapTypeName]
    !mMapTypeName
    !typedAttributeList
    !mInsertMethodList
    !mSearchMethodList
    !mRemoveMethodList
    !hasInsertOrReplaceModifier
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @mapProxyDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
#--- Get attribute list of associated map
  @typedAttributeList listTypeAttributeList ;
  @mapMethodListAST searchMethodList ;
  [inSemanticContext->mTypeMap searchKey !mAssociatedMapTypeName ?4* ?listTypeAttributeList ?12* ?searchMethodList ?*] ;
#---
  ioSemanticDeclarationListForGeneration += ![@mapProxyTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mMapProxyTypeName]
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAssociatedMapTypeName]
    !listTypeAttributeList
    !searchMethodList
  ] ;
end method ;

#---------------------------------------------------------------------------*

map @declaredMethodMap { # This map is used for checking a method is declared once within a class
  insert insertKey error message "the '%K' method is already declared in %L for this class" ;
}

#---------------------------------------------------------------------------*

override method @classDeclarationAST performSemanticAnalysis
  ??@semanticContext inSemanticContext
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
:
#------ Super type
  @unifiedTypeMapProxy superClassProxy ;
  if [mSuperClassName string] == "" then
    superClassProxy := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap ![@lstring new !"class" !here]] ;
  else
    superClassProxy := [@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mSuperClassName] ;
  end if ;
#------ Enter attributes
  @typedAttributeList allAttributeList := [superClassProxy mInheritedTypedAttributeList] ;
  @typedAttributeList typedAttributeList [emptyList] ;
  @attributeIndexMap attributeIndexMap [emptyMap] ;
  foreach mAttributeList do
    typedAttributeList +=
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName]
      !mAttributeName
    ;
    allAttributeList +=
      ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mAttributeTypeName]
      !mAttributeName
    ;
    [!?attributeIndexMap insertKey !mAttributeName ![attributeIndexMap count]] ;
  end foreach ;
#------ Check a method is defined once within class
  @declaredMethodMap classMethodMap [emptyMap] ;
  foreach mAbstractMethodList do
   [!?classMethodMap insertKey !mMethodName] ;
  end foreach ;
  foreach mMethodList do
   [!?classMethodMap insertKey !mMethodName] ;
  end foreach ;
#------ Inherited instance methods
  @instanceMethodMap inheritedInstanceMethodMap := [superClassProxy mInstanceMethodMap] ;
#------ Abstract methods
  @abstractMethodDefinitionListForGeneration abstractMethodList [emptyList] ;
  foreach mAbstractMethodList do
  #--- Check a concrete class does not declare an abstract method
    if not mIsAbstract then
      error mMethodName : "a concrete class cannot declare an abstract method" ;
    end if ;
  #--- Compute method signature
    @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
    foreach mSignature do
      formalParameterListForGeneration +=
        !mFormalParameterPassingMode
        ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalParameterTypeName]
        !mFormalParameterName
        !mIsUnused
      ;
    end foreach ;
  #--- Check overriding status
    if mIsOverriding then
      @formalParameterSignature inheritedSignature ;
      @location inheritedDeclarationLocation ;
      [inheritedInstanceMethodMap searchInheritedKey !mMethodName ?inheritedSignature ?inheritedDeclarationLocation ?2*] ;
      checkMethodSignatures
        !formalParameterListForGeneration
        ![mMethodName location]
        !inheritedSignature
        !inheritedDeclarationLocation
      ;
    elsif [inheritedInstanceMethodMap hasKey ![mMethodName string]] then
      error mMethodName : "this method cannot be declared as abstract, it is already declared in super class" ;
    end if ;
    abstractMethodList += !mIsOverriding !mMethodName !formalParameterListForGeneration ;
  end foreach ;
#------ Methods
  @methodDefinitionListForGeneration methodList [emptyList] ;
  @stringset definedMethodSet [emptySet] ;
  foreach mMethodList do
  #--- Compute method signature
    @formalParameterListForGeneration formalParameterListForGeneration [emptyList] ;
    foreach mSignature do
      formalParameterListForGeneration +=
        !mFormalParameterPassingMode
        ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalParameterTypeName]
        !mFormalParameterName
        !mIsUnused
      ;
    end foreach ;
  #--- Check overriding status
    if mIsOverriding then
      @formalParameterSignature inheritedSignature ;
      @location inheritedDeclarationLocation ;
      [inheritedInstanceMethodMap searchInheritedKey !mMethodName ?inheritedSignature ?inheritedDeclarationLocation ?2*] ;
      checkMethodSignatures
        !formalParameterListForGeneration
        ![mMethodName location]
        !inheritedSignature
        !inheritedDeclarationLocation
      ;
    elsif [inheritedInstanceMethodMap hasKey ![mMethodName string]] then
      error mMethodName : "this method should be declared as overridding, as it is already declared in super class" ;
    end if ;
  #--- Insert formal parameters in variable map
    @variableMap variableMap [emptyMap] ;
    foreach mSignature do
      [!?variableMap insertKey !mFormalParameterName ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mFormalParameterTypeName] !"prefixe_"] ;
    end foreach ;
  #---  Analyze instruction list
    @semanticInstructionListForGeneration semanticInstructionListForGeneration [emptyList] ;
    foreach mInstructionList do
      [mInstruction analyzeSemanticInstruction
        !inSemanticContext
        !?semanticInstructionListForGeneration
        !?variableMap
      ] ;
    end foreach ;
  #---
    definedMethodSet += ![mMethodName string] ;
    methodList +=
      !mIsOverriding
      !mMethodName
      !formalParameterListForGeneration
      !semanticInstructionListForGeneration
    ;
  end foreach ;
#------ Check a concrete class has no abstract method
  if not mIsAbstract then
    foreach inheritedInstanceMethodMap do
      if (mQualifier == [@readerQualifier isAbstract]) | (mQualifier == [@readerQualifier isOverridingAbstract]) then
        if not [definedMethodSet hasKey ![key string]] then
          error key : "the '@" . mClassTypeName . "' class is declared concrete, but the '" . key . "' method declared in a super class is not implemented" ;
        end if ;    
      end if ;
    end foreach ;
  end if ;
#------
  ioSemanticDeclarationListForGeneration += ![@classTypeForGeneration new
    ![@unifiedTypeMapProxy searchKey !inSemanticContext->mTypeMap !mClassTypeName]
    !mIsAbstract
    !mClassTypeName
    !superClassProxy
    !allAttributeList
    !typedAttributeList
    !abstractMethodList
    !methodList
  ] ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#    P E R F O R M     S E M A N T I C     A N A L Y S I S                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine performSemanticAnalysis
  ??@semanticDeclarationListAST inDeclarationList
  ??@semanticContext inSemanticContext
  !@semanticDeclarationListForGeneration outDecoratedDeclarationListForGeneration
:
  outDecoratedDeclarationListForGeneration := [@semanticDeclarationListForGeneration emptyList] ;
  
  foreach inDeclarationList do
    [mSemanticDeclaration performSemanticAnalysis
      !inSemanticContext
      !?outDecoratedDeclarationListForGeneration
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
