#---------------------------------------------------------------------------*
#                                                                           *
#  Grammar component compilation                                            *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics grammarCompilation :
import "grammarMetamodel.gSemantics" ;
import "galgas_cli_options.gOption" ;
import "buildPureBNFproductions.gSemantics" ;


import semantics grammarMetamodel in "grammarMetamodel.gSemantics" ;
import semantics buildPureBNFproductions in "buildPureBNFproductions.gSemantics" ;
import grammar grammarLL1grammar in "grammarLL1grammar.gGrammar" ;
import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;
import option galgas_cli_options in "galgas_cli_options.gOption" ;

#---------------------------------------------------------------------------*
#                                                                           *
#  N O N    T E R M I N A L   M A P                                         *
#                                                                           *
#---------------------------------------------------------------------------*

map @nonTerminalMap {
  @nonTerminalLabelList mLabels ;
  @bool mHasParseLabel ;
  insert insertKey error message "the '@%K' non terminal has been already declared in %L" ;
  search searchKey error message "the '@%K' non terminal is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# V O C A B U L A R Y   M A P                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @vocabularyMap {
  @uint mIndex ;
  insert insertKey error message "the '@%K' symbol has been already declared in %L" ;
  search searchKey error message "the '@%K' symbol is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# P R O D U C T I O N   L I S T    M A P                                    *
#                                                                           *
#---------------------------------------------------------------------------*

list @derivationList {
  @uint64list mDerivation ;
}

#---------------------------------------------------------------------------*

listmap @productionListMap (@derivationList) ;

#---------------------------------------------------------------------------*

listmap @productionIndexListMap (@uintlist) ;

#---------------------------------------------------------------------------*
#                                                                           *
#  H A N D L E    N O N    T E R M I N A L   D E C L A R A T I O N S        *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleNonTerminalDeclarations
  ?!@nonTerminalMap ioNonTerminalMap
  ??@nonterminalDeclarationList inNonterminalDeclarationList
:
  foreach inNonterminalDeclarationList do
    if [ioNonTerminalMap hasKey ![mNonterminalName string]] then
      @nonTerminalLabelList labels ;
      @bool hasParseLabel ;
      [ioNonTerminalMap searchKey
        !mNonterminalName
        ?labels
        ?hasParseLabel
      ] ;
     #--- Compare 'parse' label
      if mHasParseLabel & not hasParseLabel then
        error mNonterminalName: "this declaration has a 'parse' label, but declaration of the same non terminal in " 
        . [[ioNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
        . " does not have a 'parse' label" ;
      elsif (not mHasParseLabel) &  hasParseLabel then
        error mNonterminalName: "this declaration has no 'parse' label, but declaration of the same non terminal in " 
        . [[ioNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
        . " has a 'parse' label" ;
      end if ;
    #--- Compare regular labels
      if [labels length] != [mLabels length] then
        error mNonterminalName: "this declaration names " 
          . [[mLabels length] string]
          . " labels, but declaration of the same non terminal in " 
          . [[ioNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
          . " names"
          . [[labels length] string]
          . " labels."
        ;
      else
        foreach mLabels, labels (@lstring labelName @formalParameterList formalParameters) do
          if [mLabelName string] != [labelName string] then
            error mLabelName: "this label should be identical to the label '"
            . labelName
            . "' declared in " 
            . [[labelName location] locationString]
            ;
          end if ;
          foreach mFormalParameters, formalParameters (@formalArgumentPassingMode formalParameterPassingMode
                                                       @lstring formalParameterTypeName
                                                       *
                                                       *) do
            
            if mFormalParameterPassingMode != formalParameterPassingMode then
              error mFormalParameterName: "the passing mode ("
              . [mFormalParameterPassingMode string]
              . ") for this parameter should be identical to the passing mode ("
              . [formalParameterPassingMode string]
              . ") of the parameter declared in"
              . [[labelName location] locationString]
              ;
            end if ;
            if [mFormalParameterTypeName string] != [formalParameterTypeName string] then
              error mFormalParameterTypeName: "this type name should be identical to the '@"
              . formalParameterTypeName
              . "' type name used in " 
              . [[formalParameterTypeName location] locationString]
              ;
            end if ;
          end foreach ;
        end foreach ;
      end if ;
    else
      [!?ioNonTerminalMap insertKey
        !mNonterminalName
        !mLabels
        !mHasParseLabel
      ] ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList unused ioSyntaxInstructionList
;

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    S Y N T A X    I N S T R U C T I O N    L I S T             *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildSyntaxInstructionList
  ??@syntaxInstructionList inInstructionList
  !@syntaxInstructionList outSyntaxInstructionList
:
  outSyntaxInstructionList := [@syntaxInstructionList emptyList] ;
  foreach inInstructionList do
    [mInstruction buildSyntaxInstructionList !?outSyntaxInstructionList] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

override method @semanticInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList unused ioSyntaxInstructionList
:
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  ioSyntaxInstructionList += !self ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  ioSyntaxInstructionList += !self ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @syntaxInstructionList repeatedInstructionList ;
  buildSyntaxInstructionList !mRepeatedInstructionList ?repeatedInstructionList ;
  @listOfSyntaxInstructionList repeatBranchList [emptyList] ;
  foreach mRepeatBranchList do
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !mSyntaxInstructionList ?syntaxInstructionList ;
    repeatBranchList += !syntaxInstructionList ;
  end foreach ;
  @repeatInstruction ri [new
    !mRepeatInstructionLocation
    !repeatedInstructionList
    !repeatBranchList
  ] ;
  ioSyntaxInstructionList += !ri ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @listOfSyntaxInstructionList selectBranchList [emptyList] ;
  foreach mSelectBranchList do
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !mSyntaxInstructionList ?syntaxInstructionList ;
    selectBranchList += !syntaxInstructionList ;
  end foreach ;
  @selectInstruction si [new
    !mSelectInstructionLocation
    !selectBranchList
  ] ;
  ioSyntaxInstructionList += !si ;
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @syntaxInstructionList instructionList ;
  [mParseDoBranchList first ?instructionList] ;
  foreach instructionList do
    [mInstruction buildSyntaxInstructionList !?ioSyntaxInstructionList] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  foreach mInstructionList do
    [mInstruction buildSyntaxInstructionList !?ioSyntaxInstructionList] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

abstract reader @syntaxInstruction htmlListing
  -> @string outListing
;

#---------------------------------------------------------------------------*

override reader @semanticInstruction htmlListing
  -> @string outListing
:
  outListing := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @nonterminalCallInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_nonterminal\">&lt;" . mNonterminalName . "&gt;</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @terminalCheckInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_terminal\">$" . [mTerminalName HTMLRepresentation] . "$</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @repeatInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_structure\">"
  . "<span class=\"galgas_keyword\">repeat</span>"
  . "<span class=\"within_galgas_structure\">" ;
  foreach mRepeatedInstructionList do
    outListing .= [mInstruction htmlListing] ;
  end foreach ;
  outListing .= "</span>" ;
  foreach mRepeatBranchList do
    outListing .= "<span class=\"galgas_keyword\">while</span>" ;
    outListing .= "<span class=\"within_galgas_structure\">" ;
    foreach mSyntaxInstructionList do
      outListing .= [mInstruction htmlListing] ;
    end foreach ;
    outListing .= "</span>" ;
  end foreach ;
  outListing .= "<span class=\"galgas_keyword\">end repeat</span>"
  . "</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @selectInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_structure\">"
  . "<span class=\"galgas_keyword\">select</span>" ;
  foreach mSelectBranchList
  do
    outListing .= "<span class=\"within_galgas_structure\">" ;
    foreach mSyntaxInstructionList do
      outListing .= [mInstruction htmlListing] ;
    end foreach ;
    outListing .= "</span>" ;
  between 
   outListing .= "<span class=\"galgas_keyword\">or</span>" ;
  end foreach ;
  outListing .= "<span class=\"galgas_keyword\">end select</span>"
  . "</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @parseDoInstruction htmlListing
  -> @string outListing
:
  outListing := "[Parse do]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @blockInstruction htmlListing
  -> @string outListing
:
  outListing := "[block]" ;
end reader ;

#---------------------------------------------------------------------------*
#                 enterTerminalSymbolIntoVocabulary                         *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
;

#---------------------------------------------------------------------------*

override method @semanticInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap ioVocabularyMap
  ?!@stringlist ioVocabularyListForDisplaying
:
  if not [ioVocabularyMap hasKey ![mTerminalName string]] then
    [!?ioVocabularyMap insertKey !mTerminalName ![ioVocabularyMap count]] ;
    ioVocabularyListForDisplaying += !"$" . mTerminalName . "$" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*
#               enterNonTerminalSymbolIntoVocabulary                        *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
;

#---------------------------------------------------------------------------*

override method @semanticInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap ioNonTerminalMap
  ??@vocabularyMap inTerminalMap
  ?!@uint64list ioRightDerivation
  ?!@stringlist ioVocabularyListForDisplaying
:
  if not [ioNonTerminalMap hasKey ![mNonterminalName string]] then
    [!?ioNonTerminalMap insertKey !mNonterminalName ![ioNonTerminalMap count] + [inTerminalMap count]] ;
    ioVocabularyListForDisplaying += !"<" . mNonterminalName . ">" ;
  end if ;
  @uint nonterminalIndex ;
  [ioNonTerminalMap searchKey !mNonterminalName ?nonterminalIndex] ;
  ioRightDerivation += ![nonterminalIndex uint64] ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap inTerminalMap
  ?!@uint64list ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
  @uint terminalIndex ;
  [inTerminalMap searchKey !mTerminalName ?terminalIndex] ;
  ioRightDerivation += ![terminalIndex uint64] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#  G E N E R A T I O N    F I L E W R A P P E R S                           *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper grammarGenerationTemplates in "../generation_templates/grammar_generation" {
} {
  template html "grammar.html.gTemplate"
    ?@string GRAMMAR_NAME
    ?@syntaxRuleListForGrammar SYNTAX_RULE_LIST
    ?@syntaxRuleListForGrammar PURE_SYNTAX_RULE_LIST
    ?@vocabularyMap TERMINAL_MAP
    ?@vocabularyMap NON_TERMINAL_MAP
    ?@uint BIT_COUNT_FOR_BDDS
    ?@stringlist IDENTICAL_DERIVATION_ERROR_MESSAGE_LIST
    ?@stringlist USELESS_NON_TERMINAL_SYMBOL_LIST
  ;
  template optionHeaderZone2 "grammar-zone2.h.gTemplate"
    ?@string GRAMMAR_NAME
    ?@grammarComponentRoot GRAMMAR_COMPONENT_ROOT
  ;
  template optionHeaderZone3 "grammar-zone3.h.gTemplate"
    ?@string GRAMMAR_NAME
    ?@grammarComponentRoot GRAMMAR_COMPONENT_ROOT
    ?@nonTerminalMap NON_TERMINAL_MAP
    ?@string LEXIQUE_CLASS
    ?@stringlist ADDED_NON_TERMINAL_LIST
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    R U L E    L I S T                                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildRuleList
  ??@string inSyntaxComponentName
  ??@syntaxRuleList inRuleList
  ?!@syntaxRuleListForGrammar ioSyntaxRuleListForGrammar
:
  foreach inRuleList do
  #--- We get only the first label (all syntax signatures are the same)
    @syntaxInstructionList instructionList ;
    [mLabelList first ?* ?* ?instructionList] ;
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !instructionList ?syntaxInstructionList ;
    ioSyntaxRuleListForGrammar += !inSyntaxComponentName !mNonterminalName !syntaxInstructionList ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine compileGrammarComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  @grammarComponentRoot grammarComponentRoot ;
  grammar grammarLL1grammar in inSourceFile ?grammarComponentRoot ;
#---------------------------------------------------------- Check component name
  @lstring componentName := [grammarComponentRoot mGrammarName] ;
  @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ;
#---------------------------------------------------------- Parse syntax components
  @nonTerminalMap nonTerminalMap [emptyMap] ;
  @string lexiqueComponent := "" ; # Empty string means unknown
  @syntaxRuleListForGrammar syntaxRuleListForGrammar [emptyList] ;
  foreach [grammarComponentRoot mSyntaxComponents] do
    if [mValue pathExtension] != "gSyntax" then
      error mValue: "a syntax component file should have '.gSyntax' as path extension" ;
    else
      @string syntaxComponentName := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
      @syntaxComponentRoot syntaxComponentRoot ;
      if [[ioParsedComponentStruct mParsedSyntaxComponentMap] hasKey !syntaxComponentName] then
        [[ioParsedComponentStruct mParsedSyntaxComponentMap] searchKey ![@lstring new !syntaxComponentName !here] ?syntaxComponentRoot] ;
      else
        @string sourceFilePath := [mValue absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]] ;
        grammar syntaxSLRgrammar in [@lstring new !sourceFilePath ![mValue location]] ?syntaxComponentRoot ;
        [!?ioParsedComponentStruct.mParsedSyntaxComponentMap insertKey ![@lstring new !syntaxComponentName ![mValue location]] !syntaxComponentRoot] ;
      end if ;
    #--- Handle lexique component
      @string currentLexiqueName := [[[syntaxComponentRoot mImportedLexiqueReference] lastPathComponent] stringByDeletingPathExtension] ;
      if lexiqueComponent == "" then
        lexiqueComponent := currentLexiqueName ;
      elsif lexiqueComponent != currentLexiqueName then
        error mValue : "this syntax component uses '"
          . currentLexiqueName . "' lexique component, but the first syntax component uses the '"
          . lexiqueComponent . "' lexique component (they should be the same)" ;
      end if ;
    #--- Handle non terminal declarations
      handleNonTerminalDeclarations
        !?nonTerminalMap
        ![syntaxComponentRoot mNonterminalDeclarationList]
      ;
    #--- Handle syntax rules
      buildRuleList
        !syntaxComponentName
        ![syntaxComponentRoot mRuleList]
        !?syntaxRuleListForGrammar
      ;
    end if ;
  end foreach ;
#---------------------------------------------------------- Symbols declared unused
  foreach [grammarComponentRoot mUnusedNonterminalList] do
    if not [nonTerminalMap hasKey ![mValue string]] then
      error mValue : "the '<" . mValue . ">' non terminal is not declared by syntax components" ;
    end if ;
  end foreach ;
#---------------------------------------------------------- Build pure BNF productions
  @syntaxRuleListForGrammar pureSyntaxRuleListForGrammar [emptyList] ;
  @syntaxRuleListForGrammar addedPureSyntaxRuleListForGrammar [emptyList] ;
  @stringlist addedNonTerminalList [emptyList] ;
  @string currentSyntaxComponentName := "" ;
  @uint addedRuleIndex := 0 ;
  foreach syntaxRuleListForGrammar do
    if currentSyntaxComponentName != mSyntaxComponentName then
      currentSyntaxComponentName := mSyntaxComponentName  ;
      addedRuleIndex := 0 ;
    end if ;
    @syntaxInstructionList pureSyntaxInstructionList ;
    buildPureSyntaxInstructionList
      !mSyntaxComponentName
      !mSyntaxInstructionList
      ?pureSyntaxInstructionList
      !?addedPureSyntaxRuleListForGrammar
      !?addedNonTerminalList
      !?addedRuleIndex
    ;
    pureSyntaxRuleListForGrammar +=
      !mSyntaxComponentName
      !mLeftNonTerminal
      !pureSyntaxInstructionList
    ;
  end foreach ;
#--- Append added production
  pureSyntaxRuleListForGrammar .= addedPureSyntaxRuleListForGrammar ;
#--- Append production for root symbol <>
  @lstring addedRootNonTerminal [new !"" !here] ;
  pureSyntaxRuleListForGrammar +=
    !""
    !addedRootNonTerminal
    ![@syntaxInstructionList listWithValue ![@nonterminalCallInstruction new
      ![grammarComponentRoot mStartSymbol]
      ![@lstring new !"" !here] # no Label
      ![@actualParameterList emptyList]
     ]]
  ;
  if [option .verbose_output] then
    message "  Building pure BNF productions... " . [[pureSyntaxRuleListForGrammar length] string] . " productions\n" ;
  end if ;  
#---------------------------------------------------------- Build Vocabulary...
#                                                   ... and  production list map
  if [option .verbose_output] then
    message "  Checking all productions are differents..." ;
  end if ;  
  @string htmlOutputFileName := [inSourceFile stringByDeletingPathExtension] . ".html" ;
  @productionListMap productionListMap [emptyMap] ;
  @productionIndexListMap productionIndexListMap [emptyMap] ;
  @stringlist identicalDerivationErrorMessageList [emptyList] ;
  @stringlist vocabularyListForDisplaying [emptyList] ;
#--- Enter terminal symbols
  @vocabularyMap terminalMap [emptyMap] ;
  foreach pureSyntaxRuleListForGrammar do
    foreach mSyntaxInstructionList do
      [mInstruction enterTerminalSymbolIntoVocabulary !?terminalMap !?vocabularyListForDisplaying] ;
    end foreach ;
  end foreach ;
  @uint terminalSymbolCount := [terminalMap count] ;
#--- Enter non terminal symbols
  @vocabularyMap nonterminalMap [emptyMap] ;
  foreach pureSyntaxRuleListForGrammar :idx do
    if not [nonterminalMap hasKey ![mLeftNonTerminal string]] then
      [!?nonterminalMap insertKey !mLeftNonTerminal ![terminalMap count] + [nonterminalMap count]] ;
      vocabularyListForDisplaying += !"<" . mLeftNonTerminal . ">" ;
    end if ;
    @uint64list rightDerivation [emptyList] ;
    foreach mSyntaxInstructionList do
      [mInstruction enterNonTerminalSymbolIntoVocabulary !?nonterminalMap !terminalMap !?rightDerivation !?vocabularyListForDisplaying] ;
    end foreach ;
  #--- Check production is dictinct from previous ones
    @derivationList previousDerivations := [productionListMap listForKey ![mLeftNonTerminal string]] ;
    @uintlist previousDerivationsIndexes := [productionIndexListMap listForKey ![mLeftNonTerminal string]] ;
    @bool ok := true ;
    foreach previousDerivations, previousDerivationsIndexes while ok do
      if mDerivation == rightDerivation then
        ok := false ;
        if [option .verbose_output] & ([identicalDerivationErrorMessageList length] == 0) then
          message " error\n" ;
        end if ;  
        @string errorMessage := "for <"
        . mLeftNonTerminal
        . "> non terminal, productions "
        . [mValue string]
        . " and " . [idx string] . " are identical" ;
        identicalDerivationErrorMessageList += !errorMessage ;
        if [option galgas_cli_options.outputHTMLgrammarFile] then
          errorMessage .= " (for details, see " . htmlOutputFileName . " file)" ;
        else
          errorMessage .= " (for details, turn on '--output-html-grammar-file' option and see " . htmlOutputFileName . " file)" ;
        end if ;
        error mLeftNonTerminal:errorMessage ;
      end if ;
    end foreach ;
    if ok then
      productionListMap += ![mLeftNonTerminal string] !rightDerivation ;
      productionIndexListMap += ![mLeftNonTerminal string] !idx ;
    end if ;
  end foreach ;
  const @uint terminalCount := [terminalMap count] ;
  const @uint vocabularyCount := terminalCount + [nonterminalMap count] ;
  const @uint bitCountForBDDs := [vocabularyCount significantBitCount] ;
  if [option .verbose_output] & ([identicalDerivationErrorMessageList length] == 0) then
    message " ok\n" ;
  end if ;  
#---------------------------------------------------------- Computing useful vocabulary
  if [option .verbose_output] then
    message "  Checking all non terminal symbols are useful..." ;
  end if ;  
  @binaryset elementaryUtility [emptyBinarySet] ;
  foreach productionListMap do
    @binaryset derivation [emptyBinarySet] ;
    foreach object do
      foreach mDerivation do
        derivation := derivation | [@binaryset binarySetWithEqualToConstant !bitCountForBDDs !bitCountForBDDs !mValue] ;
      end foreach ;
    end foreach ;
    @uint nonterminalIndex ;
    [nonterminalMap searchKey ![@lstring new !key !here] ?nonterminalIndex] ;
    derivation := derivation & [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs ![nonterminalIndex uint64]] ;
    elementaryUtility := elementaryUtility | derivation ;
  end foreach ;
#--- Computing transitive closure
  const @binaryset startSymbol [binarySetWithEqualToConstant !0 !bitCountForBDDs ![vocabularyCount - 1 uint64]] ;
  const @binaryset usefulSymbols := [elementaryUtility accessibleStates !startSymbol !bitCountForBDDs] ;
#--- Compute and display useless symbols
  const @binaryset allSymbols [binarySetWithLowerOrEqualToConstant !0 !bitCountForBDDs ![vocabularyCount - 1 uint64]] ;
  const @binaryset unusefulSymbols := allSymbols & ~ usefulSymbols ;
  @binaryset unusefulNonTerminals := unusefulSymbols & [@binaryset binarySetWithGreaterOrEqualToConstant !0 !bitCountForBDDs ![terminalCount uint64]] ;
  foreach [grammarComponentRoot mUnusedNonterminalList] do
    @uint nonTerminalSymbolIndex ;
    [nonterminalMap searchKey !mValue ?nonTerminalSymbolIndex] ;
    unusefulNonTerminals := unusefulNonTerminals & ~ [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs ![nonTerminalSymbolIndex uint64]] ;
  end foreach ;
  const @stringlist unusefulNonTerminalList := [unusefulNonTerminals stringValueListWithNameList !bitCountForBDDs !vocabularyListForDisplaying] ;
  if [option .verbose_output] then
    message if [unusefulNonTerminalList length] == 0 then " ok\n" else " warning\n" end ;
  end if ;
  if [unusefulNonTerminalList length] > 0 then
    @string errorMessage := "the grammar contains "
    . [[unusefulNonTerminalList length] string]
    . " useless symbol" . if [unusefulNonTerminalList length] > 1 then "s" else "" end . ": " ;
    foreach unusefulNonTerminalList
    do errorMessage .= mValue ;
    between errorMessage .= ", " ;
    end foreach ;
    warning here: errorMessage ;
  end if ;
#---------------------------------------------------------- Check nonterminal symbols declared as useless are actually useless
  foreach [grammarComponentRoot mUnusedNonterminalList] do
    @uint nonTerminalSymbolIndex ;
    [nonterminalMap searchKey !mValue ?nonTerminalSymbolIndex] ;
    if [usefulSymbols containsValue ![nonTerminalSymbolIndex uint64] !0 !bitCountForBDDs] then
      warning mValue : "the '<" . mValue . ">' non terminal is declared as unused, but it is actually useful" ;
    end if ;
  end foreach ;
#---------------------------------------------------------- Build HTML file
  if [option galgas_cli_options.outputHTMLgrammarFile] then
    @string s := [filewrapper grammarGenerationTemplates.html
      ![componentName string]
      !syntaxRuleListForGrammar
      !pureSyntaxRuleListForGrammar
      !terminalMap
      !nonterminalMap
      !bitCountForBDDs
      !identicalDerivationErrorMessageList
      !unusefulNonTerminalList
    ] ;
    [s writeToFileWhenDifferentContents !htmlOutputFileName ?*] ;
  else
    [@string deleteFileIfExists !htmlOutputFileName] ;
  end if ;
#---------------------------------------------------------- Generate Header file
  if [@uint errorCount] == 0 then
    [@string generateFile
      !inOutputDirectory
      ![componentName string] . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper grammarGenerationTemplates.optionHeaderZone2
        ![componentName string]
        !grammarComponentRoot
      ]
      !"\n\n" # Defaut user zone2
      ![filewrapper grammarGenerationTemplates.optionHeaderZone3
        ![componentName string]
        !grammarComponentRoot
        !nonTerminalMap
        !lexiqueComponent
        !addedNonTerminalList
      ]
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
