#---------------------------------------------------------------------------*
#                                                                           *
#  Grammar component compilation                                            *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics grammarCompilation :
import "allASTTypes.gSemantics" ;
import "grammarSemantics.gSemantics" ;
import "galgas_cli_options.gOption" ;

import semantics allASTTypes in "allASTTypes.gSemantics" ;
import semantics grammarSemantics in "grammarSemantics.gSemantics" ;
import grammar grammarLL1grammar in "grammarLL1grammar.gGrammar" ;
import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;
import option galgas_cli_options in "galgas_cli_options.gOption" ;

#---------------------------------------------------------------------------*

function transformLabelMap
  ??@nonTerminalLabelList inLabels
  ??@bool inHasParseLabel
  -> @nonterminalSymbolLabelMapForGrammarAnalysis outNonterminalSymbolLabelMapForGrammarAnalysis
:
  outNonterminalSymbolLabelMapForGrammarAnalysis := [@nonterminalSymbolLabelMapForGrammarAnalysis emptyMap] ;
  foreach inLabels do
    @signatureForGrammarAnalysis formalParametersList [emptyList] ;
    foreach mFormalParameters do
      formalParametersList += !mFormalParameterPassingMode !mFormalParameterTypeName ;
    end foreach ;
    [!?outNonterminalSymbolLabelMapForGrammarAnalysis insertKey
      !mLabelName
      !formalParametersList
    ] ;
  end foreach ;
  if inHasParseLabel then
    [!?outNonterminalSymbolLabelMapForGrammarAnalysis insertKey
      ![@lstring new !"parse" !here] # Label 'parse'
      ![@signatureForGrammarAnalysis emptyList]
    ] ;
  end if ;
end function ;


#---------------------------------------------------------------------------*

routine checkLabelMap
  ??@location inNonTerminalLocation
  ??@nonTerminalLabelList inLabels
  ??@bool inHasParseLabel
  ??@location inOriginalNonTerminalLocation
  ??@nonterminalSymbolLabelMapForGrammarAnalysis inNonterminalSymbolLabelMapForGrammarAnalysis
:
  @stringset labelStringSet [emptySet] ;
  foreach inLabels do
    labelStringSet += ![mLabelName string] ;
    @signatureForGrammarAnalysis formalParametersList ;
    [inNonterminalSymbolLabelMapForGrammarAnalysis searchKey !mLabelName ?formalParametersList] ;
    if [mFormalParameters length] != [formalParametersList length] then
      error mLabelName: [[mFormalParameters length] string]
        . " formal parameter"
        . if [mFormalParameters length] > 1 then "s" else "" end
        . " declared here, but declaration at "
        . [[inNonterminalSymbolLabelMapForGrammarAnalysis locationForKey ![mLabelName string]] locationString]
        . "names " . [[formalParametersList length] string] . "parameter"
        . if [formalParametersList length] > 1 then "s" else "" end ;
    else
      foreach mFormalParameters, formalParametersList do
        if mFormalArgumentPassingModeForGrammarAnalysis != mFormalParameterPassingMode then
          error mGalgasTypeNameForGrammarAnalysis :
            " this formal parameter is declared with "
          . [mFormalArgumentPassingModeForGrammarAnalysis formalArgumentString]
          . " passing mode, but declaration at "
          . [[inNonterminalSymbolLabelMapForGrammarAnalysis locationForKey ![mLabelName string]] locationString]
          . " is declared with " . [mFormalParameterPassingMode formalArgumentString] . " passing mode" ;
        end if ;
        if [mGalgasTypeNameForGrammarAnalysis string] != [mFormalParameterTypeName string] then
          error mGalgasTypeNameForGrammarAnalysis :
            " this formal parameter is declared of '@"
          . mGalgasTypeNameForGrammarAnalysis
          . "' type, but declaration at "
          . [[inNonterminalSymbolLabelMapForGrammarAnalysis locationForKey ![mLabelName string]] locationString]
          . " is declared with '@" . mFormalParameterTypeName . "' type" ;
        end if ;
      end foreach ;
    end if ;
  end foreach ;
  if inHasParseLabel then
    labelStringSet += !"parse" ;
    if not [inNonterminalSymbolLabelMapForGrammarAnalysis hasKey !"parse"] then
      error inNonTerminalLocation :
        "this non terminal is declared with 'parse' label, but declaration at "
          . [inOriginalNonTerminalLocation locationString]
          . " does not declare 'parse' label" ;
    end if ;
  end if ;
#---
  foreach inNonterminalSymbolLabelMapForGrammarAnalysis do
    if not [labelStringSet hasKey ![key string]] then
      error inNonTerminalLocation :
        "this non terminal does not declare the '" . key . "' label, but declaration at "
          . [inOriginalNonTerminalLocation locationString]
          . " does" ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine handleNonTerminalDeclarations
  ?!@nonTerminalSymbolMapForGrammarAnalysis ioNonTerminalMapForGrammarAnalysis
  ??@nonterminalDeclarationList inNonterminalDeclarationList
:
  foreach inNonterminalDeclarationList do
    with !?ioNonTerminalMapForGrammarAnalysis hasKey ![mNonterminalName string] do
      checkLabelMap
        ![mNonterminalName location]
        !mLabels
        !mHasParseLabel
        ![ioNonTerminalMapForGrammarAnalysis locationForKey ![mNonterminalName string]]
        !mNonterminalSymbolParametersMap
      ;
    else
      [!?ioNonTerminalMapForGrammarAnalysis insertKey
        !mNonterminalName
        ![ioNonTerminalMapForGrammarAnalysis count]
        !transformLabelMap [!mLabels !mHasParseLabel]
      ] ;
    end with ;  
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     transformInstructionList                              *
#---------------------------------------------------------------------------*

abstract method @syntaxInstructionAST transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
;

#---------------------------------------------------------------------------*

override method @semanticInstructionAST transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis unused ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis unused inNonTerminalSymbolMap
  ?!@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis unused ioSyntaxInstructionList
:
end method ;

#---------------------------------------------------------------------------*

routine transformInstructionList
  ??@syntaxInstructionList inInstructionList
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  foreach inInstructionList do
    [mInstruction transformInstruction
      !?ioActuallyUsedTerminalSymbolMap
      !inNonTerminalSymbolMap
      !?ioAddedNonTerminalIndex
      !?ioSyntaxInstructionList
   ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis unused inNonTerminalSymbolMap
  ?!@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  @uint terminalSymbolIndex ;
  with !?ioActuallyUsedTerminalSymbolMap hasKey ![mTerminalName string] do
    terminalSymbolIndex := mTerminalIndex ;
  else
    terminalSymbolIndex := [ioActuallyUsedTerminalSymbolMap count] ;
    [!?ioActuallyUsedTerminalSymbolMap insertKey !mTerminalName !terminalSymbolIndex] ;
  end with ;
  ioSyntaxInstructionList += ![@terminalInstructionForGrammarAnalysis new
    !mStartLocation
    !mTerminalName
    !terminalSymbolIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis unused ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  @uint nonTerminalSymbolIndex ;
  [inNonTerminalSymbolMap searchKey !mNonterminalName ?nonTerminalSymbolIndex ?*] ;
  ioSyntaxInstructionList += ![@nonTerminalInstructionForGrammarAnalysis new
    !mStartLocation
    !mNonterminalName
    !nonTerminalSymbolIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  const @uint addedNonTerminalIndex := ioAddedNonTerminalIndex ;
  ioAddedNonTerminalIndex ++ ;

  @syntaxInstructionListForGrammarAnalysis repeatedInstructionList [emptyList] ;
  transformInstructionList
    !mRepeatedInstructionList
    !?ioActuallyUsedTerminalSymbolMap
    !inNonTerminalSymbolMap
    !?ioAddedNonTerminalIndex
    !?repeatedInstructionList
  ;
  @branchListForGrammarAnalysis repeatBranchList [listWithValue !repeatedInstructionList] ;

  foreach mRepeatBranchList do
    @syntaxInstructionListForGrammarAnalysis syntaxInstructionList [emptyList] ;
    transformInstructionList
      !mSyntaxInstructionList
      !?ioActuallyUsedTerminalSymbolMap
      !inNonTerminalSymbolMap
      !?ioAddedNonTerminalIndex
      !?syntaxInstructionList
    ;
    repeatBranchList += !syntaxInstructionList ;
  end foreach ;

  ioSyntaxInstructionList += ![@repeatInstructionForGrammarAnalysis new
    !mStartLocation
    !repeatBranchList
    !addedNonTerminalIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  const @uint addedNonTerminalIndex := ioAddedNonTerminalIndex ;
  ioAddedNonTerminalIndex ++ ;

  @branchListForGrammarAnalysis selectBranchList [emptyList] ;
  foreach mSelectBranchList do
    @syntaxInstructionListForGrammarAnalysis syntaxInstructionList [emptyList] ;
    transformInstructionList
      !mSyntaxInstructionList
      !?ioActuallyUsedTerminalSymbolMap
      !inNonTerminalSymbolMap
      !?ioAddedNonTerminalIndex
      !?syntaxInstructionList
    ;
    selectBranchList += !syntaxInstructionList ;
  end foreach ;

  ioSyntaxInstructionList += ![@selectInstructionForGrammarAnalysis new
    !mStartLocation
    !selectBranchList
    !addedNonTerminalIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  @syntaxInstructionList syntaxInstructionList ;
  [mParseDoBranchList first ?syntaxInstructionList] ;

  transformInstructionList
    !syntaxInstructionList
    !?ioActuallyUsedTerminalSymbolMap
    !inNonTerminalSymbolMap
    !?ioAddedNonTerminalIndex
    !?ioSyntaxInstructionList
  ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstruction transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  transformInstructionList
    !mElseInstructionList
    !?ioActuallyUsedTerminalSymbolMap
    !inNonTerminalSymbolMap
    !?ioAddedNonTerminalIndex
    !?ioSyntaxInstructionList
  ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstruction transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  transformInstructionList
    !mDoInstructionList
    !?ioActuallyUsedTerminalSymbolMap
    !inNonTerminalSymbolMap
    !?ioAddedNonTerminalIndex
    !?ioSyntaxInstructionList
  ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction transformInstruction
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  transformInstructionList
    !mInstructionList
    !?ioActuallyUsedTerminalSymbolMap
    !inNonTerminalSymbolMap
    !?ioAddedNonTerminalIndex
    !?ioSyntaxInstructionList
  ;
end method ;

#---------------------------------------------------------------------------*

routine buildRuleList
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalMapForGrammarAnalysis
  ??@lstring inSyntaxComponentName
  ??@syntaxRuleList inRuleList
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ?!@syntaxComponentListForGrammarAnalysis ioSyntaxComponentListForGrammarAnalysis
  ?!@uint ioAddedNonTerminalCount
:
  @productionRuleListForGrammarAnalysis productionRulesList [emptyList] ;
  foreach inRuleList do
    @uint nonTerminalIndex ;
    @nonterminalSymbolLabelMapForGrammarAnalysis nonterminalSymbolParametersMap ;
    [inNonTerminalMapForGrammarAnalysis searchKey !mNonterminalName ?nonTerminalIndex ?nonterminalSymbolParametersMap] ;
  #--- Retrieve instruction list from first label
    @syntaxInstructionList parsedSyntaxInstructionList ; [mLabelList first ?* ?* ?parsedSyntaxInstructionList] ;
  #--- Transform instruction list
    @syntaxInstructionListForGrammarAnalysis instructionList [emptyList] ;
    transformInstructionList
      !parsedSyntaxInstructionList
      !?ioActuallyUsedTerminalSymbolMap
      !inNonTerminalMapForGrammarAnalysis
      !?ioAddedNonTerminalCount
      !?instructionList
    ; 
  #---
    productionRulesList +=
      !mNonterminalName
      !nonTerminalIndex
      !instructionList
      ![productionRulesList length]
    ;
  end foreach ;
  ioSyntaxComponentListForGrammarAnalysis +=
    !productionRulesList
    !inSyntaxComponentName
  ;
end routine ;

#---------------------------------------------------------------------------*

list @nonTerminalToAddList {
  @string mSyntaxComponentName ;
  @uint mNonTerminalToAddCount ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    G R A M M A R    H E A D E R    F I L E    G E N E R A T I O N         *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper grammarGenerationTemplate in "../generation_templates/grammar_generation" {
} {
  template oldGrammarZone2Header "grammar-zone2.old.h.gTemplate"
    ?@grammarComponentRoot GRAMMAR_COMPONENT_ROOT
  ;
  template oldGrammarZone3Header "grammar-zone3.old.h.gTemplate"
    ?@string LEXIQUE_CLASS
    ?@grammarComponentRoot GRAMMAR_COMPONENT_ROOT
    ?@nonTerminalSymbolMapForGrammarAnalysis NON_TERMINAL_MAP
    ?@nonTerminalToAddList ADDED_NON_TERMINAL_LIST
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      C O M P I L E    G R A M M A R    C O M P O N E N T                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileGrammarComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectoryForCppFiles
  ??@string inOutputDirectoryForHTMLFile
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  @grammarComponentRoot grammarComponentRoot ;
  grammar grammarLL1grammar in inSourceFile ?grammarComponentRoot ;
#---------------------------------------------------------- Check component name
  const @lstring grammarComponentName := [grammarComponentRoot mGrammarName] ;
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [grammarComponentName string] != basename then
    warning grammarComponentName: "GALGAS checks "
      "the component name ('" . [grammarComponentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ;
#---------------------------------------------------------- Parse syntax components
  @terminalSymbolsMapForGrammarAnalysis actuallyUsedTerminalSymbolMap [emptyMap] ;
  @nonTerminalSymbolMapForGrammarAnalysis nonTerminalMapForGrammarAnalysis [emptyMap] ;
  @string lexiqueComponentName := "" ; # Empty string means unknown
  @syntaxComponentListForGrammarAnalysis syntaxComponentListForGrammarAnalysis [emptyList] ;
  @nonTerminalToAddList nonTerminalToAddList [emptyList] ;
  @uint addedNonTerminalCount := 0 ;
  foreach [grammarComponentRoot mSyntaxComponents] do
    const @uint addedNonTerminalCountRef := addedNonTerminalCount ;
    if ([mValue pathExtension] != "gSyntax") & ([mValue pathExtension] != "ggs") then
      error mValue: "a syntax component file should have '.ggs' or '.gSyntax' as path extension" ;
    else
      @string syntaxComponentName := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
      @syntaxComponentRoot syntaxComponentRoot ;
      if [[ioParsedComponentStruct mParsedSyntaxComponentMap] hasKey !syntaxComponentName] then
        [[ioParsedComponentStruct mParsedSyntaxComponentMap] searchKey ![@lstring new !syntaxComponentName !here] ?syntaxComponentRoot] ;
      else
        @string sourceFilePath := [mValue absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]] ;
        grammar syntaxSLRgrammar in [@lstring new !sourceFilePath ![mValue location]] ?syntaxComponentRoot ;
        [!?ioParsedComponentStruct.mParsedSyntaxComponentMap insertKey ![@lstring new !syntaxComponentName ![mValue location]] !syntaxComponentRoot] ;
      end if ;
    #--- Handle lexique component
      @string currentLexiqueName := [[[syntaxComponentRoot mImportedLexiqueReference] lastPathComponent] stringByDeletingPathExtension] ;
      if lexiqueComponentName == "" then
        lexiqueComponentName := currentLexiqueName ;
      elsif lexiqueComponentName != currentLexiqueName then
        error mValue : "this syntax component uses '"
          . currentLexiqueName . "' lexique component, but the first syntax component uses the '"
          . lexiqueComponentName . "' lexique component (they should be the same)" ;
      end if ;
    #--- Handle non terminal declarations
      handleNonTerminalDeclarations
        !?nonTerminalMapForGrammarAnalysis
        ![syntaxComponentRoot mNonterminalDeclarationList]
      ;
    #--- Handle syntax rules
      buildRuleList
        !nonTerminalMapForGrammarAnalysis
        ![syntaxComponentRoot mSyntaxComponentName]
        ![syntaxComponentRoot mRuleList]
        !?actuallyUsedTerminalSymbolMap
        !?syntaxComponentListForGrammarAnalysis
        !?addedNonTerminalCount
      ;
      @uint i := 0 ;
      loop addedNonTerminalCount : while i < (addedNonTerminalCount - addedNonTerminalCountRef) do
        nonTerminalToAddList += !syntaxComponentName !i ;
        i++ ;
      end loop ;
    end if ;
  end foreach ;
#---------------------------------------------------------- Start symbol
#--- Search start symbol in non terminal map
  @nonterminalSymbolLabelMapForGrammarAnalysis startSymbolAltMap ;
  @uint startSymbolIndex ;
  [nonTerminalMapForGrammarAnalysis searchKey ![grammarComponentRoot mStartSymbolName] ?startSymbolIndex ?startSymbolAltMap] ;
#--- Check signatures
  checkLabelMap
    ![[grammarComponentRoot mStartSymbolName] location]
    ![grammarComponentRoot mStartSymbolLabelList]
    ![grammarComponentRoot mStartSymbolHasParseLabel]
    ![nonTerminalMapForGrammarAnalysis locationForKey ![[grammarComponentRoot mStartSymbolName] string]]
    !startSymbolAltMap
  ;
#---------------------------------------------------------- Unused Non Terminal Symbols
  @unusedNonTerminalSymbolMapForGrammarAnalysis unusedNonTerminalSymbolsForGrammar [emptyMap] ;
  foreach [grammarComponentRoot mUnusedNonterminalList] do
    @uint nonterminalIndex ;
    [nonTerminalMapForGrammarAnalysis searchKey !mValue ?nonterminalIndex ?*] ;
    [!?unusedNonTerminalSymbolsForGrammar insertKey !mValue !nonterminalIndex] ;
  end foreach ;
#---------------------------------------------------------- Analyze grammar
  analyzeGrammar
    ![grammarComponentRoot mGrammarName]
    ![grammarComponentRoot mGrammarClass]
    !startSymbolIndex
    !lexiqueComponentName
    ![grammarComponentRoot mEndOfSourceText]
    !actuallyUsedTerminalSymbolMap
    !syntaxComponentListForGrammarAnalysis
    !nonTerminalMapForGrammarAnalysis
    !unusedNonTerminalSymbolsForGrammar
    !inOutputDirectoryForCppFiles
    !inOutputDirectoryForHTMLFile
  ;
#---------------------------------------------------------- Generate header
  if [@uint errorCount] == 0 then
    const @string zone2 := [filewrapper grammarGenerationTemplate.oldGrammarZone2Header
      !grammarComponentRoot
    ] ;
    const @string zone3 := [filewrapper grammarGenerationTemplate.oldGrammarZone3Header
      ![lexiqueComponentName identifierRepresentation]
      !grammarComponentRoot
      !nonTerminalMapForGrammarAnalysis
      !nonTerminalToAddList
    ] ;
    [@string generateFile
      !inOutputDirectoryForCppFiles
      ![[grammarComponentRoot mGrammarName] string] . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      !zone2
      !"\n\n" # Defaut user zone2
      !zone3
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
