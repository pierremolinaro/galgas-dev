#---------------------------------------------------------------------------*
#                                                                           *
#  Grammar component compilation                                            *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics grammarCompilation :
import "grammarMetamodel.gSemantics" ;
import "galgas_cli_options.gOption" ;
#import "semanticsSemantics.gSemantics" ;


import semantics grammarMetamodel in "grammarMetamodel.gSemantics" ;
#import semantics semanticsSemantics in "semanticsSemantics.gSemantics" ;
import grammar grammarLL1grammar in "grammarLL1grammar.gGrammar" ;
import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;
import option galgas_cli_options in "galgas_cli_options.gOption" ;

#---------------------------------------------------------------------------*
#                                                                           *
#  N O N    T E R M I N A L   M A P                                         *
#                                                                           *
#---------------------------------------------------------------------------*

map @nonTerminalMap {
  @nonTerminalLabelList mLabels ;
  @bool mHasParseLabel ;
  insert insertKey error message "the '@%K' non terminal has been already declared in %L" ;
  search searchKey error message "the '@%K' non terminal is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  H A N D L E    N O N    T E R M I N A L   D E C L A R A T I O N S        *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleNonTerminalDeclarations
  !@nonTerminalMap outNonTerminalMap
  ??@nonterminalDeclarationList inNonterminalDeclarationList
:
  outNonTerminalMap := [@nonTerminalMap emptyMap] ;
  foreach inNonterminalDeclarationList do
    if [outNonTerminalMap hasKey ![mNonterminalName string]] then
      @nonTerminalLabelList labels ;
      @bool hasParseLabel ;
      [outNonTerminalMap searchKey
        !mNonterminalName
        ?labels
        ?hasParseLabel
      ] ;
     #--- Compare 'parse' label
      if mHasParseLabel & not hasParseLabel then
        error mNonterminalName: "this declaration has a 'parse' label, but declaration of the same non terminal in " 
        . [[outNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
        . " does not have a 'parse' label" ;
      elsif (not mHasParseLabel) &  hasParseLabel then
        error mNonterminalName: "this declaration has no 'parse' label, but declaration of the same non terminal in " 
        . [[outNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
        . " has a 'parse' label" ;
      end if ;
    #--- Compare regular labels
      if [labels length] != [mLabels length] then
        error mNonterminalName: "this declaration names " 
          . [[mLabels length] string]
          . " labels, but declaration of the same non terminal in " 
          . [[outNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
          . " names"
          . [[labels length] string]
          . " labels."
        ;
      else
        foreach mLabels, labels (@lstring labelName @formalParameterList formalParameters) do
          if mLabelName != labelName then
            error mLabelName: "this label should be identical to the label '"
            . labelName
            . "' declared in " 
            . [[labelName location] locationString]
            ;
          end if ;
          foreach mFormalParameters, formalParameters (@formalArgumentPassingMode formalParameterPassingMode
                                                       @lstring formalParameterTypeName
                                                       *
                                                       *) do
            
            if mFormalParameterPassingMode != formalParameterPassingMode then
              error mFormalParameterName: "the passing mode ("
              . [mFormalParameterPassingMode string]
              . ") for this parameter should be identical to the passing mode ("
              . [formalParameterPassingMode string]
              . ") of the parameter declared in"
              . [[labelName location] locationString]
              ;
            end if ;
            if [mFormalParameterName string] != [formalParameterTypeName string] then
              error mFormalParameterName: "this type name should be identical to the '@"
              . labelName
              . "' type name used in " 
              . [[labelName location] locationString]
              ;
            end if ;
          end foreach ;
        end foreach ;
      end if ;
    else
      [!?outNonTerminalMap insertKey
        !mNonterminalName
        !mLabels
        !mHasParseLabel
      ] ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList unused ioSyntaxInstructionList
;

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    S Y N T A X    I N S T R U C T I O N    L I S T             *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildSyntaxInstructionList
  ??@syntaxInstructionList inInstructionList
  !@syntaxInstructionList outSyntaxInstructionList
:
  outSyntaxInstructionList := [@syntaxInstructionList emptyList] ;
  foreach inInstructionList do
    [mInstruction buildSyntaxInstructionList !?outSyntaxInstructionList] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

override method @semanticInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList unused ioSyntaxInstructionList
:
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  ioSyntaxInstructionList += !self ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  ioSyntaxInstructionList += !self ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @syntaxInstructionList repeatedInstructionList ;
  buildSyntaxInstructionList !mRepeatedInstructionList ?repeatedInstructionList ;
  @listOfSyntaxInstructionList repeatBranchList [emptyList] ;
  foreach mRepeatBranchList do
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !mSyntaxInstructionList ?syntaxInstructionList ;
    repeatBranchList += !syntaxInstructionList ;
  end foreach ;
  @repeatInstruction ri [new
    !repeatedInstructionList
    !repeatBranchList
  ] ;
  ioSyntaxInstructionList += !ri ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @listOfSyntaxInstructionList selectBranchList [emptyList] ;
  foreach mSelectBranchList do
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !mSyntaxInstructionList ?syntaxInstructionList ;
    selectBranchList += !syntaxInstructionList ;
  end foreach ;
  @selectInstruction si [new
    !selectBranchList
  ] ;
  ioSyntaxInstructionList += !si ;
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @syntaxInstructionList instructionList ;
  [mParseDoBranchList first ?instructionList] ;
  foreach instructionList do
    [mInstruction buildSyntaxInstructionList !?ioSyntaxInstructionList] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  foreach mInstructionList do
    [mInstruction buildSyntaxInstructionList !?ioSyntaxInstructionList] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

list @syntaxRuleListForGrammar {
  @lstring mLeftNonTerminal ;
  @syntaxInstructionList mSyntaxInstructionList ;
}

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

abstract reader @syntaxInstruction htmlListing
  -> @string outListing
;

#---------------------------------------------------------------------------*

override reader @semanticInstruction htmlListing
  -> @string outListing
:
  outListing := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @nonterminalCallInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_nonterminal\">&lt;" . mNonterminalName . "&gt;; </span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @terminalCheckInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_terminal\">$" . [mTerminalName HTMLRepresentation] . "$; </span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @repeatInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_structure\">"
  . "<span class=\"galgas_keyword\">repeat</span>"
  . "<span class=\"within_galgas_structure\">" ;
  foreach mRepeatedInstructionList do
    outListing .= [mInstruction htmlListing] ;
  end foreach ;
  outListing .= "</span>" ;
  foreach mRepeatBranchList do
    outListing .= "<span class=\"galgas_keyword\">while</span>" ;
    outListing .= "<span class=\"within_galgas_structure\">" ;
    foreach mSyntaxInstructionList do
      outListing .= [mInstruction htmlListing] ;
    end foreach ;
    outListing .= "</span>" ;
  end foreach ;
  outListing .= "<span class=\"galgas_keyword\">end repeat</span>"
  . "</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @selectInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_structure\">"
  . "<span class=\"galgas_keyword\">select</span>" ;
  foreach mSelectBranchList
  do
    outListing .= "<span class=\"within_galgas_structure\">" ;
    foreach mSyntaxInstructionList do
      outListing .= [mInstruction htmlListing] ;
    end foreach ;
    outListing .= "</span>" ;
  between 
   outListing .= "<span class=\"galgas_keyword\">or</span>" ;
  end foreach ;
  outListing .= "<span class=\"galgas_keyword\">end select</span>"
  . "</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @parseDoInstruction htmlListing
  -> @string outListing
:
  outListing := "[Parse do]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @blockInstruction htmlListing
  -> @string outListing
:
  outListing := "[block]" ;
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
#  G E N E R A T I O N    F I L E W R A P P E R S                           *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper grammarGenerationTemplates in "../generation_templates/grammar_generation" {
} {
  template html "grammar.html.gTemplate"
    ?@string GRAMMAR_NAME
    ?@syntaxRuleListForGrammar SYNTAX_RULE_LIST
    ?@syntaxRuleListForGrammar PURE_SYNTAX_RULE_LIST
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    R U L E    L I S T                                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildRuleList
  ??@syntaxRuleList inRuleList
  ?!@syntaxRuleListForGrammar ioSyntaxRuleListForGrammar
:
  foreach inRuleList do
  #--- We get only the first label (all syntax signatures are the same)
    @syntaxInstructionList instructionList ;
    [mLabelList first ?* ?* ?instructionList] ;
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !instructionList ?syntaxInstructionList ;
    ioSyntaxRuleListForGrammar += !mNonterminalName !syntaxInstructionList ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    P U R E    R U L E    L I S T                               *
#                                                                           *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction buildPureSyntaxInstruction
  ??@lstring inCurrentLeftNonTerminal
  ?!@syntaxRuleListForGrammar ioPureSyntaxRuleListForGrammar
  !@syntaxInstruction outPureSyntaxInstruction
  ?!@uint ioAddedNonTerminalCount
;

#---------------------------------------------------------------------------*

routine buildPureSyntaxInstructionList
  ??@lstring inCurrentLeftNonTerminal
  ??@syntaxInstructionList inSyntaxInstructionList
  !@syntaxInstructionList outPureSyntaxInstructionList
  ?!@syntaxRuleListForGrammar ioPureSyntaxRuleListForGrammar
  ?!@uint ioAddedNonTerminalCount
:
  outPureSyntaxInstructionList := [@syntaxInstructionList emptyList] ;
  foreach inSyntaxInstructionList do
    @syntaxInstruction pureSyntaxInstruction ;
    [mInstruction buildPureSyntaxInstruction
      !inCurrentLeftNonTerminal
      !?ioPureSyntaxRuleListForGrammar
      ?pureSyntaxInstruction
      !?ioAddedNonTerminalCount
    ] ;
    outPureSyntaxInstructionList += !pureSyntaxInstruction ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

override method @semanticInstruction buildPureSyntaxInstruction
  ??@lstring unused inCurrentLeftNonTerminal
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  !@syntaxInstruction outPureSyntaxInstruction
  ?!@uint unused ioAddedNonTerminalCount
:
  error here : "internal error (use debug tool)" -> outPureSyntaxInstruction ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction buildPureSyntaxInstruction
  ??@lstring unused inCurrentLeftNonTerminal
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  !@syntaxInstruction outPureSyntaxInstruction
  ?!@uint unused ioAddedNonTerminalCount
:
  outPureSyntaxInstruction := self ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction buildPureSyntaxInstruction
  ??@lstring unused inCurrentLeftNonTerminal
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  !@syntaxInstruction outPureSyntaxInstruction
  ?!@uint unused ioAddedNonTerminalCount
:
  outPureSyntaxInstruction := self ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction buildPureSyntaxInstruction
  ??@lstring inCurrentLeftNonTerminal
  ?!@syntaxRuleListForGrammar ioPureSyntaxRuleListForGrammar
  !@syntaxInstruction outPureSyntaxInstruction
  ?!@uint ioAddedNonTerminalCount
:
#--- Ceate new non terminal symbols
  @lstring selectRepeatAddedNonTerminal [new
    !"select_repeat_" . inCurrentLeftNonTerminal . "_" . [ioAddedNonTerminalCount string]
    ![inCurrentLeftNonTerminal location]
  ] ;
  ioAddedNonTerminalCount ++ ;
  @lstring repeatAddedNonTerminal [new
    !"repeat_" . inCurrentLeftNonTerminal . "_" . [ioAddedNonTerminalCount string]
    ![inCurrentLeftNonTerminal location]
  ] ;
  ioAddedNonTerminalCount ++ ;
#--- Add syntax instruction
  outPureSyntaxInstruction := [@nonterminalCallInstruction new
    !selectRepeatAddedNonTerminal
    ![@lstring new !"" !here] # no Label
    ![@actualParameterList emptyList]
  ] ;
#--- Create "select_repeat_..." single rule
  @syntaxInstructionList repeatedPureInstructionList ;
  buildPureSyntaxInstructionList
    !inCurrentLeftNonTerminal
    !mRepeatedInstructionList
    ?repeatedPureInstructionList
    !?ioPureSyntaxRuleListForGrammar
    !?ioAddedNonTerminalCount
  ;
  repeatedPureInstructionList += ![@nonterminalCallInstruction new
    !repeatAddedNonTerminal
    ![@lstring new !"" !here] # no Label
    ![@actualParameterList emptyList]
  ] ;
  ioPureSyntaxRuleListForGrammar +=
    !selectRepeatAddedNonTerminal
    !repeatedPureInstructionList
  ;
#--- Create "repeat_..." empty rule
  ioPureSyntaxRuleListForGrammar +=
    !repeatAddedNonTerminal
    ![@syntaxInstructionList emptyList]
  ;
#--- Create "repeat_..." rules
  foreach mRepeatBranchList do
    @syntaxInstructionList pureInstructionList ;
    buildPureSyntaxInstructionList
      !inCurrentLeftNonTerminal
      !mSyntaxInstructionList
      ?pureInstructionList
      !?ioPureSyntaxRuleListForGrammar
      !?ioAddedNonTerminalCount
    ;
    pureInstructionList += ![@nonterminalCallInstruction new
      !selectRepeatAddedNonTerminal
      ![@lstring new !"" !here] # no Label
      ![@actualParameterList emptyList]
    ] ;
    ioPureSyntaxRuleListForGrammar +=
      !repeatAddedNonTerminal
      !pureInstructionList
    ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction buildPureSyntaxInstruction
  ??@lstring inCurrentLeftNonTerminal
  ?!@syntaxRuleListForGrammar ioPureSyntaxRuleListForGrammar
  !@syntaxInstruction outPureSyntaxInstruction
  ?!@uint ioAddedNonTerminalCount
:
  @lstring selectAddedNonTerminal [new
    !"select_" . inCurrentLeftNonTerminal . "_" . [ioAddedNonTerminalCount string]
    ![inCurrentLeftNonTerminal location]
  ] ;
  ioAddedNonTerminalCount ++ ;
  outPureSyntaxInstruction := [@nonterminalCallInstruction new
    !selectAddedNonTerminal
    ![@lstring new !"" !here] # no Label
    ![@actualParameterList emptyList]
  ] ;
  foreach mSelectBranchList do
    @syntaxInstructionList pureSyntaxInstructionList ;
    buildPureSyntaxInstructionList
      !inCurrentLeftNonTerminal
      !mSyntaxInstructionList
      ?pureSyntaxInstructionList
      !?ioPureSyntaxRuleListForGrammar
      !?ioAddedNonTerminalCount
    ;
    ioPureSyntaxRuleListForGrammar +=
      !selectAddedNonTerminal
      !pureSyntaxInstructionList
    ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction  buildPureSyntaxInstruction
  ??@lstring unused inCurrentLeftNonTerminal
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  !@syntaxInstruction outPureSyntaxInstruction
  ?!@uint unused ioAddedNonTerminalCount
:
  error here : "internal error (use debug tool)" -> outPureSyntaxInstruction ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction buildPureSyntaxInstruction
  ??@lstring unused inCurrentLeftNonTerminal
  ?!@syntaxRuleListForGrammar unused ioPureSyntaxRuleListForGrammar
  !@syntaxInstruction outPureSyntaxInstruction
  ?!@uint unused ioAddedNonTerminalCount
:
  error here : "internal error (use debug tool)" -> outPureSyntaxInstruction ;
end method ;

#---------------------------------------------------------------------------*

routine compileGrammarComponent
  ??@lstring inSourceFile
  ??@string unused inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  @grammarComponentRoot grammarComponentRoot ;
  grammar grammarLL1grammar in inSourceFile ?grammarComponentRoot ;
#--- Check component name
  @lstring componentName := [grammarComponentRoot mGrammarName] ;
  @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ;
#--- Parse syntax components
  @string lexiqueComponent := "" ; # Empty string means unknown
  @syntaxRuleListForGrammar syntaxRuleListForGrammar [emptyList] ;
  foreach [grammarComponentRoot mSyntaxComponents] do
    if [mValue pathExtension] != "gSyntax" then
      error mValue: "a syntax component file should have '.gSyntax' as path extension" ;
    else
      @string syntaxComponentName := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
      @syntaxComponentRoot syntaxComponentRoot ;
      if [[ioParsedComponentStruct mParsedSyntaxComponentMap] hasKey !syntaxComponentName] then
        [[ioParsedComponentStruct mParsedSyntaxComponentMap] searchKey ![@lstring new !syntaxComponentName !here] ?syntaxComponentRoot] ;
      else
        @string sourceFilePath := [mValue absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]] ;
        grammar syntaxSLRgrammar in [@lstring new !sourceFilePath ![mValue location]] ?syntaxComponentRoot ;
        [!?ioParsedComponentStruct.mParsedSyntaxComponentMap insertKey ![@lstring new !syntaxComponentName ![mValue location]] !syntaxComponentRoot] ;
      end if ;
    #--- Handle lexique component
      @string currentLexiqueName := [[[syntaxComponentRoot mImportedLexiqueReference] lastPathComponent] stringByDeletingPathExtension] ;
      if lexiqueComponent == "" then
        lexiqueComponent := currentLexiqueName ;
      elsif lexiqueComponent != currentLexiqueName then
        error mValue : "this syntax component uses '"
          . currentLexiqueName . "' lexique component, but the first syntax component uses the '"
          . lexiqueComponent . "' lexique component (they should be the same)" ;
      end if ;
    #--- Handle non terminal declarations
      @nonTerminalMap nonTerminalMap ;
      handleNonTerminalDeclarations
        ?nonTerminalMap
        ![syntaxComponentRoot mNonterminalDeclarationList]
      ;
    #--- Handle syntax rules
      buildRuleList
        ![syntaxComponentRoot mRuleList]
        !?syntaxRuleListForGrammar
      ;
    end if ;
  end foreach ;
#--- Build pure BNF productions
  @syntaxRuleListForGrammar pureSyntaxRuleListForGrammar [emptyList] ;
  @syntaxRuleListForGrammar addedPureSyntaxRuleListForGrammar [emptyList] ;
  @uint addedNonTerminalCount := 0 ;
  foreach syntaxRuleListForGrammar do
    @syntaxInstructionList pureSyntaxInstructionList ;
    buildPureSyntaxInstructionList
      !mLeftNonTerminal
      !mSyntaxInstructionList
      ?pureSyntaxInstructionList
      !?addedPureSyntaxRuleListForGrammar
      !?addedNonTerminalCount
    ;
    pureSyntaxRuleListForGrammar +=
      !mLeftNonTerminal
      !pureSyntaxInstructionList
    ;
  end foreach ;
  pureSyntaxRuleListForGrammar := pureSyntaxRuleListForGrammar . addedPureSyntaxRuleListForGrammar ;
#--- Build HTML file
  if [option galgas_cli_options.outputHTMLgrammarFile] then
    @string s := [filewrapper grammarGenerationTemplates.html
      ![componentName string]
      !syntaxRuleListForGrammar
      !pureSyntaxRuleListForGrammar
    ] ;
    @string htmlOutputFileName := [inSourceFile stringByDeletingPathExtension] . ".html" ;
    [s writeToFileWhenDifferentContents !htmlOutputFileName ?*] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
