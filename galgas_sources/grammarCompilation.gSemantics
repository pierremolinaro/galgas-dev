#---------------------------------------------------------------------------*
#                                                                           *
#  Grammar component compilation                                            *
#                                                                           *
#  Copyright (C) 2009, ..., 2011 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics grammarCompilation :
import "allASTTypes.gSemantics" ;
import "grammarSemantics.gSemantics" ;
import "grammarLL1grammar.gGrammar" ;
import "syntaxSLRgrammar.gGrammar" ;
import "lexiqueCompilation.gSemantics" ;
import "semanticContext.gSemantics" ;

#---------------------------------------------------------------------------*

function transformLabelMap
  ??@nonTerminalLabelListAST inLabels
  -> @nonterminalSymbolLabelMapForGrammarAnalysis outNonterminalSymbolLabelMapForGrammarAnalysis
{
  outNonterminalSymbolLabelMapForGrammarAnalysis := [@nonterminalSymbolLabelMapForGrammarAnalysis emptyMap] ;
  foreach inLabels do
    @signatureForGrammarAnalysis formalParametersList [emptyList] ;
    foreach mFormalArgumentList do
      formalParametersList += !mFormalArgumentPassingMode !mFormalArgumentTypeName ;
    end foreach ;
    [!?outNonterminalSymbolLabelMapForGrammarAnalysis insertKey
      !mLabelName
      !formalParametersList
    ] ;
  end foreach ;
}


#---------------------------------------------------------------------------*

routine checkLabelMap
  ??@location inNonTerminalLocation
  ??@nonTerminalLabelListAST inLabels
  ??@location inOriginalNonTerminalLocation
  ??@nonterminalSymbolLabelMapForGrammarAnalysis inNonterminalSymbolLabelMapForGrammarAnalysis
:
  @stringset labelStringSet [emptySet] ;
  foreach inLabels do
    labelStringSet += ![mLabelName string] ;
    @signatureForGrammarAnalysis formalParametersList ;
    [inNonterminalSymbolLabelMapForGrammarAnalysis searchKey !mLabelName ?formalParametersList] ;
    if [mFormalArgumentList length] != [formalParametersList length] then
      error mLabelName: [[mFormalArgumentList length] string]
        . " formal parameter"
        . if [mFormalArgumentList length] > 1 then "s" else "" end
        . " declared here, but declaration at "
        . [[inNonterminalSymbolLabelMapForGrammarAnalysis locationForKey ![mLabelName string]] locationString]
        . " names " . [[formalParametersList length] string] . " parameter"
        . if [formalParametersList length] > 1 then "s" else "" end ;
    else
      foreach mFormalArgumentList, formalParametersList do
        if mFormalArgumentPassingModeForGrammarAnalysis != mFormalArgumentPassingMode then
          error mGalgasTypeNameForGrammarAnalysis :
            " this formal parameter is declared with "
          . [mFormalArgumentPassingModeForGrammarAnalysis formalArgumentString]
          . " passing mode, but declaration at "
          . [[inNonterminalSymbolLabelMapForGrammarAnalysis locationForKey ![mLabelName string]] locationString]
          . " is declared with " . [mFormalArgumentPassingMode formalArgumentString] . " passing mode" ;
        end if ;
        if [mGalgasTypeNameForGrammarAnalysis string] != [mFormalArgumentTypeName string] then
          error mGalgasTypeNameForGrammarAnalysis :
            " this formal parameter is declared of '@"
          . mGalgasTypeNameForGrammarAnalysis
          . "' type, but declaration at "
          . [[inNonterminalSymbolLabelMapForGrammarAnalysis locationForKey ![mLabelName string]] locationString]
          . " is declared with '@" . mFormalArgumentTypeName . "' type" ;
        end if ;
      end foreach ;
    end if ;
  end foreach ;
#---
  foreach inNonterminalSymbolLabelMapForGrammarAnalysis do
    if not [labelStringSet hasKey ![lkey string]] then
      error inNonTerminalLocation :
        "this non terminal does not declare the '" . lkey . "' label, but declaration at "
          . [inOriginalNonTerminalLocation locationString]
          . " does" ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine handleNonTerminalDeclarations
  ?!@nonTerminalSymbolMapForGrammarAnalysis ioNonTerminalMapForGrammarAnalysis
  ??@nonterminalDeclarationListAST inNonterminalDeclarationList
:
  foreach inNonterminalDeclarationList do
    with ioNonTerminalMapForGrammarAnalysis hasKey ![mNonterminalName string] do
      checkLabelMap
        ![mNonterminalName location]
        !mLabels
        ![ioNonTerminalMapForGrammarAnalysis locationForKey ![mNonterminalName string]]
        !mNonterminalSymbolParametersMap
      ;
    else
      [!?ioNonTerminalMapForGrammarAnalysis insertKey
        !mNonterminalName
        ![ioNonTerminalMapForGrammarAnalysis count]
        !transformLabelMap [!mLabels]
      ] ;
    end with ;  
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine handleNonTerminalDeclarationsFromRuleList
  ?!@nonTerminalSymbolMapForGrammarAnalysis ioNonTerminalMapForGrammarAnalysis
  ??@syntaxRuleListAST inRuleList
:
  foreach inRuleList do
    @nonTerminalLabelListAST nonTerminalLabelListAST [emptyList] ;
    foreach mLabelList do
      nonTerminalLabelListAST += 
        !mLabelName
        !mFormalArguments
        !mEndOfArgumentLocation
      ;
    end foreach ;
    with ioNonTerminalMapForGrammarAnalysis hasKey ![mNonterminalName string] do
      checkLabelMap
        ![mNonterminalName location]
        !nonTerminalLabelListAST
        ![ioNonTerminalMapForGrammarAnalysis locationForKey ![mNonterminalName string]]
        !mNonterminalSymbolParametersMap
      ;
    else
      [!?ioNonTerminalMapForGrammarAnalysis insertKey
        !mNonterminalName
        ![ioNonTerminalMapForGrammarAnalysis count]
        !transformLabelMap [!nonTerminalLabelListAST]
      ] ;
    end with ;  
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     transformInstructionList                              *
#---------------------------------------------------------------------------*

abstract method @syntaxInstructionAST transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
;

#---------------------------------------------------------------------------*

override method @semanticInstructionAST transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis unused ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis unused inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis unused ioSyntaxInstructionList
:
end method ;

#---------------------------------------------------------------------------*

routine transformInstructionList
  ??@syntaxInstructionList inInstructionList
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  foreach inInstructionList do
    [mInstruction transformInstruction
      !?usedTerminalMap:ioActuallyUsedTerminalSymbolMap
      !nonTerminalSymbolMap:inNonTerminalSymbolMap
      !?addedTerminalIndex:ioAddedNonTerminalIndex
      !?ioSyntaxInstructionList
   ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

override method @syntaxSendInstruction transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis unused ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis unused inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis unused ioSyntaxInstructionList
:
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis unused inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  @uint terminalSymbolIndex ;
  with ioActuallyUsedTerminalSymbolMap hasKey ![mTerminalName string] do
    terminalSymbolIndex := mTerminalIndex ;
  else
    terminalSymbolIndex := [ioActuallyUsedTerminalSymbolMap count] ;
    [!?ioActuallyUsedTerminalSymbolMap insertKey !mTerminalName !terminalSymbolIndex] ;
  end with ;
  ioSyntaxInstructionList += ![@terminalInstructionForGrammarAnalysis new
    !mInstructionLocation
    !mTerminalName
    !terminalSymbolIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis unused ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint unused ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  @uint nonTerminalSymbolIndex ;
  [inNonTerminalSymbolMap searchKey !mNonterminalName ?nonTerminalSymbolIndex ?*] ;
  ioSyntaxInstructionList += ![@nonTerminalInstructionForGrammarAnalysis new
    !mInstructionLocation
    !mNonterminalName
    !nonTerminalSymbolIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  const @uint addedNonTerminalIndex := ioAddedNonTerminalIndex ;
  ioAddedNonTerminalIndex ++ ;

  @syntaxInstructionListForGrammarAnalysis repeatedInstructionList [emptyList] ;
  transformInstructionList
    !mRepeatedInstructionList
    !?usedTerminalMap:ioActuallyUsedTerminalSymbolMap
    !nonTerminalSymbolMap:inNonTerminalSymbolMap
    !?addedTerminalIndex:ioAddedNonTerminalIndex
    !?repeatedInstructionList
  ;
  @branchListForGrammarAnalysis repeatBranchList [listWithValue !repeatedInstructionList] ;

  foreach mRepeatBranchList do
    @syntaxInstructionListForGrammarAnalysis syntaxInstructionList [emptyList] ;
    transformInstructionList
      !mSyntaxInstructionList
      !?usedTerminalMap:ioActuallyUsedTerminalSymbolMap
      !nonTerminalSymbolMap:inNonTerminalSymbolMap
      !?addedTerminalIndex:ioAddedNonTerminalIndex
      !?syntaxInstructionList
    ;
    repeatBranchList += !syntaxInstructionList ;
  end foreach ;

  ioSyntaxInstructionList += ![@repeatInstructionForGrammarAnalysis new
    !mInstructionLocation
    !repeatBranchList
    !addedNonTerminalIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  const @uint addedNonTerminalIndex := ioAddedNonTerminalIndex ;
  ioAddedNonTerminalIndex ++ ;

  @branchListForGrammarAnalysis selectBranchList [emptyList] ;
  foreach mSelectBranchList do
    @syntaxInstructionListForGrammarAnalysis syntaxInstructionList [emptyList] ;
    transformInstructionList
      !mSyntaxInstructionList
      !?usedTerminalMap:ioActuallyUsedTerminalSymbolMap
      !nonTerminalSymbolMap:inNonTerminalSymbolMap
      !?addedTerminalIndex:ioAddedNonTerminalIndex
      !?syntaxInstructionList
    ;
    selectBranchList += !syntaxInstructionList ;
  end foreach ;

  ioSyntaxInstructionList += ![@selectInstructionForGrammarAnalysis new
    !mInstructionLocation
    !selectBranchList
    !addedNonTerminalIndex
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseRewindInstruction transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  @syntaxInstructionList syntaxInstructionList ;
  [mParseRewindBranchList first ?syntaxInstructionList ?*] ;

  transformInstructionList
    !syntaxInstructionList
    !?usedTerminalMap:ioActuallyUsedTerminalSymbolMap
    !nonTerminalSymbolMap:inNonTerminalSymbolMap
    !?addedTerminalIndex:ioAddedNonTerminalIndex
    !?ioSyntaxInstructionList
  ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstruction transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  transformInstructionList
    !mElseInstructionList
    !?usedTerminalMap:ioActuallyUsedTerminalSymbolMap
    !nonTerminalSymbolMap:inNonTerminalSymbolMap
    !?addedTerminalIndex:ioAddedNonTerminalIndex
    !?ioSyntaxInstructionList
  ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstruction transformInstruction
  ?!usedTerminalMap:@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ??nonTerminalSymbolMap:@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalSymbolMap
  ?!addedTerminalIndex:@uint ioAddedNonTerminalIndex
  ?!@syntaxInstructionListForGrammarAnalysis ioSyntaxInstructionList
:
  transformInstructionList
    !mDoInstructionList
    !?usedTerminalMap:ioActuallyUsedTerminalSymbolMap
    !nonTerminalSymbolMap:inNonTerminalSymbolMap
    !?addedTerminalIndex:ioAddedNonTerminalIndex
    !?ioSyntaxInstructionList
  ;
end method ;

#---------------------------------------------------------------------------*

routine buildRuleList
  ??@nonTerminalSymbolMapForGrammarAnalysis inNonTerminalMapForGrammarAnalysis
  ??@lstring inSyntaxComponentName
  ??@syntaxRuleListAST inRuleList
  ?!@terminalSymbolsMapForGrammarAnalysis ioActuallyUsedTerminalSymbolMap
  ?!@syntaxComponentListForGrammarAnalysis ioSyntaxComponentListForGrammarAnalysis
  ?!@uint ioAddedNonTerminalCount
:
  @productionRuleListForGrammarAnalysis productionRulesList [emptyList] ;
  foreach inRuleList do
    @uint nonTerminalIndex ;
    @nonterminalSymbolLabelMapForGrammarAnalysis nonterminalSymbolParametersMap ;
    [inNonTerminalMapForGrammarAnalysis searchKey !mNonterminalName ?nonTerminalIndex ?nonterminalSymbolParametersMap] ;
  #--- Retrieve instruction list from first label
    @syntaxInstructionList parsedSyntaxInstructionList ; [mLabelList first ?* ?* ?* ?parsedSyntaxInstructionList ?*] ;
  #--- Transform instruction list
    @syntaxInstructionListForGrammarAnalysis instructionList [emptyList] ;
    transformInstructionList
      !parsedSyntaxInstructionList
      !?usedTerminalMap:ioActuallyUsedTerminalSymbolMap
      !nonTerminalSymbolMap:inNonTerminalMapForGrammarAnalysis
      !?addedTerminalIndex:ioAddedNonTerminalCount
      !?instructionList
    ; 
  #---
    productionRulesList +=
      !mNonterminalName
      !nonTerminalIndex
      !instructionList
      ![productionRulesList length]
    ;
  end foreach ;
  ioSyntaxComponentListForGrammarAnalysis +=
    !productionRulesList
    !inSyntaxComponentName
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    G R A M M A R    H E A D E R    F I L E    G E N E R A T I O N         *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper grammarGenerationTemplate in "../generation_templates/grammar_generation" {
}{
}{
  template grammarZone2Header "grammar-zone2.h.gTemplate"
    ?@galgas3GrammarComponentListAST-element GRAMMAR_COMPONENT_ROOT
  ;
  template grammarZone2HeaderGalgas3 "grammar-zone2-galgas3.h.gTemplate"
    ?@galgas3GrammarComponentListAST-element GRAMMAR_COMPONENT_ROOT
  ;
  template grammarZone3Header "grammar-zone3.h.gTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@galgas3GrammarComponentListAST-element GRAMMAR_COMPONENT_ROOT
    ?@nonTerminalSymbolMapForGrammarAnalysis NON_TERMINAL_MAP
    ?@nonTerminalToAddList ADDED_NON_TERMINAL_LIST
    ?@bool HAS_INDEXING
  ;
  template grammarZone3HeaderGalgas3 "grammar-zone3-galgas3.h.gTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@nonTerminalSymbolMapForGrammarAnalysis NON_TERMINAL_MAP
    ?@nonTerminalToAddList ADDED_NON_TERMINAL_LIST
    ?@bool HAS_INDEXING
    ?@string START_SYMBOL_NAME
    ?@bool HAS_TRANSLATE_FEATURE
    ?@string GRAMMAR_NAME
    ?@lstringlist SYNTAX_COMPONENTS
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      C O M P I L E    G R A M M A R    C O M P O N E N T                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine parseGrammarComponent
  ??@lstring inSourceFile
  ?!@parsedComponentStruct ioParsedComponentStruct
  !@galgas3GrammarComponentListAST-element outGrammarComponentRoot
:
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  with ioParsedComponentStruct->mParsedGrammarComponentMap hasKey !basename do
    outGrammarComponentRoot := mGrammarComponentRoot ;
  else
    grammar grammarLL1grammar in inSourceFile ?outGrammarComponentRoot ;
    [!?ioParsedComponentStruct->mParsedGrammarComponentMap insertKey
      ![@lstring new !basename !here]
      !inSourceFile
      !outGrammarComponentRoot
    ] ;
  end with ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Extern routine that performs grammar analysis                           *
#                                                                           *
#---------------------------------------------------------------------------*

extern routine grammarAnalysisAndGeneration
  ??@stringset inImplementationFileHeaderSet
  ??@lstring inGrammarName
  ??@lstring inGrammarClass
  ??@uint startSymbolIndex
  ??@string inLexiqueName
  ??@terminalSymbolsMapForGrammarAnalysis inTerminalSymbolMap
  ??@syntaxComponentListForGrammarAnalysis ioSyntaxComponentsList
  ??@unusedNonTerminalSymbolMapForGrammarAnalysis inUnusedNonTerminalSymbolsForGrammar
  ??@string inHTMLfilePath
  ??@nonTerminalSymbolSortedListForGrammarAnalysis inNonTerminalSymbolSortedListForGrammarAnalysis
  ??@bool inHasIndexing
  ??@string inSyntaxDirectedTranslationVarName # Empty if not syntax directed translation
  !@string outGrammarCppFile
  !@string outGrammarHTMLHelperContents
;

#---------------------------------------------------------------------------*
#                                                                           *
#      C O M P I L E    G R A M M A R    C O M P O N E N T                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileGrammarComponentFromAST
  ??@lstring inSourceFile
  ??@string inOutputDirectoryForCppFiles
  ??@galgas3GrammarComponentListAST-element inGrammarComponentRoot
  ?!@parsedComponentStruct ioParsedComponentStruct
:
 const @string outputDirectoryForHTMLFile := [inSourceFile stringByDeletingLastPathComponent] ;
#---------------------------------------------------------- Check component name
  const grammarComponentName := inGrammarComponentRoot->mGrammarComponentName ;
  const basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [grammarComponentName string] != basename then
    warning grammarComponentName: "GALGAS checks "
      "the component name ('" . [grammarComponentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ;
#---------------------------------------------------------- Parse syntax components
  @terminalSymbolsMapForGrammarAnalysis actuallyUsedTerminalSymbolMap [emptyMap] ;
  @nonTerminalSymbolMapForGrammarAnalysis nonTerminalMapForGrammarAnalysis [emptyMap] ;
  @string lexiqueComponentName := "" ; # Empty string means unknown
  @lstring lexiqueComponentPath := ["" nowhere] ;
  @syntaxComponentListForGrammarAnalysis syntaxComponentListForGrammarAnalysis [emptyList] ;
  @nonTerminalToAddList nonTerminalToAddList [emptyList] ;
  @uint addedNonTerminalCount := 0 ;
  foreach [inGrammarComponentRoot mSyntaxComponents] do
    const @uint addedNonTerminalCountRef := addedNonTerminalCount ;
    if [mValue pathExtension] != "gSyntax" then
      error mValue: "a syntax component file should have '.gSyntax' path extension" ;
    else
      @string syntaxComponentName := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
      @galgas3SyntaxComponentListAST-element syntaxComponentRoot ;
      if [[ioParsedComponentStruct mParsedSyntaxComponentMap] hasKey !syntaxComponentName] then
        [[ioParsedComponentStruct mParsedSyntaxComponentMap] searchKey ![@lstring new !syntaxComponentName !here] ?* ?syntaxComponentRoot] ;
      else
        const @string sourceFilePath := [mValue absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]] ;
        const @lstring lSourceFilePath := [@lstring new !sourceFilePath ![mValue location]] ;
        grammar syntaxSLRgrammar in lSourceFilePath ?syntaxComponentRoot ;
        [!?ioParsedComponentStruct->mParsedSyntaxComponentMap insertKey ![@lstring new !syntaxComponentName ![mValue location]] !lSourceFilePath !syntaxComponentRoot] ;
      end if ;
    #--- Check translate feature
      if inGrammarComponentRoot->mHasTranslateFeature & not syntaxComponentRoot->mHasTranslateFeature then
        error syntaxComponentRoot->mSyntaxComponentName : "as '" . inGrammarComponentRoot->mGrammarComponentName . "' grammar declares 'translate' feature, this syntax component should do so" ;
      elsif syntaxComponentRoot->mHasTranslateFeature & not inGrammarComponentRoot->mHasTranslateFeature then
        error inGrammarComponentRoot->mGrammarComponentName : "as '" . syntaxComponentRoot->mSyntaxComponentName . "' syntax component declares 'translate' feature, this grammar should do so" ;
      end if ;
    #--- Handle lexique component
      lexiqueComponentPath := [syntaxComponentRoot mImportedLexiqueFilePath] ;
      const @string currentLexiqueName := [[lexiqueComponentPath lastPathComponent] stringByDeletingPathExtension] ;
      if lexiqueComponentName == "" then
        lexiqueComponentName := currentLexiqueName ;
      elsif lexiqueComponentName != currentLexiqueName then
        error mValue : "this syntax component uses '"
          . currentLexiqueName . "' lexique component, but the first syntax component uses the '"
          . lexiqueComponentName . "' lexique component (they should be the same)" ;
      end if ;
    #--- Handle non terminal declarations
      handleNonTerminalDeclarations
        !?nonTerminalMapForGrammarAnalysis
        ![syntaxComponentRoot mNonterminalDeclarationList]
      ;
    #--- Enter non terminal definition from rule list
      handleNonTerminalDeclarationsFromRuleList
        !?nonTerminalMapForGrammarAnalysis
        ![syntaxComponentRoot mRuleList]
      ;
    #--- Handle syntax rules
      buildRuleList
        !nonTerminalMapForGrammarAnalysis
        ![syntaxComponentRoot mSyntaxComponentName]
        ![syntaxComponentRoot mRuleList]
        !?actuallyUsedTerminalSymbolMap
        !?syntaxComponentListForGrammarAnalysis
        !?addedNonTerminalCount
      ;
      @uint i := 0 ;
      loop addedNonTerminalCount : while i < (addedNonTerminalCount - addedNonTerminalCountRef) do
        nonTerminalToAddList += !syntaxComponentName !i ;
        i++ ;
      end loop ;
    end if ;
  end foreach ;
#------------------------ Get lexique component, for knowing if there are "indexing" declaration
  @galgas3LexiqueComponentListAST-element lexiqueComponentAST ;
  parseLexiqueComponent
    ![@lstring new ![lexiqueComponentPath absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]] ![lexiqueComponentPath location]]
    !?ioParsedComponentStruct
    ?lexiqueComponentAST
  ;
  const @bool hasIndexing := not [[lexiqueComponentAST mIndexingDirectory] isNowhere] ;
  if hasIndexing & not inGrammarComponentRoot->mHasIndexing->bool then
    error inGrammarComponentRoot->mGrammarComponentName : "the grammar does not enable indexing, but the '" . lexiqueComponentAST->mLexiqueComponentName . "' does" ;
  elsif (not hasIndexing) & inGrammarComponentRoot->mHasIndexing->bool then
    error inGrammarComponentRoot->mHasIndexing : "the grammar enables indexing, but the '" . lexiqueComponentAST->mLexiqueComponentName . "' does not" ;
  end if ;
#---------------------------------------------------------- Start symbol
#--- Search start symbol in non terminal map
  @nonterminalSymbolLabelMapForGrammarAnalysis startSymbolAltMap ;
  @uint startSymbolIndex ;
  [nonTerminalMapForGrammarAnalysis searchKey ![inGrammarComponentRoot mStartSymbolName] ?startSymbolIndex ?startSymbolAltMap] ;
#--- Check signatures
  checkLabelMap
    ![[inGrammarComponentRoot mStartSymbolName] location]
    ![inGrammarComponentRoot mStartSymbolLabelList]
    ![nonTerminalMapForGrammarAnalysis locationForKey ![[inGrammarComponentRoot mStartSymbolName] string]]
    !startSymbolAltMap
  ;
#---------------------------------------------------------- Unused Non Terminal Symbols
  @unusedNonTerminalSymbolMapForGrammarAnalysis unusedNonTerminalSymbolsForGrammar [emptyMap] ;
  foreach [inGrammarComponentRoot mUnusedNonterminalList] do
    @uint nonterminalIndex ;
    [nonTerminalMapForGrammarAnalysis searchKey !mValue ?nonterminalIndex ?*] ;
    [!?unusedNonTerminalSymbolsForGrammar insertKey !mValue !nonterminalIndex] ;
  end foreach ;
#---------------------------------------------------------- Non terminal symbols, sorted by index
  @nonTerminalSymbolSortedListForGrammarAnalysis nonTerminalSymbolSortedListForGrammarAnalysis [emptySortedList] ;
  foreach nonTerminalMapForGrammarAnalysis do
    nonTerminalSymbolSortedListForGrammarAnalysis += !lkey !mNonTerminalIndex !mNonterminalSymbolParametersMap ;
  end foreach ;
#---------------------------------------------------------- Analyze grammar
  const HTMLFilePath := outputDirectoryForHTMLFile . "/" . inGrammarComponentRoot->mGrammarComponentName . ".html" ;
  grammarAnalysisAndGeneration
    ![@stringset setWithString !inGrammarComponentRoot->mGrammarComponentName->string]
    !inGrammarComponentRoot->mGrammarComponentName
    ![inGrammarComponentRoot mGrammarClass]
    !startSymbolIndex
    !lexiqueComponentName
    !actuallyUsedTerminalSymbolMap
    !syntaxComponentListForGrammarAnalysis
    !unusedNonTerminalSymbolsForGrammar
    !HTMLFilePath
    !nonTerminalSymbolSortedListForGrammarAnalysis
    !hasIndexing
    !if inGrammarComponentRoot->mHasTranslateFeature then syntaxDirectedTranslationResultVarName [] else "" end
    ??@string grammarCppFile
    ??@string grammarHTMLHelperContents
  ;
#---------------------------------------------------------- Generate HTML grammer helper file
#  if [@uint errorCount] == 0 then
    if [option galgas_cli_options.outputHTMLgrammarFile value] then
      [grammarHTMLHelperContents writeToFileWhenDifferentContents !HTMLFilePath ?*] ;
    else
      [@string deleteFileIfExists !HTMLFilePath] ;
    end if ;
#  end if ;
#---------------------------------------------------------- Generate Implementation file
  if [@uint errorCount] == 0 then
    [@string generateFileWithPattern
      !inOutputDirectoryForCppFiles
      !inGrammarComponentRoot->mGrammarComponentName->string . ".cpp"
      !"//"
      !"\n\n" # Defaut user zone1
      !grammarCppFile
      !"\n\n" # Defaut user zone2
      !"\n"
    ] ;
  end if ;
#---------------------------------------------------------- Generate header
  if [@uint errorCount] == 0 then
    const zone2 := [filewrapper grammarGenerationTemplate.grammarZone2Header
      !inGrammarComponentRoot
    ] ;
    const zone3 := [filewrapper grammarGenerationTemplate.grammarZone3Header
      ![lexiqueComponentName identifierRepresentation]
      !inGrammarComponentRoot
      !nonTerminalMapForGrammarAnalysis
      !nonTerminalToAddList
      !hasIndexing
    ] ;
    [@string generateFileWithPattern
      !inOutputDirectoryForCppFiles
      !inGrammarComponentRoot->mGrammarComponentName->string . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      !zone2
      !"\n\n" # Defaut user zone2
      !zone3
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine compileGrammarComponentFromSourceFile
  ??@lstring inSourceFile
  ??@string inOutputDirectoryForCppFiles
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  parseGrammarComponent !inSourceFile !?ioParsedComponentStruct ??@galgas3GrammarComponentListAST-element grammarComponentRoot ;
#----
  compileGrammarComponentFromAST
    !inSourceFile
    !inOutputDirectoryForCppFiles
    !grammarComponentRoot
    !?ioParsedComponentStruct
  ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
