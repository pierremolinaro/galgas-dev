#---------------------------------------------------------------------------*
#                                                                           *
#  Grammar component compilation                                            *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics grammarCompilation :
import "grammarMetamodel.gSemantics" ;
import "galgas_cli_options.gOption" ;
import "buildPureBNFproductions.gSemantics" ;


import semantics grammarMetamodel in "grammarMetamodel.gSemantics" ;
import semantics buildPureBNFproductions in "buildPureBNFproductions.gSemantics" ;
import semantics grammarComputationsWithBDDs in "grammarComputationsWithBDDs.gSemantics" ;
import grammar grammarLL1grammar in "grammarLL1grammar.gGrammar" ;
import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;
import option galgas_cli_options in "galgas_cli_options.gOption" ;

#---------------------------------------------------------------------------*
#                                                                           *
#  N O N    T E R M I N A L   M A P                                         *
#                                                                           *
#---------------------------------------------------------------------------*

map @nonTerminalMap {
  @nonTerminalLabelList mLabels ;
  @bool mHasParseLabel ;
  insert insertKey error message "the '@%K' non terminal has been already declared in %L" ;
  search searchKey error message "the '@%K' non terminal is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  H A N D L E    N O N    T E R M I N A L   D E C L A R A T I O N S        *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleNonTerminalDeclarations
  ?!@nonTerminalMap ioNonTerminalMap
  ??@nonterminalDeclarationList inNonterminalDeclarationList
:
  foreach inNonterminalDeclarationList do
    if [ioNonTerminalMap hasKey ![mNonterminalName string]] then
      @nonTerminalLabelList labels ;
      @bool hasParseLabel ;
      [ioNonTerminalMap searchKey
        !mNonterminalName
        ?labels
        ?hasParseLabel
      ] ;
     #--- Compare 'parse' label
      if mHasParseLabel & not hasParseLabel then
        error mNonterminalName: "this declaration has a 'parse' label, but declaration of the same non terminal in " 
        . [[ioNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
        . " does not have a 'parse' label" ;
      elsif (not mHasParseLabel) &  hasParseLabel then
        error mNonterminalName: "this declaration has no 'parse' label, but declaration of the same non terminal in " 
        . [[ioNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
        . " has a 'parse' label" ;
      end if ;
    #--- Compare regular labels
      if [labels length] != [mLabels length] then
        error mNonterminalName: "this declaration names " 
          . [[mLabels length] string]
          . " labels, but declaration of the same non terminal in " 
          . [[ioNonTerminalMap locationForKey ![mNonterminalName string]] locationString]
          . " names"
          . [[labels length] string]
          . " labels."
        ;
      else
        foreach mLabels, labels prefixedby others_ do
          if [mLabelName string] != [others_mLabelName string] then
            error mLabelName: "this label should be identical to the label '"
            . others_mLabelName
            . "' declared in " 
            . [[others_mLabelName location] locationString]
            ;
          end if ;
          foreach mFormalParameters, others_mFormalParameters prefixedby others_ do
            
            if mFormalParameterPassingMode != others_mFormalParameterPassingMode then
              error mFormalParameterName: "the passing mode ("
              . [mFormalParameterPassingMode string]
              . ") for this parameter should be identical to the passing mode ("
              . [others_mFormalParameterPassingMode string]
              . ") of the parameter declared in"
              . [[others_mLabelName location] locationString]
              ;
            end if ;
            if [mFormalParameterTypeName string] != [others_mFormalParameterTypeName string] then
              error mFormalParameterTypeName: "this type name should be identical to the '@"
              . others_mFormalParameterTypeName
              . "' type name used in " 
              . [[others_mFormalParameterTypeName location] locationString]
              ;
            end if ;
          end foreach ;
        end foreach ;
      end if ;
    else
      [!?ioNonTerminalMap insertKey
        !mNonterminalName
        !mLabels
        !mHasParseLabel
      ] ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList unused ioSyntaxInstructionList
;

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    S Y N T A X    I N S T R U C T I O N    L I S T             *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildSyntaxInstructionList
  ??@syntaxInstructionList inInstructionList
  !@syntaxInstructionList outSyntaxInstructionList
:
  outSyntaxInstructionList := [@syntaxInstructionList emptyList] ;
  foreach inInstructionList do
    [mInstruction buildSyntaxInstructionList !?outSyntaxInstructionList] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

override method @semanticInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList unused ioSyntaxInstructionList
:
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  ioSyntaxInstructionList += !self ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  ioSyntaxInstructionList += !self ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @syntaxInstructionList repeatedInstructionList ;
  buildSyntaxInstructionList !mRepeatedInstructionList ?repeatedInstructionList ;
  @listOfSyntaxInstructionList repeatBranchList [emptyList] ;
  foreach mRepeatBranchList do
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !mSyntaxInstructionList ?syntaxInstructionList ;
    repeatBranchList += !syntaxInstructionList ;
  end foreach ;
  @repeatInstruction ri [new
    !mRepeatInstructionLocation
    !repeatedInstructionList
    !repeatBranchList
  ] ;
  ioSyntaxInstructionList += !ri ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @listOfSyntaxInstructionList selectBranchList [emptyList] ;
  foreach mSelectBranchList do
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !mSyntaxInstructionList ?syntaxInstructionList ;
    selectBranchList += !syntaxInstructionList ;
  end foreach ;
  @selectInstruction si [new
    !mSelectInstructionLocation
    !selectBranchList
  ] ;
  ioSyntaxInstructionList += !si ;
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  @syntaxInstructionList instructionList ;
  [mParseDoBranchList first ?instructionList] ;
  foreach instructionList do
    [mInstruction buildSyntaxInstructionList !?ioSyntaxInstructionList] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction buildSyntaxInstructionList
  ?!@syntaxInstructionList ioSyntaxInstructionList
:
  foreach mInstructionList do
    [mInstruction buildSyntaxInstructionList !?ioSyntaxInstructionList] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                     buildSyntaxInstructionList                            *
#---------------------------------------------------------------------------*

abstract reader @syntaxInstruction htmlListing
  -> @string outListing
;

#---------------------------------------------------------------------------*

override reader @semanticInstruction htmlListing
  -> @string outListing
:
  outListing := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @nonterminalCallInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_nonterminal\">&lt;" . mNonterminalName . "&gt;</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @terminalCheckInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_terminal\">$" . [mTerminalName HTMLRepresentation] . "$</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @repeatInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_structure\">"
  . "<span class=\"galgas_keyword\">repeat</span>"
  . "<span class=\"within_galgas_structure\">" ;
  foreach mRepeatedInstructionList do
    outListing .= [mInstruction htmlListing] ;
  end foreach ;
  outListing .= "</span>" ;
  foreach mRepeatBranchList do
    outListing .= "<span class=\"galgas_keyword\">while</span>" ;
    outListing .= "<span class=\"within_galgas_structure\">" ;
    foreach mSyntaxInstructionList do
      outListing .= [mInstruction htmlListing] ;
    end foreach ;
    outListing .= "</span>" ;
  end foreach ;
  outListing .= "<span class=\"galgas_keyword\">end repeat</span>"
  . "</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @selectInstruction htmlListing
  -> @string outListing
:
  outListing := "<span class=\"galgas_structure\">"
  . "<span class=\"galgas_keyword\">select</span>" ;
  foreach mSelectBranchList
  do
    outListing .= "<span class=\"within_galgas_structure\">" ;
    foreach mSyntaxInstructionList do
      outListing .= [mInstruction htmlListing] ;
    end foreach ;
    outListing .= "</span>" ;
  between 
   outListing .= "<span class=\"galgas_keyword\">or</span>" ;
  end foreach ;
  outListing .= "<span class=\"galgas_keyword\">end select</span>"
  . "</span>" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @parseDoInstruction htmlListing
  -> @string outListing
:
  outListing := "[Parse do]" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @blockInstruction htmlListing
  -> @string outListing
:
  outListing := "[block]" ;
end reader ;

#---------------------------------------------------------------------------*
#                 enterTerminalSymbolIntoVocabulary                         *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
;

#---------------------------------------------------------------------------*

override method @semanticInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap ioVocabularyMap
  ?!@stringlist ioVocabularyListForDisplaying
:
  if not [ioVocabularyMap hasKey ![mTerminalName string]] then
    [!?ioVocabularyMap insertKey !mTerminalName ![ioVocabularyMap count]] ;
    ioVocabularyListForDisplaying += !"$" . mTerminalName . "$" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction enterTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioVocabularyMap
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*
#               enterNonTerminalSymbolIntoVocabulary                        *
#---------------------------------------------------------------------------*

abstract method @syntaxInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
;

#---------------------------------------------------------------------------*

override method @semanticInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @nonterminalCallInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap ioNonTerminalMap
  ??@vocabularyMap inTerminalMap
  ?!@uint64list ioRightDerivation
  ?!@stringlist ioVocabularyListForDisplaying
:
  if not [ioNonTerminalMap hasKey ![mNonterminalName string]] then
    [!?ioNonTerminalMap insertKey !mNonterminalName ![ioNonTerminalMap count] + [inTerminalMap count]] ;
    ioVocabularyListForDisplaying += !"<" . mNonterminalName . ">" ;
  end if ;
  @uint nonterminalIndex ;
  [ioNonTerminalMap searchKey !mNonterminalName ?nonterminalIndex] ;
  ioRightDerivation += ![nonterminalIndex uint64] ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap inTerminalMap
  ?!@uint64list ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
  @uint terminalIndex ;
  [inTerminalMap searchKey !mTerminalName ?terminalIndex] ;
  ioRightDerivation += ![terminalIndex uint64] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @selectInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @parseDoInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*

override method @blockInstruction enterNonTerminalSymbolIntoVocabulary
  ?!@vocabularyMap unused ioNonTerminalMap
  ??@vocabularyMap unused ioTerminalMap
  ?!@uint64list unused ioRightDerivation
  ?!@stringlist unused ioVocabularyListForDisplaying
:
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#  G E N E R A T I O N    F I L E W R A P P E R S                           *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper grammarGenerationTemplates in "../generation_templates/grammar_generation" {
} {
  template html "grammar.html.gTemplate"
    ?@string GRAMMAR_NAME
    ?@syntaxRuleListForGrammar SYNTAX_RULE_LIST
    ?@syntaxRuleListForGrammar PURE_SYNTAX_RULE_LIST
    ?@stringlist IDENTICAL_DERIVATION_ERROR_MESSAGE_LIST
    ?@string HTML_FILE_HEADER
    ?@string HTML_FILE_CONTENTS
#    ?@stringlist ALL_VOCABULARY_FOR_BDD
#    ?@vocabularyMap TERMINAL_MAP
#    ?@uint ADDITIONAL_NON_TERMINAL_COUNT_FOR_BDD
#    ?@vocabularyMap NON_TERMINAL_MAP
#    ?@uint BIT_COUNT_FOR_BDDS
#    ?@stringlist NON_TERMINAL_WITH_EMPTY_PRODUCTION_LIST
#    ?@relationStringList NON_TERMINAL_WITH_ONE_ELEMENT_PRODUCTION_LIST
#    ?@relationStringList NON_TERMINAL_WITH_TWO_ELEMENT_PRODUCTION_LIST
#    ?@stringlist USELESS_NON_TERMINAL_SYMBOL_LIST
#    ?@stringlist SYMBOLS_DIRECTLY_DERIVING_IN_EMPTY_STRING
#    ?@relationStringList FIRST_SET
#    ?@uint64 FIRST_SET_VALUE_COUNT
  ;
  template optionHeaderZone2 "grammar-zone2.h.gTemplate"
    ?@string GRAMMAR_NAME
    ?@grammarComponentRoot GRAMMAR_COMPONENT_ROOT
  ;
  template optionHeaderZone3 "grammar-zone3.h.gTemplate"
    ?@string GRAMMAR_NAME
    ?@grammarComponentRoot GRAMMAR_COMPONENT_ROOT
    ?@nonTerminalMap NON_TERMINAL_MAP
    ?@string LEXIQUE_CLASS
    ?@stringlist ADDED_NON_TERMINAL_LIST
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    R U L E    L I S T                                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildRuleList
  ??@string inSyntaxComponentName
  ??@syntaxRuleList inRuleList
  ?!@syntaxRuleListForGrammar ioSyntaxRuleListForGrammar
:
  foreach inRuleList do
  #--- We get only the first label (all syntax signatures are the same)
    @syntaxInstructionList instructionList ;
    [mLabelList first ?* ?* ?instructionList] ;
    @syntaxInstructionList syntaxInstructionList ;
    buildSyntaxInstructionList !instructionList ?syntaxInstructionList ;
    ioSyntaxRuleListForGrammar += !inSyntaxComponentName !mNonterminalName !syntaxInstructionList ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine compileGrammarComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  @grammarComponentRoot grammarComponentRoot ;
  grammar grammarLL1grammar in inSourceFile ?grammarComponentRoot ;
#---------------------------------------------------------- Check component name
  const @lstring grammarComponentName := [grammarComponentRoot mGrammarName] ;
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [grammarComponentName string] != basename then
    warning grammarComponentName: "GALGAS checks "
      "the component name ('" . [grammarComponentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ;
#---------------------------------------------------------- Parse syntax components
  @nonTerminalMap nonTerminalMap [emptyMap] ;
  @string lexiqueComponentName := "" ; # Empty string means unknown
  @syntaxRuleListForGrammar syntaxRuleListForGrammar [emptyList] ;
  foreach [grammarComponentRoot mSyntaxComponents] do
    if [mValue pathExtension] != "gSyntax" then
      error mValue: "a syntax component file should have '.gSyntax' as path extension" ;
    else
      @string syntaxComponentName := [[mValue lastPathComponent] stringByDeletingPathExtension] ;
      @syntaxComponentRoot syntaxComponentRoot ;
      if [[ioParsedComponentStruct mParsedSyntaxComponentMap] hasKey !syntaxComponentName] then
        [[ioParsedComponentStruct mParsedSyntaxComponentMap] searchKey ![@lstring new !syntaxComponentName !here] ?syntaxComponentRoot] ;
      else
        @string sourceFilePath := [mValue absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]] ;
        grammar syntaxSLRgrammar in [@lstring new !sourceFilePath ![mValue location]] ?syntaxComponentRoot ;
        [!?ioParsedComponentStruct.mParsedSyntaxComponentMap insertKey ![@lstring new !syntaxComponentName ![mValue location]] !syntaxComponentRoot] ;
      end if ;
    #--- Handle lexique component
      @string currentLexiqueName := [[[syntaxComponentRoot mImportedLexiqueReference] lastPathComponent] stringByDeletingPathExtension] ;
      if lexiqueComponentName == "" then
        lexiqueComponentName := currentLexiqueName ;
      elsif lexiqueComponentName != currentLexiqueName then
        error mValue : "this syntax component uses '"
          . currentLexiqueName . "' lexique component, but the first syntax component uses the '"
          . lexiqueComponentName . "' lexique component (they should be the same)" ;
      end if ;
    #--- Handle non terminal declarations
      handleNonTerminalDeclarations
        !?nonTerminalMap
        ![syntaxComponentRoot mNonterminalDeclarationList]
      ;
    #--- Handle syntax rules
      buildRuleList
        !syntaxComponentName
        ![syntaxComponentRoot mRuleList]
        !?syntaxRuleListForGrammar
      ;
    end if ;
  end foreach ;
#---------------------------------------------------------- Build pure BNF productions
  @syntaxRuleListForGrammar pureSyntaxRuleListForGrammar [emptyList] ;
  @syntaxRuleListForGrammar addedPureSyntaxRuleListForGrammar [emptyList] ;
  @stringlist addedNonTerminalList [emptyList] ;
  @string currentSyntaxComponentName := "" ;
  @uint addedRuleIndex := 0 ;
  foreach syntaxRuleListForGrammar do
    if currentSyntaxComponentName != mSyntaxComponentName then
      currentSyntaxComponentName := mSyntaxComponentName  ;
      addedRuleIndex := 0 ;
    end if ;
    @syntaxInstructionList pureSyntaxInstructionList ;
    buildPureSyntaxInstructionList
      !mSyntaxComponentName
      !mSyntaxInstructionList
      ?pureSyntaxInstructionList
      !?addedPureSyntaxRuleListForGrammar
      !?addedNonTerminalList
      !?addedRuleIndex
    ;
    pureSyntaxRuleListForGrammar +=
      !mSyntaxComponentName
      !mLeftNonTerminal
      !pureSyntaxInstructionList
    ;
  end foreach ;
#--- Append added production
  pureSyntaxRuleListForGrammar .= addedPureSyntaxRuleListForGrammar ;
#--- Append production for start symbol <>
  @syntaxInstructionList syntaxInstructionList [emptyList] ;
  syntaxInstructionList += ![@nonterminalCallInstruction new
    ![grammarComponentRoot mStartSymbol]
    ![@lstring new !"" !here] # no Label
    ![@actualParameterList emptyList]
  ] ;
  syntaxInstructionList += ![@terminalCheckInstruction new
    ![@lstring new !"" !here] # The terminal symbol is $$
    ![@actualInputParameterList emptyList]
  ] ;
  pureSyntaxRuleListForGrammar +=
    !""
    ![@lstring new !"" !here] # Start symbol is <>
    !syntaxInstructionList
  ;
  if [option .verbose_output] then
    message "  Building pure BNF productions... " . [[pureSyntaxRuleListForGrammar length] string] . " productions\n" ;
  end if ;  
#---------------------------------------------------------- Build Vocabulary...
#                                                   ... and  production list map
  if [option .verbose_output] then
    message "  Checking all productions are differents..." ;
  end if ;  
  @string htmlOutputFileName := [inSourceFile stringByDeletingPathExtension] . ".html" ;
  @productionListMap productionListMap [emptyMap] ;
  @stringlist identicalDerivationErrorMessageList [emptyList] ;
  @stringlist vocabularyListForDisplaying [emptyList] ;
  @uint additionalNonTerminalSymbolsForPureBDDrules := 0 ;
#--- Enter terminal symbols
  @vocabularyMap terminalMap [emptyMap] ;
  foreach pureSyntaxRuleListForGrammar do
    foreach mSyntaxInstructionList do
      [mInstruction enterTerminalSymbolIntoVocabulary !?terminalMap !?vocabularyListForDisplaying] ;
    end foreach ;
  end foreach ;
  @uint terminalSymbolCount := [terminalMap count] ;
#--- Enter non terminal symbols
  @vocabularyMap nonterminalMap [emptyMap] ;
  foreach pureSyntaxRuleListForGrammar :idx do
    if not [nonterminalMap hasKey ![mLeftNonTerminal string]] then
      [!?nonterminalMap insertKey !mLeftNonTerminal ![terminalMap count] + [nonterminalMap count]] ;
      vocabularyListForDisplaying += !"<" . mLeftNonTerminal . ">" ;
    end if ;
    if [mSyntaxInstructionList length] > 2 then
      additionalNonTerminalSymbolsForPureBDDrules := additionalNonTerminalSymbolsForPureBDDrules + [mSyntaxInstructionList length] - 2 ;
    end if ;
    @uint64list rightDerivation [emptyList] ;
    foreach mSyntaxInstructionList do
      [mInstruction enterNonTerminalSymbolIntoVocabulary !?nonterminalMap !terminalMap !?rightDerivation !?vocabularyListForDisplaying] ;
    end foreach ;
  #--- Check production is dictinct from previous ones
    @derivationList previousDerivations := [productionListMap listForKey ![mLeftNonTerminal string]] ;
    @bool ok := true ;
    foreach previousDerivations while ok do
      if mDerivation == rightDerivation then
        ok := false ;
        if [option .verbose_output] & ([identicalDerivationErrorMessageList length] == 0) then
          message " error\n" ;
        end if ;  
        @string errorMessage := "for <"
        . mLeftNonTerminal
        . "> non terminal, productions "
        . [mProductionIndex string]
        . " and " . [idx string] . " are identical" ;
        identicalDerivationErrorMessageList += !errorMessage ;
        if [option galgas_cli_options.outputHTMLgrammarFile] then
          errorMessage .= " (for details, see " . htmlOutputFileName . " file)" ;
        else
          errorMessage .= " (for details, turn on '--output-html-grammar-file' option and see " . htmlOutputFileName . " file)" ;
        end if ;
        error mLeftNonTerminal:errorMessage ;
      end if ;
    end foreach ;
    if ok then
      @uint leftTerminalIndex ;
      [nonterminalMap searchKey !mLeftNonTerminal ?leftTerminalIndex] ;
      productionListMap += ![mLeftNonTerminal string] ![leftTerminalIndex uint64] !idx !rightDerivation ;
    end if ;
  end foreach ;
  if [option .verbose_output] & ([identicalDerivationErrorMessageList length] == 0) then
    message " ok\n" ;
  end if ;  
#---------------------------------------------------------- Symbols declared unused
  @uintlist unusedNonterminalSymbolList [emptyList] ;
  foreach [grammarComponentRoot mUnusedNonterminalList] do
    with !?nonterminalMap searchKey !mValue do
      unusedNonterminalSymbolList += !mIndex ;
    else
      error mValue : "the '<" . mValue . ">' non terminal is not declared by syntax components" ;
    end with ;
  end foreach ;
#---------------------------------------------------------- Start symbol
  @uint startSymbolIndex ;
  with !?nonterminalMap searchKey ![grammarComponentRoot mStartSymbol] do
    startSymbolIndex := mIndex ;
  else
    error [grammarComponentRoot mStartSymbol] : "the '<" . [grammarComponentRoot mStartSymbol]
    . ">' non terminal is not declared by syntax components, it cannot be used as start symbol"
    -> startSymbolIndex ;
  end with ;
#---------------------------------------------------------- Analyze grammar
  @string HTMLFileHeader ;
  @string HTMLFileContents ;
  newGrammarAnalyzer
    !grammarComponentName
    !startSymbolIndex
    !lexiqueComponentName
    !nonterminalMap
    !terminalMap
    !productionListMap
    !unusedNonterminalSymbolList
    ?HTMLFileHeader
    ?HTMLFileContents
  ;
##---------------------------------------------------------- BDD parameters
#  const @uint terminalCount := [terminalMap count] ;
#  const @uint vocabularyCount := terminalCount + [nonterminalMap count] + additionalNonTerminalSymbolsForPureBDDrules ;
#  const @uint startSymbolIndexForBDD := terminalCount + [nonterminalMap count] - 1 ;
#  const @uint bitCountForBDDs := [vocabularyCount significantBitCount] ;
##  log additionalNonTerminalSymbolsForPureBDDrules ;
#  @uint idx := 0 ;
#  loop additionalNonTerminalSymbolsForPureBDDrules :
#  while idx < additionalNonTerminalSymbolsForPureBDDrules  do
#    vocabularyListForDisplaying += !"<" . [idx string] . ">" ;
#    idx ++ ;
#  end loop ;
#  
##---------------------------------------------------------- Building pure BDD rules
#  @binaryset nonTerminalsWithEmptyProduction [emptyBinarySet] ; # Set of <T>, with <T> ::= ^ rule
#  @binaryset productionsWithSingleDerivation [emptyBinarySet] ; # Set of (T, X), with <T> ::= X rule
#  @binaryset productionsWithDoubleDerivation [emptyBinarySet] ; # Set of (T, X, Y), with <T> ::= X Y rule
#  @uint64 addedNonTerminalIndex := [terminalCount + [nonterminalMap count] uint64] ;
#  foreach productionListMap do
#    @uint nonterminalIndex ;
#    [nonterminalMap searchKey ![@lstring new !key !here] ?nonterminalIndex] ;
#    foreach object do
#      if [mDerivation length] == 0 then # Empty derivation
#        nonTerminalsWithEmptyProduction := nonTerminalsWithEmptyProduction |
#          [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs ![nonterminalIndex uint64]]
#        ;
#      elsif [mDerivation length] == 1 then # Single derivation
#        const @uint64 derivation0 := [mDerivation mValueAtIndex !0] ;
#        productionsWithSingleDerivation := productionsWithSingleDerivation
#         | ([@binaryset binarySetWithEqualToConstant !bitCountForBDDs !bitCountForBDDs ![nonterminalIndex uint64]]
#          & [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs !derivation0]
#           ) ;
#      elsif [mDerivation length] == 2 then # Double derivation
#        const @uint64 derivation0 := [mDerivation mValueAtIndex !0] ;
#        const @uint64 derivation1 := [mDerivation mValueAtIndex !1] ;
#        productionsWithDoubleDerivation := productionsWithDoubleDerivation
#         | ([@binaryset binarySetWithEqualToConstant !bitCountForBDDs + bitCountForBDDs !bitCountForBDDs ![nonterminalIndex uint64]]
#          & [@binaryset binarySetWithEqualToConstant !bitCountForBDDs !bitCountForBDDs !derivation0]
#          & [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs !derivation1]
#           ) ;
#      else
#        @uint64 currentLeftNonTerminal := [nonterminalIndex uint64] ;
#        foreach mDerivation :idx do
#          if idx < ([mDerivation length] - 2) then
#            const @uint64 derivation := [mDerivation mValueAtIndex !idx] ;
#            productionsWithDoubleDerivation := productionsWithDoubleDerivation
#             | ([@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs !currentLeftNonTerminal]
#                & [@binaryset binarySetWithEqualToConstant !bitCountForBDDs !bitCountForBDDs !derivation]
#                & [@binaryset binarySetWithEqualToConstant !bitCountForBDDs + bitCountForBDDs !bitCountForBDDs !addedNonTerminalIndex]
#               ) ;
#            currentLeftNonTerminal := addedNonTerminalIndex ;
#            addedNonTerminalIndex ++ ;
#          elsif idx == ([mDerivation length] - 2) then
#            const @uint64 derivation0 := [mDerivation mValueAtIndex !idx] ;
#            const @uint64 derivation1 := [mDerivation mValueAtIndex !idx+1] ;
#            productionsWithDoubleDerivation := productionsWithDoubleDerivation
#             | ([@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs !currentLeftNonTerminal]
#                & [@binaryset binarySetWithEqualToConstant !bitCountForBDDs !bitCountForBDDs !derivation0]
#                & [@binaryset binarySetWithEqualToConstant !bitCountForBDDs + bitCountForBDDs !bitCountForBDDs !derivation1]
#               ) ;
#           end if ;
#        end foreach ;
#      end if ;
#    end foreach ;
#  end foreach ;
##---------------------------------------------------------- Computing useful vocabulary
#  if [option .verbose_output] then
#    message "  Checking all non terminal symbols are useful..." ;
#  end if ;
##--- elementaryUtility (X, Y) : if X is useful, then Y is useful
#  @binaryset elementaryUtility := productionsWithSingleDerivation ; # Single derivations are useful
##--- Double derivation T ::= X Y : Add (T, X)
#  elementaryUtility := elementaryUtility | [productionsWithDoubleDerivation existOnBitIndexAndBeyond!bitCountForBDDs + bitCountForBDDs] ;
#  elementaryUtility := elementaryUtility | [[productionsWithDoubleDerivation swap132 !bitCountForBDDs !bitCountForBDDs !bitCountForBDDs] existOnBitIndexAndBeyond!bitCountForBDDs + bitCountForBDDs] ;
##--- Double derivation T ::= X Y : Add (T, Y)
##  foreach productionListMap do
##    @binaryset derivation [emptyBinarySet] ;
##    foreach object do
##      foreach mDerivation do
##        derivation := derivation | [@binaryset binarySetWithEqualToConstant !bitCountForBDDs !bitCountForBDDs !mValue] ;
##      end foreach ;
##    end foreach ;
##    @uint nonterminalIndex ;
##    [nonterminalMap searchKey ![@lstring new !key !here] ?nonterminalIndex] ;
##    derivation := derivation & [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs ![nonterminalIndex uint64]] ;
##    elementaryUtility := elementaryUtility | derivation ;
##  end foreach ;
##--- Computing transitive closure
#  const @binaryset startSymbol [binarySetWithEqualToConstant !0 !bitCountForBDDs ![startSymbolIndexForBDD uint64]] ;
#  const @binaryset usefulSymbols := [elementaryUtility accessibleStates !startSymbol !bitCountForBDDs] ;
##--- Compute and display useless symbols
#  const @binaryset allSymbols [binarySetWithLowerOrEqualToConstant !0 !bitCountForBDDs ![vocabularyCount - 1 uint64]] ;
#  const @binaryset unusefulSymbols := allSymbols & ~ usefulSymbols ;
#  @binaryset unusefulNonTerminals := unusefulSymbols & [@binaryset binarySetWithGreaterOrEqualToConstant !0 !bitCountForBDDs ![terminalCount uint64]] ;
#  foreach [grammarComponentRoot mUnusedNonterminalList] do
#    @uint nonTerminalSymbolIndex ;
#    [nonterminalMap searchKey !mValue ?nonTerminalSymbolIndex] ;
#    unusefulNonTerminals := unusefulNonTerminals & ~ [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs ![nonTerminalSymbolIndex uint64]] ;
#  end foreach ;
#  const @stringlist unusefulNonTerminalList := [unusefulNonTerminals stringValueListWithNameList !bitCountForBDDs !vocabularyListForDisplaying] ;
#  if [option .verbose_output] then
#    message if [unusefulNonTerminalList length] == 0 then " ok\n" else " warning\n" end ;
#  end if ;
#  if [unusefulNonTerminalList length] > 0 then
#    @string errorMessage := "the grammar contains "
#    . [[unusefulNonTerminalList length] string]
#    . " useless symbol" . if [unusefulNonTerminalList length] > 1 then "s" else "" end . ": " ;
#    foreach unusefulNonTerminalList
#    do errorMessage .= mValue ;
#    between errorMessage .= ", " ;
#    end foreach ;
#    warning here: errorMessage ;
#  end if ;
##---------------------------------------------------------- Check nonterminal symbols declared as useless are actually useless
#  foreach [grammarComponentRoot mUnusedNonterminalList] do
#    @uint nonTerminalSymbolIndex ;
#    [nonterminalMap searchKey !mValue ?nonTerminalSymbolIndex] ;
#    if [usefulSymbols containsValue ![nonTerminalSymbolIndex uint64] !0 !bitCountForBDDs] then
#      warning mValue : "the '<" . mValue . ">' non terminal is declared as unused, but it is actually useful" ;
#    end if ;
#  end foreach ;
##---------------------------------------------------------- Symbols deriving in empty string
#  @binaryset symbolsDirectlyDerivingInEmptyString [emptyBinarySet] ;
#  foreach productionListMap do
#    foreach object do
#      if [mDerivation length] == 0 then
#        symbolsDirectlyDerivingInEmptyString := symbolsDirectlyDerivingInEmptyString
#          | [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs !mLeftTerminalIndex] ;
#      end if ;
#    end foreach ;
#  end foreach ;
##---------------------------------------------------------- Computing FIRST set
#  @binaryset elementaryFIRSTset [emptyBinarySet] ;
#  foreach productionListMap do
#    @binaryset elementaryFIRSTsetForNonTerminal [emptyBinarySet] ;
#    @uint64 leftNonTerminalIndex := 0L ;
#    foreach object do
#      if [mDerivation length] > 0 then
#        leftNonTerminalIndex := mLeftTerminalIndex ;
#        @uint64 firstSymbol ;
#        [mDerivation first ?firstSymbol] ;
#        elementaryFIRSTsetForNonTerminal := elementaryFIRSTsetForNonTerminal | [@binaryset binarySetWithEqualToConstant !0 !bitCountForBDDs !firstSymbol] ;
#      end if ;
#    end foreach ;
#    elementaryFIRSTset := elementaryFIRSTset | (elementaryFIRSTsetForNonTerminal & [@binaryset binarySetWithEqualToConstant !bitCountForBDDs !bitCountForBDDs !leftNonTerminalIndex]) ;
#  end foreach ;
#---------------------------------------------------------- Build HTML file
  if [option galgas_cli_options.outputHTMLgrammarFile] then
#    const @stringlist listOfSymbolsDirectlyDerivingInEmptyString := [symbolsDirectlyDerivingInEmptyString stringValueListWithNameList !bitCountForBDDs !vocabularyListForDisplaying] ;
    @string s := [filewrapper grammarGenerationTemplates.html
      ![grammarComponentName string]
      !syntaxRuleListForGrammar
      !pureSyntaxRuleListForGrammar
      !identicalDerivationErrorMessageList
      !HTMLFileHeader
      !HTMLFileContents
#      !vocabularyListForDisplaying
#      !terminalMap
#      !additionalNonTerminalSymbolsForPureBDDrules
#      !nonterminalMap
#      !bitCountForBDDs
#      ![nonTerminalsWithEmptyProduction stringValueListWithNameList !bitCountForBDDs !vocabularyListForDisplaying]
#      ![productionsWithSingleDerivation relationStringListWithNameList !bitCountForBDDs !vocabularyListForDisplaying]
#      ![productionsWithDoubleDerivation tripleRelationStringListWithNameList !bitCountForBDDs !vocabularyListForDisplaying]
#      !unusefulNonTerminalList
#      !listOfSymbolsDirectlyDerivingInEmptyString
#      ![elementaryFIRSTset relationStringListWithNameList !bitCountForBDDs !vocabularyListForDisplaying]
#      ![elementaryFIRSTset valueCount !bitCountForBDDs + bitCountForBDDs]
    ] ;
    [s writeToFileWhenDifferentContents !htmlOutputFileName ?*] ;
  else
    [@string deleteFileIfExists !htmlOutputFileName] ;
  end if ;
#---------------------------------------------------------- Generate Header file
  if [@uint errorCount] == 0 then
    [@string generateFile
      !inOutputDirectory
      ![grammarComponentName string] . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper grammarGenerationTemplates.optionHeaderZone2
        ![grammarComponentName string]
        !grammarComponentRoot
      ]
      !"\n\n" # Defaut user zone2
      ![filewrapper grammarGenerationTemplates.optionHeaderZone3
        ![grammarComponentName string]
        !grammarComponentRoot
        !nonTerminalMap
        !lexiqueComponentName
        !addedNonTerminalList
      ]
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
