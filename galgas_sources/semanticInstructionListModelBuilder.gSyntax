#---------------------------------------------------------------------------*
#                                                                           *
#  'metamodel' component parser, as model builder                           *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax semanticInstructionListModelBuilder :
import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import metamodel expressionMetamodel in "expressionMetamodel.gMetamodel" ;
import metamodel parameterArgumentMetamodel in "parameterArgumentMetamodel.gMetamodel" ;
import metamodel instructionMetamodel in "instructionMetamodel.gMetamodel" ;

#---------------------------------------------------------------------------*

nonterminal <semantic_instruction_list> -> @semanticInstructions ;

nonterminal <semantic_instruction> -> @semanticInstruction ;

nonterminal <expression> -> @semanticExpression ;

nonterminal <foreach_enumerated_object> -> @foreachInstructionEnumeratedObject ;

nonterminal <actual_parameter_list> -> @actualParameters ;

nonterminal <match_instruction_branch> -> @matchInstructionBranch ;

nonterminal <cast_instruction_branch> -> @castInstructionBranch ;

nonterminal <cast_else_or_default> -> @elseOrDefaultForCastInstruction ;

nonterminal <output_expression_list> -> @outExpressionList ;

nonterminal <match_entry> -> @matchEntry ;

nonterminal <semantic_declaration> -> @semanticDeclaration ;

nonterminal <formal_parameter_list> -> @formalParameters ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E M A N T I C    I N S T R U C T I O N    L I S T                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction_list> -> @semanticInstructions :
  repeat
  while
    <semantic_instruction> +> mInstruction ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    R O U T I N E    D E C L A R A T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_declaration> -> @routineDeclaration :
  $routine$ ;
  $identifier$ ? mRoutineName ;
  <formal_parameter_list> -> mFormalParameters ;
  $:$ ;
  <semantic_instruction_list> -> mRoutineInstructions ;
  $end$ ;
  $routine$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E X T E R N    A C T I O N    D E C L A R A T I O N                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_declaration> -> @actionDeclaration :
  $action$ ;
  $identifier$ ? mActionName ;
  <formal_parameter_list> -> mFormalParameters ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  L O C A L    V A R I A B L E    D E C L A R A T I O N                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @semanticInstruction instruction :
  @lstring typeName ;
  $type_name$ ? typeName ;
  @lstring variableName ;
  $identifier$ ? variableName ;
  select
    instruction := [@localVariableDeclaration new !typeName !variableName] ;
  or
    $:=$ ;
    @semanticExpression sourceExpression ;
    <expression> -> sourceExpression ;
    instruction := [@localVariableDeclarationWithAssignment new !typeName !variableName !sourceExpression] ;
  or
    $[$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @outExpressionList expressionList ;
    <output_expression_list> -> expressionList ;
    instruction := [@localVariableDeclarationWithInitialization new !typeName !variableName !constructorName !expressionList] ;
    $]$ ;
  end select ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    A S S I G N M E N T    I N S T R U C T I O N                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @assignmentInstruction :
  $identifier$ ? mTargetVariableName ;
  $:=$ ;
  <expression> -> mSourceExpression ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    I N C R E M E N T    I N S T R U C T I O N                             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @incrementInstruction :
  $identifier$ ? mReceiverName ;
  $++$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    D E C R E M E N T    I N S T R U C T I O N                             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @decrementInstruction :
  $identifier$ ? mReceiverName ;
  $--$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    F O R E A C H    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <foreach_enumerated_object> -> @foreachInstructionEnumeratedObject :
  <expression> -> mEnumeratedExpression ;
  $($ ;
  repeat
  while
    $*$ ;
    mElements += ![@foreachInstructionJoker new] ;
  while
    @luint count ;
    $unsigned_literal_integer$ ?count ;
    $*$ ;
    @uint n := [count uint] ;
    if n == 0 then
      error count: "this value should be > 0" ;
    end if ;
    loop n :
    while n > 0 do
      mElements += ![@foreachInstructionJoker new] ;
      n -- ;
    end loop ;
  while
    @lstring typeName ;
    $type_name$ ?typeName ;
    @lstring constantName ;
    $identifier$ ?constantName ;
    @foreachInstructionEnumeratedConstant c [new !typeName !constantName] ;
    mElements += !c ;
  end repeat ;
  select
    mEndsWithEllipsis := false ;
  or
    $...$ ;
    mEndsWithEllipsis := true ;
  end select ;
  $)$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @foreachInstruction :
  $foreach$ ;
  repeat
    <foreach_enumerated_object> +> mEnumeratedObjects ;
  while
    $,$ ;
  end repeat ;
  select
    mWhileExpression := [@trueExpression new !here] ;
  or
    $while$ ;
    <expression> -> mWhileExpression ;
  end select ;
  $:$ ;
  <semantic_instruction_list> -> mInstructionList ;
  $end$ ;
  $foreach$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    I F    I N S T R U C T I O N                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @ifInstruction :
  $if$ ;
  repeat
    <expression> +> mIFexpressionList ;
    $then$ ;
    <semantic_instruction_list> +> mIFinstructionListList ;
  while
    $elsif$ ;
  end repeat ;
  select
  or
    $else$ ;
    <semantic_instruction_list> +> mElseInstructionList ;
  end select ;
  $end$ ;
  $if$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M E T H O D    C A L L    I N S T R U C T I O N                        *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @methodCallInstruction :
  $[$ ;
  <expression> -> mReceiverExpression ;
  $identifier$ ?mMethodName ;
  <actual_parameter_list> -> mActualParameterList ;
  $]$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M O D I F I E R    C A L L    I N S T R U C T I O N                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @modifierCallInstruction :
  $[$ ;
  $!?$ ;
  $identifier$ ?mReceiverName ;
  $identifier$ ?mModifierName ;
  <actual_parameter_list> -> mActualParameterList ;
  $]$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E R R O R    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @errorInstruction :
  $error$ ;
  <expression> -> mReceiverExpression ;
  $:$ ;
  <expression> -> mErrorExpression ;
  mBuiltVariableList := [@lstringlist emptyList] ;
  select
  or
    $->$ ;
    repeat
     @lstring builtVariableName ;
     $identifier$ ? builtVariableName ;
     mBuiltVariableList += !builtVariableName ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    W A R N I N G    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @warningInstruction :
  $warning$ ;
  <expression> -> mReceiverExpression ;
  $:$ ;
  <expression> -> mErrorExpression ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    R O U T I N E    C A L L    I N S T R U C T I O N                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @routineCallInstruction :
  $identifier$ ? mRoutineName ;
  <actual_parameter_list> -> mActualParameterList ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M A T C H    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <match_entry> -> @constantMatchEntry :
  $identifier$ ? mConstantName ;
end rule ;

#---------------------------------------------------------------------------*

rule <match_entry> -> @classMatchEntry :
  $type_name$ ? mClassName ;
  $($ ;
  repeat
  while
    $*$ ;
    mElements += ![@foreachInstructionJoker new] ;
  while
    @luint count ;
    $unsigned_literal_integer$ ?count ;
    $*$ ;
    @uint n := [count uint] ;
    if n == 0 then
      error count: "this value should be > 0" ;
    end if ;
    loop n :
    while n > 0 do
      mElements += ![@foreachInstructionJoker new] ;
      n -- ;
    end loop ;
  while
    @lstring typeName ;
    $type_name$ ?typeName ;
    @lstring constantName ;
    $identifier$ ?constantName ;
    @foreachInstructionEnumeratedConstant c [new !typeName !constantName] ;
    mElements += !c ;
  end repeat ;
  select
    mEndsWithEllipsis := false ;
  or
    $...$ ;
    mEndsWithEllipsis := true ;
  end select ;
  $)$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <match_instruction_branch> -> @matchInstructionBranch :
  $when$ ;
  repeat
    <match_entry> +> mMatchedEntryList ;
  while
    $::$ ;
  end repeat ;
  $:$ ;
  <semantic_instruction_list> -> mMatchBranchInstructionList ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @matchInstruction :
  $match$ ;
  mMatchedVariableNameList := [@lstringlist emptyList] ;
  @lstring matchedVariableName ;
  $identifier$ ? matchedVariableName ;
  mMatchedVariableNameList += !matchedVariableName ;
  $::$ ;
  repeat
    $identifier$ ? matchedVariableName ;
    mMatchedVariableNameList += !matchedVariableName ;
  while
    $::$ ;
  end repeat ;
  $:$ ;
  repeat
    <match_instruction_branch> +> mMatchInstructionBranchList ;
  while
  end repeat ;
  select
  or
    $else$ ;
    <semantic_instruction_list> +> mElseInstructionList ;
  end select ;
  $end$ ;
  $match$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    C A S T    I N S T R U C T I O N                                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <cast_instruction_branch> -> @castInstructionBranch :
  $when$ ;
  select
    $>=$ ;
    mUseKindOfClass := true ;
  or
    $==$ ;
    mUseKindOfClass := false ;
  end select ;
  $type_name$ ? mTypeName ;
  select
    $identifier$ ?mConstantVarName ;
    mConstantVarNameIsUnused := false ;
  or
    $unused$ ;
    $identifier$ ?mConstantVarName ;
    mConstantVarNameIsUnused := true ;
  or
    mConstantVarName := [@lstring new !"" !here] ;
    mConstantVarNameIsUnused := true ;
  end select ;
  $do$ ;
  <semantic_instruction_list> -> mCastBranchInstructionList ;
end rule ;

#---------------------------------------------------------------------------*

rule <cast_else_or_default> -> @elseForCastInstruction :
  $else$ ;
  <semantic_instruction_list> -> mElseInstructionList ;
end rule ;

#---------------------------------------------------------------------------*

rule <cast_else_or_default> -> @defaultForCastInstruction :
  $default$ ;
  $error$ ;
  <expression> -> mErrorLocationExpression ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @castInstruction :
  $cast$ ;
  <expression> -> mExpression ;
  $:$ ;
  repeat
    <cast_instruction_branch> +> mCastInstructionBranchList ;
  while
  end repeat ;
  <cast_else_or_default> -> mElseOrDefault ;
  $end$ ;
  $cast$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    A P P E N D    I N S T R U C T I O N    + =                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @appendInstruction :
  $identifier$ ? mReceiverName ;
  $+=$ ;
  <output_expression_list> -> mExpressionList ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    L O O P    I N S T R U C T I O N                                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @loopInstruction :
  $loop$ ;
  <expression> -> mVariantExpression ;
  $:$ ;
  <semantic_instruction_list> -> mFirstInstructions ;
  $while$ ;
  <expression> -> mLoopExpression ;
  $do$ ;
  <semantic_instruction_list> -> mSecondInstructions ;
  $end$ ;
  $loop$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M E S S A G E    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @messageInstruction :
  $message$ ;
  <expression> -> mExpression ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    L O G    I N S T R U C T I O N                                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @logInstruction :
  $log$ ;
  mLoggedVariableList := [@lstringlist emptyList] ;
  repeat
    @lstring loggedVariableName ;
    $identifier$ ? loggedVariableName ;
    mLoggedVariableList += !loggedVariableName ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  G R A M M A R    I N S T R U C T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> -> @grammarInstruction :
  $grammar$ ;
  $identifier$ ?mGrammarComponentName ;
  select
    mLabelName := [@lstring new !"" !here] ;
  or
    $label$ ;
    $identifier$ ?mLabelName ;
  end select ;
  $in$ ;
  <expression> -> mSourceFileExpression ;
  <actual_parameter_list> -> mActualParameterList ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
