#---------------------------------------------------------------------------*
#                                                                           *
#  'metamodel' component parser, as model builder                           *
#                                                                           *
#  Copyright (C) 2007, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax semanticInstructionListModelBuilder :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import semantics expressionMetamodel in "expressionMetamodel.gSemantics" ;
import semantics parameterArgumentMetamodel in "parameterArgumentMetamodel.gSemantics" ;
import semantics instructionMetamodel in "instructionMetamodel.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression> !@semanticExpression outExpression ;

nonterminal <formal_parameter_list> !@formalParameterList outFormalParameterList ;

nonterminal <actual_parameter_list> !@actualParameterList outActualParameterList ;

nonterminal <semantic_instruction_list> !@semanticInstructionList outInstructionsList ;

nonterminal <semantic_instruction> !@semanticInstruction outInstruction ;

nonterminal <output_expression_list> !@outExpressionList outExpressionList ;

nonterminal <semantic_declaration>
 ?!@semanticDeclarationStruct ioSemanticDeclarations
;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E M A N T I C    I N S T R U C T I O N    L I S T                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction_list> !@semanticInstructionList outInstructionsList :
  outInstructionsList := [@semanticInstructionList emptyList] ;
  repeat
  while
    @semanticInstruction instruction ;
    <semantic_instruction> ? instruction ;
    outInstructionsList += !instruction ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    R O U T I N E    D E C L A R A T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationStruct ioSemanticDeclarations
:
  $routine$ ;
  $identifier$ ? @lstring mRoutineName ;
  @formalParameterList mFormalParameterList ;
  <formal_parameter_list> ? mFormalParameterList ;
  $:$ ;
  @semanticInstructionList mRoutineInstructionList ;
  <semantic_instruction_list> ? mRoutineInstructionList ;
  $end$ ;
  $routine$ ;
  $;$ ;
  ioSemanticDeclarations.mSemanticDeclarationList += ![@routineDeclaration new
    !mRoutineName
    !mFormalParameterList
    !mRoutineInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E X T E R N    R O U T I N E    D E C L A R A T I O N                  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationStruct ioSemanticDeclarations
:
  $extern$ ;
  $routine$ ;
  $identifier$ ? @lstring mActionName ;
  @formalParameterList mFormalParameterList ;
  <formal_parameter_list> ? mFormalParameterList ;
  $;$ ;
  ioSemanticDeclarations.mSemanticDeclarationList += ![@externRoutineDeclaration new
    !mActionName
    !mFormalParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    F U N C T I O N    D E C L A R A T I O N                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationStruct ioSemanticDeclarations
:
  $function$ ;
  $identifier$ ? @lstring mRoutineName ;
  @formalParameterList mFormalParameterList ;
  <formal_parameter_list> ? mFormalParameterList ;
  $->$ ;
  $type_name$ ?@lstring resultTypeName ;
  $identifier$ ?@lstring resultVariableName ;
  $:$ ;
  @semanticInstructionList mRoutineInstructionList ;
  <semantic_instruction_list> ? mRoutineInstructionList ;
  $end$ ;
  $function$ ;
  $;$ ;
  ioSemanticDeclarations.mSemanticDeclarationList += ![@functionDeclaration new
    !mRoutineName
    !mFormalParameterList
    !resultTypeName
    !resultVariableName
    !mRoutineInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E X T E R N    F U N C T I O N    D E C L A R A T I O N                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_declaration>
 ?!@semanticDeclarationStruct ioSemanticDeclarations
:
  $extern$ ;
  $function$ ;
  $identifier$ ? @lstring mActionName ;
  @formalParameterList mFormalParameterList ;
  <formal_parameter_list> ? mFormalParameterList ;
  $->$ ;
  $type_name$ ?@lstring resultTypeName ;
  $identifier$ ?@lstring resultVariableName ;
  $;$ ;
  ioSemanticDeclarations.mSemanticDeclarationList += ![@externFunctionDeclaration new
    !mActionName
    !mFormalParameterList
    !resultTypeName
    !resultVariableName
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  L O C A L    V A R I A B L E    D E C L A R A T I O N                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $type_name$ ?@lstring typeName ;
  $identifier$ ?@lstring variableName ;
  select
    outInstruction := [@localVariableDeclaration new !typeName !variableName] ;
  or
    $:=$ ;
    @semanticExpression sourceExpression ;
    <expression> ? sourceExpression ;
    outInstruction := [@localVariableDeclarationWithAssignment new !typeName !variableName !sourceExpression] ;
  or
    $[$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @outExpressionList expressionList ;
    <output_expression_list> ? expressionList ;
    outInstruction := [@localVariableDeclarationWithInitialization new !typeName !variableName !constructorName !expressionList] ;
    $]$ ;
  end select ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    A S S I G N M E N T    I N S T R U C T I O N                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $identifier$ ?@lstring mTargetVariableName ;
  $:=$ ;
  @semanticExpression mSourceExpression ;
  <expression> ? mSourceExpression ;
  $;$ ;
  outInstruction := [@assignmentInstruction new
    !mTargetVariableName
    !mSourceExpression
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    I N C R E M E N T    I N S T R U C T I O N                             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $identifier$ ? @lstring mReceiverName ;
  $++$ ;
  $;$ ;
  outInstruction := [@incrementInstruction new !mReceiverName] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    D E C R E M E N T    I N S T R U C T I O N                             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $identifier$ ?@lstring mReceiverName ;
  $--$ ;
  $;$ ;
  outInstruction := [@decrementInstruction new !mReceiverName] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    F O R E A C H    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

nonterminal <foreach_enumerated_object>
  ?!@foreachInstructionEnumeratedObjectList ioForeachInstructionEnumeratedObjectList
;

#---------------------------------------------------------------------------*

rule <foreach_enumerated_object>
  ?!@foreachInstructionEnumeratedObjectList ioForeachInstructionEnumeratedObjectList
:
  @bool ascending ;
  select
    ascending := true ;
  or
    $<$ ;
    ascending := true ;
  or
    $>$ ;
    ascending := false ;
  end select ;
  @semanticExpression mEnumeratedExpression ;
  <expression> ? mEnumeratedExpression ;
  @foreachInstructionEnumeratedObjectElementList mElementList [emptyList] ;
  @bool mEndsWithEllipsis ;
  select
    mEndsWithEllipsis := false ;
  or
    $($ ;
    repeat
    while
      $*$ ;
      mElementList += ![@foreachInstructionJoker new] ;
    while
      @luint count ;
      $unsigned_literal_integer$ ?count ;
      $*$ ;
      @uint n := [count uint] ;
      if n == 0 then
        error count: "this value should be > 0" ;
      end if ;
      loop n :
      while n > 0 do
        mElementList += ![@foreachInstructionJoker new] ;
        n -- ;
      end loop ;
    while
      @lstring typeName ;
      $type_name$ ?typeName ;
      @lstring constantName ;
      $identifier$ ?constantName ;
      @foreachInstructionEnumeratedConstant c [new !typeName !constantName] ;
      mElementList += !c ;
    end repeat ;
    select
      mEndsWithEllipsis := false ;
    or
      $...$ ;
      mEndsWithEllipsis := true ;
    end select ;
    $)$ ;
  end select ;
  ioForeachInstructionEnumeratedObjectList +=
    !ascending
    !mEnumeratedExpression
    !mElementList
    !mEndsWithEllipsis
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $foreach$ ;
  @foreachInstructionEnumeratedObjectList mEnumeratedObjectList [emptyList] ;
  repeat
    <foreach_enumerated_object> !?mEnumeratedObjectList ;
  while
    $,$ ;
  end repeat ;
  @lstring mIndexVariableName ;
  select
    mIndexVariableName := [@lstring new !"" !here] ;
  or
    $:$ ;
    $identifier$ ? mIndexVariableName ;
  end select ;
  @semanticExpression mWhileExpression ;
  select
    mWhileExpression := [@trueExpression new] ;
  or
    $while$ ;
    <expression> ? mWhileExpression ;
  end select ;
  @semanticInstructionList mBeforeInstructionList ;
  select
    mBeforeInstructionList := [@semanticInstructionList emptyList] ;
  or
    $before$ ;
    <semantic_instruction_list> ? mBeforeInstructionList ;
  end select ;
  $do$ ;
  @semanticInstructionList mDoInstructionList ;
  <semantic_instruction_list> ? mDoInstructionList ;
  @semanticInstructionList mBetweenInstructionList ;
  select
    mBetweenInstructionList := [@semanticInstructionList emptyList] ;
  or
    $between$ ;
    <semantic_instruction_list> ? mBetweenInstructionList ;
  end select ;
  @semanticInstructionList mAfterInstructionList ;
  select
    mAfterInstructionList := [@semanticInstructionList emptyList] ;
  or
    $after$ ;
    <semantic_instruction_list> ? mAfterInstructionList ;
  end select ;
  $end$ ;
  $foreach$ ;
  $;$ ;
  outInstruction := [@foreachInstruction new
    !mEnumeratedObjectList
    !mIndexVariableName
    !mWhileExpression
    !mBeforeInstructionList
    !mBetweenInstructionList
    !mDoInstructionList
    !mAfterInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E N D    I N S T R U C T I O N                                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $send$ ;
  @semanticExpression expression ;
  <expression> ? expression ;
  $;$ ;
  outInstruction := [@sendInstruction new
    !expression
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    I F    I N S T R U C T I O N                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $if$ ;
  @ifBranchList mBranchList [emptyList] ;
  repeat
    @semanticExpression mIFexpressionList ;
    <expression> ?mIFexpressionList ;
    $then$ ;
    @semanticInstructionList mIFinstructionList ;
    <semantic_instruction_list> ? mIFinstructionList ;
    mBranchList += !mIFexpressionList !mIFinstructionList ;
  while
    $elsif$ ;
  end repeat ;
  @semanticInstructionList mElseInstructionList ;
  select
    mElseInstructionList := [@semanticInstructionList emptyList] ;
  or
    $else$ ;
    <semantic_instruction_list> ? mElseInstructionList ;
  end select ;
  $end$ ;
  $if$ ;
  $;$ ;
  outInstruction := [@ifInstruction new
    !mBranchList
    !mElseInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M E T H O D    C A L L    I N S T R U C T I O N                        *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $[$ ;
  @semanticExpression mReceiverExpression ;
  <expression> ? mReceiverExpression ;
  $identifier$ ?@lstring mMethodName ;
  @actualParameterList mActualParameterList ;
  <actual_parameter_list> ? mActualParameterList ;
  $]$ ;
  $;$ ;
  outInstruction := [@methodCallInstruction new
    !mReceiverExpression
    !mMethodName
    !mActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M O D I F I E R    C A L L    I N S T R U C T I O N                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $[$ ;
  $!?$ ;
  $identifier$ ?@lstring mReceiverName ;
  @lstringlist mReceiverStructAttributes [emptyList] ;
  repeat
  while
    $.$ ;
    $identifier$ ?@lstring structAttribute ;
    mReceiverStructAttributes += !structAttribute ;
  end repeat ;
  $identifier$ ?@lstring mModifierName ;
  @actualParameterList mActualParameterList ;
  <actual_parameter_list> ? mActualParameterList ;
  $]$ ;
  $;$ ;
  outInstruction := [@modifierCallInstruction new
    !mReceiverName
    !mReceiverStructAttributes
    !mModifierName
    !mActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E R R O R    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $error$ ;
  @semanticExpression mReceiverExpression ;
  <expression> ? mReceiverExpression ;
  $:$ ;
  @semanticExpression mErrorExpression ;
  <expression> ? mErrorExpression ;
  @lstringlist mBuiltVariableList [emptyList] ;
  select
  or
    $->$ ;
    repeat
     @lstring builtVariableName ;
     $identifier$ ? builtVariableName ;
     mBuiltVariableList += !builtVariableName ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $;$ ;
  outInstruction := [@errorInstruction new
    !mReceiverExpression
    !mErrorExpression
    !mBuiltVariableList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    W A R N I N G    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $warning$ ;
  @semanticExpression mReceiverExpression ;
  <expression> ? mReceiverExpression ;
  $:$ ;
  @semanticExpression mWarningExpression ;
  <expression> ? mWarningExpression ;
  $;$ ;
  outInstruction := [@warningInstruction new
    !mReceiverExpression
    !mWarningExpression
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    R O U T I N E    C A L L    I N S T R U C T I O N                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $identifier$ ?@lstring  mRoutineName ;
  @actualParameterList mActualParameterList ;
  <actual_parameter_list> ? mActualParameterList ;
  $;$ ;
  outInstruction := [@routineCallInstruction new
    !mRoutineName
    !mActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    W I T H    I N S T R U C T I O N                                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $with$ ;
  @lstring prefix ;
  select
    prefix := [@lstring new !"" !here] ;
  or
    $identifier$ ? prefix ;
    $:$ ;
  end select ;
  $!?$ ;
  $identifier$ ?@lstring mTargetObjectName ;
  @lstringlist structAttributeList [emptyList] ;
  repeat
  while
    $.$ ;
    $identifier$ ?@lstring mStructFieldName ;
    structAttributeList += !mStructFieldName ;
  end repeat ;
  $identifier$ ?@lstring mSearchMethodName ;
  $!$ ;
  @semanticExpression mKeyExpression ;
  <expression> ? mKeyExpression ;
  $do$ ;
  @semanticInstructionList mDoBranchInstructions ;
  <semantic_instruction_list> ? mDoBranchInstructions ;
  @semanticInstructionList mElseBranchInstructions ;
  select
    mElseBranchInstructions := [@semanticInstructionList emptyList] ;
  or
    $else$ ;
    <semantic_instruction_list> ? mElseBranchInstructions ;
  end select ;
  outInstruction := [@withInstruction new
    !prefix
    !mTargetObjectName
    !structAttributeList
    !mSearchMethodName
    !mKeyExpression
    !mDoBranchInstructions
    !mElseBranchInstructions
  ] ;
  $end$ ;
  $with$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M A T C H    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

nonterminal <match_entry> ?!@matchEntryList ioMatchEntryList ;

#---------------------------------------------------------------------------*

rule <match_entry> ?!@matchEntryList ioMatchEntryList :
  $identifier$ ? @lstring mConstantName ;
  ioMatchEntryList += ![@constantMatchEntry new !mConstantName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <match_entry> ?!@matchEntryList ioMatchEntryList :
  $type_name$ ?@lstring mClassName ;
  $($ ;
  @foreachInstructionEnumeratedObjectElementList mElements [emptyList] ;
  repeat
  while
    $*$ ;
    mElements += ![@foreachInstructionJoker new] ;
  while
    @luint count ;
    $unsigned_literal_integer$ ?count ;
    $*$ ;
    @uint n := [count uint] ;
    if n == 0 then
      error count: "this value should be > 0" ;
    end if ;
    loop n :
    while n > 0 do
      mElements += ![@foreachInstructionJoker new] ;
      n -- ;
    end loop ;
  while
    @lstring typeName ;
    $type_name$ ?typeName ;
    @lstring constantName ;
    $identifier$ ?constantName ;
    @foreachInstructionEnumeratedConstant c [new !typeName !constantName] ;
    mElements += !c ;
  end repeat ;
  @bool mEndsWithEllipsis ;
  select
    mEndsWithEllipsis := false ;
  or
    $...$ ;
    mEndsWithEllipsis := true ;
  end select ;
  $)$ ;
  ioMatchEntryList += ![@classMatchEntry new
    !mClassName
    !mElements
    !mEndsWithEllipsis
  ] ;
end rule ;

#---------------------------------------------------------------------------*

nonterminal <match_instruction_branch> ?!@matchInstructionBranchList ioMatchInstructionBranchList ;

#---------------------------------------------------------------------------*

rule <match_instruction_branch> ?!@matchInstructionBranchList ioMatchInstructionBranchList :
  $when$ ;
  @matchEntryList mMatchEntryList [emptyList] ;
  repeat
    <match_entry> !? mMatchEntryList ;
  while
    $::$ ;
  end repeat ;
  $:$ ;
  @semanticInstructionList mMatchBranchInstructionList ;
  <semantic_instruction_list> ? mMatchBranchInstructionList ;
  ioMatchInstructionBranchList +=
    !mMatchEntryList
    !mMatchBranchInstructionList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $match$ ;
  @lstring matchedVariableName ;
  $identifier$ ? matchedVariableName ;
  @lstringlist mMatchedVariableNameList [emptyList] ;
  mMatchedVariableNameList += !matchedVariableName ;
  $::$ ;
  repeat
    $identifier$ ? matchedVariableName ;
    mMatchedVariableNameList += !matchedVariableName ;
  while
    $::$ ;
  end repeat ;
  $:$ ;
  @matchInstructionBranchList mMatchInstructionBranchList [emptyList] ;
  repeat
    <match_instruction_branch> !? mMatchInstructionBranchList ;
  while
  end repeat ;
  @semanticInstructionList mElseInstructionList ;
  select
    mElseInstructionList := [@semanticInstructionList emptyList] ;
  or
    $else$ ;
    <semantic_instruction_list> ? mElseInstructionList ;
  end select ;
  $end$ ;
  $match$ ;
  $;$ ;
  outInstruction := [@matchInstruction new
    !mMatchedVariableNameList
    !mMatchInstructionBranchList
    !mElseInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    C A S T    I N S T R U C T I O N                                       *
#                                                                           *
#---------------------------------------------------------------------------*

nonterminal <cast_instruction_branch> ?!@castInstructionBranchList ioCastInstructionBranchList ;

#---------------------------------------------------------------------------*

rule <cast_instruction_branch> ?!@castInstructionBranchList ioCastInstructionBranchList :
  $when$ ;
  @bool mUseKindOfClass ;
  select
    $>=$ ;
    mUseKindOfClass := true ;
  or
    $==$ ;
    mUseKindOfClass := false ;
  end select ;
  $type_name$ ? @lstring mTypeName ;
  @lstring mConstantVarName ; # Empty string if no constant var
  @bool mConstantVarNameIsUnused ; # true if no constant var
  select
    $identifier$ ?mConstantVarName ;
    mConstantVarNameIsUnused := false ;
  or
    $unused$ ;
    $identifier$ ?mConstantVarName ;
    mConstantVarNameIsUnused := true ;
  or
    mConstantVarName := [@lstring new !"" !here] ;
    mConstantVarNameIsUnused := true ;
  end select ;
  $do$ ;
  @semanticInstructionList mCastBranchInstructionList ;
  <semantic_instruction_list> ? mCastBranchInstructionList ;
  ioCastInstructionBranchList +=
    !mUseKindOfClass
    !mTypeName
    !mConstantVarName
    !mConstantVarNameIsUnused
    !mCastBranchInstructionList
  ;
end rule ;

#---------------------------------------------------------------------------*

nonterminal <cast_else_or_default> !@elseOrDefaultForCastInstruction outElseOrDefault ;

#---------------------------------------------------------------------------*

rule <cast_else_or_default> !@elseOrDefaultForCastInstruction outElseOrDefault
:
  $else$ ;
  @semanticInstructionList mElseInstructionList ;
  <semantic_instruction_list> ? mElseInstructionList ;
  outElseOrDefault := [@elseForCastInstruction new !mElseInstructionList] ;
end rule ;

#---------------------------------------------------------------------------*

rule <cast_else_or_default> !@elseOrDefaultForCastInstruction outElseOrDefault :
  $default$ ;
  $error$ ;
  @semanticExpression mErrorLocationExpression ;
  <expression> ? mErrorLocationExpression ;
  outElseOrDefault := [@defaultForCastInstruction new !mErrorLocationExpression] ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $cast$ ;
  @semanticExpression mExpression ;
  <expression> ? mExpression ;
  $:$ ;
  @castInstructionBranchList mCastInstructionBranchList [emptyList] ;
  repeat
    <cast_instruction_branch> !? mCastInstructionBranchList ;
  while
  end repeat ;
  @elseOrDefaultForCastInstruction mElseOrDefault ;
  <cast_else_or_default> ? mElseOrDefault ;
  $end$ ;
  $cast$ ;
  $;$ ;
  outInstruction := [@castInstruction new
    !mExpression
    !mCastInstructionBranchList
    !mElseOrDefault
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    A D D    I N S T R U C T I O N    + =                                  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  @lstring mReceiverName ;
  $identifier$ ? mReceiverName ;
  @lstringlist mStructAttributeList [emptyList] ;
  repeat
  while
    $.$ ;
    $identifier$ ? @lstring attributeName ;
    mStructAttributeList += !attributeName ;
  end repeat ;
  $+=$ ;
  @outExpressionList mExpressionList ;
  <output_expression_list> ? mExpressionList ;
  $;$ ;
  outInstruction := [@addInstruction new
    !mReceiverName
    !mStructAttributeList
    !mExpressionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    R E M O V E    I N S T R U C T I O N      - =                          *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  @lstring mReceiverName ;
  $identifier$ ? mReceiverName ;
  @lstringlist mStructAttributeList [emptyList] ;
  repeat
  while
    $.$ ;
    $identifier$ ? @lstring attributeName ;
    mStructAttributeList += !attributeName ;
  end repeat ;
  $-=$ ;
  $!$ ;
  @semanticExpression mExpression ;
  <expression> ? mExpression ;
  $;$ ;
  outInstruction := [@removeInstruction new
    !mReceiverName
    !mStructAttributeList
    !mExpression
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    A P P E N D    I N S T R U C T I O N    . =                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $identifier$ ? @lstring mTargetVariableName ;
  @lstringlist mStructAttributeList [emptyList] ;
  repeat
  while
    $.$ ;
    $identifier$ ? @lstring attributeName ;
    mStructAttributeList += !attributeName ;
  end repeat ;
  $.=$ ;
  @semanticExpression mSourceExpression ;
  <expression> ? mSourceExpression ;
  $;$ ;
  outInstruction := [@appendInstruction new
    !mTargetVariableName
    !mStructAttributeList
    !mSourceExpression
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    L O O P    I N S T R U C T I O N                                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $loop$ ;
  @semanticExpression mVariantExpression ;
  <expression> ? mVariantExpression ;
  $:$ ;
  @semanticInstructionList mFirstInstructions ;
  <semantic_instruction_list> ? mFirstInstructions ;
  $while$ ;
  @semanticExpression mLoopExpression ;
  <expression> ? mLoopExpression ;
  $do$ ;
  @semanticInstructionList mSecondInstructions ;
  <semantic_instruction_list> ? mSecondInstructions ;
  $end$ ;
  $loop$ ;
  $;$ ;
  outInstruction := [@loopInstruction new
    !mVariantExpression
    !mFirstInstructions
    !mLoopExpression
    !mSecondInstructions
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M E S S A G E    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $message$ ;
  @semanticExpression mExpression ;
  <expression> ? mExpression ;
  $;$ ;
  outInstruction := [@messageInstruction new
    !mExpression
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    L O G    I N S T R U C T I O N                                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $log$ ;
  @lstringlist mLoggedVariableList [emptyList] ;
  repeat
    @lstring loggedVariableName ;
    $identifier$ ? loggedVariableName ;
    mLoggedVariableList += !loggedVariableName ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
  outInstruction := [@logInstruction new !mLoggedVariableList] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  G R A M M A R    I N S T R U C T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $grammar$ ;
  @lstring mGrammarComponentName ;
  $identifier$ ?mGrammarComponentName ;
  @lstring mLabelName ;
  select
    mLabelName := [@lstring new !"" !here] ;
  or
    $label$ ;
    $identifier$ ?mLabelName ;
  end select ;
  @bool sourceExpressionIsFile ;
  select
    $in$ ; sourceExpressionIsFile := true ;
  or
    $on$ ; sourceExpressionIsFile := false ;
  end select ;
  @semanticExpression mSourceExpression ;
  <expression> ? mSourceExpression ;
  @actualParameterList mActualParameterList ;
  <actual_parameter_list> ? mActualParameterList ;
#--- Dependency (obsolete ?)
  select
  or
    $dependency$ ;
    <expression> ? * ;
    $in$ ;
    <expression> ? * ;
  end select ;
  $;$ ;
  outInstruction := [@grammarInstruction new
    !mGrammarComponentName
    !mLabelName
    !mSourceExpression
    !sourceExpressionIsFile
    !mActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  S W I T C H    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $switch$ ;
  @semanticExpression switchExpression ;
  <expression> ? switchExpression ;
  @switchBranches switchBranches [emptyList] ;
  repeat
    $when$ ;
    @lstringlist constantNameList [emptyList] ;
    repeat
      $identifier$ ? @lstring constantName ;
      constantNameList += !constantName ;
    while
      $,$ ;
    end repeat ;
    $:$ ;
    @semanticInstructionList instructions ;
    <semantic_instruction_list> ? instructions ;
    switchBranches += !constantNameList !instructions ;
  while
  end repeat ;
  $end$ ;
  $switch$ ;
  $;$ ;
  outInstruction := [@switchInstruction new
    !switchExpression
    !switchBranches
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E    M E T H O D    C A L L    I N S T R U C T I O N               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction> !@semanticInstruction outInstruction :
  $[$ ;
  $type_name$ ? @lstring mTypeName ;
  $identifier$ ? @lstring mMethodName ;
  @actualParameterList mActualParameterList ;
  <actual_parameter_list> ? mActualParameterList ;
  $]$ ;
  $;$ ;
  outInstruction := [@typeMethodInstruction new
    !mTypeName
    !mMethodName
    !mActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

#nonterminal <sdfgh> ;
#rule <sdfgh> : $bof$ ; end rule ;


end syntax ;
