#---------------------------------------------------------------------------*
#                                                                           *
#  Common semantics definitions                                             *
#                                                                           *
#  Copyright (C) 1997, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics common_semantics :
import semantics grammarSemantics in "grammarSemantics.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#        Semantics entity abstract type                                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_semanticsEntity feature generatedInSeparateFile {
  message  "any entity";
  message messageTypeEntite  "any entity";
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of semantics entities                                              *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_semanticsEntitiesForUse {
  @AC_semanticsEntity aDefEntite ;
  insert insertKey error message "a semantics entity named '%K' is already declared in %L" ;
  search searchKey error message "there is no semantics entity named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  A C T U A L    P A R A M E T E R S    P A S S I N G    M O D E S         *
#                                                                           *
#---------------------------------------------------------------------------*

enum @EXactualParametersPassingMode {
  constructor parameterOut ;
  constructor parameterOutIn ;
  constructor parameterIn ;
}{
  reader actualArgumentMessage :
    parameterOutIn -> "an output/input (!?) actual parameter" ;
    parameterIn -> "an input (?) actual parameter" ;
    parameterOut -> "an output (!) actual parameter" ;
  end reader ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Definition du type abstrait instruction d'une methode              *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeInstruction feature generatedInSeparateFile {
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Definition du type list d'instructions d'une methode               *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeInstructionList {
  @typeInstruction mInstruction ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E    L I S T    M O D E L                                          *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeListModel {
  @lstring mTypeName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  B O O L    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @BoolModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C H A R    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @CharModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U I N T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @UIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S I N T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @SIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U I N T 6 4    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @UInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S I N T 6 4    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @SInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  D O U B L E    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @DoubleModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S T R I N G    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @StringModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L B O O L    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LBoolModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L C H A R    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LCharModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L U I N T    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LUIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S I N T    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LSIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L U I N T 6 4    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LUInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S I N T 6 4    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LSInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L D O U B L E    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LDoubleModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S T R I N G    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LStringModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S T R I N G S E T    M O D E L                                           *
#                                                                           *
#---------------------------------------------------------------------------*

class @StringsetModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L O C A T I O N    M O D E L                                             *
#                                                                           *
#---------------------------------------------------------------------------*

class @LocationModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L I S T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @ListModel extends @TypeModel {
  @typeListModel mAttributeList feature nogetter ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P    M O D E L                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @MapModel extends @TypeModel {
  @typeListModel mAttributeList feature nogetter ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E N U M    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @enumConstantMap {
  @bool mHasConstructor ;
  insert insertKey error message "the '%K' constant is already declared in %L" ;
  search searchKey, searchKeyAndGetIndex error message "the '%K' constant is not declared" ;
}

#---------------------------------------------------------------------------*

map @enumUsedConstantMap {
  insert insertKey error message "the '%K' constant is already used in %L" ;
}

#---------------------------------------------------------------------------*

map @enumMessageMap {
  insert insertKey error message "the '%K' message name is already declared in %L" ;
  search searchKey error message "the '%K' message name is not declared" ;
}

#---------------------------------------------------------------------------*

class @EnumModel extends @TypeModel {
  @enumConstantMap mEnumConstantesMap feature nogetter ; #--- Enumeration constants map
  @enumMessageMap mMessagesMap feature nogetter ; #--- Messages map
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    T Y P E    M O D E L                                      *
#                                                                           *
#---------------------------------------------------------------------------*

map @constructorMap {
  @typeListModel mFormalInputArgumentList ;
  insert insertKey error message "the '%K' constructor is already declared in %L" ;
  search searchKey error message "the '%K' constructor is not declared" ;
}

#---------------------------------------------------------------------------*

map @readerMap {
  @signatureForGrammarAnalysis mReaderFormalArgumentList ;
  insert insertKey error message "the '%K' reader is already declared in %L" ;
  search searchKey error message "the '%K' reader is not declared" ;
}

#---------------------------------------------------------------------------*

map @modifierMap {
  @signatureForGrammarAnalysis mModifierFormalArgumentList ;
  insert insertKey error message "the '%K' modifier is already declared in %L" ;
  search searchKey error message "the '%K' modifier is not declared" ;
}

#---------------------------------------------------------------------------*

class @ExternTypeModel extends @TypeModel {
  @constructorMap mExternTypeConstructorMap feature nogetter ;
  @readerMap mReaderMap feature nogetter ;
  @modifierMap mModifierMap feature nogetter ;
  @typeListModel mAddAssignFormalInputArgumentList feature nogetter ; # List is empty if += operator is not defined
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C L A S S    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

map @classMessageMap {
  insert insertKey error message "the '%K' message is already declared in %L" ;
  search searchKey error message "the '%K' message is not declared" ;
}

#---------------------------------------------------------------------------*

class @ClassModel extends @TypeModel {
  @bool mIsAbstract feature nogetter ;
  @stringset mSuperClasses ;
  @typeListModel mAttributeList ;
  @classMessageMap mMessageMap ;
}


#---------------------------------------------------------------------------*
#                                                                           *
#  M O D E L    M A P                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @ModelMap {
  @TypeModel mType ;
  insert insertKey error message "the '@%K' type has been already declared in %L" ;
  search searchKey error message "the '@%K' type is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    A C T I O N    A N D    R O U T I N E    M A P            *
#                                                                           *
#---------------------------------------------------------------------------*

map @ActionMap {
  @signatureForGrammarAnalysis mSignature ;
  @bool mIsExtern ; # true for extern extern routine, false for routines
  insert insertKey error message "the '%K' extern extern routine has been already declared in %L" ;
  search searchKey error message "the '%K' extern routine is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   F O R W A R D    T Y P E     D E C L A R A T I O N S                    *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_EXsignature ;
list @typeListeAttributsSemantiques ;
map @EXcategoryMethodMap ;

#---------------------------------------------------------------------------*

enum @localConstantBuildStyleEnum {
  constructor listStyle ;
  constructor mapStyle ;
  constructor firstIsKeyOtherMapStyle ;
}{
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    T Y P E    ( A B S T R A C T    C L A S S )              *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_galgasType ;

abstract class @AC_galgasType feature generatedInSeparateFile {
#--- Get type name
  abstract method getTypeName !@string outTypeName ;

#--- By default, object does not accept as sort key in sorted list definition
  method acceptToBeSortKeyInSortedListDefinition ??@lstring inErrorLocation :
    error inErrorLocation :
       "this attribute cannot be used for sorting" ;
  end method ;

#--- By default, object does not accept 'with' instruction access
  method check_with_InstructionAccess
    ??@location inErrorLocation
    ??@lstring unused searchMethodName
    ??@AC_galgasType unused inKeyExpressionType
    !@string outMapTypeName
    !@string outErrorMessage
    !@typeListeAttributsSemantiques outAttributeList
  :
    error inErrorLocation :
       "only a map object can be accessed by the 'with' instruction"
    -> outAttributeList, outMapTypeName, outErrorMessage ;
  end method ;

#--- By default, object does not accept assignment from 'here'
  method acceptAssignmentFromHere ??@lstring inErrorLocation :
    error inErrorLocation :
       "assignment from 'here' is not allowed for variables of this type" ;
  end method ;

#--- By default, object does not accept to be enumerated (foreach instruction)
  method acceptForeachInstruction
    ??@M_semanticsEntitiesForUse unused inSemanticsEntitiesForUse
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    error inErrorLocation :
       "variables of this type cannot be enumerated by in 'foreach' instruction"
       -> outForeachList, outStyle, outNewStyle
    ;
  end method ;

#--- By default, object does not accept modifier call
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
  end method ;

#--- By default, class does not accept reader instruction call
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outMethodSignature
    !@string outCategoryMethodClassBaseName
  :
    error inMethodName :
       "variables of this type do not support method call instruction"
       -> outMethodSignature, outCategoryMethodClassBaseName ;
  end method ;

#--- By default, class does not accept constructor call
  method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    error inClassMethodName : "This constructor is not defined"
      -> outAccessorTypesList, outHasLexiqueAndLocationArguments, outReturnedType
    ;
  end method ;

#--- By default, class does not accept class method call
  method handleClassMethodCall
    ??@lstring inTypeMethodName
    !@L_EXsignature outTypeMethodSignature
  :
    error inTypeMethodName : "This type method is not defined" -> outTypeMethodSignature ;
  end method ;

#--- By default, class does not accept operator "-=" call
  method handleMinusAssignOperatorCall 
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    error inErrorLocation :
       "variables of this type do not support call of '-=' operator"
       -> outParametersList ;
  end method ;


#--- By default, class does not accept operator "+=" call
  method handleAddAssignOperatorCall 
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    error inErrorLocation :
       "variables of this type do not support call of '+=' operator"
       -> outParametersList ;
  end method ;

#--- By default, class does not accept "++" operator
  method handleIncrementOperatorCall 
    ??@location inErrorLocation
  :
    error inErrorLocation :
       "variables of this type do not support call of '++' operator" ;
  end method ;

#--- By default, class does not accept "--" operator
  method handleDecrementOperatorCall 
    ??@location inErrorLocation
  :
    error inErrorLocation :
       "variables of this type do not support call of '--' operator" ;
  end method ;

#--- By default, class does not accept to be silently converted to @location
  method checkAbilityToBeSilentlyConvertedToLocation 
  :
    error here : "variables of this type cannot be silently converted to @location value" ;
  end method ;

#--- Error message
  message messageGalgasType "any type" ;
  message "any type" ;
}

#---------------------------------------------------------------------------*

class @typeEntiteType extends @AC_semanticsEntity {
  @AC_galgasType aDefType ;

  message messageTypeEntite "a type" ;
  message "a type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#       C++ NAME FOR A FORMAL PARAMETER OR LOCAL VARIABLE                   *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCplusPlusName feature generatedInSeparateFile {
  @location mVariableLocation ;
}

#---------------------------------------------------------------------------*
# C++ name is the value of mName

class @typeDirectName extends @typeCplusPlusName {
  @string mName feature nogetter ;
}

#---------------------------------------------------------------------------*
# C++ name is _currentObject->mName

class @typeCurrentObjectName extends @typeCplusPlusName {
  @string mName feature nogetter ;
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for local method call): it is *this

class @typeCppStarThisName extends @typeCplusPlusName {
  @string mGalgasTypeName ;
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for method call from category)

class @typeCppThisInCategoryName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for inherited method call)

class @typeCppInheritedName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of mName

class @typeAutomaticName extends @typeCplusPlusName {
  @string mName ;
}

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of an unique sequence number

class @typeLocationAutomaticName extends @typeCplusPlusName {
  @uint mSequenceNumber feature nogetter ;
}

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->zz' followed by the value of mName

class @typeOperandName extends @typeCplusPlusName {
  @string mName feature nogetter ;
  @bool mFieldKind feature nogetter ; # false : zz est vide ; true : zz est 'mInfo.'
  @bool mIteratorNewStyle feature nogetter ;
}

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->mKey' followed by the value of mName

class @typeKeyName extends @typeCplusPlusName {
  @bool mIteratorNewStyle feature nogetter ;
}

#---------------------------------------------------------------------------*
# No variable

class @typeNullName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
#                                                                           *
#     Liste des types et des noms C++ des arguments d'une methode           *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeListeTypesEtNomsArgMethode {
  @AC_galgasType mType feature nogetter ;
  @formalArgumentPassingMode mFormalArgumentPassingMode feature nogetter ;
  @typeCplusPlusName mCppName feature nogetter ;
  @bool mModeIn feature nogetter ;
  @lstring mParameterName feature nogetter ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                   Super classes map of a class                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeSuperClassesMap {
  insert insertKey error message "the class '%K' is already a super class of the current class" ;
}

#---------------------------------------------------------------------------*
#                    Liste d'attributs semantiques                          *
#---------------------------------------------------------------------------*

list @typeListeAttributsSemantiques {
  @AC_galgasType mAttributType feature nogetter ;
  @lstring mAttributeName feature nogetter ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   L I S T    O F    G A L G A S    T Y P E S                              *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeTypesList {
  @AC_galgasType mType ;
  @location mEndOfExpressionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# M E T H O D ,    A C T I O N ,   R O U T I N E    S I G N A T U R E       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_EXsignature {
  @AC_galgasType mType ;
  @formalArgumentPassingMode mFormalArgumentPassingMode ;
}

#---------------------------------------------------------------------------*

enum @categoryMethodKind {
  constructor baseMethod, abstractMethod, overridingMethod ;
}{
}

#---------------------------------------------------------------------------*

map @EXcategoryMethodMap {
  @categoryMethodKind mCategoryMethodKind ;
  @L_EXsignature aListeArgumentsFormels ;
  insert insertKey error message "the '%K' category method is already declared in %L" ;
  search searchKey, searchKeyAndGetIndex error message "the '%K' category method is not declared" ;
}

#---------------------------------------------------------------------------*

map @EXcategoryReaderMap {
  @categoryMethodKind mCategoryMethodKind ;
  @L_EXsignature aListeArgumentsFormels ;
  @AC_galgasType mReturnedType ;
  insert insertKey error message "the '%K' category reader is already declared in %L" ;
  search searchKey, searchKeyAndGetIndex error message "the '%K' category reader is not declared" ;
}

#---------------------------------------------------------------------------*

map @EXcategoryTemplateMap {
  @categoryMethodKind mCategoryMethodKind ;
  @L_EXsignature aListeArgumentsFormels ;
  insert insertKey error message "the '%K' category template is already declared in %L" ;
  search searchKey, searchKeyAndGetIndex error message "the '%K' category template is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# M E T H O D ,    A C T I O N ,   R O U T I N E    S I G N A T U R E       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_actualParametersSignature {
  @AC_galgasType mType ;
  @EXactualParametersPassingMode mFormalArgumentPassingMode ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   A C C E S S O R    M A P                                                *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_accessors_map {
  @L_EXsignature mAccessorSignature ;
  @AC_galgasType mReturnedType ;
  insert insertKey error message "the '%K' accessor has been already declared in %L" ;
  search searchKey error message "the '%K' accessor is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    J O K E R    T Y P E                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_jokerInParameterList extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "" ;
  end method ;

#--- Error message
  message messageGalgasType "??" ;
  message "a joker" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L I T E R A L    T Y P E S                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_bool extends @AC_galgasType {
#--- Get type name
  override
  method getTypeName !@string outTypeName :
    outTypeName := "bool" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- Error message
  message "a '@bool' type" ;
  message messageGalgasType "a '@bool' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_uint extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "uint" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if ([inClassMethodName string] == "max") |
       ([inClassMethodName string] == "sequenceNumber") |  
       ([inClassMethodName string] == "errorCount") |  
       ([inClassMethodName string] == "warningCount") then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "valueWithMask" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a '@uint' type" ;
  message messageGalgasType "a '@uint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_char extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "char" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    if ([inClassMethodName string] == "replacementCharacter") then
      outHasLexiqueAndLocationArguments := false ;
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "unicodeCharacterWithUnsigned" then
      outHasLexiqueAndLocationArguments := true ;
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList, outHasLexiqueAndLocationArguments ;
    end if ;
  end method ;

#--- Error message
  message "a '@char' type" ;
  message messageGalgasType "a '@char' type" ;
}

#---------------------------------------------------------------------------*

extern routine extern_build_stringlist_type !@AC_galgasType outType ;

#---------------------------------------------------------------------------*

class @typeGalgas_string extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "string" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- By default, class does not accept method instruction call
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if [inMethodName string] == "writeToFile" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inMethodName string] == "writeToFileWhenDifferentContents" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
      outReaderSignature += ![@typeGalgas_bool new] ![@formalArgumentPassingMode argumentOut] ;
   elsif [inMethodName string] == "writeToExecutableFile" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inMethodName string] == "makeDirectoryAndWriteToFile" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inMethodName string] == "makeDirectory" then
      outReaderSignature := [@L_EXsignature emptyList] ;
    else
      error inMethodName: "this method is not defined (writeToFile, makeDirectoryAndWriteToFile"
      . " and makeDirectory methods are defined on @string objects) " -> outReaderSignature ;
    end if ;
  end method ;

#--- string accepts constructors
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "stringWithVersionString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithSourceFilePath" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithCurrentDirectory" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithSequenceOfCharacters" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "stringWithMainFirstArgument" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithContentsOfFile" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "stringWithCurrentDateTime" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithEnvironmentVariable" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "stringWithEnvironmentVariableOrEmpty" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "CppLineComment" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "CppTitleComment" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "CppChar" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "CppString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "componentsJoinedByString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType stringlistType ; extern_build_stringlist_type ?stringlistType ;
      outAccessorTypesList += ! stringlistType ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- String accepts modifier call
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setCapacity" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "incIndentation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "decIndentation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setCharacterAtIndex" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_char new] ![@formalArgumentPassingMode argumentIn] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "this modifier is not defined"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- By default, class does not accept class method call
  override
  method handleClassMethodCall
    ??@lstring inTypeMethodName
    !@L_EXsignature outTypeMethodSignature
  :
    if [inTypeMethodName string] == "deleteFile" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inTypeMethodName string] == "deleteFileIfExists" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inTypeMethodName string] == "removeEmptyDirectory" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inTypeMethodName string] == "removeDirectoryRecursively" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inTypeMethodName string] == "generateFile" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inTypeMethodName : "This type method is not defined" -> outTypeMethodSignature ;
    end if ;
  end method ;

#--- Error message
  message "a '@string' type" ;
  message messageGalgasType "a '@string' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_sint extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "sint" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructors 'min' and 'max'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "min" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a '@sint' type" ;
  message "a '@sint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_sint64 extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "sint64" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructors 'min' and 'max'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "min" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a '@sint64' type" ;
  message messageGalgasType "a '@sint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_uint64 extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "uint64" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "uint64MaskWithCompressedBitString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "uint64BaseValueWithCompressedBitString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "uint64WithBitString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a '@uint64' type" ;
  message messageGalgasType "a '@uint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_double extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "double" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- Error message
  message "a '@double' type" ;
  message messageGalgasType "a '@double' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S   B D D                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_binaryset extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "binaryset" ;
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "binarySetWithBit" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "emptyBinarySet" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "fullBinarySet" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "binarySetWithPredicateString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithEqualComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithNotEqualComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithStrictLowerComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithStrictGreaterComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithLowerOrEqualComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithGreaterOrEqualComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithEqualToConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithNotEqualToConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithStrictLowerThanConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithStrictGreaterThanConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithLowerOrEqualToConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithGreaterOrEqualToConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithITE" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_binaryset new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_binaryset new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_binaryset new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a '@binaryset' type" ;
  message messageGalgasType "a '@binaryset' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S   P R I M I T I V E    T Y P E S                            *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @C_galgasPrimitiveType extends @AC_galgasType {
  message "any primitive type" ;
  message messageGalgasType "any primitive type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      G A L G A S    L O C A T I O N    T Y P E                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_location extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "location" ;
  end method ;

#--- Objects of this class accept assignment from 'here' keyword
  override method acceptAssignmentFromHere ??@lstring unused inErrorLocation :
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@location' type" ;
  message messageGalgasType "a '@location' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lstring extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lstring" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_location new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "retrieveAndResetTemplateString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setString" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lstring' type" ;
  message messageGalgasType "a '@lstring' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lchar extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lchar" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_char new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setChar" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_char new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lchar' type" ;
  message messageGalgasType "a '@lchar' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lbool extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lbool" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_bool new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setBool" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_bool new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lbool' type" ;
  message messageGalgasType "a '@lbool' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_luint extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "luint" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_uint new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setUint" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@luint' type" ;
  message messageGalgasType "a '@luint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_luint64 extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "luint64" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_uint64 new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setUint64" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint64 new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@luint64' type" ;
  message messageGalgasType "a '@luint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lsint extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lsint" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_sint new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setSint" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_sint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lsint' type" ;
  message messageGalgasType "a '@lsint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lsint64 extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lsint64" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_sint64 new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setSint64" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_sint64 new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lsint64' type" ;
  message messageGalgasType "a '@lsint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_ldouble extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "ldouble" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_double new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setDouble" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_double new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@ldouble' type" ;
  message messageGalgasType "a '@ldouble' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S T R I N G S E T    T Y P E                             *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_stringset extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "stringset" ;
  end method ;

#--- stringset accepts constructor call 'emptySet'
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptySet" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "setWithString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_string new] ;
      outAccessorTypesList += !t ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- stringset accepts operator "+=" call
  override
  method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := [@typeListeAttributsSemantiques emptyList] ;
    outParametersList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
  end method ;

#--- stringset accepts operator "-=" call
  override
  method handleMinusAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := [@typeListeAttributsSemantiques emptyList] ;
    @AC_galgasType t := [@typeGalgas_string new] ;
    outParametersList += !t ![@lstring new !""! here] ;
  end method ;

#--- stringset object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@M_semanticsEntitiesForUse unused inSemanticsEntitiesForUse
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := true ;
    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
    outForeachList += ![@typeGalgas_string new] ![@lstring new !"key" !here] ;
    outStyle := [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle] ;
  end method ;

#--- Error message
  message "a '@stringset' type" ;
  message messageGalgasType "a '@stringset' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    F I L E W R A P P E R    T Y P E                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_filewrapper extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "filewrapper" ;
  end method ;

#--- File wrapper accepts modifier call
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setCurrentDirectory" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "this modifier is not defined"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Error message
  message "a '@filewrapper' type" ;
  message messageGalgasType "a '@filewrapper' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    D A T A    T Y P E                                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_data extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "data" ;
  end method ;

#--- Constructor
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptyData" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Methods
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outMethodSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if [inMethodName string] == "writeToFile" then
      outMethodSignature := [@L_EXsignature emptyList] ;
      outMethodSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inMethodName: "this method is not defined " -> outMethodSignature ;
    end if ;
  end method ;


#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "appendByte" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "appendShortBE" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "appendShortLE" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "appendUIntBE" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "appendUIntLE" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "appendUTF8String" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "appendData" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_data new] ![@formalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "this modifier is not defined"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Error message
  message "a '@data' type" ;
  message messageGalgasType "a '@data' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    O B J E C T    T Y P E                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_object extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "object" ;
  end method ;

#--- Error message
  message "a '@object' type" ;
  message messageGalgasType "a '@object' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    ' T Y P E '    T Y P E                                   *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_typelist_type !@AC_galgasType outType ;

class @typeGalgas_type extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "type" ;
  end method ;

#--- Constructor
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "typeList" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      build_typelist_type ?outReturnedType ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList, outReturnedType ;
    end if ;
  end method ;

#--- Error message
  message "a '@type' type" ;
  message messageGalgasType "a '@type' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    ' F U N C T I O N '    T Y P E                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_functionlist_type !@AC_galgasType outType ;

class @typeGalgas_function extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "function" ;
  end method ;

#--- Constructor
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "functionList" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      build_functionlist_type ?outReturnedType ;
    elsif [inClassMethodName string] == "functionWithName" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"???" !here] ; # Unused second argument
    elsif [inClassMethodName string] == "functionIsDefined" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"???" !here] ; # Unused second argument
      outReturnedType := [@typeGalgas_bool new] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList, outReturnedType ;
    end if ;
  end method ;

#--- Error message
  message "a '@type' type" ;
  message messageGalgasType "a '@type' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M E T H O D S    M A P                                                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableMethodes {
  @L_EXsignature aListeTypesParametres ;
  insert insertKey error message "a method named '%K' is already declared" ;
  search searchKey error message "there is no method named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U N D E F I N E D    E X T E R N    T Y P E                              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedExternType extends @AC_galgasType {
#--- Galgas class name
  @lstring mGalgasClassName feature nogetter ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mGalgasClassName string] ;
  end method ;

#--- Message
  message messageGalgasType "an undefined extern type" ;
  message "an undefined extern type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Extern type constructor map                                          *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_externTypeConstructorMap {
  @typeListeAttributsSemantiques aListeDesAttributs ;
  insert insertKey error message "the '%K' constructor is already declared in %L" ;
  search searchKey error message "the '%K' constructor is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    T Y P E                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasExternType extends @typeGalgasUndefinedExternType {
#--- Constructor map
  @M_externTypeConstructorMap mConstructorMap feature nogetter ;

#--- Modifiers map
  @typeTableMethodes mModifiersMap feature nogetter ;  

#--- Readers map
  @typeTableMethodes mReadersInInstructionMap feature nogetter ;  

#--- Attributes for handling operator '+=' call
  @bool mAcceptAddAssignOperatorCall feature nogetter ;
  @typeListeAttributsSemantiques mAddAssignOperatorCallTypeList feature nogetter ;

#--- Constructors
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    [mConstructorMap searchKey !inClassMethodName ?outAccessorTypesList] ;
  end method ;

#--- Handle modifier call : return modifier signature
  override method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    [mModifiersMap searchKey !inModifierName ?outModifierSignature] ; 
  end method ;

#--- By default, class does not accept reader instruction call
  override method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    [mReadersInInstructionMap searchKey !inMethodName ?outReaderSignature] ;
  end method ;

#--- Handle operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
      [self handleAddAssignOperatorCall !inErrorLocation ?outParametersList] ;
    if not mAcceptAddAssignOperatorCall then
      [super handleAddAssignOperatorCall !inErrorLocation ?outParametersList] ;
    else
      outParametersList := mAddAssignOperatorCallTypeList ;
    end if ;
  end method ;

#--- Message
  message "an extern type" ;
  message messageGalgasType "an extern type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Terminal symbols map (for using in a syntax component)               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_terminalSymbolsMapForUse {
  @typeListeAttributsSemantiques aListeDesAttributs ;
  insert insertKey error message "the terminal symbol '$%K$' is already declared in %L" ;
  search searchKey error message "the terminal symbol '$%K$' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Lexiques map (for using in a syntax component)                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_lexiqueComponents {
  @M_terminalSymbolsMapForUse mTerminalSymbolMap ;
  insert insertKey error message"the '%K' lexique is already declared in %L" ;
  search searchKey error message"the '%K' lexique is not defined" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                   Table des classes declarees 'enavant'                   *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableEnAvant {
  @AC_galgasType mType ;
  insert insertKey error message "the type '%K' is already declared in %L" ;
  search searchKey error message "the type '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Grammars map                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonterminalSymbolAlts {
  @L_EXsignature mFormalParametersList ;

  insert insertKey error message "the label '%K' has been already declared in %L" ;
  search searchKey error message "the label '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Grammar as semantics entity                                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_grammarForSemantics extends @AC_semanticsEntity {
  @M_nonterminalSymbolAlts mGrammarAltMap ;
  @lstring mLexiqueClassName ;

  message messageTypeEntite  "a grammar entity";
  message "a grammar entity";
}

#---------------------------------------------------------------------------*
#                                                                           *
#   T Y P E S    S Y S T E M    F O R    G R A M M A R    C O M P O N E N T *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_typeForGrammarComponent feature generatedInSeparateFile {
  message typeForGrammarComponentMessage  "any type";
}

#---------------------------------------------------------------------------*

map @M_typesForGrammarComponent {
  @AC_typeForGrammarComponent mType feature nogetter ;
  insert insertKey error message "the '@%K' type is already declared in %L" ;
  search searchKey error message "the '@%K' type is not defined" ;
}

#---------------------------------------------------------------------------*

routine checkSignature_ForGrammarComponent
  ??@signatureForGrammarAnalysis inFormalReferenceSignature
  ??@signatureForGrammarAnalysis inFormalTestedSignature
  ??@location inFormalTestedLocation
  ??@location inFormalReferenceLocation
:
  if [inFormalReferenceSignature length] < [inFormalTestedSignature length] then
    error inFormalTestedLocation : "too much formal parameters (from prototype in " . [inFormalReferenceLocation locationString] . ")" ;
  elsif [inFormalReferenceSignature length] > [inFormalTestedSignature length] then
    error inFormalTestedLocation : "too much formal parameters (from prototype in " . [inFormalReferenceLocation locationString] . ")" ;
  else
    foreach inFormalReferenceSignature,
            inFormalTestedSignature prefixedby others_ do
      if mFormalArgumentPassingModeForGrammarAnalysis != others_mFormalArgumentPassingModeForGrammarAnalysis then
        error others_mGalgasTypeNameForGrammarAnalysis : "Prototype has " . [mFormalArgumentPassingModeForGrammarAnalysis formalArgumentMessage] .
                       ", and " . [mFormalArgumentPassingModeForGrammarAnalysis formalArgumentMessage] . " has been found" ;
      end if ;
      if [mGalgasTypeNameForGrammarAnalysis string] != [others_mGalgasTypeNameForGrammarAnalysis string] then
        error others_mGalgasTypeNameForGrammarAnalysis :  "I was expecting the '@" . [mGalgasTypeNameForGrammarAnalysis string] . "' type, I have got the '@" . [others_mGalgasTypeNameForGrammarAnalysis string] . "' type" ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Grammars map                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @L_grammarsMap {
  @M_nonterminalSymbolAlts mStartSymbolParametersMap ;

  insert insertKey error message "the '%K' grammar is already defined in %L" ;
  search searchKey error message "the '%K' grammar is not defined" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Class inherited messages map                                    *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeClassInheritedMessagesMap {
  insert insertKey error message "the message '%K' is already declared in %L" ;
  search searchKey error message "the message '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Semantic attributes map                                        *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeSemanticAttributesMap {
  @AC_galgasType mAttributType ;
  @bool mHasSetter ;
  @bool mHasGetter ;
  insert insertKey error message "an attribut named '%K' is already declared in %L" ;
  search searchKey error message "there is no attribut named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Definition des tables des methodes d'insertion et de recherche         *
#                                                                           *
#---------------------------------------------------------------------------*

list @insertOrSearchMethodList {
  @lstring mMethodName ;
  @string mErrorMessage ;
  @bool mIsGetIndexMethod ;
  @string mShadowErrorMessage ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#             Classe abstract definissant une classe                        *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeDefEntiteUtilisable feature generatedInSeparateFile {
  message messageTypeEntite "any type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U N D E F I N E D    L I S T    T Y P E                  *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedListType extends @AC_galgasType {
  @lstring mListTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mListTypeName string] ;
  end method ;

#--- list object accepts to be enumerated (foreach instruction),
#    if corresponding regular type is defined
#  override
#  method acceptForeachInstruction
#    ??@M_semanticsEntitiesForUse inSemanticsEntitiesForUse
#    ??@location unused inErrorLocation
#    !@typeListeAttributsSemantiques outForeachList
#    !@localConstantBuildStyleEnum outStyle
#    !@bool outNewStyle
#  :
#    if [inSemanticsEntitiesForUse hasKey ![mListTypeName string]] then
#      @AC_semanticsEntity e ;
#      [inSemanticsEntitiesForUse searchKey ! mListTypeName ?e] ;
#      @typeGalgasListType type := [(cast e if >= @typeGalgasListType else error mListTypeName) aDefType] ;
#      outNewStyle := false ;
#      outForeachList := [type mAttributeList] ;
#      outStyle := [@localConstantBuildStyleEnum listStyle] ;
#    else
#      error inErrorLocation :
#         "variables of this type cannot be enumerated by in 'foreach' instruction"
#         -> outForeachList, outStyle, outNewStyle
#      ;
#    end if ;
#  end method ;

  message "an undefined list type" ;
  message messageGalgasType "an undefined list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L I S T    T Y P E                                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasListType extends @typeGalgasUndefinedListType {
#--- List of all attributes
  @typeListeAttributsSemantiques mAttributeList ;
#--- Extract Methods signature (for 'first', 'last', 'popFirst', 'popLast')
  @L_EXsignature mExtractSignature feature nogetter ;
#--- Input Methods signature (for 'prependValue')
  @L_EXsignature mInputSignature feature nogetter ;

#--- list object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@M_semanticsEntitiesForUse unused inSemanticsEntitiesForUse
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := false ;
    outForeachList := mAttributeList ;
#    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
#    foreach mAttributeList do
#      cast mAttributType :
#      when == @typeGalgasUndefinedListType aType do
#        if [inSemanticsEntitiesForUse hasKey ![[aType mListTypeName] string]] then
#          @AC_semanticsEntity e ;
#          [inSemanticsEntitiesForUse searchKey ![aType mListTypeName] ?e] ;
#          @AC_galgasType type := [(cast e if >= @typeEntiteType else error [aType mListTypeName]) aDefType] ;
#          outForeachList += !type !mAttributeName ;
#        else
#          outForeachList += !mAttributType !mAttributeName ;
#        end if ;
#      else
#        outForeachList += !mAttributType !mAttributeName ;
#      end cast ;
#    end foreach ;
    outStyle := [@localConstantBuildStyleEnum listStyle] ;
  end method ;
  
#--- Modifiers are 'popFirst' and 'popLast' methods
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "prependValue" then
      outModifierSignature := mInputSignature ;
    elsif ([inModifierName string] == "popFirst") | ([inModifierName string] == "popLast") then
      outModifierSignature := mExtractSignature ;
    else
      outModifierSignature := [@L_EXsignature emptyList] ;
      @bool found := false ;
      foreach mAttributeList while not found do
        found := ("set" . [[mAttributeName string] stringByCapitalizingFirstCharacter] . "AtIndex") == [inModifierName string] ;
        if (found) then
          outModifierSignature += !mAttributType ![@formalArgumentPassingMode argumentConstantIn] ;
          outModifierSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentConstantIn] ;
        end if ;
      end foreach ;
      if not found then
        error inModifierName :
         "the '" . [inModifierName string] . "' modifier is not supported by the list" ;
      end if ;
    end if ;
  end method ;


#--- List accept 'first' and last' reader in instruction
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if ([inMethodName string] != "first") & ([inMethodName string] != "last") then
      error inMethodName: "a list accepts only 'first' and 'last' methods" ;
    end if ;
    outReaderSignature := mExtractSignature ;
  end method ;

#--- list accepts operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := mAttributeList ;
  end method ;

#--- A list accepts 'emptyList' and 'listWithValue' constructors
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptyList" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "listWithValue" then
      outAccessorTypesList := mAttributeList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

  message "a list type" ;
  message messageGalgasType "a list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S T R U C T    T Y P E                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasStructType extends @AC_galgasType {
  @lstring mStructTypeName ;
  @typeListeAttributsSemantiques mAttributeList ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mStructTypeName string] ;
  end method ;

#--- A struct accepts 'new' constructor
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := mAttributeList ;
    else
      error inClassMethodName : "the '" . inClassMethodName  . "' constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

  message "a struct type" ;
  message messageGalgasType "a struct type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L I S T M A P    T Y P E                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasListmapType extends @AC_galgasType {
  @lstring mListmapTypeName feature nogetter ;
  @lstring mListTypename feature nogetter ;
  @typeGalgasListType mListType ;

#--- List of all attributes of list
  @typeListeAttributsSemantiques mAttributeList feature nogetter ;

#--- listmap object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@M_semanticsEntitiesForUse unused inSemanticsEntitiesForUse
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := true ;
    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
    outForeachList += ![@typeGalgas_string new] ![@lstring new !"key" !here] ;
    outForeachList += !mListType ![@lstring new !"object" !here] ;
    outStyle := [@localConstantBuildStyleEnum listStyle] ;
  end method ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mListmapTypeName string] ;
  end method ;

#--- A listmap accepts 'emptyMap' constructor
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptyMap" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "the '" . inClassMethodName  . "' constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- listmap accepts operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := [@typeListeAttributsSemantiques emptyList] ;
    outParametersList += ![@typeGalgas_string new] ![@lstring new !"key" !here] ;
    outParametersList := outParametersList . mAttributeList ;
  end method ;

  message "a listmap type" ;
  message messageGalgasType "a listmap type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U I N T L I S T    T Y P E                               *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_uintlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_uint new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_uint new] ![@formalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"uintlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L U I N T L I S T    T Y P E                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_luintlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_luint new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_luint new] ![@formalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_luint new] ![@formalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"luintlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U I N T 6 4 L I S T    T Y P E                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_uint64list_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_uint64 new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_uint64 new] ![@formalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_uint64 new] ![@formalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"uint64list" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    C H A R L I S T    T Y P E                               *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_charlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_char new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"charlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L C H A R L I S T    T Y P E                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_lcharlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_lchar new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"lcharlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S T R I N G L I S T    T Y P E                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_stringlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_string new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"stringlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    s t r i n g 2 l i s t    T Y P E                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_string2list_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_string new] ![@lstring new !"mValue0" !here] ;
  attributesList += ![@typeGalgas_string new] ![@lstring new !"mValue1" !here] ;

  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentOut] ;
  extractSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentOut] ;

  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentConstantIn] ;
  inputSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentConstantIn] ;

  outType := [@typeGalgasListType new
    ![@lstring new !"string2list" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    s t r i n g 2 l i s t    T Y P E                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_string3list_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_string new] ![@lstring new !"mValue0" !here] ;
  attributesList += ![@typeGalgas_string new] ![@lstring new !"mValue1" !here] ;
  attributesList += ![@typeGalgas_string new] ![@lstring new !"mValue2" !here] ;

  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentOut] ;
  extractSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentOut] ;
  extractSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentOut] ;

  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentConstantIn] ;
  inputSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentConstantIn] ;
  inputSignature += ![@typeGalgas_string new] ![@formalArgumentPassingMode argumentConstantIn] ;

  outType := [@typeGalgasListType new
    ![@lstring new !"string3list" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L S T R I N G L I S T    T Y P E                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_lstringlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_lstring new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_lstring new] ![@formalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_lstring new] ![@formalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"lstringlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    T Y P E L I S T    T Y P E                               *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_typelist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_type new] ![@lstring new !"mValue" !here] ;

  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_type new] ![@formalArgumentPassingMode argumentOut] ;

  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_type new] ![@formalArgumentPassingMode argumentConstantIn] ;

  outType := [@typeGalgasListType new
    ![@lstring new !"typelist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    F U N C T I O N L I S T    T Y P E                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_functionlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_function new] ![@lstring new !"mValue" !here] ;

  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_function new] ![@formalArgumentPassingMode argumentOut] ;

  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_function new] ![@formalArgumentPassingMode argumentConstantIn] ;

  outType := [@typeGalgasListType new
    ![@lstring new !"functionlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#  D O M A I N    T Y P E                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

map @domainRelationMap {
  @stringlist mDomains ;
  insert insertKey error message "the '%K' domain relation has been already declared in %L" ;
  search searchKey error message "the '%K' domain relation is not declared" ;
}

#---------------------------------------------------------------------------*

map @domainModifierMap {
  @L_EXsignature mFormalParametersList ;
  insert insertKey error message "the '%K' domain modifier has been already declared in %L" ;
  search searchKey error message "the '%K' domain modifier is not declared" ;
}

#---------------------------------------------------------------------------*

map @domainAttributeMap {
  insert insertKey error message "an attribute named '%K' is already declared in %L" ;
  search searchKey error message "there is no attribute named '%K'" ;
}

#---------------------------------------------------------------------------*

class @typeGalgasDomainType extends @AC_galgasType {
  @lstring mDomainTypeName feature nogetter ;
  @domainAttributeMap mAttributeMap feature nogetter ;
  @domainModifierMap mDomainModifierMap ;
  @domainRelationMap mDomainRelationMap ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mDomainTypeName string] ;
  end method ;

#--- A domain accepts 'domainWithNames' constructor
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "domainWithNames" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t ; build_stringlist_type ?t ;
      foreach mAttributeMap do
        outAccessorTypesList += !t ![@lstring new !"" !here] ;
      end foreach ;
    else
      error inClassMethodName : "a domain only accepts 'domainWithNames' constructor" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [mDomainModifierMap hasKey ![inModifierName string]] then
      [mDomainModifierMap searchKey !inModifierName ?outModifierSignature] ;
    else
      error inModifierName: "this modifier is not defined" -> outModifierSignature ;
    end if ;
  end method ;

  message "a domain type" ;
  message messageGalgasType "a domain type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U N D E F I N E D    S O R T E D    L I S T    T Y P E   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedSortedListType extends @AC_galgasType {
  @lstring mListTypeName feature nogetter ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mListTypeName string] ;
  end method ;

  message "a predeclared sorted list type" ;
  message messageGalgasType "a predeclared sorted list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S O R T E D    L I S T    T Y P E                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasSortedListType extends @typeGalgasUndefinedSortedListType {
#--- List of all attributes
  @typeListeAttributsSemantiques mAttributeList feature nogetter ;
#--- Extract Methods signature (for 'smallest', 'greatest', 'popSmallest', 'popGreatest')
  @L_EXsignature mExtractSignature feature nogetter ;

#--- list object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@M_semanticsEntitiesForUse unused inSemanticsEntitiesForUse
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := false ;
    outForeachList := mAttributeList ;
    outStyle := [@localConstantBuildStyleEnum listStyle] ;
  end method ;
  
#--- Modifiers are 'popSmallest' and 'popLast' methods
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if ([inModifierName string] == "popSmallest") | ([inModifierName string] == "popGreatest") then
      outModifierSignature := mExtractSignature ;
    else
      error inModifierName: "a sorted list accepts only 'popSmallest' and 'popGreatest' modifiers" -> outModifierSignature ;
    end if ;
  end method ;


#--- List accept 'smallest' and greatest' reader in instruction
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if ([inMethodName string] != "smallest") & ([inMethodName string] != "greatest") then
      error inMethodName: "a sorted list accepts only 'smallest' and 'greatest' methods" ;
    end if ;
    outReaderSignature := mExtractSignature ;
  end method ;

#--- list accepts operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := mAttributeList ;
  end method ;

#--- A list accepts 'emptyList' and 'listWithValue' constructors
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptySortedList" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "sortedListWithValue" then
      outAccessorTypesList := mAttributeList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

  message "a sorted list type" ;
  message messageGalgasType "a sorted list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Definition des tables des methodes de surcharge                *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableBlocsDeTable {
  @L_EXsignature aSignatureDebut ;
  @L_EXsignature aSignatureFin ;
  insert insertKey error message "a block method named '%K' is already declared in %L" ;
  search searchKey error message "there is no block method named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#               Definition d'un type map utilisable                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedMapType extends @AC_galgasType {
  @lstring mMapTypeName feature nogetter ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mMapTypeName string] ;
  end method ;

  message "an undefined map type" ;
  message messageGalgasType "an undefined map type" ;
}

#---------------------------------------------------------------------------*

map @mapModifierMap {
  @L_EXsignature mMethodSignature ;
  insert insertKey error message "an insert or a remove modifier named '%K' is already declared in %L" ;
  search searchKey error message "there is no modifier named '%K'" ;
}

#---------------------------------------------------------------------------*

map @mapMethodMap {
  @L_EXsignature mMethodSignature ;
  insert insertKey error message "a search method named '%K' is already declared in %L" ;
  search searchKey error message "there is no search method named '%K'" ;
}

#---------------------------------------------------------------------------*

class @typeGalgasMapType extends @typeGalgasUndefinedMapType {
#--- Liste de tous les attributs semantiques not externes
  @typeListeAttributsSemantiques mAttributeList ;

#--- Table de toutes les methodes de surcharge
  @typeTableBlocsDeTable aTableMethodesSurcharger ;

#--- Insert or Remove (modifier) map
  @mapModifierMap mModifierMethodMap ;

#--- Search (method) map
  @mapMethodMap mReaderMethodMap ;

#--- By default, object does not accept 'with' instruction access
  override
  method check_with_InstructionAccess
    ??@location unused inErrorLocation
    ??@lstring searchMethodName
    ??@AC_galgasType inKeyExpressionType
    !@string outMapTypeName
    !@string outErrorMessage
    !@typeListeAttributsSemantiques outAttributeList
  :
    outAttributeList := mAttributeList ;
    outMapTypeName := [mMapTypeName string] ;
  #--- Test for 'hasKey' method
    if [searchMethodName string] == "hasKey" then
      @typeGalgas_string classType := (cast inKeyExpressionType if >= @typeGalgas_string else error here) ;
      outErrorMessage := "" ;
    elsif [mReaderMethodMap hasKey ![searchMethodName string]] then
      @typeGalgas_lstring classType := (cast inKeyExpressionType if >= @typeGalgas_lstring else error here) ;
      outErrorMessage := [searchMethodName string] ;
    else
      error searchMethodName:
        "this method does not exist: it should be the predefined 'hasKey', or a declared search method"
      -> outErrorMessage ;
    end if ;
  end method ;

#--- Modifiers are insert methods and (when map defines automaton) search methods
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    [mModifierMethodMap searchKey !inModifierName ?outModifierSignature] ;
    if not [mModifierMethodMap hasKey ![inModifierName string]] then
      foreach mAttributeList do 
        @string setValueForKeyName := "set" . [mAttributeName stringByCapitalizingFirstCharacter] . "ForKey" ;
        if setValueForKeyName == [inModifierName string] then
          warning mAttributeName:"'" . mAttributeName  . "' attribute is declared here" ;
        end if ;
      end foreach ;
    end if ;
  end method ;

#--- Methods are search methods (when map defines no automaton)
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    [mReaderMethodMap searchKey !inMethodName ?outReaderSignature] ;
  end method ;


#--- table object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@M_semanticsEntitiesForUse unused inSemanticsEntitiesForUse
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := false ;
    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
    outForeachList += ![@typeGalgas_lstring new] ![@lstring new !"key" !here] ;
    outForeachList := outForeachList . mAttributeList ;
    outStyle := [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle] ;
  end method ;

#--- A map accepts 'emptyMap' constructor
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "emptyMap" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "mapWithMapToOverride" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgasUndefinedMapType new !mMapTypeName] ![@lstring new !"???" !here] ; # Unused second argument
    elsif [inClassMethodName string] == "empty" then
      error inClassMethodName : "in GALGAS 1.3.0 and later, use 'emptyMap' constructor instead of 'empty' constructor" -> outAccessorTypesList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;
  
  message "a map type" ;
  message messageGalgasType "a map type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U N D E F I N E D    M A P I N D E X    T Y P E          *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedMapindexType extends @AC_galgasType {
  @lstring mMapindexTypeName feature nogetter ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mMapindexTypeName string] ;
  end method ;

#--- A mapindex accepts 'null' constructor
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "null" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "a map index only accepts 'null' constructor" -> outAccessorTypesList ;
    end if ;
  end method ;

  message "a predeclared mapindex type" ;
  message messageGalgasType "a predeclared mapindex type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    M A P I N D E X    T Y P E                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @mapIndexSearchReaderMap {
  @lstring mRetrieveErrorMessage ;
  insert insertKey error message "a search reader named '%K' is already declared in %L" ;
  search searchKey error message "there is search reader named '%K'" ;
}

#---------------------------------------------------------------------------*

class @typeGalgasMapindexType extends @typeGalgasUndefinedMapindexType {
  @lstring mMapTypeName feature nogetter ;
  @typeListeAttributsSemantiques mMapAttributesList feature nogetter ;
  @mapIndexSearchReaderMap mMapIndexSearchReaderMap feature nogetter ;

#--- Associated map features
  @typeTableBlocsDeTable aTableMethodesSurcharger feature nogetter ;
  @mapModifierMap mModifierMethodMap feature nogetter ;
  @mapMethodMap mReaderMethodMap feature nogetter ;

#--- mapindex accept method calls corresponding to search declarations
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    [mMapIndexSearchReaderMap searchKey !inMethodName ?*] ;
    outReaderSignature := [@L_EXsignature listWithValue
      ![@typeGalgas_lstring new]
      ![@formalArgumentPassingMode argumentOut]
    ] ;
    foreach mMapAttributesList do
      outReaderSignature += !mAttributType ![@formalArgumentPassingMode argumentOut] ;
    end foreach ;
  end method ;

#--- A mapindex only accept 'makeRegularIndex' type method call
  override
  method handleClassMethodCall
    ??@lstring inTypeMethodName
    !@L_EXsignature outTypeMethodSignature
  :
    if [inTypeMethodName string] == "makeRegularIndex" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature +=
        ![@typeGalgas_lstring new]
        ![@formalArgumentPassingMode argumentIn]
      ;
      outTypeMethodSignature +=
        ![@typeGalgasMapType new
           !mMapTypeName
           !mMapAttributesList
           !aTableMethodesSurcharger
           !mModifierMethodMap
           !mReaderMethodMap
         ]
        ![@formalArgumentPassingMode argumentInOut]
      ;
      outTypeMethodSignature +=
        ![@typeGalgasMapindexType new
           !mMapindexTypeName
           !mMapTypeName
           !mMapAttributesList
           !mMapIndexSearchReaderMap
           !aTableMethodesSurcharger
           !mModifierMethodMap
           !mReaderMethodMap
         ] ## self ??
        ![@formalArgumentPassingMode argumentOut]
      ;
    else
      error inTypeMethodName : "a map index only accepts 'regularIndex' type method" -> outTypeMethodSignature ;
    end if ;
  end method ;

  message "a mapindex type" ;
  message messageGalgasType "a mapindex type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    T Y P E    " C L A S S "    D E F I N I T I O N                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedClassType extends @AC_galgasType {
  @lstring mClassTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mClassTypeName string] ;
  end method ;

  message "an undefined class type" ;
  message messageGalgasType "an undefined class type" ;
}

#---------------------------------------------------------------------------*

list @L_lazyAttributeList {
  @location mLocationMagicNumber ;
  @typeListeAttributsSemantiques mComputedAttributeTypeAndNameList ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @typeGalgasClassType extends @typeGalgasUndefinedClassType {
#--- class reader map
  @typeTableMethodes mMethodMap ;

#--- Attributes list (those from inherited classes, followed by those from current class)
  @typeListeAttributsSemantiques mAttributeList ;  

#--- Table des classes ancetre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;  

#--- Table des messages
  @typeClassInheritedMessagesMap mMessagesMap ;

#--- Attributes map (those from inherited classes and those from current class)
  @typeSemanticAttributesMap mNonExternAttributesMap ;

#--- La classe est-elle abstract ?
  @bool mClassIsAbstract ;

#--- message
  @string mClassMessage ;

#--- Generate in Separate file ?
  @bool mHasGeneratedInSeparateFileSetting ;

#--- Once Reader map
  @L_lazyAttributeList mLazyAttributeList ;

#--- Handle modifier call
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    @bool found := false ;
    outModifierSignature := [@L_EXsignature emptyList] ;
    foreach mNonExternAttributesMap while not found do
      @string testedModifierName := "set" . [[key string] stringByCapitalizingFirstCharacter] ;
      if [inModifierName string] == testedModifierName then
        found := true ;
        if mHasSetter then
          outModifierSignature += !mAttributType ![@formalArgumentPassingMode argumentIn] ;
        else
          error inModifierName:"This modifier corresponds to the '" . key . "' attribute that is not declared as settable" ;
          warning key:"attribute declaration pointed out by previous error" ;
        end if ;
      end if ;
    end foreach ;
    if not found then
    error inModifierName : "variables of this type do not support modifier call" ;
    end if ;
  end method ;


#--- Handle method call : return method signature
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap inCategoryMethodMap
    !@L_EXsignature outMethodSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if [mMethodMap hasKey ![inMethodName string]] then
      [mMethodMap searchKey !inMethodName ?outMethodSignature] ;
    else
      outMethodSignature := [@L_EXsignature emptyList] ;
      const @lstring kKey [new ![mClassTypeName string] . ":" . [inMethodName string] ![inMethodName location]] ;
      if [inCategoryMethodMap hasKey ![kKey string]] then
        @categoryMethodKind categoryMethodKind ;
        [inCategoryMethodMap searchKey !kKey ?categoryMethodKind ?outMethodSignature] ;
        if categoryMethodKind != [@categoryMethodKind overridingMethod] then
          outCategoryMethodClassBaseName := [mClassTypeName string] ;
        end if ;
      end if ;
      foreach mAncestorClassesMap while outCategoryMethodClassBaseName == "" do
        @lstring superKey [new ![key string] . ":" . [inMethodName string] ![inMethodName location]] ;
        if [inCategoryMethodMap hasKey ![superKey string]] then
          @categoryMethodKind categoryMethodKind ;
          [inCategoryMethodMap searchKey !superKey ?categoryMethodKind ?outMethodSignature] ;
          if categoryMethodKind != [@categoryMethodKind overridingMethod] then
            outCategoryMethodClassBaseName := [mClassTypeName string] ;
          end if ;
        end if ;
      end foreach ;
      if outCategoryMethodClassBaseName == "" then
        error inMethodName:"there is no '" . inMethodName
        . "' method defined for '@" . mClassTypeName . "' class" -> outMethodSignature ;
      end if ;
    end if ;
  end method ;

#--- Class accepts class method call 'new' if it is not abstract
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    if mClassIsAbstract then
      error inClassMethodName : "an abstract class cannot be instancied" -> outAccessorTypesList ;
    elsif [inClassMethodName string] == "new" then
      outAccessorTypesList := mAttributeList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a class type" ;
  message messageGalgasType "a class type" ;
}

#---------------------------------------------------------------------------*

class @typeEntiteRoutine extends @AC_semanticsEntity {
  @L_EXsignature aListeArgumentsFormels ;

  message "a routine" ;
  message messageTypeEntite "a routine" ;
}

#---------------------------------------------------------------------------*

class @typeEntiteFonction extends @AC_semanticsEntity {
  @L_EXsignature aListeArgumentsFormels ;
  @AC_galgasType mReturnedType ;

  message "a function" ;
  message messageTypeEntite "a function" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E N U M    T Y P E                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeEnumMessageMap {
  @lstringlist mMessageStringList ;
  insert insertKey error message "the '%K' message name is already declared in %L" ;
  search searchKey error message "the '%K' message name is not declared" ;
}

#---------------------------------------------------------------------------*

list @enumModifierDefinitionList {
  @lstring mSourceState ;
  @lstring mTargetState ;
  @typeInstructionList mInstructionList ; # Actually: no instruction, error instruction or warning instruction
}

#---------------------------------------------------------------------------*

map @enumModifierMap {
  @enumModifierDefinitionList mActionDefinitionList ;
  @L_EXsignature mSignature ;
  @typeListeTypesEtNomsArgMethode mArgumentTypeAndNameList ;
  insert insertKey error message "the '%K' modifier is already declared in %L" ;
  search searchKey error message "the '%K' modifier is not declared" ;
}

#---------------------------------------------------------------------------*

list @enumMethodDefinitionList {
  @lstring mSourceState ;
  @typeInstructionList mInstructionList ; # Actually: no instruction, error instruction or warning instruction
}

#---------------------------------------------------------------------------*

map @enumMethodMap {
  @enumMethodDefinitionList mActionDefinitionList ;
  @L_EXsignature mSignature ;
  @typeListeTypesEtNomsArgMethode mArgumentTypeAndNameList ;
  insert insertKey error message "the '%K' method is already declared in %L" ;
  search searchKey error message "the '%K' method is not declared" ;
}

#---------------------------------------------------------------------------*

list @enumOperatorDefinitionList {
  @lstring mLeftSourceState ;
  @luint mLeftSourceStateIndex ;
  @lstring mRightSourceState ;
  @luint mRightSourceStateIndex ;
  @lstring mTargetState ;
  @luint mTargetStateIndex ;
  @typeInstructionList mInstructionList ; # Actually: no instruction, error instruction or warning instruction
}

#---------------------------------------------------------------------------*

map @enumOperatorMap {
  @enumOperatorDefinitionList mActionDefinitionList ;
  @L_EXsignature mSignature ;
  @typeListeTypesEtNomsArgMethode mArgumentTypeAndNameList ;
  insert insertKey error message "the '%K' method is already declared in %L" ;
  search searchKey error message "the '%K' method is not declared" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_enum extends @AC_galgasType {
#--- Enumeration name
  @lstring mEnumTypeName ;

#--- Enumeration constants map
  @enumConstantMap mEnumConstantesMap ;

#--- Messages map
  @typeEnumMessageMap mMessagesMap ;

#--- Modifier map
  @enumModifierMap mModifierMap feature nogetter ;

#--- Method map
  @enumMethodMap mMethodMap feature nogetter ;

#--- Operator map
  @enumOperatorMap mOperatorMap feature nogetter ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mEnumTypeName string] ;
  end method ;

#--- Class accepts class method with constant names
  override method handleConstructorInvocation
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
    !@AC_galgasType outReturnedType
  :
    outReturnedType := self ;
    outHasLexiqueAndLocationArguments := true ;
    @bool hasConstructor ;
    [mEnumConstantesMap searchKey !inClassMethodName ?hasConstructor] ;
    if hasConstructor then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName:
        "the '" . [inClassMethodName string] . "' is not declared as constructor"
        -> outAccessorTypesList
      ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    [mModifierMap searchKey !inModifierName ?* ?outModifierSignature ?*] ;
  end method ;

#--- Methods
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    [mMethodMap searchKey !inMethodName ?* ?outReaderSignature ?*] ;
  end method ;


  message "an enum type" ;
  message messageGalgasType "an enum type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                 VERIFIER LA COMPATIBILITE DE DEUX TYPES                   *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkAssignmentTypesCompatibility
  ??@AC_galgasType inFormalType
  ??@AC_galgasType inEffectiveType
  ??@location inErrorLocation
  ??@bool inAcceptPolymorphism
:
  match inFormalType :: inEffectiveType :
  when @typeGalgas_object ()       :: @typeGalgas_object () :
  when @typeGalgas_type ()         :: @typeGalgas_type () :
  when @typeGalgas_function ()     :: @typeGalgas_function () :
  when @typeGalgas_binaryset ()    :: @typeGalgas_binaryset () :
  when @typeGalgas_stringset ()    :: @typeGalgas_stringset () :
  when @typeGalgas_data ()         :: @typeGalgas_data () :
  when @typeGalgas_uint ()         :: @typeGalgas_uint () :
  when @typeGalgas_sint ()         :: @typeGalgas_sint () :
  when @typeGalgas_uint64 ()       :: @typeGalgas_uint64 () :
  when @typeGalgas_sint64 ()       :: @typeGalgas_sint64 () :
  when @typeGalgas_char ()         :: @typeGalgas_char () :
  when @typeGalgas_string ()       :: @typeGalgas_string () :
  when @typeGalgas_bool ()         :: @typeGalgas_bool () :
  when @typeGalgas_double ()       :: @typeGalgas_double () :
  when @typeGalgas_lbool ()        :: @typeGalgas_lbool () :
  when @typeGalgas_lchar ()        :: @typeGalgas_lchar () :
  when @typeGalgas_luint ()        :: @typeGalgas_luint () :
  when @typeGalgas_lsint ()        :: @typeGalgas_lsint () :
  when @typeGalgas_luint64 ()      :: @typeGalgas_luint64 () :
  when @typeGalgas_lsint64 ()      :: @typeGalgas_lsint64 () :
  when @typeGalgas_ldouble ()      :: @typeGalgas_ldouble () :
  when @typeGalgas_lstring ()      :: @typeGalgas_lstring () :
  when @typeGalgas_location ()     :: @typeGalgas_location () :
  when @typeGalgas_filewrapper ()  :: @typeGalgas_filewrapper () :

  when @typeGalgasStructType (@lstring kNomType1 *)::@typeGalgasStructType (@lstring kNomType2 *) :
    @bool accept := [kNomType1 string] == [kNomType2 string] ;
    if not accept then
      error inErrorLocation : "I was expecting the struct type '@" . [kNomType1 string] .
                              "', I have got the struc type '@" . [kNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedClassType (@lstring kNomType1)
    :: @typeGalgasClassType (@lstring kNomType2 2* @typeSuperClassesMap kAncestorClassesMap ...) :
    @bool accept := [kNomType1 string] == [kNomType2 string] ;
    if (not accept) & inAcceptPolymorphism then
      accept := [kAncestorClassesMap hasKey ![kNomType1 string]] ;
    end if ;
    if not accept then
      error inErrorLocation : "I was expecting the class type '@" . [kNomType1 string] .
                              "', I have got the class type '@" . [kNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedMapindexType (@lstring attNomType1 ...) :: @typeGalgasUndefinedMapindexType (@lstring attNomType2 ...) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the map index type '@" . [attNomType1 string] .
                                "', I have got the map index type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedListType (@lstring attNomType1) :: @typeGalgasUndefinedListType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the list type '@" . [attNomType1 string] .
                                "', I have got the list type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedSortedListType (@lstring attNomType1) :: @typeGalgasUndefinedSortedListType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the sorted list type '@" . [attNomType1 string] .
                                "', I have got the sorted list type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedMapType (@lstring attNomType1) :: @typeGalgasUndefinedMapType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the map type '@" . [attNomType1 string] .
                              "', I have got the map type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedClassType (@lstring attNomType1) :: @typeGalgasUndefinedClassType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the class type '@" . [attNomType1 string] .
                              "', I have got the class type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasListmapType (@lstring attNomType1 ...)
    :: @typeGalgasListmapType (@lstring attNomType2 ...) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting an extern variable of listmap '@" . [attNomType1 string] .
                               "' type variable, and I got a listmap '@" . [attNomType2 string] . "' type variable" ;
    end if ;

  when @typeGalgasUndefinedExternType (@lstring attNomType1)
    :: @typeGalgasUndefinedExternType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting an extern variable of extern '@" . [attNomType1 string] .
                               "' type variable, and I got an extern '@" . [attNomType2 string] . "' type variable" ;
    end if ;

  when @typeGalgas_enum (@lstring aTypeName1 5*)
    :: @typeGalgas_enum (@lstring aTypeName2 5*) :
    if [aTypeName1 string] != [aTypeName2 string] then
      error inErrorLocation : "I was expecting an enum variable of  '@" . [aTypeName1 string] .
                                "' type variable, and I got an enum '@" . [aTypeName2 string] . "' type variable" ;
    end if ;

  else
    error inErrorLocation : [inFormalType messageGalgasType] . " is not compatible with " . [inEffectiveType messageGalgasType]  ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     VERIFICATION DE COMPATIBILITE ENTRE DEUX SIGNATURES DE METHODE        *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteSignatures
  ??@L_EXsignature signatureReference
  ??@L_EXsignature signatureTestee
  ??@location ouSignalerErreur
:
  if [signatureReference length] < [signatureTestee length] then
    error ouSignalerErreur : "there are too much parameters" ;
  elsif [signatureReference length] > [signatureTestee length] then
    error ouSignalerErreur : "one or more parameters missing" ;
  else 
    foreach signatureReference,
            signatureTestee prefixedby other_ do
      checkAssignmentTypesCompatibility
         !mType
         !other_mType
         !ouSignalerErreur
         !false
      ;
      if mFormalArgumentPassingMode != other_mFormalArgumentPassingMode then
        error ouSignalerErreur : [mFormalArgumentPassingMode formalArgumentMessage] . " is not compatible with " .
                                [other_mFormalArgumentPassingMode formalArgumentMessage] ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     COMMAND LINE INTERFACE OPTION MAP                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_cli_options {
  @lchar mOptionChar ;
  @lstring mOptionString ;
  @lstring mComment ;
  insert insertKey error message "the '%K' command line option has been already declared in %L" ;
  search searchKey error message "the '%K' command line option is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of option components                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_optionComponents {
  @M_cli_options mBoolOptionsMap ;
  @M_cli_options mUintOptionsMap ;
  @M_cli_options mStringOptionsMap ;
  insert insertKey error message "the '%K' option component named is already declared in %L" ;
  search searchKey error message "there is no '%K' option component" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          Grammar component map                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_grammarComponents {
  @nonterminalSymbolLabelMapForGrammarAnalysis mNonterminalSymbolParametersMap ;
  @lstring mLexiqueName ;
  @M_optionComponents mOptionsMap ;
  insert insertKey error message "the '%K' grammar component has been already declared in %L" ;
  search searchKey error message "the '%K' grammar component is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of semantics components                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_semanticsComponents {
  @ModelMap mModelMap ; # The types and classes declared in this component
  @ActionMap mActionMap ; # The routines and the extern actions declared in this component 
  @stringset mImportedSemanticsComponents ; # The other semantics components imported in this component
  @stringset mImportedMetamodelComponents ; # The metamodel components imported in this component
  @stringset mImportedOptionsComponents ; # The option components imported in this component
  @M_optionComponents mOptionsComponents ; # The option components imported in this component (OLD STYLE)
  @M_semanticsEntitiesForUse mSemanticsEntitiesMap ; # OLD STYLE MAP
  insert insertKey error message "a semantics component named '%K' is already declared in %L" ;
  search searchKey error message "there is no semantics component named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              F I L E    W R A P P E R                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_regularFiles {
  @uint mWrapperDirectoryIndex ;
  @uint mWrapperFileIndex ;
  insert insertKey error message "a regular file named '%K' is already declared in %L" ;
  search searchKey error message "there is no regular file named '%K'" ;
}

#---------------------------------------------------------------------------*

map @filewrapperTemplateMap {
  @typeListeAttributsSemantiques mFormalAttributeList ;
  insert insertKey error message "the '%K' template is already declared in %L" ;
  search searchKey error message "the '%K' template is not declared" ;
}

#---------------------------------------------------------------------------*

map @M_filewrappers {
  @M_regularFiles mRegularFileMap ;
  @filewrapperTemplateMap mTemplateMap ;
  insert insertKey error message "a file wrapper named '%K' is already declared in %L" ;
  search searchKey error message "there is no file wrapper named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              List of attributes for label entry in GUI description        *
#                                                                           *
#---------------------------------------------------------------------------*

list @labelForPopUpList {
  @lstring mTerminal1 ;
  @uint mTerminal1ID ;
  @lstring mTerminal2 ;
  @uint mTerminal2ID ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              List of attributes for text macros                           *
#                                                                           *
#---------------------------------------------------------------------------*

list @EXtextMacroList {
  @lstring mKey ;
  @lstring mContents ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   H A N D L E    @ S T R I N G    R E A D E R    C A L L                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleStringReaderCall
  ??@lstring inReaderName
  !@typeListeAttributsSemantiques outAccessorTypesList
  !@AC_galgasType outReturnedType
  !@bool outHasLexiqueAndLocationArguments
:
  outHasLexiqueAndLocationArguments := false ;
  outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
  if [inReaderName string] == "doesEnvironmentVariableExist" then
    outReturnedType := [@typeGalgas_bool new] ;
  elsif [inReaderName string] == "length" then
    outReturnedType := [@typeGalgas_uint new] ;
  elsif [inReaderName string] == "identifierRepresentation" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "HTMLRepresentation" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "utf8Representation" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "utf32Representation" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByTrimmingWhiteSpaces" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "md5" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "decimalUnsignedNumber" then
    outHasLexiqueAndLocationArguments := true ;
    outReturnedType := [@typeGalgas_uint new] ;
  elsif [inReaderName string] == "isDecimalUnsignedNumber" then
    outReturnedType := [@typeGalgas_bool new] ;
  elsif [inReaderName string] == "capacity" then
    outReturnedType := [@typeGalgas_uint new] ;
  elsif [inReaderName string] == "fileExists" then
    outReturnedType := [@typeGalgas_bool new] ;
  elsif [inReaderName string] == "directoryExists" then
    outReturnedType := [@typeGalgas_bool new] ;
  elsif [inReaderName string] == "characterAtIndex" then
    outHasLexiqueAndLocationArguments := true ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # First @string argument
    outReturnedType := [@typeGalgas_char new] ;
  elsif [inReaderName string] == "stringByRemovingCharacterAtIndex" then
    outHasLexiqueAndLocationArguments := true ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # First @string argument
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "pathExtension" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "rightSubString" then
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "leftSubString" then
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "subString" then
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "nativePathWithUnixPath" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "unixPathWithNativePath" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "lastPathComponent" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByDeletingPathExtension" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByCapitalizingFirstCharacter" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "firstCharacterOrNul" then
    outReturnedType := [@typeGalgas_char new] ;
  elsif [inReaderName string] == "stringByDeletingLastPathComponent" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByStandardizingPath" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByLeftPadding" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # @uint arg: padding size
    outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !"" !here] ; # @char arg: padding char
  elsif [inReaderName string] == "stringByRightPadding" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # @uint arg: padding size
    outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !"" !here] ; # @char arg: padding char
  elsif [inReaderName string] == "stringByLeftAndRightPadding" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # @uint arg: padding size
    outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !"" !here] ; # @char arg: padding char
  elsif [inReaderName string] == "absolutePathFromPath" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # @string argument
  elsif [inReaderName string] == "relativePathFromPath" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # @string argument
  elsif [inReaderName string] == "stringByReplacingStringByString" then
    outHasLexiqueAndLocationArguments := true ;
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # First @string argument
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # Second @string argument
  elsif [inReaderName string] == "lowercaseString" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "uppercaseString" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "reversedString" then
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "componentsSeparatedByString" then
    outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
    build_stringlist_type  ?outReturnedType ;
  elsif [inReaderName string] == "regularFiles" then
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    build_stringlist_type  ?outReturnedType ;
  elsif [inReaderName string] == "hiddenFiles" then
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    build_stringlist_type  ?outReturnedType ;
  elsif [inReaderName string] == "directories" then
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    build_stringlist_type  ?outReturnedType ;
  elsif [inReaderName string] == "directoriesWithExtensions" then
    build_stringlist_type  ?outReturnedType ;
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ;
  elsif [inReaderName string] == "regularFilesWithExtensions" then
    build_stringlist_type  ?outReturnedType ;
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ;
  elsif [inReaderName string] == "system" then
    outReturnedType := [@typeGalgas_sint new] ;
  else
    error inReaderName : "the '" . inReaderName . "' reader is not defined" -> outReturnedType ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   H A N D L E    R E A D E R    C A L L    I N    E X P R E S S I O N     *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleReaderCall
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@EXcategoryReaderMap inCategoryReaderMap
  ??@AC_galgasType inReceiverType
  ??@lstring inReaderName
  !@typeListeAttributsSemantiques outAccessorTypesList
  !@AC_galgasType outReturnedType
  !@string outCppConversionMethod
  !@string outCategoryReaderClassBaseName
  !@bool outHasLexiqueAndLocationArguments
:
  outHasLexiqueAndLocationArguments := true ;
  outCppConversionMethod := "" ; # Means no conversion needed
  outCategoryReaderClassBaseName := "" ; # Means not a category reader
  if [inReaderName string] == "description" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outHasLexiqueAndLocationArguments := false ;
  elsif [inReaderName string] == "object" then
    outReturnedType := [@typeGalgas_object new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outHasLexiqueAndLocationArguments := false ;
  elsif [inReaderName string] == "staticType" then
    outReturnedType := [@typeGalgas_type new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outHasLexiqueAndLocationArguments := false ;
  else
    cast inReceiverType :
    when >= @typeGalgasDomainType t do
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      build_stringlist_type ?outReturnedType ; # any value
      @bool found := false ;
      @string s := "" ;
      foreach [t mDomainRelationMap] while not found do
        if [mDomains length] == 1 then
          s .= " " . [key string] . "StringValueList" ;
          found := [inReaderName string] == ([key string] . "StringValueList") ;
          build_stringlist_type ?outReturnedType ;
        elsif [mDomains length] == 2 then
          s .= " " . [key string] . "StringValueList" ;
          found := [inReaderName string] == ([key string] . "StringValueList") ;
          build_string2list_type ?outReturnedType ;
        elsif [mDomains length] == 3 then
          s .= " " . [key string] . "StringValueList" ;
          found := [inReaderName string] == ([key string] . "StringValueList") ;
          build_string3list_type ?outReturnedType ;
        end if ;
      end foreach ;
      if not found then
        error inReaderName:"this domain accepts the following readers:" . s ;
      end if ;
    when >= @typeGalgas_filewrapper do
      if [inReaderName string] == "allFilePathes" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type  ?outReturnedType ;
      elsif [inReaderName string] == "allDirectoryPathes" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type  ?outReturnedType ;
      elsif [inReaderName string] == "currentDirectory" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "directoryExistsAtPath" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "fileExistsAtPath" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "fileContentsAtPath" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "absolutePathForPath" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgasUndefinedMapindexType do
      if [inReaderName string] == "isRegular" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isNull" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "key" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_lstring new] ;
      elsif [inReaderName string] == "isSolved" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_string do
      handleStringReaderCall !inReaderName ?outAccessorTypesList ?outReturnedType ?outHasLexiqueAndLocationArguments ;
    when >= @typeGalgas_lstring do
      if [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else # Inherited @ string reader ?
        handleStringReaderCall ! inReaderName ?outAccessorTypesList ?outReturnedType ?outHasLexiqueAndLocationArguments ;
        outCppConversionMethod := "ggs_string" ;
      end if ;
    when >= @typeGalgas_location do
      if [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "locationIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "line" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "column" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_binaryset do
      if [inReaderName string] == "isFull" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isEmpty" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "significantVariableCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "ITE" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "forAllOnBitIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "forAllOnBitIndexAndBeyond" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "existOnBitIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "existOnBitIndexAndBeyond" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "valueCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "compressedValueCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "uint64ValueList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        build_uint64list_type ?outReturnedType ;
      elsif [inReaderName string] == "stringValueList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        build_stringlist_type ?outReturnedType ;
      elsif [inReaderName string] == "stringValueListWithNameList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        build_stringlist_type ?outReturnedType ;
        outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ;
      elsif [inReaderName string] == "predicateStringValue" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "compressedStringValueList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        build_stringlist_type ?outReturnedType ;
      elsif [inReaderName string] == "swap21" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap132" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap213" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap231" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap312" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap321" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "transitiveClosure" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "accessibleStates" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "equalTo" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "notEqualTo" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "lowerOrEqualTo" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "greaterOrEqualTo" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "greaterThan" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "lowerThan" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "binarySetByTranslatingFromIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "containsValue" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "existsOnBitRange" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_uint do
      if [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "lsbIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "significantBitCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "hexString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "isUnicodeValueAssigned" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_char do
      if [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "utf32CharConstantRepresentation" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "isalnum" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isalpha" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "iscntrl" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isdigit" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "islower" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isupper" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isxdigit" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "uintValue" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "isUnicodeLetter" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isUnicodeMark" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isUnicodeNumber" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isUnicodeSeparator" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isUnicodeCommand" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isUnicodePunctuation" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isUnicodeSymbol" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "unicodeName" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "unicodeToLower" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_char new] ;
      elsif [inReaderName string] == "unicodeToUpper" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_char new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_uint64 do
      if [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "uintSlice" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "hexString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_sint do
      if [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_sint64 do
      if [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_data do
      if [inReaderName string] == "length" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_type do
      if [inReaderName string] == "name" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_function do
      if [inReaderName string] == "name" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "resultType" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_type new] ;
      elsif [inReaderName string] == "formalParameterTypeList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_typelist_type ?outReturnedType ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_double do
      if [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_bool do
      if [inReaderName string] == "cString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "ocString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_lchar do
      if [inReaderName string] == "char" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_char new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_lbool do
      if [inReaderName string] == "bool" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_luint do
      if [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_luint64 do
      if [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_lsint do
      if [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_lsint64 do
      if [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_ldouble do
      if [inReaderName string] == "double" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_double new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgasListType listType do
      if [inReaderName string] == "length" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "subListFromIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "subListWithRange" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      else
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ; # Temporary
        @typeListeAttributsSemantiques attributeList := [listType mAttributeList] ;
        @bool found := false ;
        foreach attributeList while not found do
          found := ([mAttributeName string] . "AtIndex") == [inReaderName string] ;
          if (found) then
            outReturnedType := mAttributType ;
          end if ;
        end foreach ;
        if not found then
          error inReaderName :
           "the '" . [inReaderName string] . "' reader is not supported by a list" ;
        end if ;
      end if ;
    when >= @typeGalgasSortedListType do
      if [inReaderName string] == "length" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      else
        error inReaderName :
           "sorted list supports only 'length' reader call" -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgasMapType do
      if [inReaderName string] == "hasKey" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "locationForKey" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "count" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "allKeys" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_stringset new] ;
      elsif [inReaderName string] == "keyList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_lstringlist_type ? outReturnedType ;
      elsif [inReaderName string] == "unsolvedIndexCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "unsolvedIndexKeyStringList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type ?outReturnedType ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgasListmapType mapType do
      if [inReaderName string] == "hasKey" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "allKeys" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_stringset new] ;
      elsif [inReaderName string] == "count" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "keyList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type ? outReturnedType ;
      elsif [inReaderName string] == "listForKey" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [mapType mListType] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_stringset do
      if [inReaderName string] == "hasKey" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        @AC_galgasType keyType := [@typeGalgas_string new] ;
        outAccessorTypesList += !keyType ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "count" then
        outHasLexiqueAndLocationArguments := false ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "stringList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type ? outReturnedType ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;

    when >= @typeGalgasClassType t do
      outReturnedType := [@typeGalgas_string new] ; # Any Value
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @stringlist acceptedReaderList [emptyList] ;
      if not [[t mMessagesMap] hasKey ![inReaderName string]] then
      #--- Search for attribute
        @bool found := false ;
        if [[t mNonExternAttributesMap] hasKey ![inReaderName string]] then
          found := true ;
          @bool hasGetter ;
          [[t mNonExternAttributesMap] searchKey !inReaderName ?outReturnedType ?* ? hasGetter] ;
          if not hasGetter then
            error inReaderName:"the '" . inReaderName . "' attribute has 'nogetter' feature, it cannot be used as a reader" ;
            warning [[t mNonExternAttributesMap] locationForKey![inReaderName string]]:"for previous error, attribute is declared here";
          end if ;
        end if ;
      #--- Search for lazy attribute
        foreach [t mLazyAttributeList] while not found do
          foreach mComputedAttributeTypeAndNameList while not found do
            outReturnedType := mAttributType ;
            found := [inReaderName string] == [mAttributeName string] ;
          end foreach ;
        end foreach ;
      #--- Search for lazy attribute in super classes
        foreach [t mAncestorClassesMap] while not found do
          @AC_semanticsEntity entite ;
          [ioEntitiesMap searchKey !key ?entite] ;
          @AC_galgasType type := [(cast entite if >= @typeEntiteType else error key) aDefType] ;
          @typeGalgasClassType classType := (cast type if >= @typeGalgasClassType else error key) ;
          foreach [classType mLazyAttributeList] while not found do
            foreach mComputedAttributeTypeAndNameList while not found do
              outReturnedType := mAttributType ;
              found := [inReaderName string] == [mAttributeName string] ;
            end foreach ;
          end foreach ;
        end foreach ;
      #--- Search for category reader
        if not found then
          @L_EXsignature signature [emptyList] ;
          @string className := [[t mClassTypeName] string] ;
          @lstring kKey [new !className . ":" . [inReaderName string] ![inReaderName location]] ;
          if [inCategoryReaderMap hasKey ![kKey string]] then
            @categoryMethodKind categoryMethodKind ;
            [inCategoryReaderMap searchKey !kKey ?categoryMethodKind ?signature ?outReturnedType] ;
            if categoryMethodKind != [@categoryMethodKind overridingMethod] then
              outCategoryReaderClassBaseName := className ;
            end if ;
          end if ;
          foreach [t mAncestorClassesMap] while outCategoryReaderClassBaseName == "" do
            @lstring superKey [new ![key string] . ":" . [inReaderName string] ![inReaderName location]] ;
            if [inCategoryReaderMap hasKey ![superKey string]] then
              @categoryMethodKind categoryMethodKind ;
              [inCategoryReaderMap searchKey !superKey ?categoryMethodKind ?signature ?outReturnedType] ;
              if categoryMethodKind != [@categoryMethodKind overridingMethod] then
                outCategoryReaderClassBaseName := className ;
              end if ;
            end if ;
          end foreach ;
          found := outCategoryReaderClassBaseName != "" ;
          foreach signature do
            outAccessorTypesList += !mType ![@lstring new !"?" !here] ;
          end foreach ;
        end if ;
      #---
        if not found then
          error inReaderName: "this reader is not defined" ;
        end if ;
      end if ;
    when >= @typeGalgasStructType t do
      outReturnedType := [@typeGalgas_string new] ; # Any Value
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @bool found := false ;
      foreach [t mAttributeList] while not found do
        outReturnedType := mAttributType ;
        found := [inReaderName string] == [mAttributeName string] ;
      end foreach ;
      if not found then
        error inReaderName: "this reader is not defined (you can name as reader any struct attribute)" ;
      end if ;
    when >= @typeGalgas_enum e do
      @typeEnumMessageMap kMessagesMap := [e mMessagesMap] ;
      [kMessagesMap searchKey ! inReaderName ?*] ;
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ; #--- No argument
      outReturnedType := [@typeGalgas_string new] ;
    else
      error inReaderName :
         "variables of this type do not support reader call"
         -> outAccessorTypesList, outReturnedType ;
    end cast ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

extern routine check_KL_escapeCharacters
 ?@lstring inString
;

#---------------------------------------------------------------------------*

extern routine check_K_escapeCharacters
 ?@lstring inString
;

#---------------------------------------------------------------------------*

routine importSemanticsComponent
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioActionMap
  ?!@stringset ioAlreadyImportedSemanticsComponents
  ?!@stringset ioAlreadyImportedMetamodelComponents
  ?@lstring inSemanticsComponentName
:
  if not [ioAlreadyImportedSemanticsComponents hasKey ![inSemanticsComponentName string]] then
    @ModelMap modelMap ; # The types and classes declared in this component
    @ActionMap actionMap ; # The routines and the extern actions declared in this component 
    @stringset importedSemanticsComponents ; # The other semantics components imported in this component
    @stringset importedMetamodelComponents ; # The metamodel components imported in this component
    @stringset importedOptionsComponents ; # The option components imported in this component
    [ioSemanticsComponentsMap searchKey
      !inSemanticsComponentName
      ?modelMap
      ?actionMap
      ?importedSemanticsComponents
      ?importedMetamodelComponents
      ?importedOptionsComponents
      ?*
      ?*
    ] ;
  #--- Add Imported metamodels
    ioAlreadyImportedMetamodelComponents := ioAlreadyImportedMetamodelComponents | importedMetamodelComponents ;
  #--- Recursively import other semantics components
    foreach importedSemanticsComponents do
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?ioModelMap
        !?ioActionMap
        !?ioAlreadyImportedSemanticsComponents
        !?ioAlreadyImportedMetamodelComponents
        ![@lstring new !key !here]
      ;
    end foreach ;
  #--- Add imported types
    foreach modelMap do
      if not [ioModelMap hasKey ![key string]] then
        [!?ioModelMap insertKey !key !mType] ;
      end if ;
    end foreach ;
  #--- Add actions
    foreach actionMap do
      if not [ioActionMap hasKey ![key string]] then
        [!?ioActionMap insertKey !key !mSignature !mIsExtern] ;
      end if ;
    end foreach ;
  #--- Flag component as imported
    ioAlreadyImportedSemanticsComponents += ![inSemanticsComponentName string] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#         E N T E R    B U I L T I N    T Y P E S                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterBuiltinTypes !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap :
  ioComponentSemanticsEntitiesMap := [@M_semanticsEntitiesForUse emptyMap] ;

  @AC_semanticsEntity e := [@typeEntiteType new ![@typeGalgas_lstring new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lstring" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lbool new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lbool" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_luint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"luint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lsint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lsint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_luint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"luint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lsint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lsint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_ldouble new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"ldouble" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lchar new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lchar" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_location new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"location" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_uint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_sint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"sint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_uint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_sint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"sint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_char new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"char" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_string new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"string" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_bool new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"bool" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_binaryset new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"binaryset" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_double new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"double" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_stringset new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"stringset" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_filewrapper new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"filewrapper" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_data new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"data" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_type new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"type" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_object new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"object" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_function new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"function" !here] !e] ;

  @AC_galgasType t ; build_uintlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uintlist" !here] !e] ;

  build_luintlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"luintlist" !here] !e] ;

  build_uint64list_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint64list" !here] !e] ;

  build_stringlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"stringlist" !here] !e] ;

  build_lstringlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lstringlist" !here] !e] ;

  build_string2list_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"string2list" !here] !e] ;

  build_string3list_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"string3list" !here] !e] ;

  build_typelist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"typelist" !here] !e] ;

  build_functionlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"functionlist" !here] !e] ;

end routine ;

#---------------------------------------------------------------------------*

abstract class @templateInstruction feature generatedInSeparateFile {
}

#---------------------------------------------------------------------------*

list @templateInstructionList {
  @templateInstruction mInstruction ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   E X P R E S S I O N    A B S T R A C T    C L A S S                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeExpression feature generatedInSeparateFile {
}
 
#---------------------------------------------------------------------------*

class @templateInstructionString extends @templateInstruction {
  @string mTemplateString feature nogetter ;
}

#---------------------------------------------------------------------------*

class @templateInstructionExpression extends @templateInstruction {
  @typeExpression mExpression feature nogetter ;
}

#---------------------------------------------------------------------------*

class @templateBlockInstruction extends @templateInstruction {
  @typeExpression mExpression feature nogetter ;
  @location mMagicNumber feature nogetter ;
  @templateInstructionList mBlockInstructionList feature nogetter ;
}

#---------------------------------------------------------------------------*

class @templateInstructionConstant extends @templateInstruction {
  @typeCplusPlusName mCppName feature nogetter ;
}

#---------------------------------------------------------------------------*

class @templateInstructionColumnString extends @templateInstruction {
  @typeCplusPlusName mCppName feature nogetter ;
}

#---------------------------------------------------------------------------*

class @templateInstructionForeach extends @templateInstruction {
  @bool mIsAscending feature nogetter ;
  @string mCppExpressionTypeName feature nogetter ;
  @bool mNewEnumerationStyle feature nogetter ;
  @typeExpression mExpression feature nogetter ;
  @location mInstructionLocation feature nogetter ;
  @templateInstructionList mBeforeInstructionList feature nogetter ;
  @templateInstructionList mDoInstructionList feature nogetter ;
  @lstring mIndexIdentifier feature nogetter ;
  @templateInstructionList mBetweenInstructionList feature nogetter ;
  @templateInstructionList mAfterInstructionList feature nogetter ;
}

#---------------------------------------------------------------------------*

list @templateInstructionIfBranchList {
  @typeExpression mExpression ;
  @templateInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @templateInstructionIf extends @templateInstruction {
  @templateInstructionIfBranchList mTemplateInstructionIfBranchList feature nogetter ;
  @templateInstructionList mElseInstructionList feature nogetter ;
}

#---------------------------------------------------------------------------*

struct @EXsemanticContext {
  @M_filewrappers mFilewrappers ;
  @stringset mImportedSemanticComponents ;
  @EXcategoryMethodMap mCategoryMethodMap ;
  @EXcategoryReaderMap mCategoryReaderMap ;
  @EXcategoryTemplateMap mCategoryTemplateMap ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of syntax components                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_syntaxComponents {
  @nonTerminalSymbolMapForGrammarAnalysis mNonterminalSymbolsMap ;
  @productionRuleListForGrammarAnalysis mProductionRulesList ;
  @lstring mLexiqueComponentName ;
  insert insertKey error message "a syntax component named '%K' is already declared in %L" ;
  search searchKey error message "there is no syntax component named '%K'" ;
}

#---------------------------------------------------------------------------*

end semantics ;
