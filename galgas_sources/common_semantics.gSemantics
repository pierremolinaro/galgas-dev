#---------------------------------------------------------------------------*
#                                                                           *
#  Common semantics definitions                                             *
#                                                                           *
#  Copyright (C) 1997, ..., 2008 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics common_semantics :

#---------------------------------------------------------------------------*
#                                                                           *
#  A C T U A L    P A R A M E T E R S    P A S S I N G    M O D E S         *
#                                                                           *
#---------------------------------------------------------------------------*

enum @EXactualParametersPassingMode {
  constructor parameterOut ;
  constructor parameterOutIn ;
  constructor parameterIn ;
}{
  reader actualArgumentMessage :
    parameterOutIn -> "an output/input (!?) actual parameter" ;
    parameterIn -> "an input (?) actual parameter" ;
    parameterOut -> "an output (!) actual parameter" ;
  end reader ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   F O R M A L    A R G U M E N T S    P A S S I N G    M O D E S          *
#                                                                           *
#---------------------------------------------------------------------------*

enum @EXformalArgumentPassingMode {
  constructor argumentIn ;
  constructor argumentOut ;
  constructor argumentInOut ;
  constructor argumentConstantIn ;
}{
  reader formalArgumentMessage :
    argumentConstantIn -> "a constant input (??) formal argument" ;
    argumentIn -> "an input (?) formal argument" ;
    argumentOut -> "an output (!) formal argument" ;
    argumentInOut -> "an input/output (?!) argument" ;
  end reader ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Definition du type abstrait instruction d'une methode              *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeInstruction [generatedInSeparateFile] {
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Definition du type list d'instructions d'une methode               *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeInstructionList {
  @typeInstruction mInstruction ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   A C T I O N ,    M E T H O D    S I G N A T U R E                       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_signature {
  @EXformalArgumentPassingMode mFormalArgumentPassingMode ;
  @lstring mGalgasTypeName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E    L I S T    M O D E L                                          *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeListModel {
  @lstring mTypeName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T Y P E    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  B O O L    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @BoolModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C H A R    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @CharModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U I N T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @UIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S I N T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @SIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U I N T 6 4    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @UInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S I N T 6 4    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @SInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  D O U B L E    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @DoubleModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S T R I N G    M O D E L                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @StringModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L B O O L    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LBoolModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L C H A R    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LCharModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L U I N T    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LUIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S I N T    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @LSIntModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L U I N T 6 4    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LUInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S I N T 6 4    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LSInt64Model extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L D O U B L E    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LDoubleModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L S T R I N G    M O D E L                                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @LStringModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S T R I N G S E T    M O D E L                                           *
#                                                                           *
#---------------------------------------------------------------------------*

class @StringsetModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L O C A T I O N    M O D E L                                             *
#                                                                           *
#---------------------------------------------------------------------------*

class @LocationModel extends @TypeModel {
}

#---------------------------------------------------------------------------*
#                                                                           *
#  L I S T    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @ListModel extends @TypeModel {
  @typeListModel mAttributeList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P    M O D E L                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @MapModel extends @TypeModel {
  @typeListModel mAttributeList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E N U M    M O D E L                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @enumConstantMap {
  @bool mHasConstructor ;
  insert insertKey error message "the '%K' constant is already declared in %L" ;
  search searchKey, searchKeyAndGetIndex error message "the '%K' constant is not declared" ;
}

#---------------------------------------------------------------------------*

map @enumUsedConstantMap {
  insert insertKey error message "the '%K' constant is already used in %L" ;
}

#---------------------------------------------------------------------------*

map @enumMessageMap {
  insert insertKey error message "the '%K' message name is already declared in %L" ;
  search searchKey error message "the '%K' message name is not declared" ;
}

#---------------------------------------------------------------------------*

class @EnumModel extends @TypeModel {
  @enumConstantMap mEnumConstantesMap ; #--- Enumeration constants map
  @enumMessageMap mMessagesMap ; #--- Messages map
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    T Y P E    M O D E L                                      *
#                                                                           *
#---------------------------------------------------------------------------*

map @constructorMap {
  @typeListModel mFormalInputArgumentList ;
  insert insertKey error message "the '%K' constructor is already declared in %L" ;
  search searchKey error message "the '%K' constructor is not declared" ;
}

#---------------------------------------------------------------------------*

map @readerMap {
  @L_signature mReaderFormalArgumentList ;
  insert insertKey error message "the '%K' reader is already declared in %L" ;
  search searchKey error message "the '%K' reader is not declared" ;
}

#---------------------------------------------------------------------------*

map @modifierMap {
  @L_signature mModifierFormalArgumentList ;
  insert insertKey error message "the '%K' modifier is already declared in %L" ;
  search searchKey error message "the '%K' modifier is not declared" ;
}

#---------------------------------------------------------------------------*

class @ExternTypeModel extends @TypeModel {
  @constructorMap mExternTypeConstructorMap ;
  @readerMap mReaderMap ;
  @modifierMap mModifierMap ;
  @typeListModel mAddAssignFormalInputArgumentList ; # List is empty if += operator is not defined
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C L A S S    M O D E L                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

map @classMessageMap {
  insert insertKey error message "the '%K' message is already declared in %L" ;
  search searchKey error message "the '%K' message is not declared" ;
}

#---------------------------------------------------------------------------*

class @ClassModel extends @TypeModel {
  @bool mIsAbstract ;
  @stringset mSuperClasses ;
  @typeListModel mAttributeList ;
  @classMessageMap mMessageMap ;
}


#---------------------------------------------------------------------------*
#                                                                           *
#  M O D E L    M A P                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @ModelMap {
  @TypeModel mType ;
  insert insertKey error message "the '@%K' type has been already declared in %L" ;
  search searchKey error message "the '@%K' type is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    A C T I O N    A N D    R O U T I N E    M A P            *
#                                                                           *
#---------------------------------------------------------------------------*

map @ActionMap {
  @L_signature mSignature ;
  @bool mIsExtern ; # true for extern extern routine, false for routines
  insert insertKey error message "the '%K' extern extern routine has been already declared in %L" ;
  search searchKey error message "the '%K' extern routine is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   F O R W A R D    T Y P E     D E C L A R A T I O N S                    *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_EXsignature ;
list @typeListeAttributsSemantiques ;
map @EXcategoryMethodMap ;

#---------------------------------------------------------------------------*

enum @localConstantBuildStyleEnum {
  constructor listStyle ;
  constructor mapStyle ;
  constructor firstIsKeyOtherMapStyle ;
}{
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    T Y P E    ( A B S T R A C T    C L A S S )              *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_galgasType [generatedInSeparateFile] {
#--- Get type name
  abstract method getTypeName !@string outTypeName ;

#--- By default, object does not accept as sort key in sorted list definition
  method acceptToBeSortKeyInSortedListDefinition ??@lstring inErrorLocation :
    error inErrorLocation :
       "this attribute cannot be used for sorting" ;
  end method ;

#--- By default, object does not accept assignment from 'here'
  method acceptAssignmentFromHere ??@lstring inErrorLocation :
    error inErrorLocation :
       "assignment from 'here' is not allowed for variables of this type" ;
  end method ;

#--- By default, object does not accept to be enumerated (foreach instruction)
  method acceptForeachInstruction
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    error inErrorLocation :
       "variables of this type cannot be enumerated by in 'foreach' instruction"
       -> outForeachList, outStyle, outNewStyle
    ;
  end method ;

#--- By default, object does not accept modifier call
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
  end method ;

#--- By default, class does not accept reader instruction call
  method handleMethodInstructionCall
    ??@lstring inReaderName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outMethodSignature
    !@string outCategoryMethodClassBaseName
  :
    error inReaderName :
       "variables of this type do not support method call instruction"
       -> outMethodSignature, outCategoryMethodClassBaseName ;
  end method ;

#--- By default, class does not accept constructor call
  method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    error inClassMethodName : "This constructor is not defined"
      -> outAccessorTypesList, outHasLexiqueAndLocationArguments
    ;
  end method ;

#--- By default, class does not accept class method call
  method handleClassMethodCall
    ??@lstring inTypeMethodName
    !@L_EXsignature outTypeMethodSignature
  :
    error inTypeMethodName : "This type method is not defined" -> outTypeMethodSignature ;
  end method ;

#--- By default, class does not accept operator "-=" call
  method handleMinusAssignOperatorCall 
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    error inErrorLocation :
       "variables of this type do not support call of '-=' operator"
       -> outParametersList ;
  end method ;


#--- By default, class does not accept operator "+=" call
  method handleAddAssignOperatorCall 
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    error inErrorLocation :
       "variables of this type do not support call of '+=' operator"
       -> outParametersList ;
  end method ;

#--- By default, class does not accept "++" operator
  method handleIncrementOperatorCall 
    ??@location inErrorLocation
  :
    error inErrorLocation :
       "variables of this type do not support call of '++' operator" ;
  end method ;

#--- By default, class does not accept "--" operator
  method handleDecrementOperatorCall 
    ??@location inErrorLocation
  :
    error inErrorLocation :
       "variables of this type do not support call of '--' operator" ;
  end method ;

#--- By default, class does not accept to be silently converted to @location
  method checkAbilityToBeSilentlyConvertedToLocation 
  :
    error here : "variables of this type cannot be silently converted to @location value" ;
  end method ;

#--- Error message
  message messageGalgasType "any type" ;
  message "any type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#       C++ NAME FOR A FORMAL PARAMETER OR LOCAL VARIABLE                   *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCplusPlusName [generatedInSeparateFile] {
  @location mVariableLocation ;
}

#---------------------------------------------------------------------------*
# C++ name is the value of mName

class @typeDirectName extends @typeCplusPlusName {
  @string mName ;
}

#---------------------------------------------------------------------------*
# C++ name is _currentObject->mName

class @typeCurrentObjectName extends @typeCplusPlusName {
  @string mName ;
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for local method call)

class @typeCppThisName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for method call from category)

class @typeCppThisInCategoryName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is implicit (used for inherited method call)

class @typeCppInheritedName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of mName

class @typeAutomaticName extends @typeCplusPlusName {
  @string mName ;
}

#---------------------------------------------------------------------------*
# C++ name is 'var_cas_' followed by the value of an unique sequence number

class @typeLocationAutomaticName extends @typeCplusPlusName {
  @uint mSequenceNumber ;
}

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->zz' followed by the value of mName

class @typeOperandName extends @typeCplusPlusName {
  @string mName ;
  @bool mFieldKind ; # false : zz est vide ; true : zz est 'mInfo.'
  @bool mIteratorNewStyle ;
}

#---------------------------------------------------------------------------*
# C++ name is 'operand_xxx->mKey' followed by the value of mName

class @typeKeyName extends @typeCplusPlusName {
  @bool mIteratorNewStyle ;
}

#---------------------------------------------------------------------------*
# No variable

class @typeNullName extends @typeCplusPlusName {
}

#---------------------------------------------------------------------------*
#                                                                           *
#     Liste des types et des noms C++ des arguments d'une methode           *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeListeTypesEtNomsArgMethode {
  @AC_galgasType mType ;
  @EXformalArgumentPassingMode mFormalArgumentPassingMode ;
  @typeCplusPlusName mCppName ;
  @bool mModeIn ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                   Super classes map of a class                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeSuperClassesMap {
  insert insertKey error message "the class '%K' is already a super class of the current class" ;
}

#---------------------------------------------------------------------------*
#                    Liste d'attributs semantiques                          *
#---------------------------------------------------------------------------*

list @typeListeAttributsSemantiques {
  @AC_galgasType mAttributType ;
  @lstring mAttributeName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   L I S T    O F    G A L G A S    T Y P E S                              *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeTypesList {
  @AC_galgasType mType ;
  @location mEndOfExpressionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# M E T H O D ,    A C T I O N ,   R O U T I N E    S I G N A T U R E       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_EXsignature {
  @AC_galgasType mType ;
  @EXformalArgumentPassingMode mFormalArgumentPassingMode ;
}

#---------------------------------------------------------------------------*

enum @categoryMethodKind {
  constructor baseMethod, abstractMethod, overridingMethod ;
}{
}

#---------------------------------------------------------------------------*

map @EXcategoryMethodMap {
  @categoryMethodKind mCategoryMethodKind ;
  @L_EXsignature aListeArgumentsFormels ;
  insert insertKey error message "the '%K' method is already declared in %L" ;
  search searchKey, searchKeyAndGetIndex error message "the '%K' method is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# M E T H O D ,    A C T I O N ,   R O U T I N E    S I G N A T U R E       *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_actualParametersSignature {
  @AC_galgasType mType ;
  @EXactualParametersPassingMode mFormalArgumentPassingMode ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   A C C E S S O R    M A P                                                *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_accessors_map {
  @L_EXsignature mAccessorSignature ;
  @AC_galgasType mReturnedType ;
  insert insertKey error message "the '%K' accessor has been already declared in %L" ;
  search searchKey error message "the '%K' accessor is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    J O K E R    T Y P E                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_jokerInParameterList extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "" ;
  end method ;

#--- Error message
  message messageGalgasType "??" ;
  message "a joker" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L I T E R A L    T Y P E S                               *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_bool extends @AC_galgasType {
#--- Get type name
  override
  method getTypeName !@string outTypeName :
    outTypeName := "bool" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- Error message
  message "a '@bool' type" ;
  message messageGalgasType "a '@bool' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_uint extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "uint" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if ([inClassMethodName string] == "max") |
       ([inClassMethodName string] == "sequenceNumber") |  
       ([inClassMethodName string] == "errorCount") |  
       ([inClassMethodName string] == "warningCount") then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "valueWithMask" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a '@uint' type" ;
  message messageGalgasType "a '@uint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_char extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "char" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- Error message
  message "a '@char' type" ;
  message messageGalgasType "a '@char' type" ;
}

#---------------------------------------------------------------------------*

extern routine extern_build_stringlist_type !@AC_galgasType outType ;

#---------------------------------------------------------------------------*

class @typeGalgas_string extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "string" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- By default, class does not accept method instruction call
  override
  method handleMethodInstructionCall
    ??@lstring inReaderName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if [inReaderName string] == "writeToFile" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inReaderName string] == "writeToFileWhenDifferentContents" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
   elsif [inReaderName string] == "writeToExecutableFile" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inReaderName string] == "makeDirectoryAndWriteToFile" then
      outReaderSignature := [@L_EXsignature emptyList] ;
      outReaderSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inReaderName string] == "makeDirectory" then
      outReaderSignature := [@L_EXsignature emptyList] ;
    else
      error inReaderName: "this method is not defined (writeToFile, makeDirectoryAndWriteToFile"
      . " and makeDirectory methods are defined on @string objects) " -> outReaderSignature ;
    end if ;
  end method ;

#--- string accepts constructors
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "stringWithVersionString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithSourceFilePath" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "retrieveAndResetTemplateString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithCurrentDirectory" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithSequenceOfCharacters" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "stringWithMainFirstArgument" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithContentsOfFile" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "stringWithCurrentDateTime" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "stringWithEnvironmentVariable" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "stringWithEnvironmentVariableOrEmpty" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "CppLineComment" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "CppTitleComment" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "CppChar" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "CppString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "componentsJoinedByString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType stringlistType ; extern_build_stringlist_type ?stringlistType ;
      outAccessorTypesList += ! stringlistType ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- String accepts modifier call
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setCapacity" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setCharacterAtIndex" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_char new] ![@EXformalArgumentPassingMode argumentIn] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "this modifier is not defined"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- By default, class does not accept class method call
  override
  method handleClassMethodCall
    ??@lstring inTypeMethodName
    !@L_EXsignature outTypeMethodSignature
  :
    if [inTypeMethodName string] == "deleteFile" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inTypeMethodName string] == "removeEmptyDirectory" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inTypeMethodName string] == "removeDirectoryRecursively" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inTypeMethodName string] == "generateFile" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
      outTypeMethodSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inTypeMethodName : "This type method is not defined" -> outTypeMethodSignature ;
    end if ;
  end method ;

#--- Error message
  message "a '@string' type" ;
  message messageGalgasType "a '@string' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_sint extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "sint" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructors 'min' and 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "min" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message messageGalgasType "a '@sint' type" ;
  message "a '@sint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_sint64 extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "sint64" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructors 'min' and 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "min" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a '@sint64' type" ;
  message messageGalgasType "a '@sint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_uint64 extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "uint64" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- This class accepts "++" operator
  override method handleIncrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- This class accepts "--" operator
  override method handleDecrementOperatorCall 
    ??@location unused inErrorLocation
  :
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "max" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "uint64MaskWithCompressedBitString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "uint64BaseValueWithCompressedBitString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "uint64WithBitString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a '@uint64' type" ;
  message messageGalgasType "a '@uint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_double extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "double" ;
  end method ;

#--- Object accepts as sort key in sorted list definition
  override
  method acceptToBeSortKeyInSortedListDefinition ??@lstring unused inErrorLocation :
  end method ;

#--- Error message
  message "a '@double' type" ;
  message messageGalgasType "a '@double' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S   B D D                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_binaryset extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "binaryset" ;
  end method ;

#--- Class accepts constructor 'max'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "binarySetWithBit" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "emptyBinarySet" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "fullBinarySet" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "binarySetWithPredicateString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithEqualComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithNotEqualComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithStrictLowerComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithStrictGreaterComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithLowerOrEqualComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithGreaterOrEqualComparison" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithEqualToConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithNotEqualToConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithStrictLowerThanConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithStrictGreaterThanConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithLowerOrEqualToConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithGreaterOrEqualToConstant" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !""! here] ;
    elsif [inClassMethodName string] == "binarySetWithITE" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_binaryset new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_binaryset new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_binaryset new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a '@binaryset' type" ;
  message messageGalgasType "a '@binaryset' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S   P R I M I T I V E    T Y P E S                            *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @C_galgasPrimitiveType extends @AC_galgasType {
  message "any primitive type" ;
  message messageGalgasType "any primitive type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      G A L G A S    L O C A T I O N    T Y P E                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_location extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "location" ;
  end method ;

#--- Objects of this class accept assignment from 'here' keyword
  override method acceptAssignmentFromHere ??@lstring unused inErrorLocation :
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@location' type" ;
  message messageGalgasType "a '@location' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lstring extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lstring" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
      outAccessorTypesList += ![@typeGalgas_location new] ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setString" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lstring' type" ;
  message messageGalgasType "a '@lstring' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lchar extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lchar" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_char new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setChar" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_char new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lchar' type" ;
  message messageGalgasType "a '@lchar' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lbool extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lbool" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_bool new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setBool" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_bool new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lbool' type" ;
  message messageGalgasType "a '@lbool' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_luint extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "luint" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_uint new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setUint" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@luint' type" ;
  message messageGalgasType "a '@luint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_luint64 extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "luint64" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_uint64 new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setUint64" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_uint64 new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@luint64' type" ;
  message messageGalgasType "a '@luint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lsint extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lsint" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_sint new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setSint" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_sint new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lsint' type" ;
  message messageGalgasType "a '@lsint' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_lsint64 extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "lsint64" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_sint64 new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setSint64" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_sint64 new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@lsint64' type" ;
  message messageGalgasType "a '@lsint64' type" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_ldouble extends @C_galgasPrimitiveType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "ldouble" ;
  end method ;

#--- Class accepts class method call 'new'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_double new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
      t := [@typeGalgas_location new] ;
      outAccessorTypesList += !t ![@lstring new !"" !here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setDouble" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_double new] ![@EXformalArgumentPassingMode argumentIn] ;
    elsif [inModifierName string] == "setLocation" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_location new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "variables of this type do not support modifier call"
       -> outModifierSignature ;
    end if ;
  end method ;
#--- Class accepts to be silently converted to @location
  override method checkAbilityToBeSilentlyConvertedToLocation :
  end method ;

  message "a '@ldouble' type" ;
  message messageGalgasType "a '@ldouble' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S T R I N G S E T    T Y P E                             *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_stringset extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "stringset" ;
  end method ;

#--- stringset accepts constructor call 'emptySet'
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptySet" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "setWithString" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @AC_galgasType t := [@typeGalgas_string new] ;
      outAccessorTypesList += !t ![@lstring new !""! here] ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- stringset accepts operator "+=" call
  override
  method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := [@typeListeAttributsSemantiques emptyList] ;
    outParametersList += ![@typeGalgas_string new] ![@lstring new !""! here] ;
  end method ;

#--- stringset accepts operator "-=" call
  override
  method handleMinusAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := [@typeListeAttributsSemantiques emptyList] ;
    @AC_galgasType t := [@typeGalgas_string new] ;
    outParametersList += !t ![@lstring new !""! here] ;
  end method ;

#--- stringset object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := true ;
    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
    outForeachList += ![@typeGalgas_string new] ![@lstring new !"key" !here] ;
    outStyle := [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle] ;
  end method ;

#--- Error message
  message "a '@stringset' type" ;
  message messageGalgasType "a '@stringset' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    F I L E W R A P P E R    T Y P E                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgas_filewrapper extends @AC_galgasType {
#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := "filewrapper" ;
  end method ;

#--- File wrapper accepts modifier call
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "setCurrentDirectory" then
      outModifierSignature := [@L_EXsignature emptyList] ;
      outModifierSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentIn] ;
    else
      error inModifierName : "this modifier is not defined"
       -> outModifierSignature ;
    end if ;
  end method ;

#--- Error message
  message "a '@filewrapper' type" ;
  message messageGalgasType "a '@filewrapper' type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M E T H O D S    M A P                                                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableMethodes {
  @L_EXsignature aListeTypesParametres ;
  insert insertKey error message "a method named '%K' is already declared" ;
  search searchKey error message "there is no method named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  U N D E F I N E D    E X T E R N    T Y P E                              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedExternType extends @AC_galgasType {
#--- Galgas class name
  @lstring mGalgasClassName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mGalgasClassName string] ;
  end method ;

#--- Message
  message messageGalgasType "an undefined extern type" ;
  message "an undefined extern type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Extern type constructor map                                          *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_externTypeConstructorMap {
  @typeListeAttributsSemantiques aListeDesAttributs ;
  insert insertKey error message "the '%K' constructor is already declared in %L" ;
  search searchKey error message "the '%K' constructor is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    T Y P E                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasExternType extends @typeGalgasUndefinedExternType {
#--- Constructor map
  @M_externTypeConstructorMap mConstructorMap ;

#--- Modifiers map
  @typeTableMethodes mModifiersMap ;  

#--- Readers map
  @typeTableMethodes mReadersInInstructionMap ;  

#--- Attributes for handling operator '+=' call
  @bool mAcceptAddAssignOperatorCall ;
  @typeListeAttributsSemantiques mAddAssignOperatorCallTypeList ;

#--- Constructors
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    [mConstructorMap searchKey !inClassMethodName ?outAccessorTypesList] ;
  end method ;

#--- Handle modifier call : return modifier signature
  override method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    [mModifiersMap searchKey !inModifierName ?outModifierSignature] ; 
  end method ;

#--- By default, class does not accept reader instruction call
  override method handleMethodInstructionCall
    ??@lstring inReaderName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    [mReadersInInstructionMap searchKey !inReaderName ?outReaderSignature] ;
  end method ;

#--- Handle operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
      [self handleAddAssignOperatorCall !inErrorLocation ?outParametersList] ;
    if not mAcceptAddAssignOperatorCall then
      [super handleAddAssignOperatorCall !inErrorLocation ?outParametersList] ;
    else
      outParametersList := mAddAssignOperatorCallTypeList ;
    end if ;
  end method ;

#--- Message
  message "an extern type" ;
  message messageGalgasType "an extern type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Terminal symbols map (for using in a syntax component)               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_terminalSymbolsMapForUse {
  @typeListeAttributsSemantiques aListeDesAttributs ;
  insert insertKey error message "the terminal symbol '$%K$' is already declared in %L" ;
  search searchKey, searchKeyGetID error message "the terminal symbol '$%K$' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Lexiques map (for using in a syntax component)                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_lexiqueComponents {
  @M_terminalSymbolsMapForUse mTerminalSymbolMap ;
  insert insertKey error message"the '%K' lexique is already declared in %L" ;
  search searchKey error message"the '%K' lexique is not defined" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                   Table des classes declarees 'enavant'                   *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableEnAvant {
  @AC_galgasType mType ;
  insert insertKey error message "the type '%K' is already declared in %L" ;
  search searchKey error message "the type '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Grammars map                                                 *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonterminalSymbolAlts {
  @L_EXsignature mFormalParametersList ;

  insert insertKey error message "the label '%K' has been already declared in %L" ;
  search searchKey error message "the label '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Semantics entity abstract type                                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_semanticsEntity [generatedInSeparateFile] {
  message  "any entity";
  message messageTypeEntite  "any entity";
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Grammar as semantics entity                                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_grammarForSemantics extends @AC_semanticsEntity {
  @M_nonterminalSymbolAlts mGrammarAltMap ;
  @lstring mLexiqueClassName ;

  message messageTypeEntite  "a grammar entity";
  message "a grammar entity";
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of semantics entities                                              *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_semanticsEntitiesForUse  {
  @AC_semanticsEntity aDefEntite ;
  insert insertKey error message "a semantics entity named '%K' is already declared in %L" ;
  search searchKey error message "there is no semantics entity named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   T Y P E S    S Y S T E M    F O R    G R A M M A R    C O M P O N E N T *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_typeForGrammarComponent [generatedInSeparateFile] {
  message typeForGrammarComponentMessage  "any type";
}

#---------------------------------------------------------------------------*

map @M_typesForGrammarComponent {
  @AC_typeForGrammarComponent mType ;
  insert insertKey error message "the '@%K' type is already declared in %L" ;
  search searchKey error message "the '@%K' type is not defined" ;
}

#---------------------------------------------------------------------------*

routine checkSignature_ForGrammarComponent
  ??@L_signature inFormalReferenceSignature
  ??@L_signature inFormalTestedSignature
  ??@location inFormalTestedLocation
  ??@location inFormalReferenceLocation
:
  if [inFormalReferenceSignature length] < [inFormalTestedSignature length] then
    error inFormalTestedLocation : "too much formal parameters (from prototype in " . [inFormalReferenceLocation locationString] . ")" ;
  elsif [inFormalReferenceSignature length] > [inFormalTestedSignature length] then
    error inFormalTestedLocation : "too much formal parameters (from prototype in " . [inFormalReferenceLocation locationString] . ")" ;
  else
    foreach inFormalReferenceSignature (@EXformalArgumentPassingMode passingMode1 @lstring kType1),
            inFormalTestedSignature  (@EXformalArgumentPassingMode passingMode2 @lstring kType2) do
      if passingMode1 != passingMode2 then
        error kType2 : "Prototype has " . [passingMode1 formalArgumentMessage] .
                       ", and " . [passingMode1 formalArgumentMessage] . " has been found" ;
      end if ;
      if [kType1 string] != [kType2 string] then
        error kType2 :  "I was expecting the '@" . [kType1 string] . "' type, I have got the '@" . [kType2 string] . "' type" ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#         Instruction abstract class for grammar component                  *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @AC_instruction_ForGrammar [generatedInSeparateFile] {
  @location mStartLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#        Syntax signature                                                   *
#      (sequence of terminal, nonterminal, select and repeat)               *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_ruleSyntaxSignature {
  @AC_instruction_ForGrammar mInstruction ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   Grammars map                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @L_grammarsMap {
  @M_nonterminalSymbolAlts mStartSymbolParametersMap ;

  insert insertKey error message "the '%K' grammar is already defined in %L" ;
  search searchKey error message "the '%K' grammar is not defined" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  T E R M I N A L    S Y M B O L    M A P                                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonterminalSymbolAltsForGrammar {
  @L_signature mFormalParametersList ;

  insert insertKey error message "the rule label '%K' has been already declared in %L" ;
  search searchKey error message "the rule label '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   Production rules list (for a grammar component)                         *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_productionRules_ForGrammarComponent {
  @lstring mLeftNonterminalSymbol ;
  @uint mLeftNonterminalSymbolIndex ;
  @L_ruleSyntaxSignature mInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#             nonterminal symbols map                                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonTerminalSymbolsForGrammar {
  @M_nonterminalSymbolAltsForGrammar mNonterminalSymbolParametersMap ;

  insert insertKey error message "the '<%K>' non terminal symbol has already been declared" ;
  search searchKey, searchKeyGetID error message "the '<%K>' non terminal symbol is not declared" ;
}

#---------------------------------------------------------------------------*

map @M_unusedNonTerminalSymbolsForGrammar {
  @luint mSymbolIndex ;
  insert insertKey error message "the '<%K>' non terminal symbol has already been declared as unused" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of syntax components                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_syntaxComponents {
  @M_nonTerminalSymbolsForGrammar mNonterminalSymbolsMap ;
  @L_productionRules_ForGrammarComponent mProductionRulesList ;
  @lstring mLexiqueComponentName ;
  insert insertKey error message "a syntax component named '%K' is already declared in %L" ;
  search searchKey error message "there is no syntax component named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   Terminal call instruction (for a grammar component)                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @T_terminalInstruction_forGrammarComponent extends @AC_instruction_ForGrammar {
  @lstring mTerminalSymbolName ;
  @uint mTerminalSymbolIndex ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   Nonterminal call instruction (for a grammar component)                  *
#                                                                           *
#---------------------------------------------------------------------------*

class @T_nonterminalInstruction_forGrammarComponent extends @AC_instruction_ForGrammar {
  @lstring mNonterminalSymbolName ;
  @uint mNonterminalSymbolIndex ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# Liste of branches of a 'select' or 'repeat' instruction                   *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_branchList_ForGrammarComponent {
  @L_ruleSyntaxSignature mInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   select instruction (for a grammar component)                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @T_selectInstruction_forGrammarComponent extends @AC_instruction_ForGrammar {
  @L_branchList_ForGrammarComponent mSelectList ;
  @uint mAddedNonterminalmSymbolIndex ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   repeat instruction (for a grammar component)                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @T_repeatInstruction_forGrammarComponent extends @AC_instruction_ForGrammar {
  @L_branchList_ForGrammarComponent mRepeatList ;
  @uint mAddedNonterminalmSymbolIndex ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    List of syntax components For Grammar                                  *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_syntaxComponents_ForGrammar {
  @M_nonTerminalSymbolsForGrammar mNonterminalSymbolsMap ;
  @L_productionRules_ForGrammarComponent mProductionRulesList ;
  @lstring mSyntaxComponentName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Class inherited messages map                                    *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeClassInheritedMessagesMap {
  insert insertKey error message "the message '%K' is already declared in %L" ;
  search searchKey error message "the message '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Semantic attributes map                                        *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeSemanticAttributesMap {
  @AC_galgasType mAttributType ;
  insert insertKey error message "an attribut named '%K' is already declared in %L" ;
  search searchKey error message "there is no attribut named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Definition des tables des methodes d'insertion et de recherche         *
#                                                                           *
#---------------------------------------------------------------------------*

list @insertOrSearchMethodList {
  @lstring mMethodName ;
  @string mErrorMessage ;
  @bool mIsGetIndexMethod ;
  @string mShadowErrorMessage ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#             Classe abstract definissant une classe                        *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeDefEntiteUtilisable [generatedInSeparateFile] {
  message messageTypeEntite "any type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U N D E F I N E D    L I S T    T Y P E                  *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedListType extends @AC_galgasType {
  @lstring mListTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mListTypeName string] ;
  end method ;

  message "an undefined list type" ;
  message messageGalgasType "an undefined list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L I S T    T Y P E                                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasListType extends @typeGalgasUndefinedListType {
#--- List of all attributes
  @typeListeAttributsSemantiques mAttributeList ;
#--- Extract Methods signature (for 'first', 'last', 'popFirst', 'popLast')
  @L_EXsignature mExtractSignature ;
#--- Input Methods signature (for 'prependValue')
  @L_EXsignature mInputSignature ;

#--- list object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := false ;
    outForeachList := mAttributeList ;
    outStyle := [@localConstantBuildStyleEnum listStyle] ;
  end method ;
  
#--- Modifiers are 'popFirst' and 'popLast' methods
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [inModifierName string] == "prependValue" then
      outModifierSignature := mInputSignature ;
    elsif ([inModifierName string] == "popFirst") | ([inModifierName string] == "popLast") then
      outModifierSignature := mExtractSignature ;
    else
      outModifierSignature := [@L_EXsignature emptyList] ;
      @bool found := false ;
      foreach mAttributeList while not found do
        found := ("set" . [[mAttributeName string] stringByCapitalizingFirstCharacter] . "AtIndex") == [inModifierName string] ;
        if (found) then
          outModifierSignature += !mAttributType ![@EXformalArgumentPassingMode argumentConstantIn] ;
          outModifierSignature += ![@typeGalgas_uint new] ![@EXformalArgumentPassingMode argumentConstantIn] ;
        end if ;
      end foreach ;
      if not found then
        error inModifierName :
         "the '" . [inModifierName string] . "' modifier is not supported by the list" ;
      end if ;
    end if ;
  end method ;


#--- List accept 'first' and last' reader in instruction
  override
  method handleMethodInstructionCall
    ??@lstring inReaderName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if ([inReaderName string] != "first") & ([inReaderName string] != "last") then
      error inReaderName: "a list accepts only 'first' and 'last' methods" ;
    end if ;
    outReaderSignature := mExtractSignature ;
  end method ;

#--- list accepts operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := mAttributeList ;
  end method ;

#--- A list accepts 'emptyList' and 'listWithValue' constructors
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptyList" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "listWithValue" then
      outAccessorTypesList := mAttributeList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

  message "a list type" ;
  message messageGalgasType "a list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S T R U C T    T Y P E                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasStructType extends @AC_galgasType {
  @lstring mStructTypeName ;
  @typeListeAttributsSemantiques mAttributeList ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mStructTypeName string] ;
  end method ;

#--- A struct accepts 'new' constructor
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "new" then
      outAccessorTypesList := mAttributeList ;
    else
      error inClassMethodName : "the '" . inClassMethodName  . "' constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

  message "a struct type" ;
  message messageGalgasType "a struct type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L I S T M A P    T Y P E                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasListmapType extends @AC_galgasType {
  @lstring mListmapTypeName ;
  @lstring mListTypename ;
  @typeGalgasListType mListType ;

#--- List of all attributes of list
  @typeListeAttributsSemantiques mAttributeList ;

#--- listmap object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := true ;
    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
    outForeachList += ![@typeGalgas_string new] ![@lstring new !"key" !here] ;
    outForeachList += !mListType ![@lstring new !"object" !here] ;
    outStyle := [@localConstantBuildStyleEnum listStyle] ;
  end method ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mListmapTypeName string] ;
  end method ;

#--- A listmap accepts 'emptyMap' constructor
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptyMap" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "the '" . inClassMethodName  . "' constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- listmap accepts operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := [@typeListeAttributsSemantiques emptyList] ;
    outParametersList += ![@typeGalgas_string new] ![@lstring new !"key" !here] ;
    outParametersList := outParametersList . mAttributeList ;
  end method ;

  message "a listmap type" ;
  message messageGalgasType "a listmap type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U I N T L I S T    T Y P E                               *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_uintlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_uint new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_uint new] ![@EXformalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_uint new] ![@EXformalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"uintlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L U I N T L I S T    T Y P E                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_luintlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_luint new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_luint new] ![@EXformalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_luint new] ![@EXformalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"luintlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U I N T 6 4 L I S T    T Y P E                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_uint64list_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_uint64 new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_uint64 new] ![@EXformalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_uint64 new] ![@EXformalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"uint64list" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S T R I N G L I S T    T Y P E                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_stringlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_string new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_string new] ![@EXformalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"stringlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    L S T R I N G L I S T    T Y P E                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine build_lstringlist_type !@AC_galgasType outType :
  @typeListeAttributsSemantiques attributesList [emptyList] ;
  attributesList += ![@typeGalgas_lstring new] ![@lstring new !"mValue" !here] ;
  @L_EXsignature extractSignature [emptyList] ;
  extractSignature += ![@typeGalgas_lstring new] ![@EXformalArgumentPassingMode argumentOut] ;
  @L_EXsignature inputSignature [emptyList] ;
  inputSignature += ![@typeGalgas_lstring new] ![@EXformalArgumentPassingMode argumentConstantIn] ;
  outType := [@typeGalgasListType new
    ![@lstring new !"lstringlist" !here]
    !attributesList
    !extractSignature
    !inputSignature
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#  D O M A I N    T Y P E                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

map @domainModifierMap {
  @L_EXsignature mFormalParametersList ;
  insert insertKey error message "the '%K' domain modifier has been already declared in %L" ;
  search searchKey error message "the '%K' domain modifier is not declared" ;
}

#---------------------------------------------------------------------------*

map @domainAttributeMap {

  insert insertKey error message "an attribute named '%K' is already declared in %L" ;
  search searchKey error message "there is no attribute named '%K'" ;
}

#---------------------------------------------------------------------------*

class @typeGalgasDomainType extends @AC_galgasType {
  @lstring mDomainTypeName ;
  @domainAttributeMap mAttributeMap ;
  @domainModifierMap mDomainModifierMap ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mDomainTypeName string] ;
  end method ;

#--- A domain accepts 'emptyDomain' constructor
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "emptyDomain" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "a domain only accepts 'emptyDomain' constructor" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if [mDomainModifierMap hasKey ![inModifierName string]] then
      [mDomainModifierMap searchKey !inModifierName ?outModifierSignature] ;
    else
      error inModifierName: "this modifier is not defined" -> outModifierSignature ;
    end if ;
  end method ;

  message "a domain type" ;
  message messageGalgasType "a domain type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U N D E F I N E D    S O R T E D    L I S T    T Y P E   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedSortedListType extends @AC_galgasType {
  @lstring mListTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mListTypeName string] ;
  end method ;

  message "a predeclared sorted list type" ;
  message messageGalgasType "a predeclared sorted list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    S O R T E D    L I S T    T Y P E                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasSortedListType extends @typeGalgasUndefinedSortedListType {
#--- List of all attributes
  @typeListeAttributsSemantiques mAttributeList ;
#--- Extract Methods signature (for 'smallest', 'greatest', 'popSmallest', 'popGreatest')
  @L_EXsignature mExtractSignature ;

#--- list object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := false ;
    outForeachList := mAttributeList ;
    outStyle := [@localConstantBuildStyleEnum listStyle] ;
  end method ;
  
#--- Modifiers are 'popSmallest' and 'popLast' methods
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    if ([inModifierName string] == "popSmallest") | ([inModifierName string] == "popGreatest") then
      outModifierSignature := mExtractSignature ;
    else
      error inModifierName: "a sorted list accepts only 'popSmallest' and 'popGreatest' modifiers" -> outModifierSignature ;
    end if ;
  end method ;


#--- List accept 'smallest' and greatest' reader in instruction
  override
  method handleMethodInstructionCall
    ??@lstring inReaderName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if ([inReaderName string] != "smallest") & ([inReaderName string] != "greatest") then
      error inReaderName: "a sorted list accepts only 'smallest' and 'greatest' methods" ;
    end if ;
    outReaderSignature := mExtractSignature ;
  end method ;

#--- list accepts operator "+=" call
  override method handleAddAssignOperatorCall
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outParametersList
  :
    outParametersList := mAttributeList ;
  end method ;

#--- A list accepts 'emptyList' and 'listWithValue' constructors
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := false ;
    if [inClassMethodName string] == "emptySortedList" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "sortedListWithValue" then
      outAccessorTypesList := mAttributeList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

  message "a sorted list type" ;
  message messageGalgasType "a sorted list type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Definition des tables des methodes de surcharge                *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableBlocsDeTable {
  @L_EXsignature aSignatureDebut ;
  @L_EXsignature aSignatureFin ;
  insert insertKey error message "a block method named '%K' is already declared in %L" ;
  search searchKey error message "there is no block method named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#               Definition d'un type map utilisable                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedMapType extends @AC_galgasType {
  @lstring mMapTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mMapTypeName string] ;
  end method ;

  message "an undefined map type" ;
  message messageGalgasType "an undefined map type" ;
}

#---------------------------------------------------------------------------*

map @mapModifierMap {
  @L_EXsignature mMethodSignature ;
  insert insertKey error message "an insert or a remove modifier named '%K' is already declared in %L" ;
  search searchKey error message "there is no modifier named '%K'" ;
}

#---------------------------------------------------------------------------*

map @mapMethodMap {
  @L_EXsignature mMethodSignature ;
  insert insertKey error message "a search method named '%K' is already declared in %L" ;
  search searchKey error message "there is no search method named '%K'" ;
}

#---------------------------------------------------------------------------*

class @typeGalgasMapType extends @typeGalgasUndefinedMapType {
#--- Liste de tous les attributs semantiques not externes
  @typeListeAttributsSemantiques mAttributeList ;

#--- Table de toutes les methodes de surcharge
  @typeTableBlocsDeTable aTableMethodesSurcharger ;

#--- Insert or Remove (modifier) map
  @mapModifierMap mModifierMethodMap ;

#--- Search (method) map
  @mapMethodMap mReaderMethodMap ;

#--- Modifiers are insert methods and (when map defines automaton) search methods
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    [mModifierMethodMap searchKey !inModifierName ?outModifierSignature] ;
  end method ;

#--- Methods are search methods (when map defines no automaton)
  override
  method handleMethodInstructionCall
    ??@lstring inReaderName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    [mReaderMethodMap searchKey !inReaderName ?outReaderSignature] ;
  end method ;


#--- table object accepts to be enumerated (foreach instruction)
  override
  method acceptForeachInstruction
    ??@location unused inErrorLocation
    !@typeListeAttributsSemantiques outForeachList
    !@localConstantBuildStyleEnum outStyle
    !@bool outNewStyle
  :
    outNewStyle := false ;
    outForeachList := [@typeListeAttributsSemantiques emptyList] ;
    outForeachList += ![@typeGalgas_lstring new] ![@lstring new !"key" !here] ;
    outForeachList := outForeachList . mAttributeList ;
    outStyle := [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle] ;
  end method ;

#--- A map accepts 'emptyMap' constructor
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "emptyMap" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    elsif [inClassMethodName string] == "mapWithMapToOverride" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      outAccessorTypesList += ![@typeGalgasUndefinedMapType new !mMapTypeName] ![@lstring new !"???" !here] ; # Unused second argument
    elsif [inClassMethodName string] == "empty" then
      error inClassMethodName : "in GALGAS 1.3.0 and later, use 'emptyMap' constructor instead of 'empty' constructor" -> outAccessorTypesList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;
  
  message "a map type" ;
  message messageGalgasType "a map type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    U N D E F I N E D    M A P I N D E X    T Y P E          *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedMapindexType extends @AC_galgasType {
  @lstring mMapindexTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mMapindexTypeName string] ;
  end method ;

#--- A mapindex accepts 'null' constructor
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if [inClassMethodName string] == "null" then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName : "a map index only accepts 'null' constructor" -> outAccessorTypesList ;
    end if ;
  end method ;

  message "a predeclared mapindex type" ;
  message messageGalgasType "a predeclared mapindex type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   G A L G A S    M A P I N D E X    T Y P E                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @mapIndexSearchReaderMap {
  @lstring mRetrieveErrorMessage ;
  insert insertKey error message "a search reader named '%K' is already declared in %L" ;
  search searchKey error message "there is search reader named '%K'" ;
}

#---------------------------------------------------------------------------*

class @typeGalgasMapindexType extends @typeGalgasUndefinedMapindexType {
  @lstring mMapTypeName ;
  @typeListeAttributsSemantiques mMapAttributesList ;
  @mapIndexSearchReaderMap mMapIndexSearchReaderMap ;

#--- Associated map features
  @typeTableBlocsDeTable aTableMethodesSurcharger ;
  @mapModifierMap mModifierMethodMap ;
  @mapMethodMap mReaderMethodMap ;

#--- mapindex accept method calls corresponding to search declarations
  override
  method handleMethodInstructionCall
    ??@lstring inReaderName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    [mMapIndexSearchReaderMap searchKey !inReaderName ?*] ;
    outReaderSignature := [@L_EXsignature listWithValue
      ![@typeGalgas_lstring new]
      ![@EXformalArgumentPassingMode argumentOut]
    ] ;
    foreach mMapAttributesList (@AC_galgasType kAttributType *) do
      outReaderSignature += !kAttributType ![@EXformalArgumentPassingMode argumentOut] ;
    end foreach ;
  end method ;

#--- A mapindex only accept 'makeRegularIndex' type method call
  override
  method handleClassMethodCall
    ??@lstring inTypeMethodName
    !@L_EXsignature outTypeMethodSignature
  :
    if [inTypeMethodName string] == "makeRegularIndex" then
      outTypeMethodSignature := [@L_EXsignature emptyList] ;
      outTypeMethodSignature +=
        ![@typeGalgas_lstring new]
        ![@EXformalArgumentPassingMode argumentIn]
      ;
      outTypeMethodSignature +=
        ![@typeGalgasMapType new
           !mMapTypeName
           !mMapAttributesList
           !aTableMethodesSurcharger
           !mModifierMethodMap
           !mReaderMethodMap
         ]
        ![@EXformalArgumentPassingMode argumentInOut]
      ;
      outTypeMethodSignature +=
        ![@typeGalgasMapindexType new
           !mMapindexTypeName
           !mMapTypeName
           !mMapAttributesList
           !mMapIndexSearchReaderMap
           !aTableMethodesSurcharger
           !mModifierMethodMap
           !mReaderMethodMap
         ] ## self ??
        ![@EXformalArgumentPassingMode argumentOut]
      ;
    else
      error inTypeMethodName : "a map index only accepts 'regularIndex' type method" -> outTypeMethodSignature ;
    end if ;
  end method ;

  message "a mapindex type" ;
  message messageGalgasType "a mapindex type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    T Y P E    " C L A S S "    D E F I N I T I O N                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeGalgasUndefinedClassType extends @AC_galgasType {
  @lstring mClassTypeName ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mClassTypeName string] ;
  end method ;

  message "an undefined class type" ;
  message messageGalgasType "an undefined class type" ;
}

#---------------------------------------------------------------------------*

list @L_lazyAttributeList {
  @location mLocationMagicNumber ;
  @typeListeAttributsSemantiques mComputedAttributeTypeAndNameList ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @typeGalgasClassType extends @typeGalgasUndefinedClassType {
#--- class reader map
  @typeTableMethodes mMethodMap ;

#--- Attributes list (those from inherited classes, followed by those from current class)
  @typeListeAttributsSemantiques mAttributeList ;  

#--- Table des classes ancetre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;  

#--- Table des messages
  @typeClassInheritedMessagesMap mMessagesMap ;

#--- Attributes map (those from inherited classes and those from current class)
  @typeSemanticAttributesMap mNonExternAttributesMap ;

#--- La classe est-elle abstract ?
  @bool mClassIsAbstract ;

#--- message
  @string mClassMessage ;

#--- Generate in Separate file ?
  @bool mHasGeneratedInSeparateFileSetting ;

#--- Once Reader map
  @L_lazyAttributeList mLazyAttributeList ;

#--- Handle method call : return method signature
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap inCategoryMethodMap
    !@L_EXsignature outMethodSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    if [mMethodMap hasKey ![inMethodName string]] then
      [mMethodMap searchKey !inMethodName ?outMethodSignature] ;
    else
      outMethodSignature := [@L_EXsignature emptyList] ;
      @lstring key [new ![mClassTypeName string] . ":" . [inMethodName string] ![inMethodName location]] ;
      if [inCategoryMethodMap hasKey ![key string]] then
        @categoryMethodKind categoryMethodKind ;
        [inCategoryMethodMap searchKey !key ?categoryMethodKind ?outMethodSignature] ;
        if categoryMethodKind != [@categoryMethodKind overridingMethod] then
          outCategoryMethodClassBaseName := [mClassTypeName string] ;
        end if ;
      end if ;
      foreach mAncestorClassesMap while outCategoryMethodClassBaseName == "" do
        @lstring superKey [new ![key string] . ":" . [inMethodName string] ![inMethodName location]] ;
        if [inCategoryMethodMap hasKey ![superKey string]] then
          @categoryMethodKind categoryMethodKind ;
          [inCategoryMethodMap searchKey !superKey ?categoryMethodKind ?outMethodSignature] ;
          if categoryMethodKind != [@categoryMethodKind overridingMethod] then
            outCategoryMethodClassBaseName := [mClassTypeName string] ;
          end if ;
        end if ;
      end foreach ;
      if outCategoryMethodClassBaseName == "" then
        error inMethodName:"there is no '" . inMethodName
        . "' method defined for '@" . mClassTypeName . "' class" -> outMethodSignature ;
      end if ;
    end if ;
  end method ;

#--- Class accepts class method call 'new' if it is not abstract
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    if mClassIsAbstract then
      error inClassMethodName : "an abstract class cannot be instancied" -> outAccessorTypesList ;
    elsif [inClassMethodName string] == "new" then
      outAccessorTypesList := mAttributeList ;
    else
      error inClassMethodName : "This constructor is not defined" -> outAccessorTypesList ;
    end if ;
  end method ;

#--- Error message
  message "a class type" ;
  message messageGalgasType "a class type" ;
}

#---------------------------------------------------------------------------*

class @typeEntiteType extends @AC_semanticsEntity {
  @AC_galgasType aDefType ;

  message messageTypeEntite "a type" ;
  message "a type" ;
}

#---------------------------------------------------------------------------*

class @typeEntiteRoutine extends @AC_semanticsEntity {
  @L_EXsignature aListeArgumentsFormels ;

  message "a routine" ;
  message messageTypeEntite "a routine" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  E N U M    T Y P E                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeEnumMessageMap {
  @lstringlist mMessageStringList ;
  insert insertKey error message "the '%K' message name is already declared in %L" ;
  search searchKey error message "the '%K' message name is not declared" ;
}

#---------------------------------------------------------------------------*

list @enumModifierDefinitionList {
  @lstring mSourceState ;
  @lstring mTargetState ;
  @typeInstructionList mInstructionList ; # Actually: no instruction, error instruction or warning instruction
}

#---------------------------------------------------------------------------*

map @enumModifierMap {
  @enumModifierDefinitionList mActionDefinitionList ;
  @L_EXsignature mSignature ;
  @typeListeTypesEtNomsArgMethode mArgumentTypeAndNameList ;
  insert insertKey error message "the '%K' modifier is already declared in %L" ;
  search searchKey error message "the '%K' modifier is not declared" ;
}

#---------------------------------------------------------------------------*

list @enumMethodDefinitionList {
  @lstring mSourceState ;
  @typeInstructionList mInstructionList ; # Actually: no instruction, error instruction or warning instruction
}

#---------------------------------------------------------------------------*

map @enumMethodMap {
  @enumMethodDefinitionList mActionDefinitionList ;
  @L_EXsignature mSignature ;
  @typeListeTypesEtNomsArgMethode mArgumentTypeAndNameList ;
  insert insertKey error message "the '%K' method is already declared in %L" ;
  search searchKey error message "the '%K' method is not declared" ;
}

#---------------------------------------------------------------------------*

list @enumOperatorDefinitionList {
  @lstring mLeftSourceState ;
  @luint mLeftSourceStateIndex ;
  @lstring mRightSourceState ;
  @luint mRightSourceStateIndex ;
  @lstring mTargetState ;
  @luint mTargetStateIndex ;
  @typeInstructionList mInstructionList ; # Actually: no instruction, error instruction or warning instruction
}

#---------------------------------------------------------------------------*

map @enumOperatorMap {
  @enumOperatorDefinitionList mActionDefinitionList ;
  @L_EXsignature mSignature ;
  @typeListeTypesEtNomsArgMethode mArgumentTypeAndNameList ;
  insert insertKey error message "the '%K' method is already declared in %L" ;
  search searchKey error message "the '%K' method is not declared" ;
}

#---------------------------------------------------------------------------*

class @typeGalgas_enum extends @AC_galgasType {
#--- Enumeration name
  @lstring mEnumTypeName ;

#--- Enumeration constants map
  @enumConstantMap mEnumConstantesMap ;

#--- Messages map
  @typeEnumMessageMap mMessagesMap ;

#--- Modifier map
  @enumModifierMap mModifierMap ;

#--- Method map
  @enumMethodMap mMethodMap ;

#--- Operator map
  @enumOperatorMap mOperatorMap ;

#--- Get type name
  override method getTypeName !@string outTypeName :
    outTypeName := [mEnumTypeName string] ;
  end method ;

#--- Class accepts class method with constant names
  override method handleConstructorCall
    ??@lstring inClassMethodName
    !@typeListeAttributsSemantiques outAccessorTypesList
    !@bool outHasLexiqueAndLocationArguments
  :
    outHasLexiqueAndLocationArguments := true ;
    @bool hasConstructor ;
    [mEnumConstantesMap searchKey !inClassMethodName ?hasConstructor] ;
    if hasConstructor then
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    else
      error inClassMethodName:
        "the '" . [inClassMethodName string] . "' is not declared as constructor"
        -> outAccessorTypesList
      ;
    end if ;
  end method ;

#--- Modifiers
  override
  method handleModifierCall
    ??@lstring inModifierName
    !@L_EXsignature outModifierSignature
  :
    [mModifierMap searchKey !inModifierName ?* ?outModifierSignature ?*] ;
  end method ;

#--- Methods
  override
  method handleMethodInstructionCall
    ??@lstring inMethodName
    ??@EXcategoryMethodMap unused inCategoryMethodMap
    !@L_EXsignature outReaderSignature
    !@string outCategoryMethodClassBaseName
  :
    outCategoryMethodClassBaseName := "" ;
    [mMethodMap searchKey !inMethodName ?* ?outReaderSignature ?*] ;
  end method ;


  message "an enum type" ;
  message messageGalgasType "an enum type" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                 VERIFIER LA COMPATIBILITE DE DEUX TYPES                   *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkAssignmentTypesCompatibility
  ??@AC_galgasType inFormalType
  ??@AC_galgasType inEffectiveType
  ??@location inErrorLocation
  ??@bool inAcceptPolymorphism
:
  match inFormalType :: inEffectiveType :
  when @typeGalgas_binaryset ()    :: @typeGalgas_binaryset () :
  when @typeGalgas_stringset ()    :: @typeGalgas_stringset () :
  when @typeGalgas_uint ()         :: @typeGalgas_uint () :
  when @typeGalgas_sint ()         :: @typeGalgas_sint () :
  when @typeGalgas_uint64 ()       :: @typeGalgas_uint64 () :
  when @typeGalgas_sint64 ()       :: @typeGalgas_sint64 () :
  when @typeGalgas_char ()         :: @typeGalgas_char () :
  when @typeGalgas_string ()       :: @typeGalgas_string () :
  when @typeGalgas_bool ()         :: @typeGalgas_bool () :
  when @typeGalgas_double ()       :: @typeGalgas_double () :
  when @typeGalgas_lbool ()        :: @typeGalgas_lbool () :
  when @typeGalgas_lchar ()        :: @typeGalgas_lchar () :
  when @typeGalgas_luint ()        :: @typeGalgas_luint () :
  when @typeGalgas_lsint ()        :: @typeGalgas_lsint () :
  when @typeGalgas_luint64 ()      :: @typeGalgas_luint64 () :
  when @typeGalgas_lsint64 ()      :: @typeGalgas_lsint64 () :
  when @typeGalgas_ldouble ()      :: @typeGalgas_ldouble () :
  when @typeGalgas_lstring ()      :: @typeGalgas_lstring () :
  when @typeGalgas_location ()     :: @typeGalgas_location () :
  when @typeGalgas_filewrapper ()  :: @typeGalgas_filewrapper () :

  when @typeGalgasStructType (@lstring kNomType1 *)::@typeGalgasStructType (@lstring kNomType2 *) :
    @bool accept := [kNomType1 string] == [kNomType2 string] ;
    if not accept then
      error inErrorLocation : "I was expecting the struct type '@" . [kNomType1 string] .
                              "', I have got the struc type '@" . [kNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedClassType (@lstring kNomType1)
    :: @typeGalgasClassType (@lstring kNomType2 2* @typeSuperClassesMap kAncestorClassesMap ...) :
    @bool accept := [kNomType1 string] == [kNomType2 string] ;
    if (not accept) & inAcceptPolymorphism then
      accept := [kAncestorClassesMap hasKey ![kNomType1 string]] ;
    end if ;
    if not accept then
      error inErrorLocation : "I was expecting the class type '@" . [kNomType1 string] .
                              "', I have got the class type '@" . [kNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedMapindexType (@lstring attNomType1 ...) :: @typeGalgasUndefinedMapindexType (@lstring attNomType2 ...) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the map index type '@" . [attNomType1 string] .
                                "', I have got the map index type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedListType (@lstring attNomType1) :: @typeGalgasUndefinedListType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the list type '@" . [attNomType1 string] .
                                "', I have got the list type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedSortedListType (@lstring attNomType1) :: @typeGalgasUndefinedSortedListType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the sorted list type '@" . [attNomType1 string] .
                                "', I have got the sorted list type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedMapType (@lstring attNomType1) :: @typeGalgasUndefinedMapType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the map type '@" . [attNomType1 string] .
                              "', I have got the map type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedClassType (@lstring attNomType1) :: @typeGalgasUndefinedClassType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting the class type '@" . [attNomType1 string] .
                              "', I have got the class type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasListmapType (@lstring attNomType1 ...)
    :: @typeGalgasListmapType (@lstring attNomType2 ...) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting an extern variable of listmap '@" . [attNomType1 string] .
                               "' type variable, and I got a listmap '@" . [attNomType2 string] . "' type variable" ;
    end if ;

  when @typeGalgasUndefinedExternType (@lstring attNomType1)
    :: @typeGalgasUndefinedExternType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error inErrorLocation : "I was expecting an extern variable of extern '@" . [attNomType1 string] .
                               "' type variable, and I got an extern '@" . [attNomType2 string] . "' type variable" ;
    end if ;

  when @typeGalgas_enum (@lstring aTypeName1 5*)
    :: @typeGalgas_enum (@lstring aTypeName2 5*) :
    if [aTypeName1 string] != [aTypeName2 string] then
      error inErrorLocation : "I was expecting an enum variable of  '@" . [aTypeName1 string] .
                                "' type variable, and I got an enum '@" . [aTypeName2 string] . "' type variable" ;
    end if ;

  else
    error inErrorLocation : [inFormalType messageGalgasType] . " is not compatible with " . [inEffectiveType messageGalgasType]  ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     VERIFICATION DE COMPATIBILITE ENTRE DEUX SIGNATURES DE METHODE        *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteSignatures
  ??@L_EXsignature signatureReference
  ??@L_EXsignature signatureTestee
  ??@location ouSignalerErreur
:
  if [signatureReference length] < [signatureTestee length] then
    error ouSignalerErreur : "there are too much parameters" ;
  elsif [signatureReference length] > [signatureTestee length] then
    error ouSignalerErreur : "one or more parameters missing" ;
  else 
    foreach signatureReference (@AC_galgasType attTypeG @EXformalArgumentPassingMode passingMode1),
            signatureTestee (@AC_galgasType attTypeD @EXformalArgumentPassingMode passingMode2) do
      checkAssignmentTypesCompatibility
         !attTypeG
         !attTypeD
         !ouSignalerErreur
         !false
      ;
      if passingMode1 != passingMode2 then
        error ouSignalerErreur : [passingMode2 formalArgumentMessage] . " is not compatible with " .
                                [passingMode2 formalArgumentMessage] ;
      end if ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     COMMAND LINE INTERFACE OPTION MAP                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_cli_options {
  @lchar mOptionChar ;
  @lstring mOptionString ;
  @lstring mComment ;
  @string mDefaultValue ;
  insert insertKey error message "the '%K' command line option has been already declared in %L" ;
  search searchKey error message "the '%K' command line option is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of option components                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_optionComponents {
  @M_cli_options mBoolOptionsMap ;
  @M_cli_options mUintOptionsMap ;
  @M_cli_options mStringOptionsMap ;
  insert insertKey error message "the '%K' option component named is already declared in %L" ;
  search searchKey error message "there is no '%K' option component" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          Grammar component map                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_grammarComponents {
  @M_nonterminalSymbolAltsForGrammar mNonterminalSymbolParametersMap ;
  @lstring mLexiqueName ;
  @M_optionComponents mOptionsMap ;
  insert insertKey error message "the '%K' grammar component has been already declared in %L" ;
  search searchKey error message "the '%K' grammar component is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Map of semantics components                                            *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_semanticsComponents {
  @ModelMap mModelMap ; # The types and classes declared in this component
  @ActionMap mActionMap ; # The routines and the extern actions declared in this component 
  @stringset mImportedSemanticsComponents ; # The other semantics components imported in this component
  @stringset mImportedMetamodelComponents ; # The metamodel components imported in this component
  @stringset mImportedOptionsComponents ; # The option components imported in this component
  @M_optionComponents mOptionsComponents ; # The option components imported in this component (OLD STYLE)
  @M_semanticsEntitiesForUse mSemanticsEntitiesMap ; # OLD STYLE MAP
  insert insertKey error message "a semantics component named '%K' is already declared in %L" ;
  search searchKey error message "there is no semantics component named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              F I L E    W R A P P E R                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_regularFiles {
  @uint mWrapperDirectoryIndex ;
  @uint mWrapperFileIndex ;
  insert insertKey error message "a regular file named '%K' is already declared in %L" ;
  search searchKey error message "there is no regular file named '%K'" ;
}

#---------------------------------------------------------------------------*

map @filewrapperTemplateMap {
  @typeListeAttributsSemantiques mFormalAttributeList ;
  insert insertKey error message "the '%K' template is already declared" ;
  search searchKey error message "the '%K' template is not declared" ;
}

#---------------------------------------------------------------------------*

map @M_filewrappers {
  @M_regularFiles mRegularFileMap ;
  @filewrapperTemplateMap mTemplateMap ;
  insert insertKey error message "a file wrapper named '%K' is already declared in %L" ;
  search searchKey error message "there is no file wrapper named '%K'" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              List of attributes for label entry in GUI description        *
#                                                                           *
#---------------------------------------------------------------------------*

list @labelForPopUpList {
  @lstring mTerminal1 ;
  @uint mTerminal1ID ;
  @lstring mTerminal2 ;
  @uint mTerminal2ID ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   H A N D L E    @ S T R I N G    R E A D E R    C A L L                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleStringReaderCall
  ??@lstring inReaderName
  !@typeListeAttributsSemantiques outAccessorTypesList
  !@AC_galgasType outReturnedType
:
  if [inReaderName string] == "doesEnvironmentVariableExist" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_bool new] ;
  elsif [inReaderName string] == "length" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_uint new] ;
  elsif [inReaderName string] == "uint" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_uint new] ;
  elsif [inReaderName string] == "capacity" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_uint new] ;
  elsif [inReaderName string] == "fileExists" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_bool new] ;
  elsif [inReaderName string] == "directoryExists" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_bool new] ;
  elsif [inReaderName string] == "characterAtIndex" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # First @string argument
    outReturnedType := [@typeGalgas_char new] ;
  elsif [inReaderName string] == "stringByRemovingCharacterAtIndex" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # First @string argument
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "pathExtension" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "nativePathWithUnixPath" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "unixPathWithNativePath" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "lastPathComponent" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByDeletingPathExtension" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByCapitalizingFirstCharacter" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "firstCharacterOrNul" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_char new] ;
  elsif [inReaderName string] == "stringByDeletingLastPathComponent" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByStandardizingPath" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "stringByLeftPadding" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # @uint arg: padding size
    outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !"" !here] ; # @char arg: padding char
  elsif [inReaderName string] == "stringByRightPadding" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # @uint arg: padding size
    outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !"" !here] ; # @char arg: padding char
  elsif [inReaderName string] == "stringByLeftAndRightPadding" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ; # @uint arg: padding size
    outAccessorTypesList += ![@typeGalgas_char new] ![@lstring new !"" !here] ; # @char arg: padding char
  elsif [inReaderName string] == "absolutePathFromPath" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # @string argument
  elsif [inReaderName string] == "stringByReplacingStringByString" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # First @string argument
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ; # Second @string argument
  elsif [inReaderName string] == "uppercaseString" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "reversedString" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "escapedString" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_string new] ;
  elsif [inReaderName string] == "componentsSeparatedByString" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
    build_stringlist_type  ?outReturnedType ;
  elsif [inReaderName string] == "regularFiles" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    build_stringlist_type  ?outReturnedType ;
  elsif [inReaderName string] == "hiddenFiles" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    build_stringlist_type  ?outReturnedType ;
  elsif [inReaderName string] == "directories" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    build_stringlist_type  ?outReturnedType ;
  elsif [inReaderName string] == "regularFilesWithExtensions" then
    build_stringlist_type  ?outReturnedType ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outAccessorTypesList += ![@typeGalgas_bool new] ![@lstring new !"" !here] ;
    outAccessorTypesList += !outReturnedType ![@lstring new !"" !here] ;
  elsif [inReaderName string] == "system" then
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
    outReturnedType := [@typeGalgas_sint new] ;
  else
    error inReaderName : "this reader is not defined"
     -> outAccessorTypesList, outReturnedType ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   H A N D L E    R E A D E R    C A L L    I N    E X P R E S S I O N     *
#                                                                           *
#---------------------------------------------------------------------------*

routine handleReaderCall
  ??@AC_galgasType inReceiverType
  ??@lstring inReaderName
  !@typeListeAttributsSemantiques outAccessorTypesList
  !@AC_galgasType outReturnedType
  !@string outCppConversionMethod
:
  outCppConversionMethod := "" ; # Means no conversion needed
  if [inReaderName string] == "description" then
    outReturnedType := [@typeGalgas_string new] ;
    outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
  else
    cast inReceiverType :
    when >= @typeGalgas_filewrapper do
      if [inReaderName string] == "allFilePathes" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type  ?outReturnedType ;
      elsif [inReaderName string] == "allDirectoryPathes" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type  ?outReturnedType ;
      elsif [inReaderName string] == "currentDirectory" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "directoryExistsAtPath" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "fileExistsAtPath" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "fileContentsAtPath" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "absolutePathForPath" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgasUndefinedMapindexType do
      if [inReaderName string] == "isRegular" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isNull" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "key" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_lstring new] ;
      elsif [inReaderName string] == "isSolved" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_string do
      handleStringReaderCall ! inReaderName ?outAccessorTypesList ?outReturnedType ;
    when >= @typeGalgas_lstring do
      if [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else # Inherited @ string reader ?
        handleStringReaderCall ! inReaderName ?outAccessorTypesList ?outReturnedType ;
        outCppConversionMethod := "ggs_string" ;
      end if ;
    when >= @typeGalgas_location do
      if [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_binaryset do
      if [inReaderName string] == "isFull" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isEmpty" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "significantVariableCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "ITE" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "forAllOnBitIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "forAllOnBitIndexAndBeyond" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "existOnBitIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "existOnBitIndexAndBeyond" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "valueCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "compressedValueCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "uint64ValueList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        build_uint64list_type ?outReturnedType ;
      elsif [inReaderName string] == "stringValueList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        build_stringlist_type ?outReturnedType ;
      elsif [inReaderName string] == "predicateStringValue" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "compressedStringValueList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        build_stringlist_type ?outReturnedType ;
      elsif [inReaderName string] == "swap21" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap132" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap213" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap231" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap312" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "swap321" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "transitiveClosure" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "accessibleStates" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "equalTo" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "notEqualTo" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "lowerOrEqualTo" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "greaterOrEqualTo" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "greaterThan" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "lowerThan" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += !inReceiverType ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "binarySetByTranslatingFromIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "containsValue" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint64 new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "existsOnBitRange" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_uint do
      if [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "lsbIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "significantBitCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "hexString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_char do
      if [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "isalnum" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isalpha" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "iscntrl" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isdigit" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "islower" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isupper" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "isxdigit" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_uint64 do
      if [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "uintSlice" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "hexString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_sint do
      if [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_sint64 do
      if [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_double do
      if [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_lchar do
      if [inReaderName string] == "char" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_char new] ;
      elsif [inReaderName string] == "value" then
        warning inReaderName:"in GALGAS 1.4.1 and later, the 'value' reader of @lchar type  is deprecated; use 'char' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_char new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_lbool do
      if [inReaderName string] == "bool" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "value" then
        warning inReaderName:"in GALGAS 1.4.1 and later, the 'value' reader of @lbool type  is deprecated; use 'bool' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_luint do
      if [inReaderName string] == "uint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "value" then
        warning inReaderName:"in GALGAS 1.4.1 and later, the 'value' of @luint type  reader is deprecated; use 'uint' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_luint64 do
      if [inReaderName string] == "uint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint64 new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_lsint do
      if [inReaderName string] == "sint" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "value" then
        warning inReaderName:"in GALGAS 1.4.1 and later, the 'value' reader of @lsint type  is deprecated; use 'sint' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_lsint64 do
      if [inReaderName string] == "sint64" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_sint64 new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_ldouble do
      if [inReaderName string] == "double" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_double new] ;
      elsif [inReaderName string] == "value" then
        warning inReaderName:"in GALGAS 1.4.1 and later, the 'value' reader of @ldouble type  is deprecated; use 'double' instead" ;
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_double new] ;
      elsif [inReaderName string] == "string" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      elsif [inReaderName string] == "location" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_location new] ;
      elsif [inReaderName string] == "locationString" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_string new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgasListType listType do
      if [inReaderName string] == "length" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "subListFromIndex" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      elsif [inReaderName string] == "subListWithRange" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ;
      else
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_uint new] ![@lstring new !"" !here] ;
        outReturnedType := inReceiverType ; # Temporary
        @typeListeAttributsSemantiques attributeList := [listType mAttributeList] ;
        @bool found := false ;
        foreach attributeList while not found do
          found := ([mAttributeName string] . "AtIndex") == [inReaderName string] ;
          if (found) then
            outReturnedType := mAttributType ;
          end if ;
        end foreach ;
        if not found then
          error inReaderName :
           "the '" . [inReaderName string] . "' reader is not supported by a list" ;
        end if ;
      end if ;
    when >= @typeGalgasSortedListType do
      if [inReaderName string] == "length" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      else
        error inReaderName :
           "sorted list supports only 'length' reader call" -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgasMapType do
      if [inReaderName string] == "hasKey" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        @AC_galgasType keyType := [@typeGalgas_string new] ;
        outAccessorTypesList += !keyType ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "count" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "allKeys" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_stringset new] ;
      elsif [inReaderName string] == "keyList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_lstringlist_type ? outReturnedType ;
      elsif [inReaderName string] == "unsolvedIndexCount" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "unsolvedIndexKeyStringList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type ?outReturnedType ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgasListmapType mapType do
      if [inReaderName string] == "hasKey" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "allKeys" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_stringset new] ;
      elsif [inReaderName string] == "count" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      elsif [inReaderName string] == "keyList" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        build_stringlist_type ? outReturnedType ;
      elsif [inReaderName string] == "listForKey" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outAccessorTypesList += ![@typeGalgas_string new] ![@lstring new !"" !here] ;
        outReturnedType := [mapType mListType] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;
    when >= @typeGalgas_stringset do
      if [inReaderName string] == "hasKey" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        @AC_galgasType keyType := [@typeGalgas_string new] ;
        outAccessorTypesList += !keyType ![@lstring new !"" !here] ;
        outReturnedType := [@typeGalgas_bool new] ;
      elsif [inReaderName string] == "count" then
        outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
        outReturnedType := [@typeGalgas_uint new] ;
      else
        error inReaderName : "this reader is not defined"
         -> outAccessorTypesList, outReturnedType ;
      end if ;

    when >= @typeGalgasClassType t do
      outReturnedType := [@typeGalgas_string new] ; # Any Value
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      if not [[t mMessagesMap] hasKey ![inReaderName string]] then
      #--- Search for attribute
        @bool found := false ;
        foreach [t mAttributeList] while not found do
          outReturnedType := mAttributType ;
          found := [inReaderName string] == [mAttributeName string] ;
        end foreach ;
      #--- Search for lazy attribute
        foreach [t mLazyAttributeList] while not found do
          foreach mComputedAttributeTypeAndNameList while not found do
            outReturnedType := mAttributType ;
            found := [inReaderName string] == [mAttributeName string] ;
          end foreach ;
        end foreach ;
        if not found then
          error inReaderName: "this reader is not defined (you can name as class reader class attributes, class messages and lazy attributes)" ;
        end if ;
      end if ;
    when >= @typeGalgasStructType t do
      outReturnedType := [@typeGalgas_string new] ; # Any Value
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ;
      @bool found := false ;
      foreach [t mAttributeList] (@AC_galgasType kAttributType @lstring kNomAttribut) while not found do
        outReturnedType := kAttributType ;
        found := [inReaderName string] == [kNomAttribut string] ;
      end foreach ;
      if not found then
        error inReaderName: "this reader is not defined (you can name as reader any struct attribute)" ;
      end if ;
    when >= @typeGalgas_enum e do
      @typeEnumMessageMap kMessagesMap := [e mMessagesMap] ;
      [kMessagesMap searchKey ! inReaderName ?*] ;
      outAccessorTypesList := [@typeListeAttributsSemantiques emptyList] ; #--- No argument
      outReturnedType := [@typeGalgas_string new] ;
    else
      error inReaderName :
         "variables of this type do not support reader call"
         -> outAccessorTypesList, outReturnedType ;
    end cast ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

extern routine check_KL_escapeCharacters
 ?@lstring inString
;

#---------------------------------------------------------------------------*

extern routine check_K_escapeCharacters
 ?@lstring inString
;

#---------------------------------------------------------------------------*

routine importSemanticsComponent
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioActionMap
  ?!@stringset ioAlreadyImportedSemanticsComponents
  ?!@stringset ioAlreadyImportedMetamodelComponents
  ?@lstring inSemanticsComponentName
:
  if not [ioAlreadyImportedSemanticsComponents hasKey ![inSemanticsComponentName string]] then
    @ModelMap modelMap ; # The types and classes declared in this component
    @ActionMap actionMap ; # The routines and the extern actions declared in this component 
    @stringset importedSemanticsComponents ; # The other semantics components imported in this component
    @stringset importedMetamodelComponents ; # The metamodel components imported in this component
    @stringset importedOptionsComponents ; # The option components imported in this component
    [ioSemanticsComponentsMap searchKey
      !inSemanticsComponentName
      ?modelMap
      ?actionMap
      ?importedSemanticsComponents
      ?importedMetamodelComponents
      ?importedOptionsComponents
      ?*
      ?*
    ] ;
  #--- Add Imported metamodels
    ioAlreadyImportedMetamodelComponents := ioAlreadyImportedMetamodelComponents | importedMetamodelComponents ;
  #--- Recursively import other semantics components
    foreach importedSemanticsComponents (@string kKey) do
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?ioModelMap
        !?ioActionMap
        !?ioAlreadyImportedSemanticsComponents
        !?ioAlreadyImportedMetamodelComponents
        ![@lstring new !kKey !here]
      ;
    end foreach ;
  #--- Add imported types
    foreach modelMap (@lstring kKey @TypeModel kType) do
      if not [ioModelMap hasKey ![kKey string]] then
        [!?ioModelMap insertKey !kKey !kType] ;
      end if ;
    end foreach ;
  #--- Add actions
    foreach actionMap (@lstring kKey @L_signature kSignature @bool kIsExtern) do
      if not [ioActionMap hasKey ![kKey string]] then
        [!?ioActionMap insertKey !kKey !kSignature !kIsExtern] ;
      end if ;
    end foreach ;
  #--- Flag component as imported
    ioAlreadyImportedSemanticsComponents += ![inSemanticsComponentName string] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#         E N T E R    B U I L T I N    T Y P E S                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine enterBuiltinTypes !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap :
  ioComponentSemanticsEntitiesMap := [@M_semanticsEntitiesForUse emptyMap] ;

  @AC_semanticsEntity e := [@typeEntiteType new ![@typeGalgas_lstring new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lstring" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lbool new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lbool" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_luint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"luint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lsint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lsint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_luint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"luint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lsint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lsint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_ldouble new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"ldouble" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_lchar new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lchar" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_location new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"location" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_uint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_sint new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"sint" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_uint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_sint64 new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"sint64" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_char new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"char" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_string new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"string" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_bool new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"bool" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_binaryset new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"binaryset" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_double new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"double" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_stringset new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"stringset" !here] !e] ;

  e := [@typeEntiteType new ![@typeGalgas_filewrapper new]] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"filewrapper" !here] !e] ;

  @AC_galgasType t ; build_uintlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uintlist" !here] !e] ;

  build_luintlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"luintlist" !here] !e] ;

  build_uint64list_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"uint64list" !here] !e] ;

  build_stringlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"stringlist" !here] !e] ;

  build_lstringlist_type ?t ;
  e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ![@lstring new !"lstringlist" !here] !e] ;
end routine ;

#---------------------------------------------------------------------------*

abstract class @templateInstruction [generatedInSeparateFile] {
}

#---------------------------------------------------------------------------*

list @templateInstructionList {
  @templateInstruction mInstruction ;
}

#---------------------------------------------------------------------------*

class @templateInstructionString extends @templateInstruction {
  @string mTemplateString ;
}

#---------------------------------------------------------------------------*

class @templateInstructionConstant extends @templateInstruction {
  @typeCplusPlusName mCppName ;
}

#---------------------------------------------------------------------------*

struct @EXsemanticContext {
  @M_filewrappers mFilewrappers ;
  @stringset mImportedSemanticComponents ;
  @EXcategoryMethodMap mCategoryMethodMap ;
}

#---------------------------------------------------------------------------*

end semantics ;
