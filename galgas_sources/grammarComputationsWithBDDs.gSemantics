semantics grammarComputationsWithBDDs :
import option galgas_cli_options in "galgas_cli_options.gOption" ;

#---------------------------------------------------------------------------*
#                                                                           *
# D O M A I N    F O R    G R A M M A R    C O M P U T A T I O N S          *
#                                                                           *
#---------------------------------------------------------------------------*

domain @grammarDomain (V) { 
 nonterminalsWithEmptyProduction [V] ;
 nonterminalsWithOneElementProduction [V, V] ; # relation (NT, V) : NT ::= V
 nonterminalsWithTwoElementProduction [V, V, V] ; # relation (NT, V1, V2) : NT ::= V1 V2

}

#---------------------------------------------------------------------------*
#                                                                           *
# V O C A B U L A R Y   M A P                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @vocabularyMap {
  @uint mIndex ;
  insert insertKey error message "the '@%K' symbol has been already declared in %L" ;
  search searchKey error message "the '@%K' symbol is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# P R O D U C T I O N   L I S T    M A P                                    *
#                                                                           *
#---------------------------------------------------------------------------*

list @derivationList {
  @uint mLeftTerminalIndex ;
  @uint mProductionIndex ;
  @uintlist mDerivation ;
}

#---------------------------------------------------------------------------*

listmap @productionListMap (@derivationList) ;

#---------------------------------------------------------------------------*
#                                                                           *
#  G E N E R A T I O N    F I L E W R A P P E R S                           *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper grammarComputationTemplates in "../generation_templates/grammar_generation" {
} {
  template html "grammarComputations.html.gTemplate"
    ?@stringlist ALL_VOCABULARY_FOR_BDD
    ?@uint TERMINAL_COUNT
    ?@uint NON_TERMINAL_COUNT
    ?@uint ADDITIONAL_NON_TERMINAL_COUNT_FOR_BDD
    ?@stringlist NON_TERMINAL_WITH_EMPTY_PRODUCTION_LIST
    ?@relationStringList NON_TERMINAL_WITH_ONE_ELEMENT_PRODUCTION_LIST
    ?@relationStringList NON_TERMINAL_WITH_TWO_ELEMENT_PRODUCTION_LIST
    ?@stringlist unused USELESS_NON_TERMINAL_SYMBOL_LIST
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# G R A M M A R    A N A L Y S I S                                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine newGrammarAnalyzer
  ?@lstring unused inGrammarName
  ?@uint unused inStartSymbolIndex
  ?@string unused inLexiqueName
  ?@stringlist inVocabularyListForDisplaying
  ??@vocabularyMap inNonterminalMap
  ??@vocabularyMap inTerminalMap
  ??@productionListMap inProductionListMap
  ??@uintlist unused inUnusedNonterminalSymbolList
  !@string outHTMLFileHeader
  !@string outHTMLFileContents
:
  outHTMLFileHeader := "" ;
  outHTMLFileContents := "" ;
#---------------------------------------------------------- Compute vocabulary
  @stringlist vocabularyListForDisplaying := inVocabularyListForDisplaying ;
#--- Symbols added for BDD handling
  @uint additionalNonTerminalSymbolsForPureBDDrules := 0 ;
  foreach inProductionListMap do
    foreach object do
      if [mDerivation length] > 2 then
        additionalNonTerminalSymbolsForPureBDDrules := additionalNonTerminalSymbolsForPureBDDrules + [mDerivation length] - 2 ;
      end if ;
    end foreach ;
  end foreach ;
  @uint ntIndex := 0 ;
  loop additionalNonTerminalSymbolsForPureBDDrules :
  while ntIndex < additionalNonTerminalSymbolsForPureBDDrules  do
    vocabularyListForDisplaying += !"<" . [ntIndex string] . ">" ;
    ntIndex ++ ;
  end loop ;
#--- Constants
#  const @uint terminalCount := [inTerminalMap count] ;
#  const @uint startSymbolIndexForBDD := terminalCount + [inNonterminalMap count] - 1 ;
  @grammarDomain grammarComputations [domainWithNames !vocabularyListForDisplaying] ;
#---------------------------------------------------------- Building pure BDD rules
  @uint addedNonTerminalIndex := [inTerminalMap count] + [inNonterminalMap count] ;
  foreach inProductionListMap do
    @uint nonterminalIndex ;
    [inNonterminalMap searchKey ![@lstring new !key !here] ?nonterminalIndex] ;
    foreach object do
      if [mDerivation length] == 0 then # Empty derivation
        [!?grammarComputations addToNonterminalsWithEmptyProduction !nonterminalIndex] ;
      elsif [mDerivation length] == 1 then # Single derivation
        const @uint derivation0 := [mDerivation mValueAtIndex !0] ;
        [!?grammarComputations addToNonterminalsWithOneElementProduction !nonterminalIndex !derivation0] ;
      elsif [mDerivation length] == 2 then # Double derivation
        const @uint derivation0 := [mDerivation mValueAtIndex !0] ;
        const @uint derivation1 := [mDerivation mValueAtIndex !1] ;
        [!?grammarComputations addToNonterminalsWithTwoElementProduction
          !nonterminalIndex
          !derivation0
          !derivation1
        ] ;
      else
        @uint currentLeftNonTerminal := nonterminalIndex ;
        foreach mDerivation index idx do
          if idx < ([mDerivation length] - 2) then
            const @uint derivation := [mDerivation mValueAtIndex !idx] ;
            [!?grammarComputations addToNonterminalsWithTwoElementProduction
              !nonterminalIndex
              !derivation
              !addedNonTerminalIndex
            ] ;
            currentLeftNonTerminal := addedNonTerminalIndex ;
            addedNonTerminalIndex ++ ;
          elsif idx == ([mDerivation length] - 2) then
            const @uint derivation0 := [mDerivation mValueAtIndex !idx] ;
            const @uint derivation1 := [mDerivation mValueAtIndex !idx+1] ;
            [!?grammarComputations addToNonterminalsWithTwoElementProduction
              !nonterminalIndex
              !derivation0
              !derivation1
            ] ;
           end if ;
        end foreach ;
      end if ;
    end foreach ;
  end foreach ;
#---------------------------------------------------------- Output HTML file
  if [option galgas_cli_options.outputHTMLgrammarFile] then
    outHTMLFileContents := [filewrapper grammarComputationTemplates.html
      !vocabularyListForDisplaying
      ![inTerminalMap count]
      ![inNonterminalMap count]
      !additionalNonTerminalSymbolsForPureBDDrules
      ![grammarComputations nonterminalsWithEmptyProductionStringValueList]
      ![grammarComputations nonterminalsWithOneElementProductionRelationStringValueList]
#      ![@relationStringList emptyList]
      ![@relationStringList emptyList]
      ![@stringlist emptyList]
    ] ;
  end if ; 
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
