#---------------------------------------------------------------------------*
#                                                                           *
#  'expression' component parser, as model builder                          *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax parameterArgumentSyntax ("galgas_scanner.gLexique") :

import "semanticsTypesForAST.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression> !@semanticExpressionAST outExpression ;

nonterminal <formal_parameter_list> !@formalParameterListAST outFormalParameterList ;

nonterminal <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList ;

nonterminal <actual_parameter_list> !@actualParameterListAST outActualParameterList ;

nonterminal <actual_input_parameter_list> !@actualInputParameterListAST outActualInputParameterList ;

#------------------------------------------------------------------------------*
#                                                                              *
#          F O R M A L    P A R A M E T E R    L I S T                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <formal_parameter_list> !@formalParameterListAST outFormalParameterList :
  outFormalParameterList := [@formalParameterListAST emptyList] ;
  repeat
  while
    @formalArgumentPassingModeAST mFormalParameterPassingMode ;
    select
      $?$ ;
      mFormalParameterPassingMode := [@formalArgumentPassingModeAST argumentIn] ;
    or
      $??$ ;
      mFormalParameterPassingMode := [@formalArgumentPassingModeAST argumentConstantIn] ;
    or
      $?!$ ;
      mFormalParameterPassingMode := [@formalArgumentPassingModeAST argumentInOut] ;
    or
      $!$ ;
      mFormalParameterPassingMode := [@formalArgumentPassingModeAST argumentOut] ;
    end select ;
    $type_name$ ?@lstring mFormalParameterTypeName ;
    @bool mIsUnused ;
    select
      mIsUnused := false ;
    or
      $unused$ ;
      mIsUnused := true ;
    end select ;
    $identifier$ ?@lstring mFormalParameterName ;
    outFormalParameterList +=
      !mFormalParameterPassingMode
      !mFormalParameterTypeName
      !mFormalParameterName
      !mIsUnused
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  A C T U A L    P A R A M E T E R    L I S T                              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <actual_parameter_list> !@actualParameterListAST outActualParameterList :
  outActualParameterList := [@actualParameterListAST emptyList] ;
  repeat
  while
    $?$ ;
    const @location qualifierLocation := here ;
    select
      $*$ ;
      outActualParameterList += ![@inputJokerActualParameterAST new !qualifierLocation !0] ;
    or
      @luint count ;
      $unsigned_literal_integer$ ? count ;
      $*$ ;
      @uint n := [count uint] ;
      if n == 0 then
        error count: "the count value should be > 0" ;
      else
        loop n :
        while n > 0 do
          outActualParameterList += ![@inputJokerActualParameterAST new !qualifierLocation !n] ;
          n -- ;
        end loop ;
      end if ;
    end select ;
  while
    $!$ ;
    const @location qualifierLocation := here ;
    @semanticExpressionAST e ;
    <expression> ? e ;
    const @location endOfExpressionLocation := here ;
    outActualParameterList += ![@outputActualParameterAST new
      !qualifierLocation
      !e
      !endOfExpressionLocation
    ] ;
  while
    $!?$ ;
    const @location qualifierLocation := here ;
    @lstring outputInputActualParameterName ;
    $identifier$ ?outputInputActualParameterName ;
    @lstringlist structAttributeList [emptyList] ;
    repeat
    while
      $->$ ;
      $identifier$ ? @lstring structAttributeName ;
      structAttributeList += !structAttributeName ;
    end repeat ;
    outActualParameterList += ![@outputInputActualParameterAST new 
      !qualifierLocation
      !outputInputActualParameterName
      !structAttributeList
    ] ;
  while
    $?$ ;
    const @location qualifierLocation := here ;
#    @lstring declarationTypeName ;
#    select
#      declarationTypeName := [@lstring new !"" !here] ;
#    or
#      $type_name$ ? declarationTypeName ;
#    end select ;
    @lstring inputActualParameterName ;
    $identifier$ ?inputActualParameterName ;
    outActualParameterList += ![@inputActualParameterAST new
      !qualifierLocation
#      !declarationTypeName
      !inputActualParameterName
    ] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  F O R M A L    I N P U T    P A R A M E T E R S                          *
#                                                                           *
#---------------------------------------------------------------------------*

rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList :
  outFormalInputParameterList := [@formalInputParameterListAST emptyList] ;
  repeat
  while
    @bool isConstant ;
    select
      $?$ ;
      isConstant := false ;
    or
      $??$ ;
      isConstant := true ;
    end select ;
    $type_name$ ?@lstring mFormalParameterTypeName ;
    @bool mIsUnused ;
    select
      mIsUnused := false ;
    or
      $unused$ ;
      mIsUnused := true ;
    end select ;
    $identifier$ ?@lstring mFormalParameterName ;
    outFormalInputParameterList +=
      !mFormalParameterTypeName
      !mFormalParameterName
      !mIsUnused
      !isConstant
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  A C T U A L    I N P U T    P A R A M E T E R    L I S T                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <actual_input_parameter_list>
  !@actualInputParameterListAST outActualInputParameterList
:
  outActualInputParameterList := [@actualInputParameterListAST emptyList] ;
  repeat
  while
    $?$ ;
    @lstring mActualParameterTypeName ;
    select
      mActualParameterTypeName := [@lstring new !"" !here] ;
    or
      $type_name$ ? mActualParameterTypeName ;
    end select ;
    @lstring mActualParameterName ;
    select
      $identifier$ ?mActualParameterName ;
    or
      $*$ ;
      mActualParameterName := [@lstring new !"" !here] ;
    end select ;
    outActualInputParameterList +=
      !mActualParameterTypeName
      !mActualParameterName
    ;
  end repeat ;
end rule ;  

#---------------------------------------------------------------------------*

end syntax ;
