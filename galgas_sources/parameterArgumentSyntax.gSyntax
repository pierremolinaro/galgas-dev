#---------------------------------------------------------------------------*
#                                                                           *
#  'expression' component parser, as model builder                          *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax parameterArgumentSyntax ("galgas_scanner.gLexique")  feature translate :

import "semanticsTypesForAST.gSemantics" ;

#------------------------------------------------------------------------------*

nonterminal <expression> !@semanticExpressionAST outExpressionAST ;

#------------------------------------------------------------------------------*
#                                                                              *
#          F O R M A L    P A R A M E T E R    L I S T                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <formal_parameter_list> !@formalParameterListAST outFormalParameterList :
  outFormalParameterList := [@formalParameterListAST emptyList] ;
  repeat
  while
    @formalArgumentPassingModeAST mFormalParameterPassingMode ;
    @lstring selector ;
    select
      $?$ ?selector ;
      mFormalParameterPassingMode := [@formalArgumentPassingModeAST argumentIn] ;
    or
      $??$ ?selector :> ??@string sep ?* ;
      send sep + "?" + if selector->string != "" then selector->string + ":" else "" end + "let " ;
      mFormalParameterPassingMode := [@formalArgumentPassingModeAST argumentConstantIn] ;
    or
      $?!$ ?selector ;
      mFormalParameterPassingMode := [@formalArgumentPassingModeAST argumentInOut] ;
    or
      $!$ ?selector ;
      mFormalParameterPassingMode := [@formalArgumentPassingModeAST argumentOut] ;
    end select ;
    $type_name$ ?@lstring mFormalParameterTypeName ;
    @bool mIsUnused ;
    select
      mIsUnused := false ;
    or
      $unused$ ;
      mIsUnused := true ;
    end select ;
    $identifier$ ?@lstring mFormalParameterName ;
    outFormalParameterList +=
      !selector
      !mFormalParameterPassingMode
      !mFormalParameterTypeName
      !mFormalParameterName
      !mIsUnused
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  A C T U A L    P A R A M E T E R    L I S T                              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <actual_parameter_list>
  !@actualParameterListAST outActualParameterList
:
  outActualParameterList := [@actualParameterListAST emptyList] ;
  repeat
  while
    $?$ ?const selector ;
    select
      $*$ ;
      outActualParameterList += ![@inputSingleJokerActualParameterAST new !selector] ;
    or
      @luint count ;
      $unsigned_literal_integer$ ? count ;
      $*$ ;
      @uint n := [count uint] ;
      if selector->string != "" then
        error selector : "the selector should be '?'" ;
      end if ;
      if n == 0 then
        error count: "the count value should be > 0" ;
      else
        loop n :
        while n > 0 do
          outActualParameterList += ![@inputJokerActualParameterAST new !selector->location !n] ;
          n -- ;
        end loop ;
      end if ;
    end select ;
  while
    $!$ ?const selector ;
    <expression> ??@semanticExpressionAST e ;
    const @location endOfExpressionLocation := here ;
    outActualParameterList += ![@outputActualParameterAST new
      !selector
      !e
      !endOfExpressionLocation
    ] ;
  while # I/O Parameter
    $!?$ ?const selector ;
    $identifier$ ??@lstring outputInputActualParameterName ;
    @lstringlist structAttributeList [emptyList] ;
    repeat
    while
      $->$ :> ?@string sep ?* ;
      send sep . "." ;
      $identifier$ ? @lstring structAttributeName ;
      structAttributeList += !structAttributeName ;
    end repeat ;
    outActualParameterList += ![@outputInputActualParameterAST new 
      !selector
      !outputInputActualParameterName
      !structAttributeList
    ] ;
  while
    $!?$ ?const selector ;
    $*$ ;
    outActualParameterList += ![@outputInputSingleJokerParameterAST new 
      !selector
    ] ;
  while
    $!?$ ?const selector ;
    $unsigned_literal_integer$ ??@luint count ;
    $*$ ;
    var n := [count uint] ;
    if selector->string != "" then
      error selector : "the selector should be '!?'" ;
    end if ;
    if n == 0 then
      error count: "the count value should be > 0" ;
    else
      loop n :
      while n > 0 do
        outActualParameterList += ![@outputInputJokerParameterAST new !selector->location !n] ;
        n -- ;
      end loop ;
    end if ;
  while # Existing var parameter
    $?$ ?const selector ;
    $identifier$ ?const inputActualParameterName ;
    outActualParameterList += ![@inputActualExistingVariableParameterAST new
      !selector
      !inputActualParameterName
    ] ;
  while # New var parameter
    $?$ ?const selector ;
    $type_name$ ?const declarationTypeName :> ??@string sep ?* ;
    send sep . "var @" . declarationTypeName ;
    $identifier$ ?const inputActualParameterName ;
    outActualParameterList += ![@inputActualNewVariableParameterAST new
      !selector
      !declarationTypeName
      !inputActualParameterName
    ] ;
  while # New var parameter
    $?$ ?const selector ;
    $var$ ;
    @lstring declarationTypeName ;
    select
      declarationTypeName := ["" nowhere] ;
    or
      $type_name$ ?declarationTypeName ;
    end select ;
    $identifier$ ?const inputActualParameterName ;
    outActualParameterList += ![@inputActualNewVariableParameterAST new
      !selector
      !declarationTypeName
      !inputActualParameterName
    ] ;
  while # New constant parameter
    $??$ ?const selector :> ??@string sep ?* ;
    send sep + "?" + if selector->string != "" then selector->string + ":" else "" end + "let " ;
    @lstring declarationTypeName ;
    select
      declarationTypeName := ["" nowhere] ;
    or
      $type_name$ ?declarationTypeName ;
    end select ;
    $identifier$ ?@lstring inputActualParameterName ;
    outActualParameterList += ![@inputActualNewConstantParameterAST new
      !selector
      !declarationTypeName
      !inputActualParameterName
    ] ;
  while # New constant parameter
    $?$ ?const selector ;
    $let$ ;
    @lstring declarationTypeName ;
    select
      declarationTypeName := ["" nowhere] ;
    or
      $type_name$ ?declarationTypeName ;
    end select ;
    $identifier$ ?@lstring inputActualParameterName ;
    outActualParameterList += ![@inputActualNewConstantParameterAST new
      !selector
      !declarationTypeName
      !inputActualParameterName
    ] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  F O R M A L    I N P U T    P A R A M E T E R S                          *
#                                                                           *
#---------------------------------------------------------------------------*

rule <formal_input_parameter_list> !@formalInputParameterListAST outFormalInputParameterList :
  outFormalInputParameterList := [@formalInputParameterListAST emptyList] ;
  repeat
  while
    @bool isConstant ;
    @lstring selector ;
    select
      $?$ ?selector ;
      isConstant := false ;
    or
      $??$ ?selector :> ??@string sep ?* ;
      send sep + "?" + if selector->string != "" then selector->string + ":" else "" end + "let " ;
      isConstant := true ;
    end select ;
    $type_name$ ?@lstring mFormalParameterTypeName ;
    @bool mIsUnused ;
    select
      mIsUnused := false ;
    or
      $unused$ ;
      mIsUnused := true ;
    end select ;
    $identifier$ ?@lstring mFormalParameterName ;
    outFormalInputParameterList +=
      !selector
      !mFormalParameterTypeName
      !mFormalParameterName
      !mIsUnused
      !isConstant
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
