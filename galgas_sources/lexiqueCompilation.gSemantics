#---------------------------------------------------------------------------*
#                                                                           *
#  'lexique' component metamodel                                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics lexiqueCompilation :
import "predefinedLexicalActions.gSemantics" ;

import semantics lexiqueMetamodel in "lexiqueMetamodel.gSemantics" ;
import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
import semantics predefinedLexicalActions in "predefinedLexicalActions.gSemantics" ;
import grammar lexiqueLL1grammar in "lexiqueLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*
#   L E X I C A L    E X P R E S S I O N    C O D E    G E N E R A T I O N  *
#---------------------------------------------------------------------------*

abstract reader @lexicalExpression generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalOrExpression generateConditionCode
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := [mLeftOperand generateConditionCode !inLexiqueAnalysisContext] ;
  outGeneratedCode .= " || " ;
  outGeneratedCode .= [mRightOperand generateConditionCode !inLexiqueAnalysisContext] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterIntervalMatch generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
  outGeneratedCode := "testForInputUTF32CharRange (" ;
  outGeneratedCode .= [[mLowerBound char] utf32CharConstantRepresentation] ;
  outGeneratedCode .= ", " ;
  outGeneratedCode .= [[mUpperBound char] utf32CharConstantRepresentation] ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalStringMatch generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "testForInputUTF32String (kUnicodeString_" . [mString identifierRepresentation] ;
  outGeneratedCode .= ", " ;
  outGeneratedCode .= [[mString length] string] ;
  outGeneratedCode .= ", true)" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalStringNotMatch generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "notTestForInputUTF32String (kUnicodeString_" ;
  outGeneratedCode .= [mString identifierRepresentation] ;
  outGeneratedCode .= ", " ;
  outGeneratedCode .= [[mString length] string] ;
  outGeneratedCode .= ", gLexicalMessage_" ;
  outGeneratedCode .= mErrorMessage ;
  outGeneratedCode .= " COMMA_LINE_AND_SOURCE_FILE)" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterMatch generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "testForInputUTF32Char (" ;
  outGeneratedCode .= [[mCharacter char] utf32CharConstantRepresentation] ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterSetMatch generateConditionCode
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "testForCharWithFunction (" ;
  outGeneratedCode .= mCharacterSetName ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*
#     R O U T I N E    O R    F U N C T I O N    A R G U M E N T            *
#---------------------------------------------------------------------------*

abstract reader @lexicalRoutineOrFunctionFormalInputArgument generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalAttributeInputArgument generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "token.mLexicalAttribute_" . mAttributeName ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCharacterInputArgument generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [[mCharacter char] utf32CharConstantRepresentation] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalUnsignedInputArgument generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [[mUnsigned uint] string] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalCurrentCharacterInputArgument generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "previousChar ()" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalFunctionInputArgument generateRoutineOrFunctionArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "::scanner_function_" . mFunctionName . " (*this" ;
  foreach mFunctionActualArgumentList do
    outGeneratedCode .= ", " . [mLexicalActualInputArgument generateRoutineOrFunctionArgument] ;
  end foreach ;
  outGeneratedCode .= ")" ;
end reader ;

#---------------------------------------------------------------------------*
#                   R O U T I N E    A R G U M E N T                        *
#---------------------------------------------------------------------------*

abstract reader @abstractLexicalRoutineActualArgument generateRoutineArgument
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalAttributeInputOutputArgument generateRoutineArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := "token.mLexicalAttribute_" . mAttributeName ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalFormalInputArgument generateRoutineArgument
  -> @string outGeneratedCode
:
  outGeneratedCode := [mRoutineOrFunctionFormalInputArgument generateRoutineOrFunctionArgument] ;
end reader ;

#---------------------------------------------------------------------------*
#  L E X I C A L    S E N D  I N S T R U C T I O N    D E F A U L T         *
#---------------------------------------------------------------------------*

abstract reader @lexicalSendDefaultAction generateDefaultSendCode
  ?@string inScannerClassName
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalSendTerminalByDefault generateDefaultSendCode
  ?@string inScannerClassName
  -> @string outGeneratedCode
:
  outGeneratedCode := "token.mTokenCode = " . inScannerClassName . "_1_" . mDefaultSentTerminal . " ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalErrorByDefault generateDefaultSendCode
  ?@string unused inScannerClassName
  -> @string outGeneratedCode
:
  outGeneratedCode := "lexicalError (gLexicalMessage_" . mDefaultErrorMessageName . " COMMA_LINE_AND_SOURCE_FILE) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*
#  L E X I C A L    I N S T R U C T I O N    C O D E    G E N E R A T I O N *
#---------------------------------------------------------------------------*

abstract reader @lexicalInstruction generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalStructuredSendInstruction generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
  foreach mLexicalSendSearchList do
    outGeneratedCode .= "if (token.mTokenCode == -1) {\n" ;
    outGeneratedCode .= "  token.mTokenCode = search_into_" . mSearchListName . " (token.mLexicalAttribute_" . mAttributeName . ") ;\n" ;
    outGeneratedCode .= "}\n" ;
  end foreach ;
  outGeneratedCode .= "if (token.mTokenCode == -1) {\n" ;
  outGeneratedCode .= "  " . [mLexicalSendDefaultAction generateDefaultSendCode !inScannerClassName] ;
  outGeneratedCode .= "}\n" ;
  outGeneratedCode .= "enterToken (token) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalSimpleSendInstruction generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "token.mTokenCode = " . inScannerClassName . "_1_" . [mSentTerminal identifierRepresentation] . " ;\n" ;
  outGeneratedCode .= "enterToken (token) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRepeatInstruction generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "do {\n" ;
  [!?outGeneratedCode incIndentation !2] ;
#--- Repeated instruction
  foreach mRepeatedInstructionList do
    outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
  end foreach ;
#---
  foreach mLexicalWhileBranchList
  do
    outGeneratedCode .= "if (" ;
    outGeneratedCode .= [mWhileExpression generateConditionCode !inLexiqueAnalysisContext] ;
    outGeneratedCode .= ") {\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mWhileInstructionList do
      outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  between
    outGeneratedCode .= "}else " ;
  end foreach ;
  outGeneratedCode .= "}else{\n"
                      "  loop = false ;\n"
                      "}\n" ;
  [!?outGeneratedCode decIndentation !2] ;
  outGeneratedCode .= "}while (loop) ;\n"
                      "loop = true ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalSelectInstruction generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ;
#---
  foreach mLexicalSelectBranchList
  do
    outGeneratedCode .= "if (" ;
    outGeneratedCode .= [mSelectExpression generateConditionCode !inLexiqueAnalysisContext] ;
    outGeneratedCode .= ") {\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mSelectInstructionList do
      outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  between
    outGeneratedCode .= "}else " ;
  end foreach ;
#--- Default branch
  if [mDefaultInstructionList length] > 0 then
    outGeneratedCode .= "}else{\n" ;
    [!?outGeneratedCode incIndentation !2] ;
    foreach mDefaultInstructionList do
      outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
    end foreach ;
    [!?outGeneratedCode decIndentation !2] ;
  end if ;
  outGeneratedCode .= "}\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRoutineInstruction generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "::scanner_routine_" . mRoutineName . " (*this" ;
  foreach mActualArgumentList do
    outGeneratedCode .= ", " . [mLexicalRoutineActualArgument generateRoutineArgument] ;
  end foreach ;
  foreach mErrorMessageList do
    outGeneratedCode .= ", gLexicalMessage_" . mValue ;
  end foreach ;
  outGeneratedCode .= ") ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalDropInstruction generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "" ; # No generated code
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalErrorInstruction generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "lexicalError (gLexicalMessage_" . mErrorMessageName . " COMMA_LINE_AND_SOURCE_FILE) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalWarningInstruction generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "lexicalWarning (gLexicalMessage_" . mWarningMessageName . " COMMA_LINE_AND_SOURCE_FILE) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalTagInstruction generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "const C_LocationInSource locationForTag_" . mLexicalTagName . " = mCurrentLocation ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalRewindInstruction generateInstructionCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "mCurrentLocation = locationForTag_" . mLexicalTagName . " ;\n" ;
  outGeneratedCode .= "token.mTokenCode = " . inScannerClassName . "_1_" . [mTerminalName identifierRepresentation] . " ;\n" ;
  outGeneratedCode .= "enterToken (token) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalLogInstruction generateInstructionCode
  ?@string unused inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "lexicalLog (LINE_AND_SOURCE_FILE) ;\n" ;
end reader ;

#---------------------------------------------------------------------------*
#        L E X I C A L    R U L E    C O D E    G E N E R A T I O N         *
#---------------------------------------------------------------------------*

abstract reader @abstractLexicalRule generateCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext unused inLexiqueAnalysisContext
  -> @string outGeneratedCode
;

#---------------------------------------------------------------------------*

override reader @lexicalImplicitRule generateCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  @tokenSortedlist tokenSortedList ;
  [[inLexiqueAnalysisContext mLexicalTokenListMap] searchKey !mListName ?* ?tokenSortedList] ;
  outGeneratedCode := "" ;
  foreach > tokenSortedList do
    outGeneratedCode .= "if (testForInputUTF32String (kUnicodeString_" ;
    outGeneratedCode .= [mName identifierRepresentation] ;
    outGeneratedCode .= ", " ;
    outGeneratedCode .= [[mName length] string] ;
    outGeneratedCode .= ", true)) {\n" ;
    outGeneratedCode .= "  token.mTokenCode = " . inScannerClassName . "_1_" . [mTerminalName identifierRepresentation] . " ;\n" ;
    outGeneratedCode .= "  enterToken (token) ;\n" ;
    outGeneratedCode .= "}else " ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

override reader @lexicalExplicitRule generateCode
  ?@string inScannerClassName
  ?@lexiqueAnalysisContext inLexiqueAnalysisContext
  -> @string outGeneratedCode
:
  outGeneratedCode := "if (" ;
  outGeneratedCode .= [mLexicalRuleExpression generateConditionCode !inLexiqueAnalysisContext] ;
  outGeneratedCode .= ") {\n" ;
  [!?outGeneratedCode incIndentation !2] ;
  foreach mInstructionList do
    outGeneratedCode .= [mInstruction generateInstructionCode !inScannerClassName !inLexiqueAnalysisContext] ;
  end foreach ;
  [!?outGeneratedCode decIndentation !2] ;
  outGeneratedCode .= "}else " ;
end reader ;

#---------------------------------------------------------------------------*
#         G E N E R A T I O N    T E M P L A T E S                          *
#---------------------------------------------------------------------------*

filewrapper lexiqueGenerationTemplates in "../generation_templates/lexique_generation" {
} {
  template headerZone2 "lexique_header_template_zone_2.h.ggstpl"
    ?@string LEXIQUE_CLASS_NAME
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
  ;
  template headerZone3 "lexique_header_template_zone_3.h.ggstpl"
    ?@string LEXIQUE_CLASS_NAME
    ?@terminalList TERMINAL_LIST
    ?@lexicalListDeclarationList DELIMITOR_LIST_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
  ;
  template implementationZone2 "lexique_implementation.cpp.ggstpl"
    ?@string LEXIQUE_CLASS_NAME
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap LEXICAL_MESSAGE_MAP
    ?@terminalList TERMINAL_LIST
    ?@lexicalExplicitTokenListMapMap LEXICAL_TOKEN_LIST_MAP
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleList LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
  ;
}

#---------------------------------------------------------------------------*
#                     checkLexicalDefaultAction                             *
#---------------------------------------------------------------------------*

abstract method @lexicalSendDefaultAction checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalSendTerminalByDefault checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [[ioLexiqueAnalysisContext mTerminalMap] searchKey !mDefaultSentTerminal ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalErrorByDefault checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  with xyz_ : !?ioLexiqueAnalysisContext.mLexicalMessageMap searchKey !mDefaultErrorMessageName do
    xyz_mMessageIsUsed := true ;
  end with ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalExpression                              *
#---------------------------------------------------------------------------*

abstract method @lexicalExpression checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalOrExpression checkLexicalExpression
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [mLeftOperand checkLexicalExpression !? ioLexiqueAnalysisContext] ;
  [mRightOperand checkLexicalExpression !? ioLexiqueAnalysisContext] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterSetMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterIntervalMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalStringMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  ioLexiqueAnalysisContext.mUnicodeStringToGenerate += ![mString string] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalStringNotMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  ioLexiqueAnalysisContext.mUnicodeStringToGenerate += ![mString string] ;
  with !?ioLexiqueAnalysisContext.mLexicalMessageMap searchKey !mErrorMessage do
    mMessageIsUsed := true ;
  end with ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalFunctionCallArgument                    *
#---------------------------------------------------------------------------*

abstract method @lexicalRoutineOrFunctionFormalInputArgument checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum unused inLexicalRoutineFormalArgumentType
;

#---------------------------------------------------------------------------*

override method @lexicalAttributeInputArgument checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalTypeEnum attributeLexicalType ;
  [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey
    !mAttributeName
    ?attributeLexicalType
  ] ;
#--- Type check
  if attributeLexicalType != inLexicalRoutineFormalArgumentType then
    error mAttributeName:"type error, attribute type is "
    . [attributeLexicalType lexicalTypeName]
    . " type, but lexical routine prototype requires "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterInputArgument checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_char] != inLexicalRoutineFormalArgumentType then
    error mCharacter:"type error, a literal character has @char"
    . " type, but lexical routine prototype requires an "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalUnsignedInputArgument checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_uint] != inLexicalRoutineFormalArgumentType then
    error mUnsigned:"type error, a literal character has @uint"
    . " type, but lexical routine prototype requires an "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCurrentCharacterInputArgument checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_char] != inLexicalRoutineFormalArgumentType then
    error mLocation:"type error, current character value has @char"
    . " type, but lexical routine prototype requires an "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalFunctionInputArgument checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalFunctionFormalArgumentList lexicalFormalTypeList ;
  @lexicalTypeEnum returnedLexicalFormalType ;
  @string replacementFunctionName ;
  [[ioLexiqueAnalysisContext mLexicalFunctionMap] searchKey
    !mFunctionName
    ?lexicalFormalTypeList
    ?returnedLexicalFormalType
    ?replacementFunctionName
  ] ;
#--- Obsolete function ?
  if replacementFunctionName != "" then
    warning mFunctionName:"obsolete lexical function, replaced by '" . replacementFunctionName . "'" ;
  end if ;
#--- Returned type check
  if returnedLexicalFormalType != inLexicalRoutineFormalArgumentType then
    error mFunctionName:"type error, the function returns an "
    . [returnedLexicalFormalType lexicalTypeName]
    . " value, but lexical routine prototype requires an "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " value" ;
  end if ;
#--- Check actual argument count
  if [lexicalFormalTypeList length] != [mFunctionActualArgumentList length] then
    error mFunctionName: "this lexical function names "
    . [[mFunctionActualArgumentList length] string]
    . " actual argument(s), but the prototype requires "
    . [[lexicalFormalTypeList length] string] . " actual argument(s)" ;
  end if ;
#--- Check actual argument against formal parameters
  foreach lexicalFormalTypeList, mFunctionActualArgumentList do
    [mLexicalActualInputArgument checkLexicalFunctionCallArgument
      !?ioLexiqueAnalysisContext
      !mLexicalType
    ] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalRoutineCallArgument                     *
#---------------------------------------------------------------------------*

abstract method @lexicalRoutineOrFunctionFormalInputArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum unused inLexicalRoutineFormalArgumentType
;

#---------------------------------------------------------------------------*

override method @lexicalAttributeInputArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalTypeEnum attributeLexicalType ;
  [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey
    !mAttributeName
    ?attributeLexicalType
  ] ;
#--- Type check
  if attributeLexicalType != inLexicalRoutineFormalArgumentType then
    error mAttributeName:"type error, attribute type is "
    . [attributeLexicalType lexicalTypeName]
    . " type, but lexical routine prototype requires "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterInputArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_char] != inLexicalRoutineFormalArgumentType then
    error mCharacter:"type error, a literal character has @char"
    . " type, but lexical routine prototype requires an "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalUnsignedInputArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_uint] != inLexicalRoutineFormalArgumentType then
    error mUnsigned:"type error, a literal unsigned value has @uint"
    . " type, but lexical routine prototype requires an "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCurrentCharacterInputArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_char] != inLexicalRoutineFormalArgumentType then
    error mLocation:"type error, current character value has @char"
    . " type, but lexical routine prototype requires an "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalFunctionInputArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalFunctionFormalArgumentList lexicalFormalTypeList ;
  @lexicalTypeEnum returnedLexicalFormalType ;
  @string replacementFunctionName ;
  [[ioLexiqueAnalysisContext mLexicalFunctionMap] searchKey
    !mFunctionName
    ?lexicalFormalTypeList
    ?returnedLexicalFormalType
    ?replacementFunctionName
  ] ;
#--- Obsolete function ?
  if replacementFunctionName != "" then
    warning mFunctionName:"obsolete lexical function, replaced by '" . replacementFunctionName . "'" ;
  end if ;
#--- Returned type check
  if returnedLexicalFormalType != inLexicalRoutineFormalArgumentType then
    error mFunctionName:"type error, the function returns an "
    . [returnedLexicalFormalType lexicalTypeName]
    . " value, but lexical routine prototype requires an "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " value" ;
  end if ;
#--- Check actual argument count
  if [lexicalFormalTypeList length] != [mFunctionActualArgumentList length] then
    error mFunctionName: "this lexical function names "
    . [[mFunctionActualArgumentList length] string]
    . " actual argument(s), but the prototype requires "
    . [[lexicalFormalTypeList length] string] . " actual argument(s)" ;
  end if ;
#--- Check actual argument against formal parameters
  foreach lexicalFormalTypeList, mFunctionActualArgumentList do
    [mLexicalActualInputArgument checkLexicalFunctionCallArgument
      !?ioLexiqueAnalysisContext
      !mLexicalType
    ] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalRoutineCallArgument                     *
#---------------------------------------------------------------------------*

abstract method @abstractLexicalRoutineActualArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalArgumentMode unused inLexicalRoutineFormalArgumentMode
  ?@lexicalTypeEnum unused inLexicalRoutineFormalArgumentType
;

#---------------------------------------------------------------------------*

override method @lexicalAttributeInputOutputArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalArgumentMode inLexicalRoutineFormalArgumentMode
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalTypeEnum attributeLexicalType ;
  [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey
    !mAttributeName
    ?attributeLexicalType
  ] ;
#--- Type check
  if attributeLexicalType != inLexicalRoutineFormalArgumentType then
    error mAttributeName:"type error, attribute type is "
    . [attributeLexicalType lexicalTypeName]
    . " type, but lexical routine prototype requires "
    . [inLexicalRoutineFormalArgumentType lexicalTypeName]
    . " type" ;
  end if ;
#--- Passing mode check
  if inLexicalRoutineFormalArgumentMode != [@lexicalArgumentMode lexicalInputOutputMode] then
    error mActualPassingModeLocation:"the output mode (!) is required here, not an output/input mode" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalFormalInputArgument checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalArgumentMode inLexicalRoutineFormalArgumentMode
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalTypeEnum attributeLexicalType ;
  [mRoutineOrFunctionFormalInputArgument checkLexicalRoutineCallArgument
    !?ioLexiqueAnalysisContext
    !inLexicalRoutineFormalArgumentType
  ] ;
#--- Passing mode check
  if inLexicalRoutineFormalArgumentMode != [@lexicalArgumentMode lexicalInputMode] then
    error mActualPassingModeLocation:"the output/input mode (!?) is required here, not an input mode" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalInstruction                             *
#---------------------------------------------------------------------------*

abstract method @lexicalInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalStructuredSendInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  foreach mLexicalSendSearchList do
    [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey !mAttributeName ?*] ;
  end foreach ;
  [mLexicalSendDefaultAction checkLexicalDefaultAction !?ioLexiqueAnalysisContext] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalSimpleSendInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [[ioLexiqueAnalysisContext mTerminalMap] searchKey !mSentTerminal ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalRepeatInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  foreach mLexicalWhileBranchList do
    [mWhileExpression checkLexicalExpression !?ioLexiqueAnalysisContext] ;
    foreach mWhileInstructionList do
      [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext] ;
    end foreach ;
  end foreach ;
  foreach mRepeatedInstructionList do
    [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalSelectInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  foreach mLexicalSelectBranchList do
    [mSelectExpression checkLexicalExpression !?ioLexiqueAnalysisContext] ;
    foreach mSelectInstructionList do
      [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext] ;
    end foreach ;
  end foreach ;
  foreach mDefaultInstructionList do
    [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalRoutineInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  @lexicalRoutineFormalArgumentList lexicalRoutineFormalArgumentList ;
  @stringlist routineErrorMessageList ;
  @string replacementRoutineName ;
  [[ioLexiqueAnalysisContext mLexicalRoutineMessageMap] searchKey
    !mRoutineName
    ?lexicalRoutineFormalArgumentList
    ?routineErrorMessageList
    ?replacementRoutineName
  ] ;
#--- Obsolete routine ?
  if replacementRoutineName != "" then
    warning mRoutineName:"obsolete lexical routine, replaced by '" . replacementRoutineName . "'" ;
  end if ;
#--- Check actual argument count
  if [lexicalRoutineFormalArgumentList length] != [mActualArgumentList length] then
    error mRoutineName: "this lexical routine call names "
    . [[mActualArgumentList length] string]
    . " actual argument(s), but the lexical routine prototype requires "
    . [[lexicalRoutineFormalArgumentList length] string] . " actual argument(s)" ;
  end if ;
#--- Check actual argument against formal parameters
  foreach lexicalRoutineFormalArgumentList, mActualArgumentList do
    [mLexicalRoutineActualArgument checkLexicalRoutineCallArgument
      !?ioLexiqueAnalysisContext
      !mLexicalFormalArgumentMode
      !mLexicalFormalArgumentType
    ] ;
  end foreach ;
#--- Check error message count
  if [routineErrorMessageList length] != [mErrorMessageList length] then
    error mRoutineName: "this lexical routine call names "
    . [[mErrorMessageList length] string]
    . " error message(s), but the lexical routine prototype requires "
    . [[routineErrorMessageList length] string] . " error message(s)" ;
  end if ;
#--- Check error messages are actually defined
  foreach mErrorMessageList do
    with xyz_ : !?ioLexiqueAnalysisContext.mLexicalMessageMap searchKey !mValue do
      xyz_mMessageIsUsed := true ;
    end with ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalLogInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalRewindInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalDropInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalTagInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalErrorInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  with !?ioLexiqueAnalysisContext.mLexicalMessageMap searchKey !mErrorMessageName do
    mMessageIsUsed := true ;
  end with ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalWarningInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  with !?ioLexiqueAnalysisContext.mLexicalMessageMap searchKey !mWarningMessageName do
    mMessageIsUsed := true ;
  end with ;
end method ;

#---------------------------------------------------------------------------*
#                         compileLexiqueComponent                           *
#---------------------------------------------------------------------------*

abstract method @abstractLexicalRule checkLexicalRule
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalImplicitRule checkLexicalRule
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [[ioLexiqueAnalysisContext mLexicalTokenListMap] searchKey ! mListName ?* ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalExplicitRule checkLexicalRule
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [mLexicalRuleExpression checkLexicalExpression !?ioLexiqueAnalysisContext] ;
  foreach mInstructionList do
    [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                         compileLexiqueComponent                           *
#---------------------------------------------------------------------------*

routine compileLexiqueComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectory
:
  @lexiqueComponentRoot lexiqueComponentRoot ;
  grammar lexiqueLL1grammar in inSourceFile ?lexiqueComponentRoot ;
#--------------------------------------- Check component name
  @lstring componentName := [lexiqueComponentRoot mLexiqueComponentName] ;
  @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--------------------------------------- Lexical attribute type name map
  @lexicalTypeMap lexicalTypeMap [emptyMap] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"string" !here] ![@lexicalTypeEnum lexicalType_string]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"char"   !here] ![@lexicalTypeEnum lexicalType_char]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"uint"   !here] ![@lexicalTypeEnum lexicalType_uint]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"uint64" !here] ![@lexicalTypeEnum lexicalType_uint64]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"sint"   !here] ![@lexicalTypeEnum lexicalType_sint]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"sint64" !here] ![@lexicalTypeEnum lexicalType_sint64]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"double" !here] ![@lexicalTypeEnum lexicalType_double]] ;
#--------------------------------------- Build lexical routine map
  @lexicalRoutineMap lexicalRoutineMap ;
  buildLexicalRoutineMap ?lexicalRoutineMap ;
#--------------------------------------- Build lexical function map
  @lexicalFunctionMap lexicalFunctionMap ;
  buildLexicalFunctionMap ?lexicalFunctionMap ;
#--------------------------------------- Build lexical attribute map
  @lexiqueAnalysisContext lexiqueAnalysisContext [new
    !lexicalRoutineMap
    !lexicalFunctionMap
    ![@lexicalMessageMap emptyMap]
    ![@terminalMap emptyMap]
    ![@terminalList emptyList]
    ![@lexicalAttributeMap emptyMap]
    ![@lexicalExplicitTokenListMapMap emptyMap]
    ![@stringset emptySet]
  ] ;
  foreach [lexiqueComponentRoot mLexicalAttributeList] do
    if [lexicalTypeMap hasKey ![mTypeName string]] then
      @lexicalTypeEnum lexicalType ;
      [lexicalTypeMap searchKey !mTypeName ?lexicalType] ;
      [!?lexiqueAnalysisContext.mLexicalAttributeMap insertKey !mName !lexicalType] ;
    else
      @string m := "" ;
      m .= "the @" . mTypeName . " type is not a valid lexical attribute type; are allowed:" ;
      @bool firstLoop := true ;
      foreach lexicalTypeMap do
        m .= " @" . key ;
      between
        m .= "," ;
      end foreach ;
      error mTypeName: m ;
    end if ;
  end foreach ;
#--------------------------------------- Build terminal map
  foreach [lexiqueComponentRoot mTerminalDeclarationList] do
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList (@lstring kAttributeName) do
      @lexicalTypeEnum attributeLexicalType ;
      [[lexiqueAnalysisContext  mLexicalAttributeMap] searchKey !kAttributeName ?attributeLexicalType] ;
      argumentTypeList += ![kAttributeName string] !attributeLexicalType ;
    end foreach ;
    [!?lexiqueAnalysisContext.mTerminalMap insertKey !mName !argumentTypeList] ;
    lexiqueAnalysisContext.mTerminalList += !mName !argumentTypeList ![mSyntaxErrorMessage string] ;
  end foreach ;
  foreach [lexiqueComponentRoot mLexicalListDeclarationList] do
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList (@lstring kAttributeName) do
      @lexicalTypeEnum attributeLexicalType ;
      [[lexiqueAnalysisContext mLexicalAttributeMap] searchKey !kAttributeName ?attributeLexicalType] ;
      argumentTypeList += ![kAttributeName string] !attributeLexicalType ;
    end foreach ;
    @lexicalExplicitTokenListMap lexicalTokenListMap [emptyMap] ;
    @tokenSortedlist tokenSortedlist [emptySortedList] ;
    foreach mEntryList do
      @string syntaxErrorMessage := [mSyntaxErrorMessage stringByReplacingStringByString !"%K" ![mTerminalSpelling string]] ;
      lexiqueAnalysisContext.mTerminalList += !mTerminalSpelling !argumentTypeList !syntaxErrorMessage ;
      [!?lexiqueAnalysisContext.mTerminalMap insertKey !mTerminalSpelling !argumentTypeList] ;
      [!?lexicalTokenListMap insertKey !mEntrySpelling !mTerminalSpelling !mFeatureList] ;
      tokenSortedlist += ![mEntrySpelling length] ![mEntrySpelling string] ![mTerminalSpelling string] ;
      lexiqueAnalysisContext.mUnicodeStringToGenerate += ![mEntrySpelling string] ;
    end foreach ;
    [!?lexiqueAnalysisContext.mLexicalTokenListMap insertKey !mName !lexicalTokenListMap !tokenSortedlist] ;
  end foreach ;
#--------------------------------------- Build Message map
  foreach [lexiqueComponentRoot mLexicalMessageDeclarationList] do
    [!?lexiqueAnalysisContext.mLexicalMessageMap insertKey !mMessageName !mMessageValue !false] ;
  end foreach ;
#--------------------------------------- Check rules
  foreach [lexiqueComponentRoot mLexicalRuleList] do
    [mLexicalRule checkLexicalRule !?lexiqueAnalysisContext] ;
  end foreach ;
#--------------------------------------- Warn for unused messages
  foreach [lexiqueAnalysisContext mLexicalMessageMap] do
    if not mMessageIsUsed then
      warning key:"unused message" ;
    end if ;
  end foreach ;
#--------------------------------------- Build Header file
  @string lexiqueClassName := [componentName string] ;
#--- Generate header file
  if [@uint errorCount] == 0 then
    [@string generateFile
      !inOutputDirectory
      !lexiqueClassName . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper lexiqueGenerationTemplates.headerZone2
         !lexiqueClassName
         ![lexiqueAnalysisContext mLexicalAttributeMap]
       ]
      !"\n\n" # Defaut user zone2
      ![filewrapper lexiqueGenerationTemplates.headerZone3
         !lexiqueClassName
         ![lexiqueAnalysisContext mTerminalList]
         ![lexiqueComponentRoot mLexicalListDeclarationList]
         !lexiqueAnalysisContext
       ]
    ] ;
  end if ;
#--- Generate implementation file
  if [@uint errorCount] == 0 then
    [@string generateFile
      !inOutputDirectory
      !lexiqueClassName . ".cpp"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper lexiqueGenerationTemplates.implementationZone2
         !lexiqueClassName
         ![lexiqueAnalysisContext mLexicalAttributeMap]
         ![lexiqueAnalysisContext mLexicalMessageMap]
         ![lexiqueAnalysisContext mTerminalList]
         ![lexiqueAnalysisContext mLexicalTokenListMap]
         ![lexiqueAnalysisContext mUnicodeStringToGenerate]
         ![lexiqueComponentRoot mLexicalRuleList]
         !lexiqueAnalysisContext
       ]
      !"\n\n" # Defaut user zone2
      !"\n\n" # Zone 3
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;