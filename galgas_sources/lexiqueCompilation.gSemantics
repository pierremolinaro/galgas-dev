#---------------------------------------------------------------------------*
#                                                                           *
#  'lexique' component metamodel                                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics lexiqueCompilation :

import semantics lexiqueMetamodel in "lexiqueMetamodel.gSemantics" ;
import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
import grammar lexiqueLL1grammar in "lexiqueLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                     checkLexicalDefaultAction                             *
#---------------------------------------------------------------------------*

abstract method @lexicalSendDefaultAction checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalSendTerminalByDefault checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [[ioLexiqueAnalysisContext mTerminalMap] searchKey !mDefaultSentTerminal ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalErrorByDefault checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  if [[ioLexiqueAnalysisContext mLexicalMessageMap] hasKey ![mDefaultErrorMessageName string]] then
    [!? ioLexiqueAnalysisContext.mLexicalMessageMap setMessageIsUsedForKey !true ![mDefaultErrorMessageName string]] ;
  else
    [[ioLexiqueAnalysisContext mLexicalMessageMap] searchKey !mDefaultErrorMessageName ?* ?*] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalExpression                              *
#---------------------------------------------------------------------------*

abstract method @lexicalExpression checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalOrExpression checkLexicalExpression
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [mLeftOperand checkLexicalExpression !? ioLexiqueAnalysisContext] ;
  [mRightOperand checkLexicalExpression !? ioLexiqueAnalysisContext] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterSetMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterIntervalMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalStringMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalStringNotMatch checkLexicalExpression
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
#  [!? ioLexiqueAnalysisContext setMessageIsUsedForKey !true !mErrorMessage] ;
  if [[ioLexiqueAnalysisContext mLexicalMessageMap] hasKey ![mErrorMessage string]] then
    [!? ioLexiqueAnalysisContext.mLexicalMessageMap setMessageIsUsedForKey !true ![mErrorMessage string]] ;
  else
    [[ioLexiqueAnalysisContext mLexicalMessageMap] searchKey !mErrorMessage ?* ?*] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalInstruction                             *
#---------------------------------------------------------------------------*

abstract method @lexicalInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalStructuredSendInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  foreach mLexicalSendSearchList do
    [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey !mAttributeName ?*] ;
  end foreach ;
  [mLexicalSendDefaultAction checkLexicalDefaultAction !?ioLexiqueAnalysisContext] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalSimpleSendInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [[ioLexiqueAnalysisContext mTerminalMap] searchKey !mSentTerminal ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalRepeatInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  foreach mLexicalWhileBranchList do
    [mWhileExpression checkLexicalExpression !? ioLexiqueAnalysisContext] ;
    foreach mWhileInstructionList do
      [mInstruction checkLexicalInstruction !? ioLexiqueAnalysisContext] ;
    end foreach ;
  end foreach ;
  foreach mRepeatedInstructionList do
    [mInstruction checkLexicalInstruction !? ioLexiqueAnalysisContext] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalSelectInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  foreach mLexicalSelectBranchList do
    foreach mSelectInstructionList do
      [mInstruction checkLexicalInstruction !? ioLexiqueAnalysisContext] ;
    end foreach ;
  end foreach ;
  foreach mDefaultInstructionList do
    [mInstruction checkLexicalInstruction !? ioLexiqueAnalysisContext] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalActionInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  foreach mErrorMessageList do
#    [!? ioLexiqueAnalysisContext setMessageIsUsedForKey !true !mValue] ;
    if [[ioLexiqueAnalysisContext mLexicalMessageMap] hasKey ![mValue string]] then
      [!? ioLexiqueAnalysisContext.mLexicalMessageMap setMessageIsUsedForKey !true ![mValue string]] ;
    else
      [[ioLexiqueAnalysisContext mLexicalMessageMap] searchKey !mValue ?* ?*] ;
    end if ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalLogInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalRewindInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalDropInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalTagInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalErrorInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
#  [!? ioLexiqueAnalysisContext setMessageIsUsedForKey !true !mErrorMessageName] ;
  if [[ioLexiqueAnalysisContext mLexicalMessageMap] hasKey ![mErrorMessageName string]] then
    [!? ioLexiqueAnalysisContext.mLexicalMessageMap setMessageIsUsedForKey !true ![mErrorMessageName string]] ;
  else
    [[ioLexiqueAnalysisContext mLexicalMessageMap] searchKey !mErrorMessageName ?* ?*] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalWarningInstruction checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
#  [!? ioLexiqueAnalysisContext setMessageIsUsedForKey !true !mWarningMessageName] ;
  if [[ioLexiqueAnalysisContext mLexicalMessageMap] hasKey ![mWarningMessageName string]] then
    [!? ioLexiqueAnalysisContext.mLexicalMessageMap setMessageIsUsedForKey !true ![mWarningMessageName string]] ;
  else
    [[ioLexiqueAnalysisContext mLexicalMessageMap] searchKey !mWarningMessageName ?* ?*] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*
#                         compileLexiqueComponent                           *
#---------------------------------------------------------------------------*

abstract method @abstractLexicalRule checkLexicalRule
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalImplicitRule checkLexicalRule
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalExplicitRule checkLexicalRule
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  foreach mInstructionList do
    [mInstruction checkLexicalInstruction !? ioLexiqueAnalysisContext] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                         compileLexiqueComponent                           *
#---------------------------------------------------------------------------*

routine compileLexiqueComponent
  ??@lstring inSourceFile
  ??@string unused inOutputDirectory
:
  @lexiqueComponentRoot lexiqueComponentRoot ;
  grammar lexiqueLL1grammar in inSourceFile ?lexiqueComponentRoot ;
#--------------------------------------- Check component name
  @lstring componentName := [lexiqueComponentRoot mLexiqueComponentName] ;
  @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--------------------------------------- Lexical attribute type name map
  @lexicalTypeMap lexicalTypeMap [emptyMap] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"string" !here] ![@lexicalTypeEnum lexicalType_string]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"char"   !here] ![@lexicalTypeEnum lexicalType_char]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"uint"   !here] ![@lexicalTypeEnum lexicalType_uint]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"uint64" !here] ![@lexicalTypeEnum lexicalType_uint64]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"sint"   !here] ![@lexicalTypeEnum lexicalType_sint]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"sint64" !here] ![@lexicalTypeEnum lexicalType_sint64]] ;
  [!?lexicalTypeMap insertKey ![@lstring new !"double" !here] ![@lexicalTypeEnum lexicalType_double]] ;
#--------------------------------------- Build lexical attribute map
  @lexiqueAnalysisContext lexiqueAnalysisContext [new
    ![@lexicalMessageMap emptyMap]
    ![@terminalMap emptyMap]
    ![@lexicalAttributeMap emptyMap]
    ![@lexicalExplicitTokenListMapMap emptyMap]
  ] ;
  foreach [lexiqueComponentRoot mLexicalAttributeList] do
    if [lexicalTypeMap hasKey ![mTypeName string]] then
      @lexicalTypeEnum lexicalType ;
      [lexicalTypeMap searchKey !mTypeName ?lexicalType] ;
      [!?lexiqueAnalysisContext.mLexicalAttributeMap insertKey !mName !lexicalType] ;
    else
      @string m := "" ;
      m .= "the @" . mTypeName . " type is not a valid lexical attribute type; are allowed:" ;
      @bool firstLoop := true ;
      foreach lexicalTypeMap do
        m .= " @" . key ;
      between
        m .= "," ;
      end foreach ;
      error mTypeName: m ;
    end if ;
  end foreach ;
#--------------------------------------- Build terminal map
  foreach [lexiqueComponentRoot mTerminalDeclarationList] do
    @lexicalTypeList argumentTypeList [emptyList] ;
    foreach mSentAttributeList (@lstring kAttributeName) do
      @lexicalTypeEnum attributeLexicalType ;
      [[lexiqueAnalysisContext  mLexicalAttributeMap] searchKey !kAttributeName ?attributeLexicalType] ;
      argumentTypeList += !attributeLexicalType ;
    end foreach ;
    [!?lexiqueAnalysisContext.mTerminalMap insertKey !mName !argumentTypeList] ;
  end foreach ;
  foreach [lexiqueComponentRoot mLexicalListDeclarationList] do
    @lexicalTypeList argumentTypeList [emptyList] ;
    foreach mSentAttributeList (@lstring kAttributeName) do
      @lexicalTypeEnum attributeLexicalType ;
      [[lexiqueAnalysisContext mLexicalAttributeMap] searchKey !kAttributeName ?attributeLexicalType] ;
      argumentTypeList += !attributeLexicalType ;
    end foreach ;
    @lexicalExplicitTokenListMap lexicalTokenListMap [emptyMap] ;
    foreach mEntryList do
      [!?lexiqueAnalysisContext.mTerminalMap insertKey !mTerminalSpelling !argumentTypeList] ;
      [!?lexicalTokenListMap insertKey !mEntrySpelling !mTerminalSpelling !mFeatureList] ;
    end foreach ;
    [!?lexiqueAnalysisContext.mLexicalTokenListMapMap insertKey !mName !lexicalTokenListMap] ;
  end foreach ;
#--------------------------------------- Build Message map
  foreach [lexiqueComponentRoot mLexicalMessageDeclarationList] do
    [!?lexiqueAnalysisContext.mLexicalMessageMap insertKey !mMessageName !mMessageValue !false] ;
  end foreach ;
#--------------------------------------- Check rules
  foreach [lexiqueComponentRoot mLexicalRuleList] do
    [mLexicalRule checkLexicalRule !?lexiqueAnalysisContext] ;
  end foreach ;
#--------------------------------------- Warn for unused messages
  foreach [lexiqueAnalysisContext mLexicalMessageMap] do
    if not messageIsUsed then
      warning key:"unused message" ;
    end if ;
  end foreach ;

end routine ;

#---------------------------------------------------------------------------*

end semantics ;