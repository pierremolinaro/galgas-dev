#---------------------------------------------------------------------------*
#                                                                           *
#  'lexique' component metamodel                                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics lexiqueCompilation :
import "lexiqueGeneration.gSemantics" ;
import "lexiqueCocoaGeneration.gSemantics" ;
import "allASTTypes.gSemantics" ;
import "lexiqueSemantics.gSemantics" ;

import semantics allASTTypes in "allASTTypes.gSemantics" ;
import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
import semantics lexiqueGeneration in "lexiqueGeneration.gSemantics" ;
import semantics lexiqueCocoaGeneration in "lexiqueCocoaGeneration.gSemantics" ;
import option galgas_cli_options in "galgas_cli_options.gOption" ;
import grammar lexiqueLL1grammar in "lexiqueLL1grammar.gGrammar" ;
import "lexiqueLL1grammar.gGrammar" ;
import "galgas_cli_options.gOption" ;

#---------------------------------------------------------------------------*
#                     checkLexicalDefaultAction                             *
#---------------------------------------------------------------------------*

abstract method @lexicalSendDefaultActionAST checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalSendTerminalByDefaultAST checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [[ioLexiqueAnalysisContext mTerminalMap] searchKey !mDefaultSentTerminal ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalErrorByDefaultAST checkLexicalDefaultAction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  with !?ioLexiqueAnalysisContext->mLexicalMessageMap searchKey !mDefaultErrorMessageName prefixedby xyz_ do
    xyz_mMessageIsUsed := true ;
  end with ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalExpression                              *
#---------------------------------------------------------------------------*

abstract method @lexicalExpressionAST checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalOrExpressionAST checkLexicalExpression
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [mLeftOperand checkLexicalExpression !? ioLexiqueAnalysisContext] ;
  [mRightOperand checkLexicalExpression !? ioLexiqueAnalysisContext] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterMatchAST checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterSetMatchAST checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterIntervalMatchAST checkLexicalExpression
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalStringMatchAST checkLexicalExpression
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  ioLexiqueAnalysisContext->mUnicodeStringToGenerate += ![mString string] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalStringNotMatchAST checkLexicalExpression
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  ioLexiqueAnalysisContext->mUnicodeStringToGenerate += ![mString string] ;
  with !?ioLexiqueAnalysisContext->mLexicalMessageMap searchKey !mErrorMessage do
    mMessageIsUsed := true ;
  end with ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalFunctionCallArgument                    *
#---------------------------------------------------------------------------*

abstract method @lexicalRoutineOrFunctionFormalInputArgumentAST checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum unused inLexicalRoutineFormalArgumentType
;

#---------------------------------------------------------------------------*

override method @lexicalAttributeInputArgumentAST checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalTypeEnum attributeLexicalType ;
  [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey
    !mAttributeName
    ?attributeLexicalType
  ] ;
#--- Type check
  if attributeLexicalType != inLexicalRoutineFormalArgumentType then
    error mAttributeName:"type error, attribute type is @"
    . [attributeLexicalType lexicalTypeBaseName]
    . " type, but lexical routine prototype requires @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterInputArgumentAST checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_char] != inLexicalRoutineFormalArgumentType then
    error mCharacter:"type error, a literal character has @char"
    . " type, but lexical routine prototype requires an @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalUnsignedInputArgumentAST checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_uint] != inLexicalRoutineFormalArgumentType then
    error mUnsigned:"type error, a literal character has @uint"
    . " type, but lexical routine prototype requires an @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCurrentCharacterInputArgumentAST checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_char] != inLexicalRoutineFormalArgumentType then
    error mLocation:"type error, current character value has @char"
    . " type, but lexical routine prototype requires an @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalFunctionInputArgumentAST checkLexicalFunctionCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalFunctionFormalArgumentList lexicalFormalTypeList ;
  @lexicalTypeEnum returnedLexicalFormalType ;
  @string replacementFunctionName ;
  [[ioLexiqueAnalysisContext mLexicalFunctionMap] searchKey
    !mFunctionName
    ?lexicalFormalTypeList
    ?returnedLexicalFormalType
    ?replacementFunctionName
    ?*
  ] ;
#--- Obsolete function ?
  if replacementFunctionName != "" then
    warning mFunctionName:"obsolete lexical function, replaced by '" . replacementFunctionName . "'" ;
  end if ;
#--- Returned type check
  if returnedLexicalFormalType != inLexicalRoutineFormalArgumentType then
    error mFunctionName:"type error, the function returns an @"
    . [returnedLexicalFormalType lexicalTypeBaseName]
    . " value, but lexical routine prototype requires an @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " value" ;
  end if ;
#--- Check actual argument count
  if [lexicalFormalTypeList length] != [mFunctionActualArgumentList length] then
    error mFunctionName: "this lexical function names "
    . [[mFunctionActualArgumentList length] string]
    . " actual argument(s), but the prototype requires "
    . [[lexicalFormalTypeList length] string] . " actual argument(s)" ;
  end if ;
#--- Check actual argument against formal parameters
  foreach lexicalFormalTypeList, mFunctionActualArgumentList do
    [mLexicalActualInputArgument checkLexicalFunctionCallArgument
      !?ioLexiqueAnalysisContext
      !mLexicalType
    ] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalRoutineCallArgument                     *
#---------------------------------------------------------------------------*

abstract method @lexicalRoutineOrFunctionFormalInputArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum unused inLexicalRoutineFormalArgumentType
;

#---------------------------------------------------------------------------*

override method @lexicalAttributeInputArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalTypeEnum attributeLexicalType ;
  [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey
    !mAttributeName
    ?attributeLexicalType
  ] ;
#--- Type check
  if attributeLexicalType != inLexicalRoutineFormalArgumentType then
    error mAttributeName:"type error, attribute type is @"
    . [attributeLexicalType lexicalTypeBaseName]
    . " type, but lexical routine prototype requires @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCharacterInputArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_char] != inLexicalRoutineFormalArgumentType then
    error mCharacter:"type error, a literal character has @char"
    . " type, but lexical routine prototype requires an @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalUnsignedInputArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_uint] != inLexicalRoutineFormalArgumentType then
    error mUnsigned:"type error, a literal unsigned value has @uint"
    . " type, but lexical routine prototype requires an @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalCurrentCharacterInputArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Type check
  if [@lexicalTypeEnum lexicalType_char] != inLexicalRoutineFormalArgumentType then
    error mLocation:"type error, current character value has @char"
    . " type, but lexical routine prototype requires an @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type value" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalFunctionInputArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalFunctionFormalArgumentList lexicalFormalTypeList ;
  @lexicalTypeEnum returnedLexicalFormalType ;
  @string replacementFunctionName ;
  [[ioLexiqueAnalysisContext mLexicalFunctionMap] searchKey
    !mFunctionName
    ?lexicalFormalTypeList
    ?returnedLexicalFormalType
    ?replacementFunctionName
    ?*
  ] ;
#--- Obsolete function ?
  if replacementFunctionName != "" then
    warning mFunctionName:"obsolete lexical function, replaced by '" . replacementFunctionName . "'" ;
  end if ;
#--- Returned type check
  if returnedLexicalFormalType != inLexicalRoutineFormalArgumentType then
    error mFunctionName:"type error, the function returns an @"
    . [returnedLexicalFormalType lexicalTypeBaseName]
    . " value, but lexical routine prototype requires an @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " value" ;
  end if ;
#--- Check actual argument count
  if [lexicalFormalTypeList length] != [mFunctionActualArgumentList length] then
    error mFunctionName: "this lexical function names "
    . [[mFunctionActualArgumentList length] string]
    . " actual argument(s), but the prototype requires "
    . [[lexicalFormalTypeList length] string] . " actual argument(s)" ;
  end if ;
#--- Check actual argument against formal parameters
  foreach lexicalFormalTypeList, mFunctionActualArgumentList do
    [mLexicalActualInputArgument checkLexicalFunctionCallArgument
      !?ioLexiqueAnalysisContext
      !mLexicalType
    ] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalRoutineCallArgument                     *
#---------------------------------------------------------------------------*

abstract method @abstractLexicalRoutineActualArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?@lexicalArgumentModeAST unused inLexicalRoutineFormalArgumentMode
  ?@lexicalTypeEnum unused inLexicalRoutineFormalArgumentType
;

#---------------------------------------------------------------------------*

override method @lexicalAttributeInputOutputArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalArgumentModeAST inLexicalRoutineFormalArgumentMode
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  @lexicalTypeEnum attributeLexicalType ;
  [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey
    !mAttributeName
    ?attributeLexicalType
  ] ;
#--- Type check
  if attributeLexicalType != inLexicalRoutineFormalArgumentType then
    error mAttributeName:"type error, attribute type is @"
    . [attributeLexicalType lexicalTypeBaseName]
    . " type, but lexical routine prototype requires @"
    . [inLexicalRoutineFormalArgumentType lexicalTypeBaseName]
    . " type" ;
  end if ;
#--- Passing mode check
  if inLexicalRoutineFormalArgumentMode != [@lexicalArgumentModeAST lexicalInputOutputMode] then
    error mActualPassingModeLocation:"the output mode (!) is required here, not an output/input mode" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalFormalInputArgumentAST checkLexicalRoutineCallArgument
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?@lexicalArgumentModeAST inLexicalRoutineFormalArgumentMode
  ?@lexicalTypeEnum inLexicalRoutineFormalArgumentType
:
#--- Check attribute definition
  [mRoutineOrFunctionFormalInputArgument checkLexicalRoutineCallArgument
    !?ioLexiqueAnalysisContext
    !inLexicalRoutineFormalArgumentType
  ] ;
#--- Passing mode check
  if inLexicalRoutineFormalArgumentMode != [@lexicalArgumentModeAST lexicalInputMode] then
    error mActualPassingModeLocation:"the output/input mode (!?) is required here, not an input mode" ;
  end if ;
end method ;

#---------------------------------------------------------------------------*
#                       checkLexicalInstruction                             *
#---------------------------------------------------------------------------*

abstract method @lexicalInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?!@lexicalTagMap unused ioTagMap
;

#---------------------------------------------------------------------------*

override method @lexicalStructuredSendInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?!@lexicalTagMap unused ioTagMap
:
  foreach mLexicalSendSearchList do
    with !?ioLexiqueAnalysisContext->mLexicalTokenListMap searchKey !mSearchListName do
      mShouldBeGenerated := true ;
    end with ;
    [[ioLexiqueAnalysisContext mLexicalAttributeMap] searchKey !mAttributeName ?*] ;
  end foreach ;
  [mLexicalSendDefaultAction checkLexicalDefaultAction !?ioLexiqueAnalysisContext] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalSimpleSendInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?!@lexicalTagMap unused ioTagMap
:
  [[ioLexiqueAnalysisContext mTerminalMap] searchKey !mSentTerminal ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalRepeatInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?!@lexicalTagMap ioTagMap
:
  foreach mLexicalWhileBranchList do
    [mWhileExpression checkLexicalExpression !?ioLexiqueAnalysisContext] ;
    @lexicalTagMap tagMap [mapWithMapToOverride !ioTagMap] ;
    foreach mWhileInstructionList do
      [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext !?tagMap] ;
    end foreach ;
  end foreach ;
  @lexicalTagMap tagMap [mapWithMapToOverride !ioTagMap] ;
  foreach mRepeatedInstructionList do
    [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext !?tagMap] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalSelectInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?!@lexicalTagMap  ioTagMap
:
  foreach mLexicalSelectBranchList do
    [mSelectExpression checkLexicalExpression !?ioLexiqueAnalysisContext] ;
    @lexicalTagMap tagMap [mapWithMapToOverride !ioTagMap] ;
    foreach mSelectInstructionList do
      [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext !?tagMap] ;
    end foreach ;
  end foreach ;
  @lexicalTagMap tagMap [mapWithMapToOverride !ioTagMap] ;
  foreach mDefaultInstructionList do
    [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext !?tagMap] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalRoutineInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?!@lexicalTagMap unused ioTagMap
:
  @lexicalRoutineFormalArgumentList lexicalRoutineFormalArgumentList ;
  @stringlist routineErrorMessageList ;
  @string replacementRoutineName ;
  [[ioLexiqueAnalysisContext mLexicalRoutineMessageMap] searchKey
    !mRoutineName
    ?lexicalRoutineFormalArgumentList
    ?routineErrorMessageList
    ?replacementRoutineName
    ?*
  ] ;
#--- Obsolete routine ?
  if replacementRoutineName != "" then
    warning mRoutineName:"obsolete lexical routine, replaced by '" . replacementRoutineName . "'" ;
  end if ;
#--- Check actual argument count
  if [lexicalRoutineFormalArgumentList length] != [mActualArgumentList length] then
    error mRoutineName: "this lexical routine call names "
    . [[mActualArgumentList length] string]
    . " actual argument(s), but the lexical routine prototype requires "
    . [[lexicalRoutineFormalArgumentList length] string] . " actual argument(s)" ;
  end if ;
#--- Check actual argument against formal parameters
  foreach lexicalRoutineFormalArgumentList, mActualArgumentList do
    [mLexicalRoutineActualArgument checkLexicalRoutineCallArgument
      !?ioLexiqueAnalysisContext
      !mLexicalFormalArgumentMode
      !mLexicalFormalArgumentType
    ] ;
  end foreach ;
#--- Check error message count
  if [routineErrorMessageList length] != [mErrorMessageList length] then
    error mRoutineName: "this lexical routine call names "
    . [[mErrorMessageList length] string]
    . " error message(s), but the lexical routine prototype requires "
    . [[routineErrorMessageList length] string] . " error message(s)" ;
  end if ;
#--- Check error messages are actually defined
  foreach mErrorMessageList do
    with !?ioLexiqueAnalysisContext->mLexicalMessageMap searchKey !mValue prefixedby xyz_ do
      xyz_mMessageIsUsed := true ;
    end with ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalLogInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?!@lexicalTagMap unused ioTagMap
:
end method ;

#---------------------------------------------------------------------------*

override method @lexicalRewindInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?!@lexicalTagMap ioTagMap
:
  [ioTagMap searchKey !mLexicalTagName] ;
  [[ioLexiqueAnalysisContext mTerminalMap] searchKey !mTerminalName ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalDropInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext  ioLexiqueAnalysisContext
  ?!@lexicalTagMap unused ioTagMap
:
  [[ioLexiqueAnalysisContext mTerminalMap] searchKey !mTerminalName ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalTagInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext unused ioLexiqueAnalysisContext
  ?!@lexicalTagMap ioTagMap
:
  [!?ioTagMap insertKey !mLexicalTagName] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalErrorInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?!@lexicalTagMap unused ioTagMap
:
  with !?ioLexiqueAnalysisContext->mLexicalMessageMap searchKey !mErrorMessageName do
    mMessageIsUsed := true ;
  end with ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalWarningInstructionAST checkLexicalInstruction
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
  ?!@lexicalTagMap unused ioTagMap
:
  with !?ioLexiqueAnalysisContext->mLexicalMessageMap searchKey !mWarningMessageName do
    mMessageIsUsed := true ;
  end with ;
end method ;

#---------------------------------------------------------------------------*
#                         compileLexiqueComponent                           *
#---------------------------------------------------------------------------*

abstract method @abstractLexicalRuleAST checkLexicalRule
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
;

#---------------------------------------------------------------------------*

override method @lexicalImplicitRuleAST checkLexicalRule
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [[ioLexiqueAnalysisContext mLexicalTokenListMap] searchKey !mListName ?* ?* ?*] ;
end method ;

#---------------------------------------------------------------------------*

override method @lexicalExplicitRuleAST checkLexicalRule
  ?!@lexiqueAnalysisContext ioLexiqueAnalysisContext
:
  [mLexicalRuleExpression checkLexicalExpression !?ioLexiqueAnalysisContext] ;
  @lexicalTagMap tagMap [emptyMap] ;
  foreach mInstructionList do
    [mInstruction checkLexicalInstruction !?ioLexiqueAnalysisContext !?tagMap] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#         G E N E R A T I O N    T E M P L A T E S                          *
#---------------------------------------------------------------------------*

filewrapper lexiqueGenerationTemplates in "../generation_templates/lexique_generation" {
} {
  template oldHeaderZone2 "lexique_header_template_zone_2.old.h.gTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@lexiqueComponentAST LEXIQUE_COMPONENT_ROOT
  ;

  template newHeaderZone2 "lexique_header_template_zone_2.new.h.gTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@lexiqueComponentAST LEXIQUE_COMPONENT_ROOT
  ;

  template oldHeaderZone3 "lexique_header_template_zone_3.old.h.gTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexicalListDeclarationListAST DELIMITOR_LIST_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
  ;

  template newHeaderZone3 "lexique_header_template_zone_3.new.h.gTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexicalListDeclarationListAST DELIMITOR_LIST_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
  ;

  template oldImplementationZone2 "lexique_implementation.old.cpp.gTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap LEXICAL_MESSAGE_MAP
    ?@terminalList TERMINAL_LIST
    ?@lexicalExplicitTokenListMapMap LEXICAL_TOKEN_LIST_MAP
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleListAST LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@lexiqueComponentAST LEXIQUE_COMPONENT_ROOT
  ;

  template newImplementationZone2 "lexique_implementation.new.cpp.gTemplate"
    ?@string LEXIQUE_IDENTIFIER
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap LEXICAL_MESSAGE_MAP
    ?@terminalList TERMINAL_LIST
    ?@lexicalExplicitTokenListMapMap LEXICAL_TOKEN_LIST_MAP
    ?@stringset STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleListAST LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@lexiqueComponentAST LEXIQUE_COMPONENT_ROOT
  ;

  template cocoaHeaderZone2 "lexique_cocoa_header_template_zone_2.h.gTemplate"
    ?@string LEXIQUE_CLASS_NAME
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
  ;
  template cocoaHeaderZone3 "lexique_cocoa_header_template_zone_3.h.gTemplate"
    ?@string unused LEXIQUE_CLASS_NAME
    ?@lexiqueAnalysisContext unused LEXIQUE_ANALYSIS_CONTEXT
  ;
  template cocoaImplementationZone2 "lexique_cocoa_implementation.m.gTemplate"
    ?@string LEXIQUE_CLASS_NAME
    ?@lexicalAttributeMap LEXICAL_ATTRIBUTE_MAP
    ?@lexicalMessageMap unused LEXICAL_MESSAGE_MAP
    ?@terminalList unused TERMINAL_LIST
    ?@stringset unused STRINGS_IN_EXPLICIT_RULES
    ?@lexicalRuleListAST LEXICAL_RULE_LIST
    ?@lexiqueAnalysisContext LEXIQUE_ANALYSIS_CONTEXT
    ?@lexiqueComponentAST LEXIQUE_COMPONENT_ROOT
  ;
}

#---------------------------------------------------------------------------*
#                         parseLexiqueComponent                             *
#---------------------------------------------------------------------------*

routine parseLexiqueComponent
  ??@lstring inSourceFile
  ?!@parsedComponentStruct ioParsedComponentStruct
  !@lexiqueComponentAST outLexiqueComponentRoot
:
  @lstring key [new ![[[inSourceFile string] lastPathComponent] stringByDeletingPathExtension] ![inSourceFile location]] ;
  if [[ioParsedComponentStruct mParsedLexiqueComponentMap] hasKey ! [key string]] then
    [[ioParsedComponentStruct mParsedLexiqueComponentMap] searchKey !key ?outLexiqueComponentRoot] ;
  else
    grammar lexiqueLL1grammar in inSourceFile ?outLexiqueComponentRoot ;
    [!?ioParsedComponentStruct->mParsedLexiqueComponentMap insertKey !key !outLexiqueComponentRoot] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#          B U I L D    L E X I C A L    T Y P E    M A P                   *
#---------------------------------------------------------------------------*

once buildLexicalTypeMap
  ->@lexicalTypeMap outLexicalTypeMap
:
  outLexicalTypeMap := [@lexicalTypeMap emptyMap] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"string" !here] ![@lexicalTypeEnum lexicalType_string]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"char"   !here] ![@lexicalTypeEnum lexicalType_char]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"uint"   !here] ![@lexicalTypeEnum lexicalType_uint]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"uint64" !here] ![@lexicalTypeEnum lexicalType_uint64]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"sint"   !here] ![@lexicalTypeEnum lexicalType_sint]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"sint64" !here] ![@lexicalTypeEnum lexicalType_sint64]] ;
  [!?outLexicalTypeMap insertKey ![@lstring new !"double" !here] ![@lexicalTypeEnum lexicalType_double]] ;
end once ;

#---------------------------------------------------------------------------*
#   B U I L D    L E X I C A L    A T T R I B U T E    M A P                *
#---------------------------------------------------------------------------*

routine buildLexicalAttributeMap
  ??@lexicalTypeMap inLexicalTypeMap
  ??@lexicalAttributeListAST inLexicalAttributeList
  ?!@lexicalAttributeMap ioLexicalAttributeMap
:
  foreach inLexicalAttributeList do
    if [inLexicalTypeMap hasKey ![mTypeName string]] then
      @lexicalTypeEnum lexicalType ;
      [inLexicalTypeMap searchKey !mTypeName ?lexicalType] ;
      [!?ioLexicalAttributeMap insertKey !mName !lexicalType] ;
    else
      @string m := "" ;
      m .= "the @" . mTypeName . " type is not a valid lexical attribute type; are allowed:" ;
      @bool firstLoop := true ;
      foreach inLexicalTypeMap do
        m .= " @" . lkey ;
      between
        m .= "," ;
      end foreach ;
      error mTypeName: m ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                         compileLexiqueComponent                           *
#---------------------------------------------------------------------------*

routine compileLexiqueComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ??@bool inGenerateGALGAS1Code
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  @lexiqueComponentAST lexiqueComponentRoot ;
  parseLexiqueComponent
    !inSourceFile
    !?ioParsedComponentStruct
    ?lexiqueComponentRoot
  ;
#--------------------------------------- Check component name
  @lstring componentName := [lexiqueComponentRoot mLexiqueComponentName] ;
  @string basename := [[[inSourceFile string] lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--------------------------------------- Lexical attribute type name map
  const @lexicalTypeMap lexicalTypeMap := buildLexicalTypeMap [] ;
#--------------------------------------- Build lexical routine map
  @lexicalRoutineMap lexicalRoutineMap ;
  buildLexicalRoutineMap ?lexicalRoutineMap ;
#--------------------------------------- Add extern routines
  foreach [lexiqueComponentRoot mExternRoutineList] do
    @lexicalRoutineFormalArgumentList lexicalRoutineFormalArgumentList [emptyList] ;
    foreach mLexicalRoutineFormalArgumentList do
      @lexicalTypeEnum lexicalFormalArgumentType ;
      [lexicalTypeMap searchKey !mLexicalTypeName ?lexicalFormalArgumentType] ;
      lexicalRoutineFormalArgumentList += !mPassingMode !lexicalFormalArgumentType ![mFormalArgumentName string] ;
    end foreach ;
    [!?lexicalRoutineMap insertKey !mRoutineName !lexicalRoutineFormalArgumentList !mErrorMessageList !"" !true] ;
  end foreach ;
#--------------------------------------- Build lexical function map
  @lexicalFunctionMap lexicalFunctionMap ;
  buildLexicalFunctionMap ?lexicalFunctionMap ;
#--------------------------------------- Add extern functions
  foreach [lexiqueComponentRoot mExternFunctionList] do
    @lexicalFunctionFormalArgumentList lexicalFunctionFormalArgumentList [emptyList] ;
    foreach mLexicalFunctionFormalArgumentList do
      @lexicalTypeEnum lexicalFormalArgumentType ;
      [lexicalTypeMap searchKey !mLexicalTypeName ?lexicalFormalArgumentType] ;
      lexicalFunctionFormalArgumentList += !lexicalFormalArgumentType ![mFormalArgumentName string] ;
    end foreach ;
    @lexicalTypeEnum returnedArgumentType ;
    [lexicalTypeMap searchKey !mReturnedTypeName ? returnedArgumentType] ;
    [!?lexicalFunctionMap insertKey !mFunctionName !lexicalFunctionFormalArgumentList !returnedArgumentType !"" !true] ;
  end foreach ;
#---------------------------------------
  @lexiqueAnalysisContext lexiqueAnalysisContext [new
    !lexicalRoutineMap
    !lexicalFunctionMap
    ![@lexicalMessageMap emptyMap]
    ![@terminalMap emptyMap]
    ![@terminalList emptyList]
    ![@lexicalAttributeMap emptyMap]
    ![@lexicalExplicitTokenListMapMap emptyMap]
    ![@stringset emptySet]
    ![@templateDelimitorList emptyList]
    ![@styleMap emptyMap]
  ] ;
#--------------------------------------- Build style map
  @uint styleIndex := 1 ;
  foreach [lexiqueComponentRoot mLexicalStyleList] do
    [!?lexiqueAnalysisContext->mStyleMap insertKey !mName !mComment !styleIndex] ;
    styleIndex ++ ;
  end foreach ;
#--------------------------------------- Build lexical attribute map
  buildLexicalAttributeMap
   !lexicalTypeMap
   ![lexiqueComponentRoot mLexicalAttributeList]
   !?lexiqueAnalysisContext->mLexicalAttributeMap
  ;
#--------------------------------------- Build terminal map
  foreach [lexiqueComponentRoot mTerminalDeclarationList] do
    @uint terminalStyleIndex := 0 ;
    if [[mStyle string] length] > 0 then
      [[lexiqueAnalysisContext mStyleMap] searchKey !mStyle ?* ?terminalStyleIndex] ;
    end if ;
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType ;
      [lexiqueAnalysisContext->mLexicalAttributeMap searchKey !mValue ?attributeLexicalType] ;
      argumentTypeList += ![mValue string] !attributeLexicalType ;
    end foreach ;
    [!?lexiqueAnalysisContext->mTerminalMap insertKey !mName !argumentTypeList] ;
    @bool isEndOfTemplateMark := false ;
    foreach mOptionList do
      if [mValue string] != "templateEndMark" then
        error mValue:"only the 'templateEndMark' feature is allowed here" ;
      elsif isEndOfTemplateMark then
        error mValue:"the 'templateEndMark' feature is already set" ;
      else
        isEndOfTemplateMark := true ;
      end if ;
    end foreach ;
    lexiqueAnalysisContext->mTerminalList +=
      !mName
      !argumentTypeList
      ![mSyntaxErrorMessage string]
      !isEndOfTemplateMark
      !terminalStyleIndex
    ;
  end foreach ;
  foreach [lexiqueComponentRoot mLexicalListDeclarationList] do
    @uint terminalStyleIndex := 0 ;
    if [[mStyle string] length] > 0 then
      [[lexiqueAnalysisContext mStyleMap] searchKey !mStyle ?* ?terminalStyleIndex] ;
    end if ;
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType ;
      [lexiqueAnalysisContext->mLexicalAttributeMap searchKey !mValue ?attributeLexicalType] ;
      argumentTypeList += ![mValue string] !attributeLexicalType ;
    end foreach ;
    @lexicalExplicitTokenListMap lexicalTokenListMap [emptyMap] ;
    @tokenSortedlist tokenSortedlist [emptySortedList] ;
    foreach mEntryList do
      @string syntaxErrorMessage := [[mSyntaxErrorMessage string] stringByReplacingStringByString !"%K" ![mTerminalSpelling string]] ;
      @bool isEndOfTemplateMark := false ;
      foreach mFeatureList do
        if [mValue string] != "templateEndMark" then
          error mValue:"only the 'templateEndMark' feature is allowed here" ;
        elsif isEndOfTemplateMark then
          error mValue:"the 'templateEndMark' feature is already set" ;
        else
          isEndOfTemplateMark := true ;
        end if ;
      end foreach ;
      lexiqueAnalysisContext->mTerminalList +=
        !mTerminalSpelling
        !argumentTypeList
        !syntaxErrorMessage
        !isEndOfTemplateMark
        !terminalStyleIndex
      ;
      [!?lexiqueAnalysisContext->mTerminalMap insertKey !mTerminalSpelling !argumentTypeList] ;
      [!?lexicalTokenListMap insertKey !mEntrySpelling !mTerminalSpelling !mFeatureList] ;
      tokenSortedlist += ![[mEntrySpelling string] length] ![mEntrySpelling string] ![mTerminalSpelling string] ;
      lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mEntrySpelling string] ;
    end foreach ;
    [!?lexiqueAnalysisContext->mLexicalTokenListMap insertKey !mName !lexicalTokenListMap !tokenSortedlist !false] ;
  end foreach ;
#--------------------------------------- Build Message map
  foreach [lexiqueComponentRoot mLexicalMessageDeclarationList] do
    [!?lexiqueAnalysisContext->mLexicalMessageMap insertKey !mMessageName !mMessageValue !false] ;
  end foreach ;
#--------------------------------------- Check rules
  foreach [lexiqueComponentRoot mLexicalRuleList] do
    [mLexicalRule checkLexicalRule !?lexiqueAnalysisContext] ;
  end foreach ;
#--------------------------------------- Warn for unused messages
  foreach [lexiqueAnalysisContext mLexicalMessageMap] do
    if not mMessageIsUsed then
      warning lkey:"unused message" ;
    end if ;
  end foreach ;
#--------------------------------------- Template delimiters
  foreach [lexiqueComponentRoot mTemplateDelimitorList] do
   lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mStartString string] ;
   lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mEndString string] ;
   @bool preservesStartDelimiter := false ;
   foreach mOptionList do
     if [mValue string] != "preserved" then
       error mValue:"only the 'preserved' feature is allowed here" ;
     elsif preservesStartDelimiter then
       error mValue:"the 'preserved' feature is already set" ;
     else
       preservesStartDelimiter := true ;
     end if ;
   end foreach ;
   lexiqueAnalysisContext->mTemplateDelimitorList += !mStartString !mEndString !preservesStartDelimiter ;
  end foreach ;
#--------------------------------------- Template replacements
  foreach [lexiqueComponentRoot mTemplateReplacementList] do
   lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mMatchString string] ;
   lexiqueAnalysisContext->mUnicodeStringToGenerate += ![mReplacementString string] ;
   # § TODO Check replacement function
  end foreach ;
#--------------------------------------- Build Header file
  @string lexiqueClassName := [componentName string] ;
#--- Generate header file
  if [@uint errorCount] == 0 then
    if not inGenerateGALGAS1Code then
      [@string generateFile
        !inOutputDirectory
        !lexiqueClassName . ".h"
        !"//"
        !"\n\n" # Defaut user zone1
        ![filewrapper lexiqueGenerationTemplates.newHeaderZone2
           ![lexiqueClassName identifierRepresentation]
           !lexiqueAnalysisContext
           !lexiqueComponentRoot
         ]
        !"\n\n" # Defaut user zone2
        ![filewrapper lexiqueGenerationTemplates.newHeaderZone3
           ![lexiqueClassName identifierRepresentation]
           ![lexiqueComponentRoot mLexicalListDeclarationList]
           !lexiqueAnalysisContext
         ]
      ] ;
    else
      [@string generateFile
        !inOutputDirectory
        !lexiqueClassName . ".h"
        !"//"
        !"\n\n" # Defaut user zone1
        ![filewrapper lexiqueGenerationTemplates.oldHeaderZone2
           ![lexiqueClassName identifierRepresentation]
           !lexiqueAnalysisContext
           !lexiqueComponentRoot
         ]
        !"\n\n" # Defaut user zone2
        ![filewrapper lexiqueGenerationTemplates.oldHeaderZone3
           ![lexiqueClassName identifierRepresentation]
           ![lexiqueComponentRoot mLexicalListDeclarationList]
           !lexiqueAnalysisContext
         ]
      ] ;
    end if ;
  end if ;
#--- Generate implementation file
  if [@uint errorCount] == 0 then
    if not inGenerateGALGAS1Code then
      [@string generateFile
        !inOutputDirectory
        !lexiqueClassName . ".cpp"
        !"//"
        !"\n\n" # Defaut user zone1
        ![filewrapper lexiqueGenerationTemplates.newImplementationZone2
           ![lexiqueClassName identifierRepresentation]
           ![lexiqueAnalysisContext mLexicalAttributeMap]
           ![lexiqueAnalysisContext mLexicalMessageMap]
           ![lexiqueAnalysisContext mTerminalList]
           ![lexiqueAnalysisContext mLexicalTokenListMap]
           ![lexiqueAnalysisContext mUnicodeStringToGenerate]
           ![lexiqueComponentRoot mLexicalRuleList]
           !lexiqueAnalysisContext
           !lexiqueComponentRoot
         ]
        !"\n\n" # Defaut user zone2
        !"\n\n" # Zone 3
      ] ;
    else
      [@string generateFile
        !inOutputDirectory
        !lexiqueClassName . ".cpp"
        !"//"
        !"\n\n" # Defaut user zone1
        ![filewrapper lexiqueGenerationTemplates.oldImplementationZone2
           ![lexiqueClassName identifierRepresentation]
           ![lexiqueAnalysisContext mLexicalAttributeMap]
           ![lexiqueAnalysisContext mLexicalMessageMap]
           ![lexiqueAnalysisContext mTerminalList]
           ![lexiqueAnalysisContext mLexicalTokenListMap]
           ![lexiqueAnalysisContext mUnicodeStringToGenerate]
           ![lexiqueComponentRoot mLexicalRuleList]
           !lexiqueAnalysisContext
           !lexiqueComponentRoot
         ]
        !"\n\n" # Defaut user zone2
        !"\n\n" # Zone 3
      ] ;
    end if ;
  end if ;
#--- Generate cocoa header file
  if [@uint errorCount] == 0 then
    [@string generateFile
      !inOutputDirectory
      !lexiqueClassName . "-cocoa.h"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper lexiqueGenerationTemplates.cocoaHeaderZone2
         !lexiqueClassName
         !lexiqueAnalysisContext
       ]
      !"\n\n" # Defaut user zone2
      ![filewrapper lexiqueGenerationTemplates.cocoaHeaderZone3
         !lexiqueClassName
         !lexiqueAnalysisContext
       ]
    ] ;
  end if ;
#--- Generate Cocoa implementation file
  if [@uint errorCount] == 0 then
    [@string generateFile
      !inOutputDirectory
      !lexiqueClassName . "-cocoa.m"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper lexiqueGenerationTemplates.cocoaImplementationZone2
         !lexiqueClassName
         ![lexiqueAnalysisContext mLexicalAttributeMap]
         ![lexiqueAnalysisContext mLexicalMessageMap]
         ![lexiqueAnalysisContext mTerminalList]
         ![lexiqueAnalysisContext mUnicodeStringToGenerate]
         ![lexiqueComponentRoot mLexicalRuleList]
         !lexiqueAnalysisContext
         !lexiqueComponentRoot
       ]
      !"\n\n" # Defaut user zone2
      !"\n\n" # Zone 3
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;