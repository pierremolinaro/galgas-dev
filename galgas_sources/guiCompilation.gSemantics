#---------------------------------------------------------------------------*
#                                                                           *
#  'gui' component compilation                                              *
#                                                                           *
#  Copyright (C) 2008, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics guiCompilation :

import "allASTTypes.gSemantics" ;
import "lexiqueCompilation.gSemantics" ;
import "optionCompilation.gSemantics" ;
import "guiGrammar.gGrammar" ;

#---------------------------------------------------------------------------*

list @guiCommandLineOptionList {
  @string mOptionComponent ;
  @string mOptionIdentifier ;
  @char mOptionChar ;
  @string mOptionString ;
  @string mComment ;
}

#------------------------------------------------------------------*

map @extensionMap {
  @string mLexiqueName ;
  insert insertKey error message "the '%K' extension is already declared in %L" ;
}

#---------------------------------------------------------------------------*

list @nibAndClassList {
  @string mNibName ;
  @string mClassName ;
}

#---------------------------------------------------------------------------*

list @textMacroList {
  @string mKey ;
  @string mContents ;
}

#---------------------------------------------------------------------------*

list @importedLexiqueList {
  @string mLexiqueClassName ;
  @string mBlockComment ;
  @string mTitle ;
  @textMacroList mTextMacroList ;
  @guiLabelListAST mLabels ;
}

#---------------------------------------------------------------------------*

struct @guiAnalysisContext {
  @stringlist mImportedOptionComponentList ;
  @guiCommandLineOptionList mBoolOptionList ;
  @guiCommandLineOptionList mUIntOptionList ;
  @guiCommandLineOptionList mStringOptionList ;
  @nibAndClassList mNibAndClassList ;
  @extensionMap mExtensionMap ;
  @importedLexiqueList mWithLexiqueList ;
}

#---------------------------------------------------------------------------*
#         G E N E R A T I O N    T E M P L A T E S                          *
#---------------------------------------------------------------------------*

local filewrapper guiGenerationTemplates in "../generation_templates/gui_generation" {
}{
}{
  template gui_implementation "gui-implementation.m.gTemplate"
    ?@guiAnalysisContext GUI_CONTEXT
  ;
}

#---------------------------------------------------------------------------*
#       C O M P I L E   G U I   C O M P O N E N T   F R O M   A S T         *
#---------------------------------------------------------------------------*

routine compileGuiComponentFromAST
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ??@guiComponentAST inGuiComponentRoot
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Check component name
  @lstring componentName := [inGuiComponentRoot mGUIName] ;
  @string basename := [[[inSourceFile string] lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ;
#--- 
  @guiAnalysisContext context [new
    ![@stringlist emptyList]
    ![@guiCommandLineOptionList emptyList] # Bool options
    ![@guiCommandLineOptionList emptyList] # UInt options
    ![@guiCommandLineOptionList emptyList] # string options
    ![@nibAndClassList emptyList]
    ![@extensionMap emptyMap]
    ![@importedLexiqueList emptyList]
  ] ;
#--- Check imported options components
  foreach [inGuiComponentRoot mImportedOptionList] do 
    if [[mValue string] pathExtension] != "gOption" then
      error mValue: "only an option component (path extension '.gOption') can be imported here" ;
    else
      parseOptionComponent
        ![@lstring new
          ![[mValue string] absolutePathFromPath ![[inSourceFile string] stringByDeletingLastPathComponent]]
          ![mValue location]
        ]
        !?ioParsedComponentStruct
        ?4*
      ;
      context->mImportedOptionComponentList += ![[[mValue string] lastPathComponent] stringByDeletingPathExtension] ;
    end if ;
  end foreach ;
#--- Nib and main classes
  foreach [inGuiComponentRoot mGlobalSimpleAttributeList] do
    if [mKey string] != "nibAndMainClass" then
      warning mKey:"the '" . mKey . "' key is invalid and has no effect" ;
    else
      @stringlist x := [[mValue string] componentsSeparatedByString !"."] ;
      if [x length] != 2 then
        error mValue:"the string string should conform to \"nib_name.nib_main_class\"" ;
      else
        context->mNibAndClassList +=
          ![x mValueAtIndex !0]
          ![x mValueAtIndex !1]
        ;
      end if ;
    end if ;
  end foreach ;
#--- 'with lexique' construct analysis
  foreach [inGuiComponentRoot mWithLexiqueList] do
  #--- Check lexique
    @lexiqueComponentAST lexiqueComponentRoot ;
    if [[mLexiqueFileName string] pathExtension] != "gLexique" then
      error mLexiqueFileName:"the file extension for a lexique component should be 'gLexique'" : lexiqueComponentRoot ;
    else
      @lstring lexiqueFullPathName [new
        ![[mLexiqueFileName string] absolutePathFromPath ![[inSourceFile string] stringByDeletingLastPathComponent]]
        ![mLexiqueFileName location]
      ] ;
      parseLexiqueComponent
        !lexiqueFullPathName
        !?ioParsedComponentStruct
        ?lexiqueComponentRoot
      ;
    end if ;
  #--- Build terminal symbol set
    @stringset terminalSymbolSet [emptySet] ;
    foreach [lexiqueComponentRoot mTerminalDeclarationList] do
      terminalSymbolSet += ![mName string] ;
    end foreach ;
    foreach [lexiqueComponentRoot mLexicalListDeclarationList] do
      foreach mEntryList do
        terminalSymbolSet += ![mTerminalSpelling string] ;
      end foreach ;
    end foreach ;
  #--- Check labels
    foreach mLabels do
      foreach mTerminalList do
        if not [terminalSymbolSet hasKey ![mValue string]] then
          error mValue: "the '$"
            . mValue
            . "$' terminal symbol is not declared by the '"
            . mLexiqueFileName
            . "' lexique"
          ;
        end if ;
      end foreach ;
    end foreach ;
  #--- Compound attributes
    @textMacroList textMacroList [emptyList] ;
    foreach mCompoundAttributes do
      if [mKey string] != "textMacro" then
        error mKey: "for a compound attribute, only the 'textMacro' key is valid" ;
      else
        textMacroList += ![mAttributeName string] ![mValue string] ;
      end if ;
    end foreach ;
  #--- Simple attributes
    @bool hasAssociatedExtension := false ;
    @bool hasTabViewTitle := false ;
    @bool hasBlockComment := false ;
    @string tabViewTitle := "" ;
    @string blockComment := "" ;
    foreach mSimpleAttributes do
      if [mKey string] == "fileExtension" then
        [!?context->mExtensionMap insertKey !mValue ![[[mLexiqueFileName string] lastPathComponent] stringByDeletingPathExtension]] ;
        hasAssociatedExtension := true ;
      elsif [mKey string] == "title" then
        if hasTabViewTitle then
          error mKey: "the '" . mKey . "' key should be defined once" ;
        end if ;
        hasTabViewTitle := true ;
        tabViewTitle := [mValue string] ;
      elsif [mKey string] == "blockComment" then
        if hasBlockComment then
          error mKey: "the '" . mKey . "' key should be defined once" ;
        end if ;
        hasBlockComment := true ;
        blockComment := [mValue string] ;
      else
        error mKey: "the '" . mKey . "' key is not valid (valid keys: 'blockComment,', 'fileExtension', 'title')" ;
      end if ;
    end foreach ;
  #--- has an extension ?
    if not hasAssociatedExtension then
      error mLexiqueFileName:"one or more file extensions should be associated with a lexique (fileExtension : \"...\")" ;
    end if ;
  #--- has title ?
    if not hasTabViewTitle then
      error mLexiqueFileName:"the 'title' key should be defined once (it is not defined)" ;
    end if ;
  #---
    context->mWithLexiqueList +=
      ![[[mLexiqueFileName string] lastPathComponent] stringByDeletingPathExtension]
      !blockComment
      !tabViewTitle
      !textMacroList
      !mLabels
    ;
  end foreach ;
#--- Generation
  if [@uint errorCount] == 0 then
    [@string generateFileWithPattern
      !inOutputDirectory
      ![componentName string] . ".m"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper guiGenerationTemplates.gui_implementation !context]
      !"\n\n" # Defaut user zone2
      !"\n\n" # Zone 3
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#C O M P I L E   G U I   C O M P O N E N T   F R O M   S O U R C E   F I L E*
#---------------------------------------------------------------------------*

routine compileGuiComponentFromSourceFile
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  @guiComponentAST guiComponentRoot ;
  grammar guiGrammar in inSourceFile ?guiComponentRoot ;
#---
  compileGuiComponentFromAST
    !inSourceFile
    !inOutputDirectory
    !guiComponentRoot
    !?ioParsedComponentStruct
  ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
