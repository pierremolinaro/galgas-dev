#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component semantics definition                          *
#                                                                           *
#  Copyright (C) 1997, ..., 2008 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semantics_semantics :

import semantics common_semantics in "common_semantics.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#   A LIST OF C++ NAMES                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeCplusPlusNameList {
  @typeCplusPlusName mCppName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   E X P R E S S I O N    A B S T R A C T    C L A S S                     *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeExpression {
}
 
#---------------------------------------------------------------------------*
#                                                                           *
#   C L A S S    M E S S A G E    M A P                                     *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeClassMessagesMap {
  @lstring mMessage ;
  insert insertKey error message "the message '%K' is already declared in %L" ;
  search searchKey error message "the message '%K' is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  S E M A N T I C S   T Y P E S   L I S T                                  *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeSemanticsTypesList {
  @AC_galgasType mType ;
  @lstring mGalgasVariableName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  V A R I A B L E S    M A P                                               *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeVariablesMap
  class cGalgasVariablesMap ;
#--- Inserting
  insert insertListOfEntitiesLocalVariable error message "the variable '%' is already declared" ;
  insert insertSingleEntityLocalVariable error message "the variable '%' is already declared" ;
  insert insertEntityAttributeLocalVariable error message "the variable '%' is already declared" ;
  insert insertInArgument error message "the variable '%' is already declared" ;
  insert insertUnusedInArgument error message "the variable '%' is already declared" ;
  insert insertConstInArgument error message "the variable '%' is already declared" ;
  insert insertUsedConstInArgument error message "the variable '%' is already declared" ;
  insert insertUsedConstInArgumentNoShadow error message "the variable '%' is already declared" ;
  insert insertUnusedConstInArgument error message "the variable '%' is already declared" ;
  insert insertLocalVariable error message "the variable '%' is already declared" ;
  insert insertOutArgument error message "the variable '%' is already declared" ;
  insert insertOutProperty error message "the variable '%' is already declared" ;
  insert insertInOutArgument error message "the variable '%' is already declared" ;
  insert insertUsedInOutArgument error message "the variable '%' is already declared" ;
  insert insertUnusedInOutArgument error message "the variable '%' is already declared" ;
#--- Searching
  search searchForReadOnlyAccess error message "the variable '%' cannot be accessed in read only mode" ;
  search searchForDestructiveReadAccess error message "the variable '%' cannot be accessed in destructive read mode" ;
  search searchForReadWriteAccess error message "the variable '%' cannot be accessed in read/write mode" ;
  search searchForWriteAccess error message "the variable '%' cannot be accessed in write mode" ;
#--- Blocks
  block  verifyVariableUsing : () : (?@location positionErreur) ;
  block  testBloc : () : () ;
  block  testPart : () : (?@location positionErreur) ;
  block  repeatBlock : () : () ;
  block  repeatPart : () : (?@location positionErreur) ;
#--- Attributes
  @AC_galgasType mArgumentType ;
  @typeCplusPlusName mCplusPlusName ;
}

#---------------------------------------------------------------------------*

list @L_assignedVariables  {
  @typeCplusPlusName aNomVariableCible ;
  @lstring aNomAttributSource ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                            class 'typeCible'                              *
#     Est utilise pour denoter le type d'une variable cible anonyme         *       
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeCible {
  abstract method verifierType
    ??@AC_galgasType typeArgumentFormel
    ?!@lstring nomAttributSource
    ?!@L_assignedVariables listeAffectations
    ?!@typeCplusPlusNameList outAllVariablesList
  ;
}

#---------------------------------------------------------------------------*

list @typeListeCibles {
  @typeCible aCible ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                  Liste d'attributs externes                               *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_nameWithType {
  @lstring mType ;
  @lstring mName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Table des methodes (d'une classe a implementer)              *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableMethodesAimplementer
  class cTableMethodesAimplementer ;
  insert insertAbstract error message "the method '%' is already declared" ;
  insert insertNotAbstract error message "the method '%' is already declared" ;
  @L_EXsignature aListeTypesParametres ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*
#   E X P R E S S I O N S    L I S T                                        *
#---------------------------------------------------------------------------*

list @typeExpressionList {
  @typeExpression mExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    E R R O R    I N S T R U C T I O N                                     *
#                                                                           *
#---------------------------------------------------------------------------*

list @varToDropList {
  @typeCplusPlusName mVarToDrop ;
}

#---------------------------------------------------------------------------*

class @typeErrorInstruction extends @typeInstruction {
  @typeExpression mErrorLocationExpression ;
  @typeExpression mErrorMessageExpression ;
  @location mLocation ;
  @varToDropList mVarToDropList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    S E N D    I N S T R U C T I O N                                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeSendInstruction extends @typeInstruction {
  @typeExpression mExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    W A R N I N G    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeWarningInstruction extends @typeInstruction {
  @typeExpression mWarningLocationExpression ;
  @typeExpression mWarningMessageExpression ;
  @location mLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    M E S S A G E    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMessageInstruction extends @typeInstruction {
  @typeExpression mMessageExpression ;
  @location mInstructionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M E T H O D    C A L L    I N S T R U C T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMethodCallInstruction extends @typeInstruction {
  @AC_galgasType mExpressionType ;
  @typeExpression mExpression ;
  @lstring mMethodName ;
  @string mCategoryMethodClassBaseName ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   T Y P E    M E T H O D    C A L L    I N S T R U C T I O N              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeCallOfTypeMethodInstruction extends @typeInstruction {
  @lstring mTypeName ;
  @lstring mTypeMethodName ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   M O D I F I E R    C A L L    I N S T R U C T I O N                     *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeModifierCallInstruction extends @typeInstruction {
  @typeCplusPlusName aNomCppVariable ;
  @lstringlist mStructAttributeList ;
  @lstring aNomMethodeSimple ;
  @typeExpressionList mExpressionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Instruction d'appel d'une methode de list                       *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionAppelMethodeListe extends @typeInstruction {
  @typeCplusPlusName aNomCppAttribut ;
  @lstring aMethodeDeListe ;
  @typeCplusPlusNameList aListeNomsCppArguments ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           Instruction de declaration d'une variable locale                *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeInstructionDeclarationVarLocale extends @typeInstruction {
  @typeCplusPlusName aNomCppVariable ;
  @AC_galgasType aTypeVariable ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#               'block...' instruction for a map                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMapBlockPrologueInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeBloc ;
  @typeExpressionList mPrologueExpressionList ;
}

#---------------------------------------------------------------------------*

class @typeMapBlockEpilogueInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariableTable ;
  @lstring aNomMethodeBloc ;
  @typeExpressionList mEpilogueExpressionList ;
}

#---------------------------------------------------------------------------*
#   R E A D E R    C A L L    O P E R A N D                                 *
#---------------------------------------------------------------------------*

class @typeReaderCallInExpression extends @typeExpression {
  @typeExpression mExpressionValue ;
  @lstring mReaderName ;
  @typeExpressionList mExpressionList ;
  @string mConversionMethod ;
}
 
#---------------------------------------------------------------------------*
#   F I L E W R A P P E R    W I T H    S T A T I C    P A T H              *
#---------------------------------------------------------------------------*

class @typeFileWrapperWithStaticPath extends @typeExpression {
  @lstring mFileWrapperName ;
  @uint mFileIndex ;
}
 
#---------------------------------------------------------------------------*
#   F I L E W R A P P E R    T E M P L A T E     C A L L                    *
#---------------------------------------------------------------------------*

class @typeFileWrapperTemplateCall extends @typeExpression {
  @lstring mFileWrapperName ;
  @lstring mTemplateName ;
  @typeExpressionList mOutExpressionList ;
}
 
#---------------------------------------------------------------------------*
#   F I L E W R A P P E R    O B J E C T    I N S T A N C I A T I O N       *
#---------------------------------------------------------------------------*

class @typeFileWrapperObjectInstanciation extends @typeExpression {
  @lstring mFileWrapperName ;
}
 
#---------------------------------------------------------------------------*
#   D E S C R I P T I O N    O P E R A N D                                  *
#---------------------------------------------------------------------------*

class @typeDescriptionInExpression extends @typeExpression {
  @typeExpression mExpressionValue ;
  @location mOperatorLocation ;
}
 
#---------------------------------------------------------------------------*
#   C A S T    O P E R A N D                                                *
#---------------------------------------------------------------------------*

class @typeCastInExpression extends @typeExpression {
  @typeExpression mCastedExpression ;
  @bool mCheckForKindOfClass ;
  @lstring mCastTypeName ;
  @typeExpression mErrorLocationExpression ;
}
 
#---------------------------------------------------------------------------*
#   B O O L E A N    O P E R A T I O N S                                    *
#---------------------------------------------------------------------------*

class @typeAndOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeOrOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeXorOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeConcatOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeTrueBool extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeFalseBool extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeLiteralStringExpression extends @typeExpression {
  @stringlist mLiteralStringList ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralUIntExpression extends @typeExpression {
  @luint mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralSIntExpression extends @typeExpression {
  @lsint mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralUInt64Expression extends @typeExpression {
  @luint64 mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralSInt64Expression extends @typeExpression {
  @lsint64 mLiteralInt ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralCharExpression extends @typeExpression {
  @lchar mLiteralChar ;
}
 
#---------------------------------------------------------------------------*

class @typeLiteralDoubleExpression extends @typeExpression {
  @ldouble mLiteralDouble ;
}
 
#---------------------------------------------------------------------------*

class @typeHereExpression extends @typeExpression {
}
 
#---------------------------------------------------------------------------*

class @typeConstructorExpression extends @typeExpression {
  @AC_galgasType mType ;
  @string mClassMethodName ;
  @typeExpressionList mExpressionList ;
}
 
#---------------------------------------------------------------------------*

class @typeTestComplement extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeLogicalNegate extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeBoolOption extends @typeExpression {
  @string mOptionComponentName ;
  @lstring mOptionName ;
}
 
#---------------------------------------------------------------------------*

class @typeUIntOption extends @typeExpression {
  @string mOptionComponentName ;
  @lstring mOptionName ;
}
 
#---------------------------------------------------------------------------*

class @typeStringOption extends @typeExpression {
  @string mOptionComponentName ;
  @lstring mOptionName ;
}
 
#---------------------------------------------------------------------------*
#   S I M P L E    V A R I A B L E                                          *
#---------------------------------------------------------------------------*

class @typeVarInExpression extends @typeExpression {
  @typeCplusPlusName mCppVarName ;
}
 
#---------------------------------------------------------------------------*
#   J O K E R    E X P R E S S I O N                                        *
#---------------------------------------------------------------------------*

class @typeJokerInExpression extends @typeExpression {
}
 
#---------------------------------------------------------------------------*
#   A D D I T I O N    O P E R A T I O N                                    *
#---------------------------------------------------------------------------*

class @typeAddOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*
#   S U B S T R A C T I O N    O P E R A T I O N                            *
#---------------------------------------------------------------------------*

class @typeSubOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*
#   M U L T I P L I C A T I O N    O P E R A T I O N                        *
#---------------------------------------------------------------------------*

class @typeMultiplyOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*
#   D I V I S I O N    O P E R A T I O N                                    *
#---------------------------------------------------------------------------*

class @typeDivideOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*
#   M O D U L O    O P E R A T I O N                                        *
#---------------------------------------------------------------------------*

class @typeModuloOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*
#   U N A R Y   -    O P E R A T I O N                                      *
#---------------------------------------------------------------------------*

class @typeUnaryMinusOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mExpression ;
}
 
#---------------------------------------------------------------------------*
#  ==    O P E R A T I O N                                                  *
#---------------------------------------------------------------------------*

class @typeEqualTest extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeNonEqualTest extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeStrictInfTest extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeInfOrEqualTest extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeStrictSupTest extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeSupOrEqualTest extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeLeftShiftOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*

class @typeRightShiftOperation extends @typeExpression {
  @location mOperatorLocation ;
  @typeExpression mLeftExpression ;
  @typeExpression mRightExpression ;
}
 
#---------------------------------------------------------------------------*
#   C A L L    T E S T    M E T H O D    F O R    M A P                     *
#---------------------------------------------------------------------------*

class @typeTextTableCall extends @typeExpression {
  @typeExpression mExpression ;
  @lstring aNomMethodeTest ;
  @typeCplusPlusName aNomCppClef ;
}
 
#---------------------------------------------------------------------------*
#                                                                           *
#   A S S I G N M E N T    I N S T R U C T I O N                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_assignmentInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   . =    I N S T R U C T I O N                                            *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_dotEqualInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @lstringlist mStructAttributeList ;
  @typeExpression mSourceExpression ;
  @string mSourceExpressionConverter ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   D E C L A R A T I O N    I N S T R U C T I O N                          *
#                                                                           *
#   W I T H    A S S I G N M E N T                                          *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_declarationInstructionWithAssignment extends @typeInstruction {
  @AC_galgasType mVariableType ;
  @typeCplusPlusName mTargetVarCppName ;
  @typeExpression mSourceExpression ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   " W H I L E "   I N S T R U C T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_while_instruction extends @typeInstruction {
  @typeExpression mVariantExpression ;
  @typeInstructionList mInstructionList1 ;
  @typeExpression mWhileExpression ;
  @typeInstructionList mInstructionList2 ;
  @location mLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   " I F "   I N S T R U C T I O N                                         *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_expression_instructionsList_list {
  @typeExpression mIFexpression ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @C_if_instruction extends @typeInstruction {
  @L_expression_instructionsList_list mIFbranchesList ;
  @typeInstructionList mElseInstructionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   " S W I T C H "   I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_switchBranchlist {
  @stringset mConstantSet ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @C_switch_instruction extends @typeInstruction {
  @typeExpression mSwitchExpression ;
  @lstring mEnumTypeName ;
  @L_switchBranchlist mBranchList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Definition de la map des routines a implementer                      *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableRoutinesAimplementer {
  insert insertKey error message "the routine '%K' is already declared in %L" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# Table des attributs semantiques internes (pour list d'instructions)       *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableAttributsSemantiques {
  @typeCplusPlusName aNomCppAttribut ;
  @AC_galgasType mAttributType ;
  insert insertKey error message "the attribute '%K' is already declared in %L" ;
  search searchKey error message "the attribute '%K' is not declared" ;
}

#---------------------------------------------------------------------------*

routine buildMapWithLocalConstants
  ?@L_nameWithType inLocalDeclarationsList
  ?@typeListeAttributsSemantiques inSemanticAttributsList
  ?!@typeVariablesMap ioVariablesMap
  ?@location inLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
  ?@bool inEllipsisFound
:
  @bool mapStyle := inLocalConstantStyle != [@localConstantBuildStyleEnum listStyle] ;
  @bool firstOne := true ;
  foreach inLocalDeclarationsList (@lstring typeNameInDeclaration @lstring cstName),
          inSemanticAttributsList (@AC_galgasType type @lstring attributeName) do
    if [cstName string] != "" then
      @string typeName ;
      [type getTypeName ? typeName] ;
      if [typeNameInDeclaration string] == typeName then
        @typeCplusPlusName cppName ;
        if (inLocalConstantStyle == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & firstOne then
          cppName := [@typeKeyName new !inLocation] ;
        else
          cppName := [@typeOperandName new !inLocation ![attributeName string] !mapStyle] ;
        end if ;
        [!?ioVariablesMap insertUsedConstInArgument !cstName !type !cppName] ;
      else
        error typeNameInDeclaration : "I have found the '@" . [typeNameInDeclaration string]
          . "' type, I was expected the '@" . typeName . "' type" ;
      end if ;
    end if ;
    firstOne := false ;
  end foreach ;
#--- Check effective parameters list length
  if ([inLocalDeclarationsList length] < [inSemanticAttributsList length]) & not inEllipsisFound then
    error here : "one or more parameters missing: found "
    . [[inLocalDeclarationsList length] string] . " effective parameters, while "
    . [[inSemanticAttributsList length] string] . " are needed" ;
  elsif [inLocalDeclarationsList length] > [inSemanticAttributsList length] then
    error here : "too much parameters: found "
    . [[inLocalDeclarationsList length] string] . " effective parameters, while "
    . [[inSemanticAttributsList length] string] . " are needed" ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     ITERATEUR (DOUBLE) DE VERIFICATION DE COMPATIBILITE ENTRE             *
#   ENTRE UNE LISTE DE TYPES ET UNE LISTE D'ATTRIBUTS SEMANTIQUES           *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteTypes
  ??@typeSemanticsTypesList t1
  ??@typeListeAttributsSemantiques t2
  ??@location inErrorLocation
:
  if [t1 length] < [t2 length] then
    error inErrorLocation : "one or more identifiers missing" ;
  elsif [t1 length] > [t2 length] then
    error inErrorLocation : "too much identifiers" ;
  else
    foreach t1 (@AC_galgasType attTypeEffectif @lstring attNomVariableEffectif),
            t2 (@AC_galgasType attTypeAttributFormel @lstring attNomAttributFormel) do
      checkAssignmentTypesCompatibility
        !attTypeEffectif
        !attTypeAttributFormel
        ![attNomVariableEffectif location]
        !false
      ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#     VERIFICATION DE COMPATIBILITE ENTRE UNE SIGNATURE ET UN APPEL         *
#                                                                           *
#---------------------------------------------------------------------------*

routine verifierCompatibiliteArgEffectifsSignature
  ??@L_EXsignature signatureReference
  ??@L_actualParametersSignature inEffectiveArgumentsSignature
  ??@location inErrorLocation
  ?!@typeInstructionList ioInstructionsList
  ?!@typeExpressionList ioExpressionList
:
  if [signatureReference length] > [inEffectiveArgumentsSignature length] then
    error inErrorLocation : "one or more arguments missing" ;
  elsif [signatureReference length] < [inEffectiveArgumentsSignature length] then
    error inErrorLocation : "too much arguments" ;
  else
  #--- Check signatures
    foreach signatureReference (@AC_galgasType attSignatureType @EXformalArgumentPassingMode formalArgPassingMode),
            inEffectiveArgumentsSignature (@AC_galgasType attEffectiveType @EXactualParametersPassingMode parameterPassingMode) do
      match formalArgPassingMode::parameterPassingMode :
      when argumentConstantIn :: parameterOut :
        checkAssignmentTypesCompatibility !attSignatureType !attEffectiveType !inErrorLocation !true ;
      when argumentIn :: parameterOut :
        checkAssignmentTypesCompatibility !attSignatureType !attEffectiveType !inErrorLocation !true ;
      when argumentInOut :: parameterOutIn :
        checkAssignmentTypesCompatibility !attSignatureType !attEffectiveType !inErrorLocation !false ;
      when argumentOut :: parameterIn :
        cast attEffectiveType :
        when >= @typeGalgas_jokerInParameterList do
        else
          checkAssignmentTypesCompatibility !attSignatureType !attEffectiveType !inErrorLocation !false ;
        end cast ;
      else
        error inErrorLocation : [parameterPassingMode actualArgumentMessage] . " is not compatible with " .
                                [formalArgPassingMode formalArgumentMessage] ;
      end match ;
    end foreach ;
  #--- Build expression list
    @typeExpressionList expressionList := ioExpressionList ;
    ioExpressionList := [@typeExpressionList emptyList] ;
    foreach signatureReference (@AC_galgasType attSignatureType *),
            expressionList (@typeExpression attExpressionType) do
      cast attExpressionType :
      when >= @typeJokerInExpression do
        @typeCplusPlusName cppVarName := [@typeLocationAutomaticName new !here ![@uint sequenceNumber]] ;
        @typeExpression e := [@typeVarInExpression new !cppVarName] ;
        ioExpressionList += !e ;
        @typeInstruction i := [@typeInstructionDeclarationVarLocale new !cppVarName !attSignatureType] ;
        ioInstructionsList += !i ;
      else
        ioExpressionList += !attExpressionType ;
      end cast ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           class 'typeJoker'                               *
#     Est utilise pour denoter le type d'une variable cible anonyme         *       
#                                                                           *
#---------------------------------------------------------------------------*

class @typeJoker extends @typeCible {
  override method verifierType
    ??@AC_galgasType unused typeArgumentFormel
    ?!@lstring unused nomAttributSource
    ?!@L_assignedVariables unused listeAffectations
    ?!@typeCplusPlusNameList outAllVariablesList
  :
    outAllVariablesList += ![@typeNullName new !here] ;
  end method ;
}

#---------------------------------------------------------------------------*

class @typeEntiteDest extends @typeCible {
  @AC_galgasType aTypeVarDest ;
  @typeCplusPlusName mCppName ;
  @location aPositionVariableCible ;

  override method verifierType
    ??@AC_galgasType typeArgumentFormel
    ?!@lstring nomAttributSource
    ?!@L_assignedVariables listeAffectations
    ?!@typeCplusPlusNameList ioAllVariablesList
  :
    checkAssignmentTypesCompatibility
       !aTypeVarDest
       !typeArgumentFormel
       !aPositionVariableCible
       !false
    ;
    listeAffectations += !mCppName !nomAttributSource ;
    ioAllVariablesList += !mCppName ;
  end method ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#      Map of non terminal symbols                                          *
#                                                                           *
#---------------------------------------------------------------------------*

map @M_nonTerminalSymbolForSyntax {
  @M_nonterminalSymbolAlts mAltParametersMap ;
  insert insertKey error message "the '%K' non terminal symbol is already declared in %L"  ;
  search searchKey error message "the '%K' non terminal symbol is not declared" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    Grammar instruction                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

class @C_grammarInstruction extends @typeInstruction {
  @bool mSourceIsFile ; # if false, next arg is a @string
  @typeExpression mSourceExpression ; # @lstring var or @string var
  @lstring mGrammarName ;
  @typeExpressionList mExpressionsList ;
  @lstring mAltSymbol ;
  @lstring mLexiqueClassName ;
  @typeCplusPlusName mSentStringName ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          += instruction (without luint assignment)                        *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeAppendInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @lstringlist mStructAttributeList ;
  @typeExpressionList mSourceExpressions ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          -= instruction                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeRemoveInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @lstringlist mStructAttributeList ;
  @typeExpressionList mSourceExpressions ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          ++ instruction                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeIncrementInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @lstringlist mStructAttributeList ;
  @location mInstructionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#          -- instruction                                                   *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeDecrementInstruction extends @typeInstruction {
  @typeCplusPlusName mTargetVarCppName ;
  @lstringlist mStructAttributeList ;
  @location mInstructionLocation ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#   C A S E S    L I S T    F O R    M A T C H    I N S T R U C T I O N     *
#                                                                           *
#---------------------------------------------------------------------------*

list @L_matchInstructionCasesList {
  @lstring mCase1_name ;
  @lstring mCase2_name ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#     M A T C H    I N S T R U C T I O N                                    *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeMatchInstruction extends @typeInstruction {
  @location aIndicatif1 ;
  @location aIndicatif2 ;
  @typeCplusPlusName aNomCppVariable1 ;
  @typeCplusPlusName aNomCppVariable2 ;
  @lstring aNomTypeBase1 ;
  @lstring aNomTypeBase2 ;
  @bool mOperand1_isEnumeration ;
  @bool mOperand2_isEnumeration ;
  @L_matchInstructionCasesList aListeCas ;
  @typeInstructionList mElseInstructionsList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  Instruction                                                              *
#    foreach var ??@... name ??@... name, ... :                             *
#      instructions                                                         *
#    end foreach ;                                                          *
#                                                                           *
#---------------------------------------------------------------------------*

list @foreachEnumerationList  {
  @typeExpression mSourceExpression ;
  @location mLocationOffset ;
  @string mCppTypeName ;
  @bool mAscending ;
}

#---------------------------------------------------------------------------*

class @typeForeachInstruction extends @typeInstruction {
  @foreachEnumerationList mForeachEnumerationList ;
  @typeCplusPlusName mIndexVariable ;
  @typeExpression mWhileExpression ;
  @typeInstructionList mBeforeInstructionList ;
  @typeInstructionList mDoInstructionList ;
  @typeInstructionList mBetweenInstructionList ;
  @typeInstructionList mAfterInstructionList ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction 'extract ...'                              *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeSimpleExtractInstruction extends @typeInstruction {
  @typeCplusPlusName aNomVariable ;
  @lstring aNomClasse ;
  @L_assignedVariables aListeAffectationParametresEffectifs ;
  @typeExpression mErrorLocationExpression ;
  @lstring aNomMessage ;
}

#----------------------------------------------------------------------*
#                                                                      *
#                    Structured instruction 'extract ...'              *
#                                                                      *
#----------------------------------------------------------------------*

list @typeStructuredExtractCasesList {
  @lstring mClassName ;
  @location mResultVarID ;
  @typeInstructionList mInstructionList ;
  @bool mNoUsedParameter ;
}

#----------------------------------------------------------------------*

class @typeStructuredExtractInstructionWithElse extends @typeInstruction {
  @typeCplusPlusName mVariableName ;
  @typeStructuredExtractCasesList mCasesList ;
  @typeInstructionList mElseInstructionList ;
}

#----------------------------------------------------------------------*
#                                                                      *
#                    Structured instruction 'cast ...'                 *
#                                                                      *
#----------------------------------------------------------------------*

abstract class @AC_elseOrDefaultForCastInstruction {
}

#----------------------------------------------------------------------*

class @C_elseForCastInstruction extends @AC_elseOrDefaultForCastInstruction {
  @typeInstructionList mElseInstructionList ;
}

#----------------------------------------------------------------------*

class @C_defaultForCastInstruction extends @AC_elseOrDefaultForCastInstruction {
  @typeExpression mErrorLocationExpression ;
  @location mLocation ;
}

#----------------------------------------------------------------------*

list @typeStructuredCastBranchList {
  @lstring mCastClassName ;
  @bool mCheckForKindOfClass ;
  @typeCplusPlusNameList mLocalConstantName ; # 0 or 1 element
  @typeInstructionList mInstructionList ;
}

#----------------------------------------------------------------------*

class @typeStructuredCastInstruction extends @typeInstruction {
  @location mCastInstructionLocation ;
  @typeExpression mSourceExpression ;
  @lstring mSourceExpressionTypeName ;
  @typeStructuredCastBranchList mBranchList ;
  @AC_elseOrDefaultForCastInstruction mElseOrDefault ;
}


#---------------------------------------------------------------------------*
#                                                                           *
#       Routine or extern extern routine call instruction                           *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeRoutineCallInstruction extends @typeInstruction {
  @lstring mRoutineName ;
  @typeExpressionList mExpressionsList ;
  @L_EXsignature mFormalParameterList ;
  @bool mIsExternActionCall ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    'log ...' instruction                                  *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeLogInstruction extends @typeInstruction {
  @lstring mGalgasVariableName ;
  @typeCplusPlusName mLoggedVariable ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#                    'drop ...' instruction                                 *
#                                                                           *
#---------------------------------------------------------------------------*

class @typeDropInstruction extends @typeInstruction {
  @typeCplusPlusName aVariableConsommee ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#            Table des routines declarees par un prototype                  *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeTableNomRoutinesDeclarees {
  insert insertKey error message "the routine '%K' is already declared in %L" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Entites a engendrer                                          *
#                                                                           *
#---------------------------------------------------------------------------*

abstract class @typeEntityToGenerate {
}

#---------------------------------------------------------------------------*

class @typeExternTypeToGenerate extends @typeEntityToGenerate {
  @lstring mGalgasName ;
#--- Constructor map
  @M_externTypeConstructorMap mConstructorMap ;
#--- Modifiers map
  @typeTableMethodes mModifiersMap ;  
#--- Readers map
  @typeTableMethodes mReadersInInstructionMap ;  
#--- Attributes for handling operator '+=' call
  @bool mAcceptAddAssignOperatorCall ;
  @typeListeAttributsSemantiques mAddAssignOperatorCallTypeList ;
}

#---------------------------------------------------------------------------*

class @typeRoutineAengendrer extends @typeEntityToGenerate {
  @lstring aNomRoutine ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

class @categoryMethodToImplement extends @typeEntityToGenerate {
  @bool mOverride ;
  @string mBaseClassName ;
  @lstring mClassName ;
  @lstring mMethodName ;
  @typeListeTypesEtNomsArgMethode aListeTypeEtNomsArguments ;
  @typeInstructionList mInstructionList ;
  @location mMagicNumber ;
}

#---------------------------------------------------------------------------*

class @C_listTypeToImplement extends @typeEntityToGenerate {
  @lstring aNomListe ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
}

#---------------------------------------------------------------------------*

list @EXsortDescriptorList {
  @lstring mSortAttribute ;
  @bool mAscendingOrder ;
}

#---------------------------------------------------------------------------*

class @C_sortedListTypeToImplement extends @typeEntityToGenerate {
  @lstring aNomListe ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @EXsortDescriptorList mSortDescriptorList ;
}

#---------------------------------------------------------------------------*

class @typeDefinitionTableAimplementer extends @typeEntityToGenerate {
  @lstring aNomTable ;
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @lstring aNomClasseGenerique ;
  @insertOrSearchMethodList mInsertMethodList ;
  @insertOrSearchMethodList mSearchMethodList ;
  @typeTableBlocsDeTable aTableMethodesSurcharger ;
}

#---------------------------------------------------------------------------*

class @C_mapToImplement extends @typeEntityToGenerate {
  @lstring mMapTypeName ;
  @lstring mEnumTypeName ; # Empty if no associated enumeration
  @lstring mCheckFinalStateMethod ; # Empty if no associated enumeration
  @typeListeAttributsSemantiques mNonExternAttributesList ;
  @insertOrSearchMethodList mInsertMethodList ;
  @insertOrSearchMethodList mSearchMethodList ;
  @insertOrSearchMethodList mRemoveMethodList ;
}

#---------------------------------------------------------------------------*

class @C_classToImplement extends @typeEntityToGenerate {
#--- Class Name
  @lstring aNomClasse ;

#--- Is Abstract ?
  @bool mIsAbstract ;

#--- Liste de tous les attributs not externes, y compris ceux definis dans une classe mere
  @typeListeAttributsSemantiques aListeTousAttributsNonExternes ;  

#--- Table de toutes les methodes, y compris celles heritees
  @typeTableMethodes aTableToutesMethodes ;

#--- Table des methodes de la classe abstract
  @typeTableMethodesAimplementer mMethodsMap ;

#--- Liste des attributs semantiques not externes definis dans cette classe
  @typeListeAttributsSemantiques aListeAttributsCourants ;

#--- Table des classes ancetre de la classe courante
  @typeSuperClassesMap mAncestorClassesMap ;

#--- Table des messages
  @typeClassMessagesMap mMessagesMap ;

#--- Table des messages
  @string mClassMessage ;
}

#---------------------------------------------------------------------------*

class @C_mapindexToImplement extends @typeEntityToGenerate {
#--- Map index type Name
  @lstring mMapindexTypeName ;
#--- Map type Map
  @lstring mMapTypeName ;
#--- Map attributes
  @typeListeAttributsSemantiques mMapAttributesList ;
#--- Readers
  @mapIndexSearchReaderMap mMapIndexSearchReaderMap ;
}

#---------------------------------------------------------------------------*

map @domainRelationMap {
  @stringlist mDomains ;
  insert insertKey error message "the '%K' domain relation has been already declared in %L" ;
  search searchKey error message "the '%K' domain relation is not declared" ;
}

#---------------------------------------------------------------------------*

class @C_domainToImplement extends @typeEntityToGenerate {
#--- Domain Name
  @lstring mDomainName ;
#--- Attribute Map
  @domainAttributeMap mAttributeMap ;
#--- Relation Map
  @domainRelationMap mRelationMap ;
}

#---------------------------------------------------------------------------*

class @typeEntiteActionExterne extends @AC_semanticsEntity {
  @L_EXsignature aSignature ;
  message "an external extern routine" ;
  message messageTypeEntite "an external extern routine" ;
}

#---------------------------------------------------------------------------*

class @typeActionExterneAengendrer extends @typeEntityToGenerate {
  @lstring aNomAction ;
  @L_EXsignature aSignature ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#              Liste des entites a engendrer                                *
#                                                                           *
#---------------------------------------------------------------------------*

list @typeEntitiesToGenerateList {
  @typeEntityToGenerate mEntityToGenerate ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#    E N U M     T Y P E                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

map @typeEnumCstMessageStringMap {
  @lstring mMessageString ;
  insert insertKey error message "the message for '%K' constant is already declared in %L" ;
  search searchKey error message "the message for '%K' constant is not declared" ;
}

#---------------------------------------------------------------------------*

class @enumGalgasType extends @typeEntityToGenerate {
  @lstring mEnumTypeName ;
  @enumConstantMap mConstantMap ;
  @typeEnumMessageMap mEnumMessageMap ;
  @enumModifierMap mEnumActionMap ;
  @enumMethodMap mMethodMap ;
  @enumOperatorMap mOperatorMap ;
}

#---------------------------------------------------------------------------*

extern routine appendJokersIfNeeded
 ?!@typeCplusPlusNameList ioAllVariablesList
 ?@uint inEffectiveParametersCount
 ?@uint inFormalArgumentsCount
 ?@typeCplusPlusName inNullName
;

#---------------------------------------------------------------------------*

extern routine generateSemanticsComponent
  ?!@lstring componentName
  ?!@stringset includesForHeaderFile
  ?!@string defLexique
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@stringset includesForImplementationFile
;

#---------------------------------------------------------------------------*
#                                                                           *
#              Grammar descriptor (for program component)                   *
#                                                                           *
#---------------------------------------------------------------------------*

list @ruleDescriptorForProgramList {
  @lstring mSourceExtension ;
  @string mHelpMessage ;
  @lstring mSourceFileName ;
  @typeInstructionList mInstructionList ;
}

#---------------------------------------------------------------------------*

extern routine fixFileGenerationStartDirectory
  ??@lstring inSourceFile
;

#---------------------------------------------------------------------------*
#                                                                           *
#              F I L E    W R A P P E R                                     *
#                                                                           *
#---------------------------------------------------------------------------*

sortedlist @wrapperFileSortedList {
  @string mRegularFileName ;
  @string mAbsoluteFilePath ;
  @uint mWrapperDirectoryIndex ;
  @uint mWrapperFileIndex ;
}{
  mRegularFileName <
}

#---------------------------------------------------------------------------*

sortedlist @wrapperDirectorySortedList ;

sortedlist @wrapperDirectorySortedList {
  @string mDirectoryName ;
  @wrapperFileSortedList mRegularFileSortedList ;
  @wrapperDirectorySortedList mDirectorySortedList ;
  @uint mWrapperDirectoryIndex ;
}{
  mDirectoryName <
}

#---------------------------------------------------------------------------*

map @wrapperExtensionMap {
  insert insertKey error message "the '%K' extension has been already declared" ;
}

#---------------------------------------------------------------------------*

class @C_wrapperToImplement extends @typeEntityToGenerate {
  @lstring mWrapperName ;
  @string mSourceDirectory ; # Used for comment in generated code
  @wrapperExtensionMap mExtensionMap ; # Used for comment in generated code
  @wrapperFileSortedList mRegularFileSortedList ;
  @wrapperDirectorySortedList mDirectorySortedList ;
}

#---------------------------------------------------------------------------*

class @C_structToImplement extends @typeEntityToGenerate {
  @lstring mStructName ;
  @typeListeAttributsSemantiques mAttributeList ;
}

#---------------------------------------------------------------------------*

class @C_filewrapperTemplateToImplement extends @typeEntityToGenerate {
  @lstring mFilewrapperName ;
  @lstring mTemplateName ;
  @typeListeTypesEtNomsArgMethode mTemplateArgumentList ;
  @templateInstructionList mTemplateInstructionList ;
}

#---------------------------------------------------------------------------*

end semantics ;
