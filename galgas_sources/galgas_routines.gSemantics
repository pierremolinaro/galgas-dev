#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS LL1 routines                                                      *
#                                                                           *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics galgas_routines :
  import "semanticsCompilation.gSemantics" ;
  import "projectMetamodel.gSemantics" ;
  import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
  import semantics optionSemantics in "optionSemantics.gSemantics" ;
  import semantics semantics_semantics in "semantics_semantics.gSemantics" ;
  import semantics grammarMetamodel in "grammarMetamodel.gSemantics" ;
  import semantics optionTypesForAST in "optionTypesForAST.gSemantics" ;
  import semantics semanticsTypesForAST in "semanticsTypesForAST.gSemantics" ;
  import semantics syntaxMetamodel in "syntaxMetamodel.gSemantics" ;
  import semantics programMetamodel in "programMetamodel.gSemantics" ;
  import semantics semanticsCompilation in "semanticsCompilation.gSemantics" ;
  import semantics projectMetamodel in "projectMetamodel.gSemantics" ;

  import grammar galgas_LL1_grammar in "galgas_LL1_grammar.gGrammar" ;
  import grammar optionLL1grammar in "optionLL1grammar.gGrammar" ;
  import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;
  import grammar grammarLL1grammar in "grammarLL1grammar.gGrammar" ;
  import grammar programSLRgrammar in "programSLRgrammar.gGrammar" ;
  import grammar projectLL1grammar in "projectLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*

function outputDirectory
  ??@lstring inSourceFile
->
  @string outOuputDirectory
:
  if [inSourceFile characterAtIndex !0] == '/' then
    outOuputDirectory := [inSourceFile stringByDeletingLastPathComponent] ;
    outOuputDirectory .= "/GALGAS_OUTPUT" ;
  else
    outOuputDirectory := "GALGAS_OUTPUT" ;
  end if ;
end function ;

##---------------------------------------------------------------------------*
#
#routine checkCategoryMethodDefinitionForClass
#  ??@string inClassNameForErrorSignaling
#  ??@string inClassName
#  ??@lstring inAbstractCategoryMethodName
#  ??@descendantClassListMapEX inDescendantClassListMap
#  ??@overridingMultiMethodListMapAST inOverridingCategoryMethodListMap
#:
#  @classIndexListEX descendantClasses := [inDescendantClassListMap listForKey !inClassName] ;
#  foreach descendantClasses do
#    @lstring descendantClassName := [mClassMapindex key] ;
#    @ACGalgasType t := [mClassMapindex mType] ;
#    @bool isAbstract ;
#    cast t :
#    when >= @classGalgasType classType do
#      isAbstract := [classType mIsAbstract] ;
#    else
#      error descendantClassName: "the '@" . descendantClassName . "' type should be a class" -> isAbstract ;
#    end cast ;
#    @overridingMultiMethodListAST overridingMethods := [inOverridingCategoryMethodListMap listForKey ![descendantClassName string]] ;
#    @bool found := false ;
#    foreach overridingMethods while not found do
#      found := [inAbstractCategoryMethodName string] == [mOverridingCategoryMethodName string] ;
#    end foreach ;
#    if not found then
#      if isAbstract then
#        checkCategoryMethodDefinitionForClass
#          !inClassNameForErrorSignaling
#          ![descendantClassName string]
#          !inAbstractCategoryMethodName
#          !inDescendantClassListMap
#          !inOverridingCategoryMethodListMap
#        ;
#      else
#        error inAbstractCategoryMethodName: "an abstract category method '" . inAbstractCategoryMethodName . "' is defined for abstract class '@"
#        . inClassNameForErrorSignaling
#        . "', but concrete descendant class '@" . descendantClassName . "' does not implement this method" ; 
#      end if ;
#    end if ;
#  end foreach ;
#end routine ;

#---------------------------------------------------------------------------*

#routine checkCategoryReaderDefinitionForClass
#  ??@string inClassNameForErrorSignaling
#  ??@string inClassName
#  ??@lstring inAbstractCategoryReaderName
#  ??@descendantClassListMapEX inDescendantClassListMap
#  ??@overridingMultiReaderListMapAST inOverridingCategoryReaderListMap
#:
#  @classIndexListEX descendantClasses := [inDescendantClassListMap listForKey !inClassName] ;
#  foreach descendantClasses do
#    @lstring descendantClassName := [mClassMapindex key] ;
#    @ACGalgasType t := [mClassMapindex mType] ;
#    @bool isAbstract ;
#    cast t :
#    when >= @classGalgasType classType do
#      isAbstract := [classType mIsAbstract] ;
#    else
#      error descendantClassName: "the '@" . descendantClassName . "' type should be a class" -> isAbstract ;
#    end cast ;
#    @overridingMultiReaderListAST overridingReaders := [inOverridingCategoryReaderListMap listForKey ![descendantClassName string]] ;
#    @bool found := false ;
#    foreach overridingReaders while not found do
#      found := [inAbstractCategoryReaderName string] == [mOverridingCategoryReaderName string] ;
#    end foreach ;
#    if not found then
#      if isAbstract then
#        checkCategoryReaderDefinitionForClass
#          !inClassNameForErrorSignaling
#          ![descendantClassName string]
#          !inAbstractCategoryReaderName
#          !inDescendantClassListMap
#          !inOverridingCategoryReaderListMap
#        ;
#      else
#        error inAbstractCategoryReaderName: "an abstract category reader '" . inAbstractCategoryReaderName . "' is defined for abstract class '@"
#        . inClassNameForErrorSignaling
#        . "', but concrete descendant class '@" . descendantClassName . "' does not implement this reader" ; 
#      end if ;
#    end if ;
#  end foreach ;
#end routine ;

#---------------------------------------------------------------------------*

routine performProjectGlobalCheckings
  ??@parsedComponentStruct inParsedComponentStruct
  ??@location inEndOfSourceFile
:
#--- Build all declaration list
  @semanticDeclarationListAST semanticDeclarationList [emptyList] ;
  foreach [inParsedComponentStruct mParsedSemanticsComponentMap] do
    semanticDeclarationList .= [[mRoot mSemanticDeclarations] mSemanticDeclarationList] ;
  end foreach ;
##---- Build semantic context
#  @semanticContextEX semanticContext ;
#  buildSemanticContextEX !semanticDeclarationList !inEndOfSourceFile ?semanticContext ;
##--- Check that for every abstract category method, an overridden category method
##    defined in an concrete subclass
#  if [@uint errorCount] == 0 then
#    @abstractMultiMethodListMapAST abstractCategoryMethodListMap [emptyMap] ;
#    @multiMethodListMapAST categoryMethodListMap [emptyMap] ;
#    @overridingMultiMethodListMapAST overridingCategoryMethodListMap [emptyMap];
#    foreach [inParsedComponentStruct mParsedSemanticsComponentMap] do
#      abstractCategoryMethodListMap .= [[mRoot mSemanticDeclarations] mAbstractCategoryMethodListMap] ;
#      overridingCategoryMethodListMap .= [[mRoot mSemanticDeclarations] mOverridingCategoryMethodListMap] ;
#    end foreach ;
#    @descendantClassListMapEX descendantClassListMap := [semanticContext mDescendantClassListMap] ;
#    foreach abstractCategoryMethodListMap do
#      foreach object do
#        checkCategoryMethodDefinitionForClass
#          !key
#          !key
#          !mAbstractCategoryMethodName
#          !descendantClassListMap
#          !overridingCategoryMethodListMap
#        ;
#      end foreach ;
#    end foreach ;
#  end if ;
##--- Check that for every abstract category reader, an overridden category reader
##    defined in an concrete subclass
#  if [@uint errorCount] == 0 then
#    @abstractMultiReaderListMapAST abstractCategoryReaderListMap [emptyMap] ;
#    @multiReaderListMapAST categoryReaderListMap [emptyMap] ;
#    @overridingMultiReaderListMapAST overridingCategoryReaderListMap [emptyMap];
#    foreach [inParsedComponentStruct mParsedSemanticsComponentMap] do
#      abstractCategoryReaderListMap .= [[mRoot mSemanticDeclarations] mAbstractCategoryReaderListMap] ;
#      overridingCategoryReaderListMap .= [[mRoot mSemanticDeclarations] mOverridingCategoryReaderListMap] ;
#    end foreach ;
#    @descendantClassListMapEX descendantClassListMap := [semanticContext mDescendantClassListMap] ;
#    foreach abstractCategoryReaderListMap do
#      foreach object do
#        checkCategoryReaderDefinitionForClass
#          !key
#          !key
#          !mAbstractCategoryReaderName
#          !descendantClassListMap
#          !overridingCategoryReaderListMap
#        ;
#      end foreach ;
#    end foreach ;
#  end if ;
end routine ;

#------------------------------------------------------------------------------*
#                                                                              *
#   PROJECT                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

listmap @targetFileListMap (@stringlist) ;

#------------------------------------------------------------------------------*

map @sourceFileMap {
  @string mFullPath ;
  @sourceFileKind mSourceKind ;
  insert insertKey error message "the '%K' source base name has been already declared in %L" ;
  search searchKey error message "the '%K' source base name is not declared" ;
}

#------------------------------------------------------------------------------*

filewrapper fileListTemplateFileWrapper in "../generation_templates/file_list_template" {
 "mke"
} {
#--- Project
  template fileListTemplate "/file_list_template.mke.gTemplate"
    ?@string HAND_CODED_SOURCES_SUB_DIRS
    ?@string GALGAS_SOURCE_LIST
    ?@string HAND_CODED_SOURCE_LIST
  ;
}

#---------------------------------------------------------------------------*

end semantics ;

#---------------------------------------------------------------------------*
