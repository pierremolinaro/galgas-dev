#---------------------------------------------------------------------------*
#                                                                           *
#  'metamodel' component parser, as model builder                           *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodelModelBuilder :
import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import metamodel metamodelMetamodel in "metamodelMetamodel.gMetamodel" ;

nonterminal <metamodel_component_start_symbol>
  !@location outEndOfSourceFile
-> @metamodelComponentRoot ;

nonterminal <entity_declaration> -> @metamodelEntity ;

nonterminal <component_importation> ?!@lstringlist ioImportedComponentList ;

nonterminal <attribute_or_single_reference_declaration> ??@lstring inPropertyTypeName -> @metamodelProperty ;

nonterminal <multiple_reference_declaration> ??@lstring inPropertyTypeName -> @metamodelMultipleReference ;

#---------------------------------------------------------------------------*

rule <metamodel_component_start_symbol>
  !@location outEndOfSourceFile
-> @metamodelComponentRoot :
  mSuperMetamodels := [@lstringlist emptyList] ;
  select
    $metamodel$ ;
  #--- Metamodel Component Name
    $identifier$ ? mMetamodelComponentName ;
  #--- Super metamodels
    select
    or
      $extends$ ;
      repeat
        @lstring superMetamodelName ;
        $identifier$ ? superMetamodelName ;
        mSuperMetamodels += !superMetamodelName ;
      while
        $,$ ;
      end repeat ;
    end select ;
  #--- Root Entity
    $root$ ;
    $type_name$ ? mMetamodelRootEntityName ;
  or
    $abstract$ ;
    $metamodel$ ;
  #--- Metamodel Component Name
    $identifier$ ? mMetamodelComponentName ;
  #--- Super metamodels
    select
    or
      $extends$ ;
      repeat
        @lstring superMetamodelName ;
        $identifier$ ? superMetamodelName ;
        mSuperMetamodels += !superMetamodelName ;
      while
        $,$ ;
      end repeat ;
    end select ;
  #--- No Root Entity
    mMetamodelRootEntityName := [@lstring new !"" !here] ;
  end select ;
  $:$ ;
#--- Parse entities and import
  mMetamodelImportedComponents := [@lstringlist emptyList] ;
  repeat
  while 
    <entity_declaration> +> mMetamodelEntities ;
  while 
    <component_importation> !?mMetamodelImportedComponents ;
  end repeat ;
  $end$ ;
  $metamodel$ ;
  outEndOfSourceFile := here ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <component_importation> ?!@lstringlist ioImportedComponentList :
  $import$ ;
  repeat
    select
      @lstring importedComponentFileName ;
      $literal_string$ ? importedComponentFileName ;
      ioImportedComponentList += !importedComponentFileName ;
    or
      $semantics$ ;
      $identifier$ ?* ;
      $in$ ;
      $literal_string$ ?* ;
    or
      $metamodel$ ;
      $identifier$ ?* ;
      $in$ ;
      $literal_string$ ?* ;
    end select ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <entity_declaration> -> @metamodelEntity :
#--- Entity header
  select
    mIsAbstract := false ;
  or
   $abstract$ ;
    mIsAbstract := true ;
  end select ;
#---
  $entity$ ;
  mEntityNameList := [@lstringlist emptyList] ;
  repeat
    @lstring entityName ;
    $type_name$ ? entityName  ;
    mEntityNameList += !entityName ;
  while
    $,$ ;
  end repeat ;
#--- Super entity
  select
    mSuperEntityName := [@lstring new !"" !here] ;
  or
    $extends$ ;
    $type_name$ ? mSuperEntityName  ;
  end select ;
#--- Properties
  ${$ ;
  repeat
  while
    @lstring propertyTypeName ;
    $type_name$ ? propertyTypeName ;
    select
      <attribute_or_single_reference_declaration> !propertyTypeName +> mProperties ;
    or
      $[$ ;
      <multiple_reference_declaration> !propertyTypeName +> mProperties ;
    end select ;
    $;$ ;
  end repeat ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <attribute_or_single_reference_declaration> ??@lstring inPropertyTypeName -> @metamodelProperty :
  mAttributeTypeName := inPropertyTypeName ;
  $identifier$ ? mAttributeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <multiple_reference_declaration> ??@lstring inPropertyTypeName -> @metamodelMultipleReference :
  select # [] equivalent to [0, 0]
    mLowerBound := 0 ;
    mUpperBound := 0 ;
  or
    @luint lowerBound ;
    $unsigned_literal_integer$ ? lowerBound ;
    mLowerBound := [lowerBound uint] ;
    select # [n] equivalent to [n, n], with n > 0
      mUpperBound := mLowerBound ;
      if mLowerBound == 0 then
        error lowerBound: "multiplicity should be greater than zero" ;
      end if ;
    or # [n, p], and p >= n ; [0, 0] forbidden
      $,$ ;
      select
        @luint upperBound ;
        $unsigned_literal_integer$ ? upperBound ;
        mUpperBound := [upperBound uint] ;
        if mUpperBound < mLowerBound then
          error upperBound: "upper bound should be greater or equal to lower bound" ;
        elsif (mUpperBound == 0) & (mLowerBound == 0) then
          error upperBound: "lower bound and upper bound should not to be both zero" ;
        end if ;
      or # [n, *]
        $*$ ;
        mUpperBound := 0 ;
      end select ;
    end select ;
  end select ;
  $]$ ;
  mAttributeTypeName := inPropertyTypeName ;
  $identifier$ ? mAttributeName ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
