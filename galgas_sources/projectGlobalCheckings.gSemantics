#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS LL1 routines                                                      *
#                                                                           *
#  Copyright (C) 2007, ..., 2013 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics projectGlobalCheckings :
  import "semanticsCompilation.gSemantics" ;
  import "predefinedTypes.gSemantics" ;
  import "projectMetamodel.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#        M U L T I - M E T H O D   L I S T M A P                            *
#                                                                           *
#---------------------------------------------------------------------------*

listmap @genericCategoryMethodListMap (@lstringlist) ;

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    M U L T I - M E T H O D S    L I S M A P S                  *
#                                                                           *
#---------------------------------------------------------------------------*

method @semanticDeclarationAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryModifierAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioAbstractCategoryModifierListMapAST +=
    ![mTypeName string]
    !mAbstractCategoryModifierName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @categoryModifierAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioCategoryModifierListMap +=
    ![mTypeName string]
    !mCategoryModifierName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingCategoryModifierAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioOverridingCategoryModifierListMap +=
    ![mTypeName string]
    !mOverridingCategoryModifierName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingAbstractCategoryModifierAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioOverridingAbstractCategoryModifierListMap +=
    ![mTypeName string]
    !mOverridingCategoryModifierName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryMethodAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioAbstractCategoryMethodListMapAST +=
    ![mTypeName string]
    !mAbstractCategoryMethodName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @categoryMethodAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioCategoryMethodListMap +=
    ![mTypeName string]
    !mCategoryMethodName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingCategoryMethodAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioOverridingCategoryMethodListMap +=
    ![mTypeName string]
    !mOverridingCategoryMethodName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingAbstractCategoryMethodAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioOverridingAbstractCategoryMethodListMap +=
    ![mTypeName string]
    !mOverridingCategoryMethodName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryReaderAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioAbstractCategoryReaderListMap +=
    ![mTypeName string]
    !mAbstractCategoryReaderName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @categoryReaderAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioCategoryReaderListMap +=
    ![mTypeName string]
    !mCategoryReaderName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingCategoryReaderAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryReaderListMap
:
  ioOverridingCategoryReaderListMap +=
    ![mTypeName string]
    !mOverridingCategoryReaderName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingAbstractCategoryReaderAST buildCategoryListMaps
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryModifierListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryModifierListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryMethodListMapAST
  ?!@genericCategoryMethodListMap unused ioCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioOverridingAbstractCategoryMethodListMap
  ?!@genericCategoryMethodListMap unused ioAbstractCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioCategoryReaderListMap
  ?!@genericCategoryMethodListMap unused ioOverridingCategoryReaderListMap
  ?!@genericCategoryMethodListMap ioOverridingAbstractCategoryReaderListMap
:
  ioOverridingAbstractCategoryReaderListMap +=
    ![mTypeName string]
    !mAbstractCategoryReaderName
  ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#    D E S C E N D A N T    C L A S S    L I S T M A P                      *
#                                                                           *
#---------------------------------------------------------------------------*

listmap @descendantClassListMap (@unifiedTypeMapProxyList) ;

#---------------------------------------------------------------------------*
#                                                                           *
#  C A T E G O R Y    M E T H O D    M A P                                  *
#                                                                           *
# Used for checking a category-method is defined once for a type            *
#---------------------------------------------------------------------------*

map @categoryMethodMapForGlobalCheckings {
  insert insertKey error message "the '%K' category method is already declared in %L" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C A T E G O R Y    M O D I F I E R    M A P                              *
#                                                                           *
# Used for checking a category-modifier is defined once for a type          *
#---------------------------------------------------------------------------*

map @categoryModifierMapForGlobalCheckings {
  insert insertKey error message "the '%K' category modifier is already declared in %L" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  C A T E G O R Y    R E A D E R    M A P                                  *
#                                                                           *
# Used for checking a category-method is defined once for a type            *
#---------------------------------------------------------------------------*

map @categoryReaderMapForGlobalCheckings {
  insert insertKey error message "the '%K' category reader is already declared in %L" ;
}

#---------------------------------------------------------------------------*

function outputDirectory
  ??@lstring inSourceFile
->
  @string outOuputDirectory
:
  if [inSourceFile characterAtIndex !0] == '/' then
    outOuputDirectory := [inSourceFile stringByDeletingLastPathComponent] ;
    outOuputDirectory .= "/GALGAS_OUTPUT" ;
  else
    outOuputDirectory := "GALGAS_OUTPUT" ;
  end if ;
end function ;

#---------------------------------------------------------------------------*

local routine checkCategoryModifierDefinitionForClass
  ??@string inClassNameForErrorSignaling
  ??@string inClassName
  ??@lstring inAbstractCategoryModifierName
  ??@descendantClassListMap inDescendantClassListMap
  ??@genericCategoryMethodListMap inOverridingCategoryMethodListMap
  ??@unifiedTypeMap inUnifiedTypeMap
:
  const @unifiedTypeMapProxyList descendantClasses := [inDescendantClassListMap listForKey !inClassName] ;
  foreach descendantClasses do
    const @lstring descendantClassName := [mType lkey] ;
    @lstringlist overridingMethods := [inOverridingCategoryMethodListMap listForKey ![descendantClassName string]] ;
    @bool found := false ;
    foreach overridingMethods while not found do
      found := [inAbstractCategoryModifierName string] == [mValue string] ;
    end foreach ;
    if not found then
      if not [mType mIsConcrete] then
        checkCategoryModifierDefinitionForClass
          !inClassNameForErrorSignaling
          ![descendantClassName string]
          !inAbstractCategoryModifierName
          !inDescendantClassListMap
          !inOverridingCategoryMethodListMap
          !inUnifiedTypeMap
        ;
      else
        error inAbstractCategoryModifierName: "an abstract category method '" . inAbstractCategoryModifierName . "' is defined for abstract class '@"
        . inClassNameForErrorSignaling
        . "', but concrete descendant class '@" . descendantClassName . "' does not implement this method" ; 
      end if ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

local routine checkCategoryMethodDefinitionForClass
  ??@string inClassNameForErrorSignaling
  ??@string inClassName
  ??@lstring inAbstractCategoryMethodName
  ??@descendantClassListMap inDescendantClassListMap
  ??@genericCategoryMethodListMap inOverridingCategoryMethodListMap
  ??@unifiedTypeMap inUnifiedTypeMap
:
  const @unifiedTypeMapProxyList descendantClasses := [inDescendantClassListMap listForKey !inClassName] ;
  foreach descendantClasses do
    const @lstring descendantClassName := [mType lkey] ;
    @lstringlist overridingMethods := [inOverridingCategoryMethodListMap listForKey ![descendantClassName string]] ;
    @bool found := false ;
    foreach overridingMethods while not found do
      found := [inAbstractCategoryMethodName string] == [mValue string] ;
    end foreach ;
    if not found then
      if not [mType mIsConcrete] then
        checkCategoryMethodDefinitionForClass
          !inClassNameForErrorSignaling
          ![descendantClassName string]
          !inAbstractCategoryMethodName
          !inDescendantClassListMap
          !inOverridingCategoryMethodListMap
          !inUnifiedTypeMap
        ;
      else
        error inAbstractCategoryMethodName: "an abstract category method '" . inAbstractCategoryMethodName . "' is defined for abstract class '@"
        . inClassNameForErrorSignaling
        . "', but concrete descendant class '@" . descendantClassName . "' does not implement this method" ; 
      end if ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

local routine checkCategoryReaderDefinitionForClass
  ??@string inClassNameForErrorSignaling
  ??@string inClassName
  ??@lstring inAbstractCategoryReaderName
  ??@descendantClassListMap inDescendantClassListMap
  ??@genericCategoryMethodListMap inOverridingCategoryReaderListMap
  ??@unifiedTypeMap inUnifiedTypeMap
:
  const @unifiedTypeMapProxyList descendantClasses := [inDescendantClassListMap listForKey !inClassName] ;
  foreach descendantClasses do
    @lstring descendantClassName := [mType lkey] ;
    @lstringlist overridingReaders := [inOverridingCategoryReaderListMap listForKey ![descendantClassName string]] ;
    @bool found := false ;
    foreach overridingReaders while not found do
      found := [inAbstractCategoryReaderName string] == [mValue string] ;
    end foreach ;
    if not found then
      if not [mType mIsConcrete] then
        checkCategoryReaderDefinitionForClass
          !inClassNameForErrorSignaling
          ![descendantClassName string]
          !inAbstractCategoryReaderName
          !inDescendantClassListMap
          !inOverridingCategoryReaderListMap
          !inUnifiedTypeMap
        ;
      else
        error inAbstractCategoryReaderName: "an abstract category reader '" . inAbstractCategoryReaderName . "' is defined for abstract class '@"
        . inClassNameForErrorSignaling
        . "', but concrete descendant class '@" . descendantClassName . "' does not implement this reader" ; 
      end if ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine performProjectGlobalCheckings
  ??@parsedComponentStruct inParsedComponentStruct
  ??@string inProjectSourceFilePath
  ??@location inEndOfSourceFile
:
  @semanticDeclarationListAST semanticDeclarationList [emptyList] ;
#------ Add predefined types to semantics declarations
  appendPredefinedTypesASTs !?semanticDeclarationList ;
#--- Build all declaration list
  foreach [inParsedComponentStruct mParsedSemanticsComponentMap] do
    semanticDeclarationList .= [mSemanticComponentRoot mSemanticDeclarationList] ;
  end foreach ;
  foreach [inParsedComponentStruct mParsedSyntaxComponentMap] do
    semanticDeclarationList .= [mSyntaxComponentRoot mSemanticDeclarationList] ;
  end foreach ;
  foreach [inParsedComponentStruct mParsedProgramComponentMap] do
    semanticDeclarationList .= [mProgramComponentAST mSemanticDeclarationList] ;
  end foreach ;
#------ Generate declarations
  buildSemanticContext
    !""
    !semanticDeclarationList
    !inEndOfSourceFile
    ??@semanticContext semanticContext
  ;
#------ Build descendant type list map
# For every type, a list of its directed descendants is associated
  @descendantClassListMap descendantClassListMap [emptyMap] ;
  foreach semanticContext->mTypeMap do
     if not [mSuperType isNull] then
       descendantClassListMap +=
         ![mSuperType key]
         ![@unifiedTypeMapProxy searchKey !semanticContext->mTypeMap !lkey]
       ;
     end if ;
  end foreach ;
#--- Build Category method listmaps
  @genericCategoryMethodListMap abstractCategoryMethodListMap [emptyMap] ;
  @genericCategoryMethodListMap categoryMethodListMap [emptyMap] ;
  @genericCategoryMethodListMap overridingCategoryMethodListMap [emptyMap];
  @genericCategoryMethodListMap overridingAbstractCategoryMethodListMap [emptyMap];
  @genericCategoryMethodListMap abstractCategoryReaderListMap [emptyMap] ;
  @genericCategoryMethodListMap categoryReaderListMap [emptyMap] ;
  @genericCategoryMethodListMap overridingCategoryReaderListMap [emptyMap];
  @genericCategoryMethodListMap overridingAbstractCategoryReaderListMap [emptyMap] ;
  @genericCategoryMethodListMap abstractCategoryModifierListMap [emptyMap] ;
  @genericCategoryMethodListMap categoryModifierListMap [emptyMap] ;
  @genericCategoryMethodListMap overridingCategoryModifierListMap [emptyMap] ;
  @genericCategoryMethodListMap overridingAbstractCategoryModifierListMap [emptyMap] ;
  foreach semanticDeclarationList do
    [mSemanticDeclaration buildCategoryListMaps
      !?abstractCategoryModifierListMap
      !?categoryModifierListMap
      !?overridingCategoryModifierListMap
      !?overridingAbstractCategoryModifierListMap
      !?abstractCategoryMethodListMap
      !?categoryMethodListMap
      !?overridingCategoryMethodListMap
      !?overridingAbstractCategoryMethodListMap
      !?abstractCategoryReaderListMap
      !?categoryReaderListMap
      !?overridingCategoryReaderListMap
      !?overridingAbstractCategoryReaderListMap
    ] ;
  end foreach ;
#------ Check Category
  if [@uint errorCount] == 0 then
  #--- A given abstract category modifier is defined only once for a class
    foreach abstractCategoryModifierListMap do
      @categoryModifierMapForGlobalCheckings categoryModifierMap [emptyMap] ;
      foreach mList do
        [!?categoryModifierMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given base category modifier is defined only once for a class
    foreach categoryModifierListMap do
      @categoryModifierMapForGlobalCheckings categoryModifierMap [emptyMap] ;
      foreach mList do
        [!?categoryModifierMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given overriding category modifier is defined only once for a class
    foreach overridingCategoryModifierListMap do
      @categoryModifierMapForGlobalCheckings categoryModifierMap [emptyMap] ;
      foreach mList do
        [!?categoryModifierMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given overriding abstract category modifier is defined only once for a class
    foreach overridingAbstractCategoryMethodListMap do
      @categoryModifierMapForGlobalCheckings categoryModifierMap [emptyMap] ;
      foreach mList do
        [!?categoryModifierMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #------ Check that for every abstract category modifier, an overridden category modifier defined in an concrete subclass
    foreach abstractCategoryModifierListMap do
      foreach mList do
        checkCategoryModifierDefinitionForClass
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingCategoryModifierListMap
          !semanticContext->mTypeMap
        ;
      end foreach ;
    end foreach ;
  #------ Check that for every overriding abstract category modifier, an overridden category modifier defined in an concrete subclass
    foreach overridingAbstractCategoryModifierListMap do
      foreach mList do
        checkCategoryModifierDefinitionForClass
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingCategoryModifierListMap
          !semanticContext->mTypeMap
        ;
      end foreach ;
    end foreach ;
  #--- A given abstract category method is defined only once for a class
    foreach abstractCategoryMethodListMap do
      @categoryMethodMapForGlobalCheckings categoryMethodMap [emptyMap] ;
      foreach mList do
        [!?categoryMethodMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given base category method is defined only once for a class
    foreach categoryMethodListMap do
      @categoryMethodMapForGlobalCheckings categoryMethodMap [emptyMap] ;
      foreach mList do
        [!?categoryMethodMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given overriding category method is defined only once for a class
    foreach overridingCategoryMethodListMap do
      @categoryMethodMapForGlobalCheckings categoryMethodMap [emptyMap] ;
      foreach mList do
        [!?categoryMethodMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given overriding abstract category method is defined only once for a class
    foreach overridingAbstractCategoryMethodListMap do
      @categoryMethodMapForGlobalCheckings categoryMethodMap [emptyMap] ;
      foreach mList do
        [!?categoryMethodMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #------ Check that for every abstract category method, an overridden category method defined in an concrete subclass
    foreach abstractCategoryMethodListMap do
      foreach mList do
        checkCategoryMethodDefinitionForClass
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingCategoryMethodListMap
          !semanticContext->mTypeMap
        ;
      end foreach ;
    end foreach ;
  #------ Check that for every abstract category method, an overridden category method defined in an concrete subclass
    foreach overridingAbstractCategoryMethodListMap do
      foreach mList do
        checkCategoryMethodDefinitionForClass
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingCategoryMethodListMap
          !semanticContext->mTypeMap
        ;
      end foreach ;
    end foreach ;
  #------ Check Category readers
##--- Check that for every abstract category reader, an overridden category reader
##    defined in an concrete subclass
  #--- A given abstract category reader is defined only once for a class
    foreach abstractCategoryReaderListMap do
      @categoryReaderMapForGlobalCheckings CategoryReaderMap [emptyMap] ;
      foreach mList do
        [!?CategoryReaderMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given base category reader is defined only once for a class
    foreach categoryReaderListMap do
      @categoryReaderMapForGlobalCheckings CategoryReaderMap [emptyMap] ;
      foreach mList do
        [!?CategoryReaderMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given overriding category reader is defined only once for a class
    foreach overridingCategoryReaderListMap do
      @categoryReaderMapForGlobalCheckings CategoryReaderMap [emptyMap] ;
      foreach mList do
        [!?CategoryReaderMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- Check every abstract category reader is implemented by every inherited concrete type
    foreach abstractCategoryReaderListMap do
      foreach mList do
        checkCategoryReaderDefinitionForClass
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingCategoryReaderListMap
          !semanticContext->mTypeMap
        ;
      end foreach ;
    end foreach ;
  #--- Check every abstract category reader is implemented by every inherited concrete type
    foreach overridingAbstractCategoryReaderListMap do
      foreach mList do
        checkCategoryReaderDefinitionForClass
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingCategoryReaderListMap
          !semanticContext->mTypeMap
        ;
      end foreach ;
    end foreach ;
  end if ;
#--- Build a text file that contains all declared types
  @string typeDumpString := [[semanticContext->mTypeMap count] string] . " types.\n\n" ;
  foreach semanticContext->mTypeMap : type_ do
    typeDumpString .= "TYPE --------- @" . type_lkey . " ------------\n\n" ;
  #--- Kind
    typeDumpString .= "Kind: " ;
    if not type_mIsConcrete then
      typeDumpString .= "abstract " ;
    end if ;
    switch type_mTypeKindEnum
    when classType : typeDumpString .= "class" ;
    when enumType : typeDumpString .= "enum" ;
    when listType : typeDumpString .= "list" ;
    when sortedListType : typeDumpString .= "sorted list" ;
    when mapType : typeDumpString .= "map" ;
    when uniqueMapType : typeDumpString .= "unique map" ;
    when mapProxyType : typeDumpString .= "map proxy" ;
    when listMapType : typeDumpString .= "list map" ;
    when structType : typeDumpString .= "struct" ;
    when graphType : typeDumpString .= "graph" ;
    when predefinedType : typeDumpString .= "predefined type" ;
    end switch ;
    typeDumpString .= "\n" ;
    if not [type_mSuperType isNull] then
      typeDumpString .= "Superclass: @" . [type_mSuperType key] . "\n" ;  
    end if ;
    typeDumpString .= "\n" ;
  #--- Handled operators
    typeDumpString .= "Handled operators\n" ;
    if (type_mHandledOperatorFlags & binaryAddOperator []) != 0 then
      typeDumpString .= "  addition: @" . type_lkey . " + @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binarySubOperator []) != 0 then
      typeDumpString .= "  substraction: @" . type_lkey . " - @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binaryMulOperator []) != 0 then
      typeDumpString .= "  multiplication: @" . type_lkey . " * @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binaryDivOperator []) != 0 then
      typeDumpString .= "  division: @" . type_lkey . " / @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binaryModOperator []) != 0 then
      typeDumpString .= "  modulo: @" . type_lkey . " mod @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binaryShiftOperator []) != 0 then
      typeDumpString .= "  left shift: @" . type_lkey . " << @uint -> @" . type_lkey . "\n" ;
      typeDumpString .= "  right shift: @" . type_lkey . " >> @uint -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & unaryPlusOperator []) != 0 then
      typeDumpString .= "  unary +: + @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & unaryMinusOperator []) != 0 then
      typeDumpString .= "  unary -: - @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & unaryTildeOperator []) != 0 then
      typeDumpString .= "  bit wise negation: ~ @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binaryAndOperator []) != 0 then
      typeDumpString .= "  boolean and: @" . type_lkey . " & @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binaryOrOperator []) != 0 then
      typeDumpString .= "  inclusive or: @" . type_lkey . " | @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binaryXorOperator []) != 0 then
      typeDumpString .= "  exclusive or: @" . type_lkey . " ^ @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & unaryNotOperator []) != 0 then
      typeDumpString .= "  boolean negation: not @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    typeDumpString .= "  equality test: @" . type_lkey . " == @" . type_lkey . " -> @bool\n" ;
    typeDumpString .= "  inequality test: @" . type_lkey . " != @" . type_lkey . " -> @bool\n" ;
    if (type_mHandledOperatorFlags & isComparable []) != 0 then
      typeDumpString .= "  lower than test: @" . type_lkey . " < @" . type_lkey . " -> @bool\n" ;
      typeDumpString .= "  lower or equal test: @" . type_lkey . " <= @" . type_lkey . " -> @bool\n" ;
      typeDumpString .= "  greater than test: @" . type_lkey . " > @" . type_lkey . " -> @bool\n" ;
      typeDumpString .= "  greater or equal test: @" . type_lkey . " >= @" . type_lkey . " -> @bool\n" ;
    end if ;
    if (type_mHandledOperatorFlags & binaryConcatOperator []) != 0 then
      typeDumpString .= "  concatenation: @" . type_lkey . " . @" . type_lkey . " -> @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & dotAssignOperator []) != 0 then
      typeDumpString .= "  appending instruction: @" . type_lkey . " .= @" . type_lkey . "\n" ;
    end if ;
    if (type_mHandledOperatorFlags & incDecOperator []) != 0 then
      typeDumpString .= "  incrementation instruction: @" . type_lkey . " ++\n" ;
      typeDumpString .= "  decrementation instruction: @" . type_lkey . " --\n" ;
    end if ;
    typeDumpString .= "\n" ;
  #--- += Operator arguments
    foreach type_mAddAssignOperatorArguments
    before
      typeDumpString .= "+= instruction arguments:\n" ;
    do
      typeDumpString .= "  @" . [mType key] . "\n" ;
    after
      typeDumpString .= "\n" ;
    end foreach ;
  #--- Enumeration by foreach
    foreach type_mEnumerationDescriptor
    before
      typeDumpString .= "foreach instruction enumeration constants:\n" ;
    do
      typeDumpString .= "  @" . [mEnumeratedType key] . " " . mEnumerationName . "\n" ;
    after
      typeDumpString .= "\n" ;
    end foreach ;
  #--- Enumeration by for
    if not [type_mTypeForEnumeratedElement isNull] then
      typeDumpString .= "for instruction enumeration type: @" . [type_mTypeForEnumeratedElement key] . "\n\n" ;
    end if ;
  #--- Constructors
    foreach type_mConstructorMap
    before
      typeDumpString .= "Constructors:\n" ;
    do
      typeDumpString .= "  constructor " . lkey ;
      foreach mArgumentTypeList do
        typeDumpString .= " ?@" . [mType key] ;
      end foreach ;
      typeDumpString .= " -> @" . [mReturnedType key] . " ;\n" ;
    after
      typeDumpString .= "\n" ;
    end foreach ;
  #--- Readers
    foreach type_mReaderMap
    before
      typeDumpString .= "Readers:\n" ;
    do
      typeDumpString .= "  " ;
      switch mKind
      when definedAsMember :
      when definedAsCategory : typeDumpString .= "(category) " ;
      end switch ;
      switch mQualifier
      when isAbstract : typeDumpString .= "abstract " ;
      when isBasic :
      when isBasicFinal :
      when isInherited :
      when isOverriding : typeDumpString .= "override " ;
      when isOverridingAbstract : typeDumpString .= "abstract override " ;
      end switch ;
      typeDumpString .= "reader " . lkey ;
      foreach mArgumentTypeList do
        typeDumpString .= " ?@" . [mType key] ;
      end foreach ;
      typeDumpString .= " -> @" . [mReturnedType key] . " ;\n" ;
    after
      typeDumpString .= "\n" ;
    end foreach ;
  #--- Methods
    foreach type_mInstanceMethodMap
    before
      typeDumpString .= "Methods:\n" ;
    do
      typeDumpString .= "  " ;
      switch mKind
      when definedAsMember :
      when definedAsCategory : typeDumpString .= "(category) " ;
      end switch ;
      switch mQualifier
      when isAbstract : typeDumpString .= "abstract " ;
      when isBasic :
      when isBasicFinal :
      when isInherited :
      when isOverriding : typeDumpString .= "override " ;
      when isOverridingAbstract : typeDumpString .= "abstract override " ;
      end switch ;
      typeDumpString .= "method " . lkey ;
      foreach mParameterList do
        switch mFormalArgumentPassingMode
        when argumentConstantIn : typeDumpString .= " ??" ;
        when argumentIn         : typeDumpString .= " ?" ;
        when argumentInOut      : typeDumpString .= " ?!" ;
        when argumentOut        : typeDumpString .= " !" ;
        end switch ;
        typeDumpString .= "@" . [mFormalArgumentType key] ;
      end foreach ;
      typeDumpString .= " ;\n" ;
    after
      typeDumpString .= "\n" ;
    end foreach ;
  #--- Modifiers
    foreach type_mModifierMap
    before
      typeDumpString .= "Modifiers:\n" ;
    do
      typeDumpString .= "  " ;
      switch mKind
      when definedAsMember :
      when definedAsCategory : typeDumpString .= "(category) " ;
      end switch ;
      switch mQualifier
      when isAbstract : typeDumpString .= "abstract " ;
      when isBasic :
      when isBasicFinal :
      when isInherited :
      when isOverriding : typeDumpString .= "override " ;
      when isOverridingAbstract : typeDumpString .= "abstract override " ;
      end switch ;
      typeDumpString .= "modifier " . lkey ;
      foreach mParameterList do
        switch mFormalArgumentPassingMode
        when argumentConstantIn : typeDumpString .= " ??" ;
        when argumentIn         : typeDumpString .= " ?" ;
        when argumentInOut      : typeDumpString .= " ?!" ;
        when argumentOut        : typeDumpString .= " !" ;
        end switch ;
        typeDumpString .= "@" . [mFormalArgumentType key] ;
      end foreach ;
      typeDumpString .= " ;\n" ;
    after
      typeDumpString .= "\n" ;
    end foreach ;
  #--- class methods
    foreach type_mClassMethodMap
    before
      typeDumpString .= "Class methods:\n" ;
    do
      typeDumpString .= "  class method " . lkey ;
      foreach mParameterList do
        switch mFormalArgumentPassingMode
        when argumentConstantIn : typeDumpString .= " ??" ;
        when argumentIn         : typeDumpString .= " ?" ;
        when argumentInOut      : typeDumpString .= " ?!" ;
        when argumentOut        : typeDumpString .= " !" ;
        end switch ;
        typeDumpString .= "@" . [mFormalArgumentType key] ;
      end foreach ;
      typeDumpString .= " ;\n" ;
    after
      typeDumpString .= "\n" ;
    end foreach ;
  end foreach ;
#--- Write file
  const @string typeDumpFilePath := inProjectSourceFilePath . ".txt" ;
  [typeDumpString writeToFileWhenDifferentContents !typeDumpFilePath ?*] ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;

#---------------------------------------------------------------------------*
