#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS LL1 routines                                                      *
#                                                                           *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics projectGlobalCheckings :
  import "semanticsCompilation.gSemantics" ;
  import "predefinedTypes.gSemantics" ;
  import "projectMetamodel.gSemantics" ;

  import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
  import semantics optionSemantics in "optionSemantics.gSemantics" ;
  import semantics semantics_semantics in "semantics_semantics.gSemantics" ;
  import semantics grammarMetamodel in "grammarMetamodel.gSemantics" ;
  import semantics optionTypesForAST in "optionTypesForAST.gSemantics" ;
  import semantics semanticsTypesForAST in "semanticsTypesForAST.gSemantics" ;
  import semantics syntaxMetamodel in "syntaxMetamodel.gSemantics" ;
  import semantics programMetamodel in "programMetamodel.gSemantics" ;
  import semantics semanticsCompilation in "semanticsCompilation.gSemantics" ;
  import semantics predefinedTypes in "predefinedTypes.gSemantics" ;
  import semantics projectMetamodel in "projectMetamodel.gSemantics" ;

  import grammar galgas_LL1_grammar in "galgas_LL1_grammar.gGrammar" ;
  import grammar optionLL1grammar in "optionLL1grammar.gGrammar" ;
  import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;
  import grammar grammarLL1grammar in "grammarLL1grammar.gGrammar" ;
  import grammar programSLRgrammar in "programSLRgrammar.gGrammar" ;
  import grammar projectLL1grammar in "projectLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#        M U L T I - M E T H O D   L I S T M A P                            *
#                                                                           *
#---------------------------------------------------------------------------*

listmap @genericMultiMethodListMap (@lstringlist) ;

#---------------------------------------------------------------------------*
#                                                                           *
#  B U I L D    M U L T I - M E T H O D S    L I S M A P S                  *
#                                                                           *
#---------------------------------------------------------------------------*

method @semanticDeclarationAST buildMultiMethodListMaps
  ?!@genericMultiMethodListMap unused ioAbstractMultiMethodListMapAST
  ?!@genericMultiMethodListMap unused ioMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioAbstractMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiReaderListMap
:
end method ;

#---------------------------------------------------------------------------*

override method @abstracMultiMethodAST buildMultiMethodListMaps
  ?!@genericMultiMethodListMap ioAbstractMultiMethodListMapAST
  ?!@genericMultiMethodListMap unused ioMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioAbstractMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiReaderListMap
:
  ioAbstractMultiMethodListMapAST +=
    ![mTypeName string]
    !mAbstractMultiMethodName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @multiMethodAST buildMultiMethodListMaps
  ?!@genericMultiMethodListMap unused ioAbstractMultiMethodListMapAST
  ?!@genericMultiMethodListMap ioMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioAbstractMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiReaderListMap
:
  ioMultiMethodListMap +=
    ![mTypeName string]
    !mMultiMethodName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingMultiMethodAST buildMultiMethodListMaps
  ?!@genericMultiMethodListMap unused ioAbstractMultiMethodListMapAST
  ?!@genericMultiMethodListMap unused ioMultiMethodListMap
  ?!@genericMultiMethodListMap ioOverridingMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioAbstractMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiReaderListMap
:
  ioOverridingMultiMethodListMap +=
    ![mTypeName string]
    !mOverridingMultiMethodMethodName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @abstractMultiReaderAST buildMultiMethodListMaps
  ?!@genericMultiMethodListMap unused ioAbstractMultiMethodListMapAST
  ?!@genericMultiMethodListMap unused ioMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiMethodListMap
  ?!@genericMultiMethodListMap ioAbstractMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiReaderListMap
:
  ioAbstractMultiReaderListMap +=
    ![mTypeName string]
    !mAbstractMultiReaderName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @multiReaderAST buildMultiMethodListMaps
  ?!@genericMultiMethodListMap unused ioAbstractMultiMethodListMapAST
  ?!@genericMultiMethodListMap unused ioMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioAbstractMultiReaderListMap
  ?!@genericMultiMethodListMap ioMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiReaderListMap
:
  ioMultiReaderListMap +=
    ![mTypeName string]
    !mMultiReaderName
  ;
end method ;

#---------------------------------------------------------------------------*

override method @overridingMultiReaderAST buildMultiMethodListMaps
  ?!@genericMultiMethodListMap unused ioAbstractMultiMethodListMapAST
  ?!@genericMultiMethodListMap unused ioMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioOverridingMultiMethodListMap
  ?!@genericMultiMethodListMap unused ioAbstractMultiReaderListMap
  ?!@genericMultiMethodListMap unused ioMultiReaderListMap
  ?!@genericMultiMethodListMap ioOverridingMultiReaderListMap
:
  ioOverridingMultiReaderListMap +=
    ![mTypeName string]
    !mOverridingMultiReaderName
  ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#    D E S C E N D A N T    C L A S S    L I S T M A P                      *
#                                                                           *
#---------------------------------------------------------------------------*

listmap @descendantClassListMap (@unifiedTypeMapProxyList) ;

#---------------------------------------------------------------------------*
#                                                                           *
#  M U L T I    M E T H O D    M A P                                        *
#                                                                           *
# Used for checking a multi-method is defined once for a type               *
#---------------------------------------------------------------------------*

map @multiMethodMap {
  insert insertKey error message "the '%K' multi method is already declared in %L" ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#  M U L T I    R E A D E R    M A P                                        *
#                                                                           *
# Used for checking a multi-method is defined once for a type               *
#---------------------------------------------------------------------------*

map @multiReaderMap {
  insert insertKey error message "the '%K' multi reader is already declared in %L" ;
}

#---------------------------------------------------------------------------*

function outputDirectory
  ??@lstring inSourceFile
->
  @string outOuputDirectory
:
  if [inSourceFile characterAtIndex !0] == '/' then
    outOuputDirectory := [inSourceFile stringByDeletingLastPathComponent] ;
    outOuputDirectory .= "/GALGAS_OUTPUT" ;
  else
    outOuputDirectory := "GALGAS_OUTPUT" ;
  end if ;
end function ;

#---------------------------------------------------------------------------*

routine checkMultiMethodDefinitionForClass
  ??@string inClassNameForErrorSignaling
  ??@string inClassName
  ??@lstring inAbstractMultiMethodName
  ??@descendantClassListMap inDescendantClassListMap
  ??@genericMultiMethodListMap inOverridingMultiMethodListMap
  ??@unifiedTypeMap inUnifiedTypeMap
:
  const @unifiedTypeMapProxyList descendantClasses := [inDescendantClassListMap listForKey !inClassName] ;
  foreach descendantClasses do
    const @lstring descendantClassName := [mType lkey] ;
    @lstringlist overridingMethods := [inOverridingMultiMethodListMap listForKey ![descendantClassName string]] ;
    @bool found := false ;
    foreach overridingMethods while not found do
      found := [inAbstractMultiMethodName string] == [mValue string] ;
    end foreach ;
    if not found then
      @bool isConcrete ;
      [inUnifiedTypeMap searchKey !descendantClassName ?isConcrete ?20*] ;
      if not isConcrete then # Does not work in GALGAS 1, mType is an undefined mapindex type
#      if not [mType mIsConcrete] then # Does not work in GALGAS 1, mType is an undefined mapindex type
        checkMultiMethodDefinitionForClass
          !inClassNameForErrorSignaling
          ![descendantClassName string]
          !inAbstractMultiMethodName
          !inDescendantClassListMap
          !inOverridingMultiMethodListMap
          !inUnifiedTypeMap
        ;
      else
        error inAbstractMultiMethodName: "an abstract multi method '" . inAbstractMultiMethodName . "' is defined for abstract class '@"
        . inClassNameForErrorSignaling
        . "', but concrete descendant class '@" . descendantClassName . "' does not implement this method" ; 
      end if ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine checkMultiReaderDefinitionForClass
  ??@string inClassNameForErrorSignaling
  ??@string inClassName
  ??@lstring inAbstractMultiReaderName
  ??@descendantClassListMap inDescendantClassListMap
  ??@genericMultiMethodListMap inOverridingMultiReaderListMap
  ??@unifiedTypeMap inUnifiedTypeMap
:
  const @unifiedTypeMapProxyList descendantClasses := [inDescendantClassListMap listForKey !inClassName] ;
  foreach descendantClasses do
    @lstring descendantClassName := [mType lkey] ;
    @lstringlist overridingReaders := [inOverridingMultiReaderListMap listForKey ![descendantClassName string]] ;
    @bool found := false ;
    foreach overridingReaders while not found do
      found := [inAbstractMultiReaderName string] == [mValue string] ;
    end foreach ;
    if not found then
      @bool isConcrete ;
      [inUnifiedTypeMap searchKey !descendantClassName ?isConcrete ?20*] ;
      if not isConcrete then # Does not work in GALGAS 1, mType is an undefined mapindex type
#      if not [mType mIsConcrete] then # Does not work in GALGAS 1, mType is an undefined mapindex type
        checkMultiReaderDefinitionForClass
          !inClassNameForErrorSignaling
          ![descendantClassName string]
          !inAbstractMultiReaderName
          !inDescendantClassListMap
          !inOverridingMultiReaderListMap
          !inUnifiedTypeMap
        ;
      else
        error inAbstractMultiReaderName: "an abstract category reader '" . inAbstractMultiReaderName . "' is defined for abstract class '@"
        . inClassNameForErrorSignaling
        . "', but concrete descendant class '@" . descendantClassName . "' does not implement this reader" ; 
      end if ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine performProjectGlobalCheckings
  ??@parsedComponentStruct inParsedComponentStruct
  ??@location inEndOfSourceFile
:
  @semanticDeclarationListAST semanticDeclarationList [emptyList] ;
#------ Add predefined types to semantics declarations
  appendPredefinedTypesASTs !?semanticDeclarationList ;
#--- Build all declaration list
  foreach [inParsedComponentStruct mParsedSemanticsComponentMap] do
    semanticDeclarationList .= [mRoot mSemanticDeclarationList] ;
  end foreach ;
#------ Generate declarations
  @semanticContext semanticContext ;
  buildSemanticContext
    !semanticDeclarationList
    !inEndOfSourceFile
    ?semanticContext
  ;
#------ Build descendant type list map
# For every type, a list of its directed descendants is associated
  @descendantClassListMap descendantClassListMap [emptyMap] ;
  foreach semanticContext->mTypeMap do
     if not [mSuperType isNull] then
       descendantClassListMap +=
         ![mSuperType key]
         ![@unifiedTypeMapProxy searchKey !semanticContext->mTypeMap !lkey]
       ;
     end if ;
  end foreach ;
#--- Build multi method listmaps
  @genericMultiMethodListMap abstractMultiMethodListMap [emptyMap] ;
  @genericMultiMethodListMap multiMethodListMap [emptyMap] ;
  @genericMultiMethodListMap overridingMultiMethodListMap [emptyMap];
  @genericMultiMethodListMap abstractMultiReaderListMap [emptyMap] ;
  @genericMultiMethodListMap multiReaderListMap [emptyMap] ;
  @genericMultiMethodListMap overridingMultiReaderListMap [emptyMap];
  foreach [inParsedComponentStruct mParsedSemanticsComponentMap] do
    foreach [mRoot mSemanticDeclarationList] do
      [mSemanticDeclaration buildMultiMethodListMaps
        !?abstractMultiMethodListMap
        !?multiMethodListMap
        !?overridingMultiMethodListMap
        !?abstractMultiReaderListMap
        !?multiReaderListMap
        !?overridingMultiReaderListMap
      ] ;
    end foreach ;
  end foreach ;
#------ Check multi methods
  if [@uint errorCount] == 0 then
  #--- A given abstract multi method id defined only once for a class
    foreach abstractMultiMethodListMap do
      @multiMethodMap multiMethodMap [emptyMap] ;
      foreach mList do
        [!?multiMethodMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given base multi method id defined only once for a class
    foreach multiMethodListMap do
      @multiMethodMap multiMethodMap [emptyMap] ;
      foreach mList do
        [!?multiMethodMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given overriding multi method id defined only once for a class
    foreach overridingMultiMethodListMap do
      @multiMethodMap multiMethodMap [emptyMap] ;
      foreach mList do
        [!?multiMethodMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
#    log abstractMultiMethodListMap ;
  #------ Check that for every abstract multi method, an overridden multi method
  #    defined in an concrete subclass
    foreach abstractMultiMethodListMap do
      foreach mList do
        checkMultiMethodDefinitionForClass
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingMultiMethodListMap
          !semanticContext->mTypeMap
        ;
      end foreach ;
    end foreach ;
  #------ Check multi readers
##--- Check that for every abstract category reader, an overridden category reader
##    defined in an concrete subclass
  #--- A given abstract multi reader id defined only once for a class
    foreach abstractMultiReaderListMap do
      @multiReaderMap multiReaderMap [emptyMap] ;
      foreach mList do
        [!?multiReaderMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given base multi reader id defined only once for a class
    foreach multiReaderListMap do
      @multiReaderMap multiReaderMap [emptyMap] ;
      foreach mList do
        [!?multiReaderMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- A given overriding multi reader id defined only once for a class
    foreach overridingMultiReaderListMap do
      @multiReaderMap multiReaderMap [emptyMap] ;
      foreach mList do
        [!?multiReaderMap insertKey !mValue] ;
      end foreach ;
    end foreach ;  
  #--- Check every abstract multi reader is implemented by every inherited concrete type
    foreach abstractMultiReaderListMap do
      foreach mList do
        checkMultiReaderDefinitionForClass
          !key
          !key
          !mValue
          !descendantClassListMap
          !overridingMultiReaderListMap
          !semanticContext->mTypeMap
        ;
      end foreach ;
    end foreach ;
  end if ;
end routine ;

#------------------------------------------------------------------------------*
#                                                                              *
#   PROJECT                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

listmap @targetFileListMap (@stringlist) ;

#------------------------------------------------------------------------------*

map @sourceFileMap {
  @string mFullPath ;
  @sourceFileKind mSourceKind ;
  insert insertKey error message "the '%K' source base name has been already declared in %L" ;
  search searchKey error message "the '%K' source base name is not declared" ;
}

#------------------------------------------------------------------------------*

filewrapper fileListTemplateFileWrapper in "../generation_templates/file_list_template" {
 "mke"
} {
#--- Project
  template fileListTemplate "/file_list_template.mke.gTemplate"
    ?@string HAND_CODED_SOURCES_SUB_DIRS
    ?@string GALGAS_SOURCE_LIST
    ?@string HAND_CODED_SOURCE_LIST
  ;
}

#---------------------------------------------------------------------------*

end semantics ;

#---------------------------------------------------------------------------*
