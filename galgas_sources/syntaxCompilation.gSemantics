#---------------------------------------------------------------------------*
#                                                                           *
#  Syntax component compilation                                             *
#                                                                           *
#  Copyright (C) 2009, ..., 2014 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics syntaxCompilation :
import "semanticsCompilation.gSemantics" ;
import "semanticGeneration.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    S Y N T A X    C O M P O N E N T               *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileSyntaxComponentFromAST
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ??@galgas3SyntaxComponentListAST-element inSyntaxComponentRoot
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
#--- Check component name
  const @lstring componentName := [inSyntaxComponentRoot mSyntaxComponentName] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--- Recursively parse all imported files
  @semanticDeclarationListAST semanticDeclarationList := [inSyntaxComponentRoot mSemanticDeclarationList] ;
  @stringset parsedFileSet [setWithString ![inSourceFile string]] ;
  @lstringlist optionComponentFileNameList [emptyList] ;
  @grammarComponentASTList grammarComponentASTList [emptyList] ;
  @stringlist headerIncludeList [emptyList] ;
  @stringlist implementationIncludeList [emptyList] ;
  recursivelyImportSemanticComponentAndCheckNoCircularityInImportSemantics
    !inSourceFile
    !?ioParsedComponentStruct
    !?optionComponentFileNameList
    !?grammarComponentASTList
    !?semanticDeclarationList
    !?parsedFileSet
    !?headerIncludeList
    !?implementationIncludeList
    ![inSyntaxComponentRoot mImportedComponentFileNameList]
    ![inSourceFile stringByDeletingLastPathComponent]
  ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := semanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  buildSemanticContext
    !semanticDeclarationListWithPredefinedTypes
    ?@semanticContext semanticContext
  ;
#--- Perform semantic analysis of grammar components
  buildGrammarComponentMapForSemanticAnalysis
    !grammarComponentASTList
    !?semanticContext
  ;
#--- Build option component map for analysis
  buildOptionComponentMapForSemanticAnalysis
    !optionComponentFileNameList
    !?ioParsedComponentStruct
    !?semanticContext->mOptionComponentMapForSemanticAnalysis
  ;
#--- Build lexique component map for semantic analysis
  buildLexiqueComponentMapForSemanticAnalysis
    !ioParsedComponentStruct
    ?@lexiqueComponentMapForSemanticAnalysis lexiqueMap
  ;
  semanticContext->mLexiqueComponentMapForSemanticAnalysis := lexiqueMap ;
#--- Parse lexique component
  const lexiqueFilePath := [@lstring new
    ![[inSyntaxComponentRoot mImportedLexiqueFilePath] absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]]
    ![[inSyntaxComponentRoot mImportedLexiqueFilePath] location]
  ] ;
  @galgas3LexiqueComponentListAST-element lexiqueComponentRoot ;
  parseLexiqueComponent
    !lexiqueFilePath
    !?ioParsedComponentStruct
    ?lexiqueComponentRoot
  ;
#--- Build token map
  @terminalMap terminalMap ;
  buildTerminalMap !lexiqueComponentRoot ?terminalMap ;
#--------------------------------------- Build "indexing" set
  @stringset indexNameSet [emptySet] ;
  foreach [lexiqueComponentRoot mIndexingListAST] do
    indexNameSet += ![mIndexName string] ;
  end foreach ;
  const @bool hasIndexing := not [[lexiqueComponentRoot mIndexingDirectory] isNowhere] ;
#--- Build semantic context from rule headers and non terminal declaration
  if [@uint errorCount] == 0 then
    const @string lexiqueName := [[[inSyntaxComponentRoot mImportedLexiqueFilePath] lastPathComponent] stringByDeletingPathExtension] ;
    @semanticDeclarationSortedListForGeneration decoratedDeclarationListForGeneration ;
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!semanticContext] ;
    @syntaxDeclarationForGeneration syntaxDeclarationForGeneration ;
    semanticAnalysisOfSyntaxComponent
      ![inSyntaxComponentRoot mNonterminalDeclarationList]
      ![inSyntaxComponentRoot mRuleList]
      ![componentName string]
      !lexiqueName
      !semanticContext
      !predefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !inSyntaxComponentRoot->mHasTranslateFeature
      ?syntaxDeclarationForGeneration
    ;
  #------ Semantic Analysis
    performSemanticAnalysis
      !inOutputDirectory
      ![inSyntaxComponentRoot mSemanticDeclarationList]
      !semanticContext
      ?decoratedDeclarationListForGeneration
    ;
    decoratedDeclarationListForGeneration +=
      !"syntax"
      !syntaxDeclarationForGeneration
      !""
    ;
  #------ Generate Header File
    if [@uint errorCount] == 0 then
      var headerString := [filewrapper syntaxFileGenerationTemplate.syntaxFileHeader
        ![componentName string]
        !lexiqueName
        !headerIncludeList
      ] ;
      foreach decoratedDeclarationListForGeneration do
        var unusedInclusionSet := [@stringset emptySet] ;
        [mDeclaration appendDeclaration1 !?unusedInclusionSet ??@string code] ;
        headerString .= code ;
      end foreach ;
      foreach decoratedDeclarationListForGeneration do
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !false !inOutputDirectory !?inclusionSet2 ??@string headerString2] ;
      headerString .= headerString2 ;
      end foreach ;
      [@string generateFileWithPattern
        !inOutputDirectory
        ![componentName string] . ".h"
        !"//"
        !"\n\n" # Defaut user zone1
        !headerString
        !"\n\n" # Defaut user zone2
        !"#endif\n"
      ] ;
    #------ Generate Implementation File
      if [@uint errorCount] == 0 then
        @string implementationString := [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementation
          ![componentName string]
          !implementationIncludeList
        ] ;
        foreach decoratedDeclarationListForGeneration do
          implementationString .= [mDeclaration appendTypeGenericImplementation] ;
          var unusedInclusionSet := [@stringset emptySet] ;
          [mDeclaration appendSpecificImplementation !?unusedInclusionSet ??@string code] ;
          implementationString += code ;
        end foreach ;
#        const @string lexiqueCppName := "C_Lexique_"
#        . [[[[inSyntaxComponentRoot mImportedLexiqueFilePath] lastPathComponent] stringByDeletingPathExtension] identifierRepresentation] ;
#        var inclusionSet := [@stringset emptySet] ;
#        foreach [syntaxDeclarationForGeneration mRuleDeclarationList] do
#        #--- Generate rule label implementation
#          foreach mLabelImplementationList do
#            const @string ruleName := "cParser_" . [componentName identifierRepresentation]
#              . "::rule_" . [componentName identifierRepresentation] . "_"
#              . [mNonterminalName identifierRepresentation]
#              . "_i" . [mRuleIndex string] . "_" . [mLabelName identifierRepresentation]
#            ;
#            implementationString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
#            generateProcedure
#              !static:false
#              !ruleName
#              !?inclusionSet
#              !mSignatureForGeneration
#              !mInstructionListForGeneration
#              !false
#              !lexiqueCppName
#              !false # Do not generate location Argument
#              !false # Do not generate 'resetTemplateString'
#              !inSyntaxComponentRoot->mHasTranslateFeature
#              ??@string code
#            ;
#            implementationString .= code ;
#          end foreach ;
#        #--- Generate "parse" label
#          @semanticInstructionListForGeneration instructionList ;
#          [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
#          const @string ruleName := "cParser_" . [componentName identifierRepresentation]
#          . "::rule_" . [componentName identifierRepresentation] . "_"
#          . [mNonterminalName identifierRepresentation]
#          . "_i" . [mRuleIndex string] . "_parse" ;
#          implementationString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
#          generateProcedure
#            !static:false
#            !ruleName
#            !?inclusionSet
#            ![@formalParameterListForGeneration emptyList]
#            !syntaxSignatureOfInstructionList [!"parse" !instructionList]
#            !false
#            !lexiqueCppName
#            !false # Do not generate location Argument
#            !true # Generate 'resetTemplateString'
#            !inSyntaxComponentRoot->mHasTranslateFeature
#            ??@string code
#          ;
#          implementationString .= code ;
#        #--- Generate indexing code
#          if hasIndexing then
#            @semanticInstructionListForGeneration instructionList ;
#            [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
#            const @string ruleName := "cParser_" . [componentName identifierRepresentation]
#            . "::rule_" . [componentName identifierRepresentation] . "_"
#            . [mNonterminalName identifierRepresentation]
#            . "_i" . [mRuleIndex string] . "_indexing" ;
#            implementationString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
#            generateProcedure
#              !static:false
#              !ruleName
#              !?inclusionSet
#              ![@formalParameterListForGeneration emptyList]
#              !syntaxSignatureOfInstructionList [!"indexing" !instructionList]
#              !false
#              !lexiqueCppName
#              !false # Do not generate location Argument
#              !false # Do not generate 'resetTemplateString'
#              !false # Do not generate syntaxDirectedTranslationString argument
#              ??@string code
#            ;
#            implementationString .= code ;
#          end if ;
#        end foreach ;
        [@string generateFileWithPattern
          !inOutputDirectory
          ![componentName string] . ".cpp"
          !"//"
          !"\n\n" # Defaut user zone1
          !implementationString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
      end if ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine compileSyntaxComponentFromSourceFile
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Parse source file
  const basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  const basenameKey := [@lstring new !basename !here] ;
  @galgas3SyntaxComponentListAST-element syntaxComponentRoot ;
  if [[ioParsedComponentStruct mParsedSyntaxComponentMap] hasKey ! basename] then
    [[ioParsedComponentStruct mParsedSyntaxComponentMap] searchKey !basenameKey ?* ?syntaxComponentRoot] ;
  else
    grammar syntaxSLRgrammar in inSourceFile ?syntaxComponentRoot ;
    [!?ioParsedComponentStruct->mParsedSyntaxComponentMap insertKey !basenameKey !inSourceFile !syntaxComponentRoot] ;
  end if ;
#---
  compileSyntaxComponentFromAST
    !inSourceFile
    !inOutputDirectory
    !syntaxComponentRoot
    !?ioParsedComponentStruct
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           G R O U P    S Y N T A X    C O M P O N E N T S                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine groupSyntaxComponentsGalgas3
  ??@galgas3SyntaxComponentListAST inAllSyntaxComponents
  ?!@semanticDeclarationListAST ioDeclarationList
:
#--- get together syntax components with the same name
  var syntaxComponentNames := [@stringset emptySet] ; 
  for component in inAllSyntaxComponents do
    syntaxComponentNames += !component->mSyntaxComponentName->string ;
  end for ;
  var allGroupedSyntaxComponents := [@galgas3SyntaxComponentListAST emptyList] ;
  for (name) in syntaxComponentNames do
    var componentName := ["" nowhere] ;
    var importedLexiqueName := ["" nowhere] ; 
    var nonterminalDeclarationList := [@nonterminalDeclarationListAST emptyList] ;
    var ruleList := [@syntaxRuleListAST emptyList] ;
    var hasTranslateFeature := false ;
    for component in inAllSyntaxComponents do
      if component->mSyntaxComponentName->string == name then
        componentName := component->mSyntaxComponentName ;
        if importedLexiqueName->string == "" then
          importedLexiqueName := component->mImportedLexiqueFilePath ;
        elsif (component->mImportedLexiqueFilePath->string != "") & (importedLexiqueName->string != component->mImportedLexiqueFilePath->string) then
          error component->mImportedLexiqueFilePath : "lexique name is different from that previously declared ('" .  importedLexiqueName . "')" ;
          error importedLexiqueName : "previously declaration is here" ;
        end if ;
        nonterminalDeclarationList += component->mNonterminalDeclarationList ;
        ruleList += component->mRuleList ;
        if component->mHasTranslateFeature then
          hasTranslateFeature := true ;
        end if ;
      end if ;
    end for ;
    ioDeclarationList += ![@galgas3SyntaxComponentAST new
      !false # Is not predefined
      !componentName
      !importedLexiqueName
      !nonterminalDeclarationList
      !ruleList
      !hasTranslateFeature
    ] ;
  end for ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    S Y N T A X    C O M P O N E N T               *
#                                                                           *
#---------------------------------------------------------------------------*

#routine compileAllSyntaxComponentsGalgas3
#  ??@galgas3SyntaxComponentListAST inAllSyntaxComponents
#  ??@semanticContext inSemanticContext
#  ?!@parsedSyntaxComponentMap ioParsedSyntaxComponentMap
#:
##--- get together syntax components with the same name
#  var syntaxComponentNames := [@stringset emptySet] ; 
#  for component in inAllSyntaxComponents do
#    syntaxComponentNames += !component->mSyntaxComponentName->string ;
#  end for ;
#  var allGroupedSyntaxComponents := [@galgas3SyntaxComponentListAST emptyList] ;
#  for (name) in syntaxComponentNames do
#    var componentName := ["" nowhere] ;
#    var importedLexiqueName := ["" nowhere] ; 
#    var nonterminalDeclarationList := [@nonterminalDeclarationListAST emptyList] ;
#    var ruleList := [@syntaxRuleListAST emptyList] ;
#    var hasTranslateFeature := false ;
#    for component in inAllSyntaxComponents do
#      if component->mSyntaxComponentName->string == name then
#        componentName := component->mSyntaxComponentName ;
#        if importedLexiqueName->string == "" then
#          importedLexiqueName := component->mImportedLexiqueFilePath ;
#        elsif (component->mImportedLexiqueFilePath->string != "") & (importedLexiqueName->string != component->mImportedLexiqueFilePath->string) then
#          error component->mImportedLexiqueFilePath : "lexique name is different from that previously declared ('" .  importedLexiqueName . "')" ;
#          error importedLexiqueName : "previously declaration is here" ;
#        end if ;
#        nonterminalDeclarationList += component->mNonterminalDeclarationList ;
#        ruleList += component->mRuleList ;
#        if component->mHasTranslateFeature then
#          hasTranslateFeature := true ;
#        end if ;
#      end if ;
#    end for ;
#    allGroupedSyntaxComponents +=
#      !componentName
#      !importedLexiqueName
#      ![@lstringlist emptyList] # Unused in GALGAS 3
#      !nonterminalDeclarationList
#      !ruleList
#      ![@semanticDeclarationListAST emptyList] # Unused in GALGAS 3
#      !hasTranslateFeature
#    ;
#  end for ;
##---- Compile
#  for component in allGroupedSyntaxComponents do
#    compileSyntaxComponentGalgas3
#      !component
#      !inSemanticContext
#      !?ioParsedSyntaxComponentMap
#    ;
#  end for ;
#end routine ;

#---------------------------------------------------------------------------*

routine compileSyntaxComponentGalgas3
  ??@galgas3SyntaxComponentListAST-element inSyntaxComponentRoot
  ??@semanticContext inSemanticContext
  ?!@parsedSyntaxComponentMap ioParsedSyntaxComponentMap
:
  const componentName := inSyntaxComponentRoot->mSyntaxComponentName->string ;
#--------------------------------------- Build terminal map
  [inSemanticContext->mLexiqueComponentMapForSemanticAnalysis searchKey
    !inSyntaxComponentRoot->mImportedLexiqueFilePath
    ??@terminalMap terminalMap
    ??@indexingListAST indexingListAST
    ??@lstring indexingDirectory
  ] ;
#--------------------------------------- Build "indexing" set
  @stringset indexNameSet [emptySet] ;
  foreach indexingListAST do
    indexNameSet += !mIndexName->string ;
  end foreach ;
  const @bool hasIndexing := not [indexingDirectory isNowhere] ;
#--- Build semantic context from rule headers and non terminal declaration
  if [@uint errorCount] == 0 then
    const lexiqueName := inSyntaxComponentRoot->mImportedLexiqueFilePath->string ;
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!inSemanticContext] ;
    semanticAnalysisOfSyntaxComponent
      !inSyntaxComponentRoot->mNonterminalDeclarationList
      !inSyntaxComponentRoot->mRuleList
      !componentName
      !lexiqueName
      !inSemanticContext
      !predefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !inSyntaxComponentRoot->mHasTranslateFeature
      ?*
    ;
  #------
    [!?ioParsedSyntaxComponentMap insertKey
      !inSyntaxComponentRoot->mSyntaxComponentName
      !inSyntaxComponentRoot->mSyntaxComponentName
      !inSyntaxComponentRoot     
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
