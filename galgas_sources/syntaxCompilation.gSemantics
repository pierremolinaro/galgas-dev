#---------------------------------------------------------------------------*
#                                                                           *
#  Syntax component compilation                                             *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics syntaxCompilation :
import "semanticAnalysisOfSyntaxComponent.gSemantics" ;

import semantics lexiqueCompilation in "lexiqueCompilation.gSemantics" ;
import semantics semanticAnalysisOfSyntaxComponent in "semanticAnalysisOfSyntaxComponent.gSemantics" ;
import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#           B U I L D    T E R M I N A L    M A P                           *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildTerminalMap
  ??@lexiqueComponentAST inLexiqueComponentRoot
  !@terminalMap outTerminalMap
:
#--------------------------------------- Build lexical attribute map
  const @lexicalTypeMap lexicalTypeMap := buildLexicalTypeMap [] ;
  @lexicalAttributeMap lexicalAttributeMap [emptyMap] ;
  buildLexicalAttributeMap
   !lexicalTypeMap
   ![inLexiqueComponentRoot mLexicalAttributeList]
   !?lexicalAttributeMap
  ;
#--------------------------------------- 
  outTerminalMap := [@terminalMap emptyMap] ;
  foreach [inLexiqueComponentRoot mTerminalDeclarationList] do
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType ;
      [lexicalAttributeMap searchKey !mValue ?attributeLexicalType] ;
      argumentTypeList += ![mValue string] !attributeLexicalType ;
    end foreach ;
    [!?outTerminalMap insertKey !mName !argumentTypeList] ;
  end foreach ;
#---
  foreach [inLexiqueComponentRoot mLexicalListDeclarationList] do
    @lexicalSentValueList argumentTypeList [emptyList] ;
    foreach mSentAttributeList do
      @lexicalTypeEnum attributeLexicalType ;
      [lexicalAttributeMap searchKey !mValue ?attributeLexicalType] ;
      argumentTypeList += ![mValue string] !attributeLexicalType ;
    end foreach ;
    foreach mEntryList do
      [!?outTerminalMap insertKey !mTerminalSpelling !argumentTypeList] ;
    end foreach ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    S Y N T A X    C O M P O N E N T               *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileSyntaxComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Parse source file
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  const @lstring basenameKey [new !basename !here] ;
  @syntaxComponentAST syntaxComponentRoot ;
  if [[ioParsedComponentStruct mParsedSyntaxComponentMap] hasKey ! basename] then
    [[ioParsedComponentStruct mParsedSyntaxComponentMap] searchKey !basenameKey ?syntaxComponentRoot] ;
  else
    grammar syntaxSLRgrammar in inSourceFile ?syntaxComponentRoot ;
    [!?ioParsedComponentStruct->mParsedSyntaxComponentMap insertKey !basenameKey !syntaxComponentRoot] ;
  end if ;
#--- Check component name
  const @lstring componentName := [syntaxComponentRoot mSyntaxComponentName] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--- Recursively parse all imported files
  @semanticDeclarationListAST semanticDeclarationList := [syntaxComponentRoot mSemanticDeclarationList] ;
  @stringset parsedFileSet [setWithString ![inSourceFile string]] ;
  @lstringlist optionComponentFileNameList [emptyList] ;
  @grammarComponentASTList grammarComponentASTList [emptyList] ;
  @stringlist headerIncludeList [emptyList] ;
  @stringlist implementationIncludeList [emptyList] ;
  recursivelyImportSemanticComponent
    !?ioParsedComponentStruct
    !?optionComponentFileNameList
    !?grammarComponentASTList
    !?semanticDeclarationList
    !?parsedFileSet
    !?headerIncludeList
    !?implementationIncludeList
    ![syntaxComponentRoot mImportedComponentFileNameList]
    ![inSourceFile stringByDeletingLastPathComponent]
  ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := semanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  @semanticContext semanticContext ;
  buildSemanticContext
    ![inSourceFile string]
    !semanticDeclarationListWithPredefinedTypes
    ![syntaxComponentRoot mEndOfSourceFile]
    ?semanticContext
  ;
#--- Perform semantic analysis of grammar components
  buildGrammarComponentMapForSemanticAnalysis
    !grammarComponentASTList
    !?semanticContext
  ;
#--- Build option component map for analysis
  buildOptionComponentMapForSemanticAnalysis
    !optionComponentFileNameList
    !?ioParsedComponentStruct
    !?semanticContext->mOptionComponentMapForSemanticAnalysis
  ;
#--- Parse lexique component
  const @lstring lexiqueFilePath [new
    ![[syntaxComponentRoot mImportedLexiqueFilePath] absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]]
    ![[syntaxComponentRoot mImportedLexiqueFilePath] location]
  ] ;
  @lexiqueComponentAST lexiqueComponentRoot ;
  parseLexiqueComponent
    !lexiqueFilePath
    !?ioParsedComponentStruct
    ?lexiqueComponentRoot
  ;
#--- Build token map
  @terminalMap terminalMap ;
  buildTerminalMap !lexiqueComponentRoot ?terminalMap ;
#--- Build semantic context from rule headers and non terminal declaration
  const @predefinedTypes predefinedTypes := buildPredefinedTypes [!semanticContext] ;
  @syntaxDeclarationForGeneration syntaxDeclarationForGeneration ;
  const @string lexiqueName := [[[syntaxComponentRoot mImportedLexiqueFilePath] lastPathComponent] stringByDeletingPathExtension] ;
  semanticAnalysisOfSyntaxComponent
    ![syntaxComponentRoot mNonterminalDeclarationList]
    ![syntaxComponentRoot mRuleList]
    ![componentName string]
    ![lexiqueName identifierRepresentation]
    !semanticContext
    !predefinedTypes
    !terminalMap
    ?syntaxDeclarationForGeneration
  ;
#------ Semantic Analysis
  @semanticDeclarationListForGeneration decoratedDeclarationListForGeneration ;
  performSemanticAnalysis
    ![syntaxComponentRoot mSemanticDeclarationList]
    !semanticContext
    ?decoratedDeclarationListForGeneration
  ;
  decoratedDeclarationListForGeneration += !syntaxDeclarationForGeneration ;
#------ Generate Header File
  if [@uint errorCount] == 0 then
    @string headerString := [filewrapper syntaxFileGenerationTemplate.syntaxFileHeader
      ![componentName string]
      !lexiqueName
      !headerIncludeList
      ![semanticContext->mTypeMap allKeyList]
    ] ;
    foreach decoratedDeclarationListForGeneration do
      headerString .= [mDeclaration appendDeclaration1] ;
    end foreach ;
    foreach decoratedDeclarationListForGeneration do
      headerString .= [mDeclaration appendDeclaration2] ;
    end foreach ;
    [@string generateFile
      !inOutputDirectory
      ![componentName string] . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      !headerString
      !"\n\n" # Defaut user zone2
      !"#endif\n"
    ] ;
  end if ;
#------ Generate Implementation File
  if [@uint errorCount] == 0 then
    @string implementationString := [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementation
      ![componentName string]
      !implementationIncludeList
    ] ;
    foreach decoratedDeclarationListForGeneration do
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      implementationString .= [mDeclaration appendSpecificImplementation] ;
    end foreach ;
    const @string lexiqueCppName := "C_Lexique_"
    . [[[[syntaxComponentRoot mImportedLexiqueFilePath] lastPathComponent] stringByDeletingPathExtension] identifierRepresentation] ;
    foreach [syntaxDeclarationForGeneration mRuleDeclarationList] do
      foreach mLabelImplementationList do
        const @string ruleName := "cParser_" . [componentName identifierRepresentation]
        . "::rule_" . [componentName identifierRepresentation] . "_"
        . [mNonterminalName identifierRepresentation]
        . "_i" . [mRuleIndex string] . "_" . [mLabelName identifierRepresentation] ;
        implementationString .= generateProcedure [
          !ruleName
          !mSignatureForGeneration
          !mInstructionListForGeneration
          !false
          !lexiqueCppName
          !false # Do not generate location Argument
          !false # Do not generate 'resetTemplateString'
        ] ;
      end foreach ;
      if mHasParseLabel then
        @semanticInstructionListForGeneration instructionList ;
        [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
        const @string ruleName := "cParser_" . [componentName identifierRepresentation]
        . "::rule_" . [componentName identifierRepresentation] . "_"
        . [mNonterminalName identifierRepresentation]
        . "_i" . [mRuleIndex string] . "_parse" ;
        implementationString .= generateProcedure [
          !ruleName
          ![@formalParameterListForGeneration emptyList]
          !syntaxSignatureOfInstructionList [!instructionList]
          !false
          !lexiqueCppName
          !false # Do not generate location Argument
          !true # Generate 'resetTemplateString'
        ] ;
      end if ;
    end foreach ;
    [@string generateFile
      !inOutputDirectory
      ![componentName string] . ".cpp"
      !"//"
      !"\n\n" # Defaut user zone1
      !implementationString
      !"\n\n" # Defaut user zone2
      !"\n"
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
