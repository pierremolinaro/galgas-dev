#---------------------------------------------------------------------------*
#                                                                           *
#  Syntax component compilation                                             *
#                                                                           *
#  Copyright (C) 2009, ..., 2014 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics syntaxCompilation :
import "semanticAnalysisOfSyntaxComponent.gSemantics" ;
import "lexiqueCompilation.gSemantics" ;
import "syntaxSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    S Y N T A X    C O M P O N E N T               *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileSyntaxComponentFromAST
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ??@galgas3SyntaxComponentListAST.element inSyntaxComponentRoot
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
#--- Check component name
  const @lstring componentName := [inSyntaxComponentRoot mSyntaxComponentName] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--- Recursively parse all imported files
  @semanticDeclarationListAST semanticDeclarationList := [inSyntaxComponentRoot mSemanticDeclarationList] ;
  @stringset parsedFileSet [setWithString ![inSourceFile string]] ;
  @lstringlist optionComponentFileNameList [emptyList] ;
  @grammarComponentASTList grammarComponentASTList [emptyList] ;
  @stringlist headerIncludeList [emptyList] ;
  @stringlist implementationIncludeList [emptyList] ;
  recursivelyImportSemanticComponentAndCheckNoCircularityInImportSemantics
    !inSourceFile
    !?ioParsedComponentStruct
    !?optionComponentFileNameList
    !?grammarComponentASTList
    !?semanticDeclarationList
    !?parsedFileSet
    !?headerIncludeList
    !?implementationIncludeList
    ![inSyntaxComponentRoot mImportedComponentFileNameList]
    ![inSourceFile stringByDeletingLastPathComponent]
  ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := semanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  @semanticContext semanticContext ;
  buildSemanticContext
    ![inSourceFile string]
    !semanticDeclarationListWithPredefinedTypes
    ![inSyntaxComponentRoot mEndOfSourceFile]
    ?semanticContext
  ;
#--- Perform semantic analysis of grammar components
  buildGrammarComponentMapForSemanticAnalysis
    !grammarComponentASTList
    !?semanticContext
  ;
#--- Build option component map for analysis
  buildOptionComponentMapForSemanticAnalysis
    !optionComponentFileNameList
    !?ioParsedComponentStruct
    !?semanticContext->mOptionComponentMapForSemanticAnalysis
  ;
#--- Build lexique component map for semantic analysis
  buildLexiqueComponentMapForSemanticAnalysis
    !ioParsedComponentStruct
    ?@lexiqueComponentMapForSemanticAnalysis lexiqueMap
  ;
  semanticContext->mLexiqueComponentMapForSemanticAnalysis := lexiqueMap ;
#--- Parse lexique component
  const lexiqueFilePath := [@lstring new
    ![[inSyntaxComponentRoot mImportedLexiqueFilePath] absolutePathFromPath ![inSourceFile stringByDeletingLastPathComponent]]
    ![[inSyntaxComponentRoot mImportedLexiqueFilePath] location]
  ] ;
  @galgas3LexiqueComponentListAST.element lexiqueComponentRoot ;
  parseLexiqueComponent
    !lexiqueFilePath
    !?ioParsedComponentStruct
    ?lexiqueComponentRoot
  ;
#--- Build token map
  @terminalMap terminalMap ;
  buildTerminalMap !lexiqueComponentRoot ?terminalMap ;
#--------------------------------------- Build "indexing" set
  @stringset indexNameSet [emptySet] ;
  foreach [lexiqueComponentRoot mIndexingListAST] do
    indexNameSet += ![mIndexName string] ;
  end foreach ;
  const @bool hasIndexing := not [[lexiqueComponentRoot mIndexingDirectory] isNowhere] ;
#--- Build semantic context from rule headers and non terminal declaration
  if [@uint errorCount] == 0 then
    const @string lexiqueName := [[[inSyntaxComponentRoot mImportedLexiqueFilePath] lastPathComponent] stringByDeletingPathExtension] ;
    @semanticDeclarationSortedListForGeneration decoratedDeclarationListForGeneration ;
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!semanticContext] ;
    @syntaxDeclarationForGeneration syntaxDeclarationForGeneration ;
    semanticAnalysisOfSyntaxComponent
      ![inSyntaxComponentRoot mNonterminalDeclarationList]
      ![inSyntaxComponentRoot mRuleList]
      ![componentName string]
      ![lexiqueName identifierRepresentation]
      !semanticContext
      !predefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !inSyntaxComponentRoot->mHasTranslateFeature
      ?syntaxDeclarationForGeneration
    ;
  #------ Semantic Analysis
    performSemanticAnalysis
      ![inSyntaxComponentRoot mSemanticDeclarationList]
      !semanticContext
      ?decoratedDeclarationListForGeneration
    ;
    decoratedDeclarationListForGeneration +=
#      !false
      !syntaxDeclarationForGeneration
      !""
    ;
  #------ Generate Header File
    if [@uint errorCount] == 0 then
      var headerString := [filewrapper syntaxFileGenerationTemplate.syntaxFileHeader
        ![componentName string]
        !lexiqueName
        !headerIncludeList
        ![semanticContext->mTypeMap allKeyList]
      ] ;
      foreach decoratedDeclarationListForGeneration do
        headerString .= [mDeclaration appendDeclaration1 !false] ;
      end foreach ;
      foreach decoratedDeclarationListForGeneration do
        headerString .= [mDeclaration appendDeclaration2 !inOutputDirectory !false] ;
      end foreach ;
      [@string generateFileWithPattern
        !inOutputDirectory
        ![componentName string] . ".h"
        !"//"
        !"\n\n" # Defaut user zone1
        !headerString
        !"\n\n" # Defaut user zone2
        !"#endif\n"
      ] ;
    #------ Generate Implementation File
      if [@uint errorCount] == 0 then
        @string implementationString := [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementation
          ![componentName string]
          !implementationIncludeList
        ] ;
        foreach decoratedDeclarationListForGeneration do
          implementationString .= [mDeclaration appendTypeGenericImplementation] ;
          implementationString .= [mDeclaration appendSpecificImplementation !false] ;
        end foreach ;
        const @string lexiqueCppName := "C_Lexique_"
        . [[[[inSyntaxComponentRoot mImportedLexiqueFilePath] lastPathComponent] stringByDeletingPathExtension] identifierRepresentation] ;
        foreach [syntaxDeclarationForGeneration mRuleDeclarationList] do
        #--- Generate rule label implementation
          foreach mLabelImplementationList do
            const @string ruleName := "cParser_" . [componentName identifierRepresentation]
              . "::rule_" . [componentName identifierRepresentation] . "_"
              . [mNonterminalName identifierRepresentation]
              . "_i" . [mRuleIndex string] . "_" . [mLabelName identifierRepresentation]
            ;
            implementationString .= "//---------------------------------------------------------------------------*\n\n" ;
            implementationString .= generateProcedure [
              !ruleName
              !false
              !mSignatureForGeneration
              !mInstructionListForGeneration
              !false
              !lexiqueCppName
              !false # Do not generate location Argument
              !false # Do not generate 'resetTemplateString'
              !inSyntaxComponentRoot->mHasTranslateFeature
            ] ;
          end foreach ;
        #--- Generate "parse" label
          @semanticInstructionListForGeneration instructionList ;
          [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
          const @string ruleName := "cParser_" . [componentName identifierRepresentation]
          . "::rule_" . [componentName identifierRepresentation] . "_"
          . [mNonterminalName identifierRepresentation]
          . "_i" . [mRuleIndex string] . "_parse" ;
          implementationString .= "//---------------------------------------------------------------------------*\n\n" ;
          implementationString .= generateProcedure [
            !ruleName
            !false
            ![@formalParameterListForGeneration emptyList]
            !syntaxSignatureOfInstructionList [!"parse" !instructionList]
            !false
            !lexiqueCppName
            !false # Do not generate location Argument
            !true # Generate 'resetTemplateString'
            !inSyntaxComponentRoot->mHasTranslateFeature
          ] ;
        #--- Generate indexing code
          if hasIndexing then
            @semanticInstructionListForGeneration instructionList ;
            [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
            const @string ruleName := "cParser_" . [componentName identifierRepresentation]
            . "::rule_" . [componentName identifierRepresentation] . "_"
            . [mNonterminalName identifierRepresentation]
            . "_i" . [mRuleIndex string] . "_indexing" ;
            implementationString .= "//---------------------------------------------------------------------------*\n\n" ;
            implementationString .= generateProcedure [
              !ruleName
              !false
              ![@formalParameterListForGeneration emptyList]
              !syntaxSignatureOfInstructionList [!"indexing" !instructionList]
              !false
              !lexiqueCppName
              !false # Do not generate location Argument
              !false # Do not generate 'resetTemplateString'
              !false # Do not generate syntaxDirectedTranslationString argument
            ] ;
          end if ;
        end foreach ;
        [@string generateFileWithPattern
          !inOutputDirectory
          ![componentName string] . ".cpp"
          !"//"
          !"\n\n" # Defaut user zone1
          !implementationString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
      end if ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine compileSyntaxComponentFromSourceFile
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Parse source file
  const basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  const basenameKey := [@lstring new !basename !here] ;
  @galgas3SyntaxComponentListAST.element syntaxComponentRoot ;
  if [[ioParsedComponentStruct mParsedSyntaxComponentMap] hasKey ! basename] then
    [[ioParsedComponentStruct mParsedSyntaxComponentMap] searchKey !basenameKey ?* ?syntaxComponentRoot] ;
  else
    grammar syntaxSLRgrammar in inSourceFile ?syntaxComponentRoot ;
    [!?ioParsedComponentStruct->mParsedSyntaxComponentMap insertKey !basenameKey !inSourceFile !syntaxComponentRoot] ;
  end if ;
#---
  compileSyntaxComponentFromAST
    !inSourceFile
    !inOutputDirectory
    !syntaxComponentRoot
    !?ioParsedComponentStruct
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    S Y N T A X    C O M P O N E N T               *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileSyntaxComponentGalgas3
  ??@string inOutputDirectory
  ??@galgas3SyntaxComponentListAST.element inSyntaxComponentRoot
  ??@semanticContext inSemanticContext
  ?!@parsedSyntaxComponentMap ioParsedSyntaxComponentMap
  ?!@stringlist ioToolProductFileList
:
  const @string componentName := inSyntaxComponentRoot->mSyntaxComponentName->string ;
#--------------------------------------- Build terminal map
  [inSemanticContext->mLexiqueComponentMapForSemanticAnalysis searchKey
    !inSyntaxComponentRoot->mImportedLexiqueFilePath
    ??@terminalMap terminalMap
    ??@indexingListAST indexingListAST
    ??@lstring indexingDirectory
  ] ;
#--------------------------------------- Build "indexing" set
  @stringset indexNameSet [emptySet] ;
  foreach indexingListAST do
    indexNameSet += !mIndexName->string ;
  end foreach ;
  const @bool hasIndexing := not [indexingDirectory isNowhere] ;
#--- Build semantic context from rule headers and non terminal declaration
  if [@uint errorCount] == 0 then
    const lexiqueName := inSyntaxComponentRoot->mImportedLexiqueFilePath->string ;
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!inSemanticContext] ;
    semanticAnalysisOfSyntaxComponent
      !inSyntaxComponentRoot->mNonterminalDeclarationList
      !inSyntaxComponentRoot->mRuleList
      !componentName
      ![lexiqueName identifierRepresentation]
      !inSemanticContext
      !predefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !inSyntaxComponentRoot->mHasTranslateFeature
      ??@syntaxDeclarationForGeneration syntaxDeclarationForGeneration
    ;
  #------
    [!?ioParsedSyntaxComponentMap insertKey
      !inSyntaxComponentRoot->mSyntaxComponentName
      !inSyntaxComponentRoot->mSyntaxComponentName # mSourceFullFilePath
      !inSyntaxComponentRoot     
    ] ;
    var implementationIncludeList := [@stringlist emptyList] ;
    implementationIncludeList += !"lexique-" + lexiqueName ;
    implementationIncludeList += !"AZERTYUIOP" ;
  #------ Generate Header File
    if [@uint errorCount] == 0 then
      var headerString := [filewrapper syntaxFileGenerationTemplate.syntaxFileHeaderGalgas3
        !componentName
      ] ;
      headerString .= [syntaxDeclarationForGeneration appendDeclaration1 !true] ;
      headerString .= [syntaxDeclarationForGeneration appendDeclaration2 !inOutputDirectory !true] ;
      [@string generateFileWithPattern
        !inOutputDirectory
        !"syntax-" . componentName . ".h"
        !"//"
        !"\n\n" # Defaut user zone1
        !headerString
        !"\n\n" # Defaut user zone2
        !"#endif\n"
      ] ;
    #------ Generate Implementation File
      if [@uint errorCount] == 0 then
        const lexiqueCppName := "C_Lexique_" . [inSyntaxComponentRoot->mImportedLexiqueFilePath  identifierRepresentation] ;
        @string implementationString := [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementationGalgas3
          !componentName
          !implementationIncludeList
        ] ;
        implementationString .= [syntaxDeclarationForGeneration appendTypeGenericImplementation] ;
        implementationString .= [syntaxDeclarationForGeneration appendSpecificImplementation !false] ;
        foreach [syntaxDeclarationForGeneration mRuleDeclarationList] do
        #--- Generate rule label implementation
          foreach mLabelImplementationList do
            const @string ruleName := "cParser_" . [componentName identifierRepresentation]
              . "::rule_" . [componentName identifierRepresentation] . "_"
              . [mNonterminalName identifierRepresentation]
              . "_i" . [mRuleIndex string] . "_" . [mLabelName identifierRepresentation]
            ;
            implementationString .= "//---------------------------------------------------------------------------*\n\n" ;
            implementationString .= generateProcedure [
              !ruleName
              !false
              !mSignatureForGeneration
              !mInstructionListForGeneration
              !false
              !lexiqueCppName
              !false # Do not generate location Argument
              !false # Do not generate 'resetTemplateString'
              !inSyntaxComponentRoot->mHasTranslateFeature
            ] ;
          end foreach ;
        #--- Generate "parse" label
          @semanticInstructionListForGeneration instructionList ;
          [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
          const @string ruleName := "cParser_" . [componentName identifierRepresentation]
          . "::rule_" . [componentName identifierRepresentation] . "_"
          . [mNonterminalName identifierRepresentation]
          . "_i" . [mRuleIndex string] . "_parse" ;
          implementationString .= "//---------------------------------------------------------------------------*\n\n" ;
          implementationString .= generateProcedure [
            !ruleName
            !false
            ![@formalParameterListForGeneration emptyList]
            !syntaxSignatureOfInstructionList [!"parse" !instructionList]
            !false
            !lexiqueCppName
            !false # Do not generate location Argument
            !true # Generate 'resetTemplateString'
            !inSyntaxComponentRoot->mHasTranslateFeature
          ] ;
        #--- Generate indexing code
          if hasIndexing then
            @semanticInstructionListForGeneration instructionList ;
            [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
            const @string ruleName := "cParser_" . [componentName identifierRepresentation]
            . "::rule_" . [componentName identifierRepresentation] . "_"
            . [mNonterminalName identifierRepresentation]
            . "_i" . [mRuleIndex string] . "_indexing" ;
            implementationString .= "//---------------------------------------------------------------------------*\n\n" ;
            implementationString .= generateProcedure [
              !ruleName
              !false
              ![@formalParameterListForGeneration emptyList]
              !syntaxSignatureOfInstructionList [!"indexing" !instructionList]
              !false
              !lexiqueCppName
              !false # Do not generate location Argument
              !false # Do not generate 'resetTemplateString'
              !false # Do not generate syntaxDirectedTranslationString argument
            ] ;
          end if ;
        end foreach ;
        ioToolProductFileList += !"syntax-" . componentName . ".cpp" ;
        [@string generateFileWithPattern
          !inOutputDirectory
          !"syntax-" . componentName . ".cpp"
          !"//"
          !"\n\n" # Defaut user zone1
          !implementationString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
      end if ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
