#---------------------------------------------------------------------------*
#                                                                           *
#  Treewalking for building type map of a semantics component               *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

treewalking buildMapsForSemantics (semanticsMetamodel) :
import "semanticsMetamodel.gMetamodel" ;
import metamodel semanticsMetamodel in "semanticsMetamodel.gMetamodel" ;
import semantics commonSemantics in "commonSemantics.gSemantics" ;
import semantics semanticsSemantics in "semanticsSemantics.gSemantics" ;
import semantics mda_galgas_LL1_routines in "mda_galgas_LL1_routines.gSemantics" ;
import grammar semanticsSLRgrammar in "semanticsSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*

rule @semanticsComponentRoot
  ??@string inSourceFileDirectory
  ??@location inErrorLocation
  ?!@stringset ioImportedComponentSet
  ?!@typeMap ioTypeMap
  ?!@routineMap ioRoutineMap
  !@typeList outTypeList
:
#--- Walk throught imported components
  foreach mImportedSemanticsComponentSet (@string kComponentName) :
    if not [ioImportedComponentSet hasKey !kComponentName] then
      if kComponentName != [mSemanticsComponentName string] then
        @lstring sourceFilePath [new
          !inSourceFileDirectory . "/" . kComponentName . ".gSemantics"
          !inErrorLocation
        ] ;
        @semanticsComponentRoot semanticsComponentRoot ;
        @location endOfSourceFile ;
        @typeList unusedTypeList ;
        grammar semanticsSLRgrammar in sourceFilePath ?endOfSourceFile -> semanticsComponentRoot ;
        treewalking buildMapsForSemantics on semanticsComponentRoot
          !inSourceFileDirectory
          !inErrorLocation
          !?ioImportedComponentSet
          !?ioTypeMap
          !?ioRoutineMap
          ?unusedTypeList
       ;
      end if ;
      ioImportedComponentSet += !kComponentName ;
    end if ;
  end foreach ;
#--- Walk throught definitions of current files
  if [ioImportedComponentSet hasKey ![mSemanticsComponentName string]] then
    error mSemanticsComponentName:
    "this component is involved in a circularity in 'extends' definitions" -> outTypeList ;
  else
    outTypeList := [@typeList emptyList] ;
    call mSemanticDeclarationList !?ioTypeMap !?ioRoutineMap !?outTypeList ;
  end if ;
end rule ;

#---------------------------------------------------------------------------*

rule @semanticDeclaration
  ?!@typeMap unused ioTypeMap
  ?!@routineMap unused ioRoutineMap
  ?!@typeList unused ioTypeList
:
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  R O U T I N E    D E C L A R A T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule @routineDeclaration
  ?!@typeMap ioTypeMap
  ?!@routineMap ioRoutineMap
  ?!@typeList unused ioTypeList
:
  @signature methodSignature ;
  call mFormalParameters ?methodSignature !?ioTypeMap ;
  [!?ioRoutineMap insertKey !mRoutineName !methodSignature] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  E X T E R N    R O U T I N E    D E C L A R A T I O N                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule @externRoutineDeclaration
  ?!@typeMap ioTypeMap
  ?!@routineMap ioRoutineMap
  ?!@typeList unused ioTypeList
:
  @signature methodSignature ;
  call mFormalParameters ?methodSignature !?ioTypeMap ;
  [!?ioRoutineMap insertKey !mActionName !methodSignature] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  C L A S S    T Y P E                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule @classDeclaration
  ?!@typeMap ioTypeMap
  ?!@routineMap unused ioRoutineMap
  ?!@typeList unused ioTypeList
:
#--- Super class index
  @typeMapIndex superClassIndex ;
  if [mSuperClassName length] == 0 then
    superClassIndex := [@typeMapIndex null] ;
  else
    [@typeMapIndex makeRegularIndex !mSuperClassName !?ioTypeMap ?superClassIndex] ;
  end if ;
#--- Attributes
  @attributeList attributeList [emptyList] ;
  call mAttributeList !?attributeList !?ioTypeMap ;
#--- Methods
  @classMethodList classMethodList [emptyList] ;
  call mAbstractMethodList !?classMethodList !?ioTypeMap ;
  call mMethodList !?classMethodList !?ioTypeMap ;
  call mOverridenMethodList !?classMethodList !?ioTypeMap ;
#--- Enter in type map
  @ACGalgasType t := [@classGalgasType new
    !mIsAbstract
    !mClassTypeName
    !superClassIndex
    !attributeList
    !classMethodList
  ] ;
  [!?ioTypeMap insertKey !mClassTypeName !t] ;
end rule ;

#---------------------------------------------------------------------------*

rule @formalParameter 
  ?!@signature ioMethodSignature
  ?!@typeMap ioTypeMap
:
#--- Parameter type index
  @typeMapIndex parameterTypeIndex ;
  [@typeMapIndex makeRegularIndex !mFormalParameterTypeName !?ioTypeMap ?parameterTypeIndex] ;
#--- Add formalparameter to signature
  ioMethodSignature += !parameterTypeIndex !mFormalParameterName !mFormalParameterPassingMode ;
end rule ;

#---------------------------------------------------------------------------*

rule @formalParameters 
  !@signature outMethodSignature
  ?!@typeMap ioTypeMap
:
  outMethodSignature := [@signature emptyList] ;
  call mFormalParameterList !?outMethodSignature !?ioTypeMap ;
end rule ;

#---------------------------------------------------------------------------*

rule @abstractMethodDefinition 
  ?!@classMethodList ioClassMethodList
  ?!@typeMap ioTypeMap
:
  @signature methodSignature ;
  call mSignature ?methodSignature !?ioTypeMap ;
  ioClassMethodList += !mMethodName !methodSignature ;
end rule ;

#---------------------------------------------------------------------------*

rule @overridenMethodDefinition 
  ?!@classMethodList ioClassMethodList
  ?!@typeMap ioTypeMap
:
  @signature methodSignature ;
  call mSignature ?methodSignature !?ioTypeMap ;
  ioClassMethodList += !mMethodName !methodSignature ;
end rule ;

#---------------------------------------------------------------------------*

rule @methodDefinition 
  ?!@classMethodList ioClassMethodList
  ?!@typeMap ioTypeMap
:
  @signature methodSignature ;
  call mSignature ?methodSignature !?ioTypeMap ;
  ioClassMethodList += !mMethodName !methodSignature ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  E N U M    T Y P E                                                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule @enumDeclaration
  ?!@typeMap ioTypeMap
  ?!@routineMap unused ioRoutineMap
  ?!@typeList unused ioTypeList
:
#--- Enter in type map
  @ACGalgasType t := [@enumType new
    !mEnumTypeName
    !mConstantList
  ] ;
  [!?ioTypeMap insertKey !mEnumTypeName !t] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P    T Y P E                                                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule @mapDeclaration
  ?!@typeMap ioTypeMap
  ?!@routineMap unused ioRoutineMap
  ?!@typeList unused ioTypeList
:
#--- Attributes
  @attributeList attributeList [emptyList] ;
  call mAttributeList !?attributeList !?ioTypeMap ;
#--- Enter in type map
  @ACGalgasType t := [@mapType new
    !mMapTypeName
    !attributeList
  ] ;
  [!?ioTypeMap insertKey !mMapTypeName !t] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    L I S T    T Y P E                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule @listDeclaration
  ?!@typeMap ioTypeMap
  ?!@routineMap unused ioRoutineMap
  ?!@typeList unused ioTypeList
:
#--- Attributes
  @attributeList attributeList [emptyList] ;
  call mAttributeList !?attributeList !?ioTypeMap ;
#--- Enter in type map
  @ACGalgasType t := [@listGalgasType new
    !mListTypeName
    !attributeList
  ] ;
  [!?ioTypeMap insertKey !mListTypeName !t] ;
end rule ;

#---------------------------------------------------------------------------*

rule @attributeInCollection
  ?!@attributeList ioAttributeList
  ?!@typeMap ioTypeMap
:
  @typeMapIndex index ;
  [@typeMapIndex makeRegularIndex !mAttributeTypeName !?ioTypeMap ?index] ;
  ioAttributeList += !index !mAttributeName ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S O R T E D    L I S T    T Y P E                                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule @sortedListSortDescriptor
  ?!@sortDescriptorList ioSortDescriptorList
:
  ioSortDescriptorList += !mSortedAttributeName !mAscending ;
end rule ;

#---------------------------------------------------------------------------*

rule @sortedListDeclaration
  ?!@typeMap ioTypeMap
  ?!@routineMap unused ioRoutineMap
  ?!@typeList unused ioTypeList
:
#--- Attributes
  @attributeList attributeList [emptyList] ;
  call mAttributeList !?attributeList !?ioTypeMap ;
#--- Sort Descriptors
  @sortDescriptorList sortDescriptorList [emptyList] ;
  call mSortDescriptorList !?sortDescriptorList ;
#--- Enter in type map
  @ACGalgasType t := [@sortedlistGalgasType new
    !mSortedListTypeName
    !attributeList
    !sortDescriptorList
  ] ;
  [!?ioTypeMap insertKey !mSortedListTypeName !t] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M A P    I N D E X    T Y P E                                          *
#                                                                           *
#---------------------------------------------------------------------------*

rule @mapindexDeclaration
  ?!@typeMap ioTypeMap
  ?!@routineMap unused ioRoutineMap
  ?!@typeList unused ioTypeList
:
  @typeMapIndex index ;
  [@typeMapIndex makeRegularIndex !mMapTypeName !?ioTypeMap ?index] ;
#--- Enter in type map
  @ACGalgasType t := [@mapindexType new
    !mMapIndexName
    !index
    !mSearchMethodName
    !mSearchMethodErrorMessage
  ] ;
  [!?ioTypeMap insertKey !mMapIndexName !t] ;
end rule ;

#---------------------------------------------------------------------------*

end treewalking ;
