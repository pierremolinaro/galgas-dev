#---------------------------------------------------------------------------*
#                                                                           *
#  'semantics' component parser, as model builder                           *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax syntaxModelBuilder :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import semantics semanticsTypesForAST in "semanticsTypesForAST.gSemantics" ;
import semantics syntaxMetamodel in "syntaxMetamodel.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression> !@semanticExpressionAST outExpression ;

nonterminal <syntax_component_start_symbol> !@syntaxComponentAST outSyntaxComponentRoot ;

nonterminal <nonterminal_declaration> ?!@nonterminalDeclarationListAST ioNonterminalDeclarationList ;

nonterminal <syntax_rule_declaration> ?!@syntaxRuleListAST ioRuleList ;

nonterminal <syntax_instruction_list> !@syntaxInstructionList outSyntaxInstructionList ;

nonterminal <semantic_instruction> !@semanticInstructionAST outInstruction ;

nonterminal <syntax_instruction> !@syntaxInstructionAST outInstruction ;

nonterminal <formal_parameter_list> !@formalParameterListAST outFormalParameterList ;

nonterminal <actual_parameter_list> !@actualParameterListAST outActualParameterList ;

nonterminal <semantic_declaration>
 ?!@semanticDeclarationStructAST ioSemanticDeclarations
;

nonterminal <actual_input_parameter_list>
  !@actualInputParameterListAST outActualInputParameterList
;

nonterminal <obsolete_declaration> ;

#------------------------------------------------------------------------------*
#                                                                              *
#      S Y N T A X    C O M P O N E N T                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <syntax_component_start_symbol> !@syntaxComponentAST outSyntaxComponentRoot :
  $syntax$ ;
#--- Semantics Component Name
  $identifier$ ? @lstring mSyntaxComponentName ;
  $:$ ;
#--- Imported lexique
  $with$ ;
  $literal_string$ ? @lstring importedLexiqueReference ;
  $;$ ;
#--- Loop on import declarations
  @lstringlist importedComponentPathList [emptyList] ;
  repeat
  while
    $import$ ;
    select
      $literal_string$ ? @lstring path ;
      importedComponentPathList += !path ;
    or
      $semantics$ ;
      $identifier$ ?* ;
      $in$ ;
      $literal_string$ ? * ;
    or
      $lexique$ ;
      $identifier$ ?* ;
      $in$ ;
      $literal_string$ ? * ;
    or
      $grammar$ ;
      $identifier$ ?* ;
      $in$ ;
      $literal_string$ ? * ;
    or
      $option$ ;
      $identifier$ ?* ;
      $in$ ;
      $literal_string$ ? * ;
    end select ;
    $;$ ;
  end repeat ;
#--- Loop on declarations
  @nonterminalDeclarationListAST mNonterminalDeclarationList [emptyList] ;
  @syntaxRuleListAST mRuleList [emptyList] ;
  @semanticDeclarationStructAST mSemanticDeclarations [new
    ![@semanticDeclarationListAST emptyList]
    ![@abstractMultiMethodListMapAST emptyMap]
    ![@multiMethodListMapAST emptyMap]
    ![@overridingMultiMethodListMapAST emptyMap]
    ![@abstractMultiReaderListMapAST emptyMap]
    ![@multiReaderListMapAST emptyMap]
    ![@overridingMultiReaderListMapAST emptyMap]
  ] ;
  repeat
  while
    <nonterminal_declaration> !? mNonterminalDeclarationList ;
  while
    <syntax_rule_declaration> !? mRuleList ;
  while
    <semantic_declaration> !?mSemanticDeclarations ;
  while
    <obsolete_declaration> ;
  end repeat ;
#--- end
  $end$ ;
  const @location endOfSource := here ;
  $syntax$ ;
  $;$ ;
  outSyntaxComponentRoot := [@syntaxComponentAST new
    !mSyntaxComponentName
    !importedLexiqueReference
    !importedComponentPathList
    !mNonterminalDeclarationList
    !mRuleList
    !mSemanticDeclarations
    !endOfSource
  ] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#      N O N T E R M I N A L    D E C L A R A T I O N                          *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <nonterminal_label_declaration> ??@lstring inLabelName ?!@nonTerminalLabelListAST ioNonTerminalLabelList ;

#---------------------------------------------------------------------------*

rule <nonterminal_label_declaration> ??@lstring inLabelName ?!@nonTerminalLabelListAST ioNonTerminalLabelList :
  @formalParameterListAST mFormalParameters ;
  <formal_parameter_list> ? mFormalParameters ;
  ioNonTerminalLabelList +=
    !inLabelName
    !mFormalParameters
    !here
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <nonterminal_declaration> ?!@nonterminalDeclarationListAST ioNonterminalDeclarationList :
  @bool mHasParseLabel := false ;
  $nonterminal$ ;
  $non_terminal_symbol$ ? @lstring mNonterminalName ;
  @nonTerminalLabelListAST mLabels [emptyList] ;
  <nonterminal_label_declaration> ![@lstring new !"" !here] !?mLabels ;
  repeat
  while
    $label$ ;
    select
      @lstring labelName ;
      $identifier$ ?labelName ;
      <nonterminal_label_declaration> !labelName !?mLabels ;
    or
      $parse$ ;
      if mHasParseLabel then
        error here: "the 'parse' id already defined for this nonterminal" ;
      end if ;
      mHasParseLabel := true ;
    end select ;
  end repeat ;
  $;$ ;
  ioNonterminalDeclarationList +=
    !mNonterminalName
    !mLabels
    !mHasParseLabel
  ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#      S Y N T A X    R U L E    D E C L A R A T I O N                         *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <syntax_rule_label>
  ??@lstring inLabelName
  ?!@syntaxRuleLabelListAST ioLabelList
;

#------------------------------------------------------------------------------*

rule <syntax_rule_label>
  ??@lstring inLabelName
  ?!@syntaxRuleLabelListAST ioLabelList
:
  @formalParameterListAST mFormalParameters ;
  <formal_parameter_list> ? mFormalParameters ;
  const @location endOfArguments := here ;
  $:$ ;
  @syntaxInstructionList mSyntaxInstructionList ;
  <syntax_instruction_list> ? mSyntaxInstructionList ;
  ioLabelList +=
    !inLabelName
    !mFormalParameters
    !endOfArguments
    !mSyntaxInstructionList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <syntax_rule_declaration> ?!@syntaxRuleListAST ioRuleList :
  $rule$ ;
  $non_terminal_symbol$ ? @lstring mNonterminalName ;
  @lstring labelName [new !"" !here] ;
  @syntaxRuleLabelListAST mLabelList [emptyList] ;
  repeat
    <syntax_rule_label> !labelName !? mLabelList ;
  while
    $label$ ;
    $identifier$ ?labelName ;
  end repeat ;
  $end$ ;
  $rule$ ;
  $;$ ;
  ioRuleList +=
    !mNonterminalName
    !mLabelList
  ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   S Y N T A X    I N S T R U C T I O N    L I S T                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction_list> !@syntaxInstructionList outSyntaxInstructionList :
  outSyntaxInstructionList := [@syntaxInstructionList emptyList] ;
  repeat
  while
    @semanticInstructionAST instruction ;
    <semantic_instruction> ? instruction ;
    outSyntaxInstructionList += !instruction ;
  while
    @syntaxInstructionAST instruction ;
    <syntax_instruction> ? instruction ;
    outSyntaxInstructionList += !instruction ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   N O N T E R M I N A L    C A L L    I N S T R U C T I O N               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstructionAST outInstruction :
  $non_terminal_symbol$ ? @lstring mNonterminalName ;
  @lstring mLabelName ; # No label : empty string
  select
    mLabelName := [@lstring new !"" !here] ;
  or
    $parse$ ;
    mLabelName := [@lstring new !"parse" !here] ;
  or
    $identifier$ ? mLabelName ;
  end select ;
  @actualParameterListAST mActualParameterList ;
  <actual_parameter_list> ? mActualParameterList ;
  $;$ ;
  outInstruction := [@nonterminalCallInstruction new
    ![mNonterminalName location]
    !mNonterminalName
    !mLabelName
    !mActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   T E R M I N A L    C H E C K    I N S T R U C T I O N                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstructionAST outInstruction :
  $terminal$ ? @lstring mTerminalName ;
  @actualInputParameterListAST mActualInputParameterList ;
  <actual_input_parameter_list> ? mActualInputParameterList ;
  $;$ ;
  outInstruction := [@terminalCheckInstruction new
    ![mTerminalName location]
    !mTerminalName
    !mActualInputParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   R E P E A T    I N S T R U C T I O N                                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstructionAST outInstruction :
  $repeat$ ;
  @location mRepeatInstructionLocation := here ;
  @syntaxInstructionList mRepeatedInstructionList ;
  <syntax_instruction_list> ? mRepeatedInstructionList ;
  @listOfSyntaxInstructionList mRepeatBranchList [emptyList] ;
  repeat
    $while$ ;
    @syntaxInstructionList mInstructionList ;
    <syntax_instruction_list> ? mInstructionList ;
    mRepeatBranchList += ! mInstructionList ;
  while
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  outInstruction := [@repeatInstruction new
    !mRepeatInstructionLocation
    !mRepeatedInstructionList
    !mRepeatBranchList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   S E L E C T    I N S T R U C T I O N                                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstructionAST outInstruction :
  $select$ ;
  @location mSelectInstructionLocation := here ;
  @listOfSyntaxInstructionList mSelectBranchList [emptyList] ;
  @syntaxInstructionList instructionList ;
  <syntax_instruction_list> ? instructionList ;
  mSelectBranchList += !instructionList ;
  repeat
    $or$ ;
    <syntax_instruction_list> ? instructionList ;
    mSelectBranchList += !instructionList ;
  while
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  outInstruction := [@selectInstruction new
    !mSelectInstructionLocation
    !mSelectBranchList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   P A R S E    D O    I N S T R U C T I O N                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstructionAST outInstruction :
  $parse$ ;
  const @location instructionLocation := here ;
  $do$ ;
  @listOfSyntaxInstructionList mParseDoBranchList [emptyList] ;
  @syntaxInstructionList instructionList ;
  <syntax_instruction_list> ? instructionList ;
  mParseDoBranchList += !instructionList ;
  repeat
    $rewind$ ;
    <syntax_instruction_list> ? instructionList ;
    mParseDoBranchList += !instructionList ;
  while
  end repeat ;
  $end$ ;
  $parse$ ;
  $;$ ;
  outInstruction := [@parseDoInstruction new
    !instructionLocation
    !mParseDoBranchList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   P A R S E    W H E N    I N S T R U C T I O N                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstructionAST outInstruction :
  $parse$ ;
  const @location instructionLocation := here ;
  @whenBranchList whenBranchList [emptyList] ;
  repeat
    $when$ ;
    @semanticExpressionAST whenExpression ;
    <expression> ? whenExpression ;
    $:$ ;
    @syntaxInstructionList instructionList ;
    <syntax_instruction_list> ? instructionList ;
    whenBranchList += !whenExpression !instructionList ;
  while
  end repeat ;
  $else$ ;
  @syntaxInstructionList elseInstructionList ;
  <syntax_instruction_list> ? elseInstructionList ;
  $end$ ;
  $parse$ ;
  $;$ ;
  outInstruction := [@parseWhenInstruction new
    !instructionLocation
    !whenBranchList
    !elseInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   P A R S E    L O O P    I N S T R U C T I O N                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstructionAST outInstruction :
  $parse$ ;
  const @location instructionLocation := here ;
  $loop$ ;
  @semanticExpressionAST variantExpression ;
  <expression> ? variantExpression ;
  $while$ ;
  @semanticExpressionAST whileExpression ;
  <expression> ? whileExpression ;
  $do$ ;
  @syntaxInstructionList instructionList ;
  <syntax_instruction_list> ? instructionList ;
  $end$ ;
  $parse$ ;
  $;$ ;
  outInstruction := [@parseLoopInstruction new
    !instructionLocation
    !variantExpression
    !whileExpression
    !instructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   B L O C K    I N S T R U C T I O N                                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstructionAST outInstruction :
  $block$ ;
  const @location instructionLocation := here ;
  $identifier$ ? @lstring mReceiverVariable ;
  $.$ ;
  $identifier$ ? @lstring mBlockMethodName ;
  $($ ;
  @actualParameterListAST mPrologActualParameterList ;
  <actual_parameter_list> ? mPrologActualParameterList ;
  $)$ ;
  $:$ ;
  @syntaxInstructionList mInstructionList ;
  <syntax_instruction_list> ? mInstructionList ;
  $end$ ;
  $block$ ;
  $($ ;
  @actualParameterListAST mEpilogActualParameterList ;
  <actual_parameter_list> ? mEpilogActualParameterList ;
  $)$ ;
  $;$ ;
  outInstruction := [@blockInstruction new
    !instructionLocation
    !mReceiverVariable
    !mBlockMethodName
    !mPrologActualParameterList
    !mInstructionList
    !mEpilogActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;