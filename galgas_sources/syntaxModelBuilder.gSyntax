#---------------------------------------------------------------------------*
#                                                                           *
#  'semantics' component parser, as model builder                           *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax syntaxModelBuilder :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import semantics expressionMetamodel in "expressionMetamodel.gSemantics" ;
import semantics instructionMetamodel in "instructionMetamodel.gSemantics" ;
import semantics parameterArgumentMetamodel in "parameterArgumentMetamodel.gSemantics" ;
import semantics syntaxMetamodel in "syntaxMetamodel.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <syntax_component_start_symbol> !@syntaxComponentRoot outSyntaxComponentRoot ;

nonterminal <nonterminal_declaration> ?!@nonterminalDeclarationList ioNonterminalDeclarationList ;

nonterminal <syntax_rule_declaration> ?!@syntaxRuleList ioRuleList ;

nonterminal <syntax_instruction_list> !@syntaxInstructionList outSyntaxInstructionList ;

nonterminal <semantic_instruction> !@semanticInstruction outInstruction ;

nonterminal <syntax_instruction> !@syntaxInstruction outInstruction ;

nonterminal <formal_parameter_list> !@formalParameterList outFormalParameterList ;

nonterminal <actual_parameter_list> !@actualParameterList outActualParameterList ;

nonterminal <semantic_declaration>
 ?!@semanticDeclarationStruct ioSemanticDeclarations
;

nonterminal <actual_input_parameter_list>
  !@actualInputParameterList outActualInputParameterList
;

#------------------------------------------------------------------------------*
#                                                                              *
#      S Y N T A X    C O M P O N E N T                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <syntax_component_start_symbol> !@syntaxComponentRoot outSyntaxComponentRoot :
  $syntax$ ;
#--- Semantics Component Name
  $identifier$ ? @lstring mSyntaxComponentName ;
  $:$ ;
#--- Imported lexique
  $with$ ;
  $literal_string$ ? @lstring importedLexiqueReference ;
  $;$ ;
#--- Loop on import declarations
  repeat
  while
    $import$ ;
    select
      $semantics$ ;
    or
      $lexique$ ;
    or
      $grammar$ ;
    or
      $option$ ;
    end select ;
    $identifier$ ?* ;
    $in$ ;
    $literal_string$ ? * ;
    $;$ ;
  end repeat ;
#--- Loop on declarations
  @nonterminalDeclarationList mNonterminalDeclarationList [emptyList] ;
  @syntaxRuleList mRuleList [emptyList] ;
  @semanticDeclarationStruct mSemanticDeclarations [new
    ![@semanticDeclarationList emptyList]
    ![@abstractCategoryMethodListMap emptyMap]
    ![@categoryMethodListMap emptyMap]
    ![@overridingCategoryMethodListMap emptyMap]
    ![@abstractCategoryReaderListMap emptyMap]
    ![@categoryReaderListMap emptyMap]
    ![@overridingCategoryReaderListMap emptyMap]
  ] ;
  repeat
  while
    <nonterminal_declaration> !? mNonterminalDeclarationList ;
  while
    <syntax_rule_declaration> !? mRuleList ;
  while
    <semantic_declaration> !?mSemanticDeclarations ;
  end repeat ;
#--- end
  $end$ ;
  $syntax$ ;
  $;$ ;
  outSyntaxComponentRoot := [@syntaxComponentRoot new
    !mSyntaxComponentName
    !importedLexiqueReference
    !mNonterminalDeclarationList
    !mRuleList
    !mSemanticDeclarations
  ] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#      N O N T E R M I N A L    D E C L A R A T I O N                          *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <nonterminal_label_declaration> ??@lstring inLabelName ?!@nonTerminalLabelList ioNonTerminalLabelList ;

#---------------------------------------------------------------------------*

rule <nonterminal_label_declaration> ??@lstring inLabelName ?!@nonTerminalLabelList ioNonTerminalLabelList :
  @formalParameterList mFormalParameters ;
  <formal_parameter_list> ? mFormalParameters ;
  ioNonTerminalLabelList +=
    !inLabelName
    !mFormalParameters
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <nonterminal_declaration> ?!@nonterminalDeclarationList ioNonterminalDeclarationList :
  @bool mHasParseLabel := false ;
  $nonterminal$ ;
  $non_terminal_symbol$ ? @lstring mNonterminalName ;
  @nonTerminalLabelList mLabels [emptyList] ;
  <nonterminal_label_declaration> ![@lstring new !"" !here] !?mLabels ;
  repeat
  while
    $label$ ;
    select
      @lstring labelName ;
      $identifier$ ?labelName ;
      <nonterminal_label_declaration> !labelName !?mLabels ;
    or
      $parse$ ;
      if mHasParseLabel then
        error here: "the 'parse' id already defined for this nonterminal" ;
      end if ;
      mHasParseLabel := true ;
    end select ;
  end repeat ;
  $;$ ;
  ioNonterminalDeclarationList +=
    !mNonterminalName
    !mLabels
    !mHasParseLabel
  ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#      S Y N T A X    R U L E    D E C L A R A T I O N                         *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <syntax_rule_label>
  ??@lstring inLabelName
  ?!@syntaxRuleLabelList ioLabelList
;

#------------------------------------------------------------------------------*

rule <syntax_rule_label>
  ??@lstring inLabelName
  ?!@syntaxRuleLabelList ioLabelList
:
  @formalParameterList mFormalParameters ;
  <formal_parameter_list> ? mFormalParameters ;
  $:$ ;
  @syntaxInstructionList mSyntaxInstructionList ;
  <syntax_instruction_list> ? mSyntaxInstructionList ;
  ioLabelList +=
    !inLabelName
    !mFormalParameters
    !mSyntaxInstructionList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <syntax_rule_declaration> ?!@syntaxRuleList ioRuleList :
  $rule$ ;
  $non_terminal_symbol$ ? @lstring mNonterminalName ;
  @lstring labelName [new !"" !here] ;
  @syntaxRuleLabelList mLabelList [emptyList] ;
  repeat
    <syntax_rule_label> !labelName !? mLabelList ;
  while
    $label$ ;
    $identifier$ ?labelName ;
  end repeat ;
  $end$ ;
  $rule$ ;
  $;$ ;
  ioRuleList +=
    !mNonterminalName
    !mLabelList
  ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   S Y N T A X    I N S T R U C T I O N    L I S T                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction_list> !@syntaxInstructionList outSyntaxInstructionList :
  outSyntaxInstructionList := [@syntaxInstructionList emptyList] ;
  repeat
  while
    @semanticInstruction instruction ;
    <semantic_instruction> ? instruction ;
    outSyntaxInstructionList += !instruction ;
  while
    @syntaxInstruction instruction ;
    <syntax_instruction> ? instruction ;
    outSyntaxInstructionList += !instruction ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   N O N T E R M I N A L    C A L L    I N S T R U C T I O N               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstruction outInstruction :
  $non_terminal_symbol$ ? @lstring mNonterminalName ;
  @lstring mLabelName ; # No label : empty string
  select
    mLabelName := [@lstring new !"" !here] ;
  or
    $parse$ ;
    mLabelName := [@lstring new !"parse" !here] ;
  or
    $identifier$ ? mLabelName ;
  end select ;
  @actualParameterList mActualParameterList ;
  <actual_parameter_list> ? mActualParameterList ;
  $;$ ;
  outInstruction := [@nonterminalCallInstruction new
    !mNonterminalName
    !mLabelName
    !mActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   T E R M I N A L    C H E C K    I N S T R U C T I O N                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstruction outInstruction :
  $terminal$ ? @lstring mTerminalName ;
  @actualInputParameterList mActualInputParameterList ;
  <actual_input_parameter_list> ? mActualInputParameterList ;
  $;$ ;
  outInstruction := [@terminalCheckInstruction new
    !mTerminalName
    !mActualInputParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   R E P E A T    I N S T R U C T I O N                                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstruction outInstruction :
  $repeat$ ;
  @syntaxInstructionList mRepeatedInstructionList ;
  <syntax_instruction_list> ? mRepeatedInstructionList ;
  @listOfSyntaxInstructionList mRepeatBranchList [emptyList] ;
  repeat
    $while$ ;
    @syntaxInstructionList mInstructionList ;
    <syntax_instruction_list> ? mInstructionList ;
    mRepeatBranchList += ! mInstructionList ;
  while
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  outInstruction := [@repeatInstruction new
    !mRepeatedInstructionList
    !mRepeatBranchList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   S E L E C T    I N S T R U C T I O N                                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstruction outInstruction :
  $select$ ;
  @listOfSyntaxInstructionList mSelectBranchList [emptyList] ;
  @syntaxInstructionList instructionList ;
  <syntax_instruction_list> ? instructionList ;
  mSelectBranchList += !instructionList ;
  repeat
    $or$ ;
    <syntax_instruction_list> ? instructionList ;
    mSelectBranchList += !instructionList ;
  while
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  outInstruction := [@selectInstruction new
    !mSelectBranchList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   P A R S E    D O    I N S T R U C T I O N                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstruction outInstruction :
  $parse$ ;
  $do$ ;
  @listOfSyntaxInstructionList mParseDoBranchList [emptyList] ;
  @syntaxInstructionList instructionList ;
  <syntax_instruction_list> ? instructionList ;
  mParseDoBranchList += !instructionList ;
  repeat
    $rewind$ ;
    <syntax_instruction_list> ? instructionList ;
    mParseDoBranchList += !instructionList ;
  while
  end repeat ;
  $end$ ;
  $parse$ ;
  $;$ ;
  outInstruction := [@parseDoInstruction new
    !mParseDoBranchList
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   B L O C K    I N S T R U C T I O N                                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <syntax_instruction> !@syntaxInstruction outInstruction :
  $block$ ;
  $identifier$ ? @lstring mReceiverVariable ;
  $.$ ;
  $identifier$ ? @lstring mBlockMethodName ;
  $($ ;
  @actualParameterList mPrologActualParameterList ;
  <actual_parameter_list> ? mPrologActualParameterList ;
  $)$ ;
  $:$ ;
  @syntaxInstructionList mInstructionList ;
  <syntax_instruction_list> ? mInstructionList ;
  $end$ ;
  $block$ ;
  $($ ;
  @actualParameterList mEpilogActualParameterList ;
  <actual_parameter_list> ? mEpilogActualParameterList ;
  $)$ ;
  $;$ ;
  outInstruction := [@blockInstruction new
    !mReceiverVariable
    !mBlockMethodName
    !mPrologActualParameterList
    !mInstructionList
    !mEpilogActualParameterList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;