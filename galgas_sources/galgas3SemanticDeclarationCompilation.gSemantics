#---------------------------------------------------------------------------*
#                                                                           *
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics galgas3SemanticDeclarationCompilation :
import "optionTypesForAST.gSemantics" ;
import "semanticAnalysis.gSemantics" ;
import "predefinedTypes.gSemantics" ;
import "semanticsCompilation.gSemantics" ;
import "projectGlobalCheckings.gSemantics" ;

#---------------------------------------------------------------------------*

routine compileSemanticDeclarationsGalgas3
  ??@string inProductDirectory
  ??@location inEndOfProjectSourceFile
  ??@semanticDeclarationListAST inSemanticDeclarationList
  !@semanticContext outSemanticContext
  !@semanticDeclarationSortedListForGeneration outSemanticDeclarationSortedListForGeneration
:
  message "*** Building context\n" ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := inSemanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#---- Add predefined option component
  @commandLineOptionListAST options := {} ;
  foreach [@application boolOptionNameList] do
    options +=
      !["bool" nowhere]
      ![@lstring new !mValue1 !here]
      ![@lchar new ![@application boolOptionInvocationLetter !mValue0 !mValue1] ![@location nowhere]]
      ![[@application boolOptionInvocationString !mValue0 !mValue1] nowhere]
      ![[@application boolOptionCommentString !mValue0 !mValue1] nowhere]
      !["" nowhere]
      ![@optionDefaultValueEnumAST noDefaultValue]
    ;
  end foreach ;
  foreach [@application uintOptionNameList] do
    options +=
      !["uint" nowhere]
      ![@lstring new !mValue1 !here]
      ![@lchar new ![@application boolOptionInvocationLetter !mValue0 !mValue1] ![@location nowhere]]
      ![[@application boolOptionInvocationString !mValue0 !mValue1] nowhere]
      ![[@application boolOptionCommentString !mValue0 !mValue1] nowhere]
      !["" nowhere]
      ![@optionDefaultValueEnumAST noDefaultValue]
    ;
  end foreach ;
  foreach [@application stringOptionNameList] do
    options +=
      !["string" nowhere]
      ![@lstring new !mValue1 !here]
      ![@lchar new ![@application boolOptionInvocationLetter !mValue0 !mValue1] ![@location nowhere]]
      ![[@application boolOptionInvocationString !mValue0 !mValue1] nowhere]
      ![[@application boolOptionCommentString !mValue0 !mValue1] nowhere]
      !["" nowhere]
      ![@optionDefaultValueEnumAST noDefaultValue]
    ;
  end foreach ;
  semanticDeclarationListWithPredefinedTypes += ![@optionComponentDeclarationAST new
    !true # Is predefined
    !["galgas_builtin_options" nowhere]
    !options
  ] ;
#------ Build semantic context
  buildGalgas3SemanticContext
    !semanticDeclarationListWithPredefinedTypes
    !inEndOfProjectSourceFile
    ?outSemanticContext
    ??@semanticDeclarationListAST sortedSemanticDeclarationListAST
  ;
#---
  if [option .verbose_output value] then
    message "*** Semantic analysis\n" ;
  end if ;
#------ Check there is no undefined types
  foreach [outSemanticContext->mTypeMap unsolvedProxyList] do
    error mValue : "the '" . mValue . "' type is undefined" ;
  end foreach ;
#------ Semantic Analysis
  outSemanticDeclarationSortedListForGeneration := [@semanticDeclarationSortedListForGeneration emptySortedList] ;
  if [@uint errorCount] == 0 then
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!outSemanticContext] ;
    foreach sortedSemanticDeclarationListAST do
      [mSemanticDeclaration semanticAnalysis
        !inProductDirectory
        !outSemanticContext
        !predefinedTypes
        !?outSemanticDeclarationSortedListForGeneration
      ] ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

#routine buildGalgas3GrammarComponentMapForSemanticAnalysis
#  ??@galgas3GrammarComponentListAST inGrammarComponentList
#  ?!@semanticContext ioSemanticContext
#:
##--- Perform semantic analysis of grammar components
#  foreach inGrammarComponentList do
#  #--- Analyze start symbol labels
#    @grammarLabelMap grammarLabelMap [emptyMap] ;
#    foreach mStartSymbolLabelList do
#    #--- Analyze signature
#      @formalParameterSignature formalArgumentList [emptyList] ;
#      foreach mFormalArgumentList do
#        formalArgumentList +=
#          !mFormalSelector
#          ![@unifiedTypeMapProxy searchKey !ioSemanticContext->mTypeMap !mFormalArgumentTypeName]
#          !mFormalArgumentPassingMode
#          !mFormalArgumentName->string
#        ;
#      end foreach ;
#      [!?grammarLabelMap insertKey
#        !mLabelName
#        !formalArgumentList
#      ] ;
#    end foreach ;
#  #--- Insert grammar in grammar map
#    [!?ioSemanticContext->mGrammarMap insertGrammar
#      !mGrammarComponentName
#      !grammarLabelMap
#      !mHasIndexing->bool
#      !mHasTranslateFeature
#    ] ;
#  end foreach ;
#end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    B U I L D    S E M A N T I C    C O N T E X T                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildGalgas3SemanticContext
  ??@semanticDeclarationListAST inSemanticDeclarationList
  ??@location inEndOfProjectSourceFile
  !@semanticContext outSemanticContext
  !@semanticDeclarationListAST outSortedSemanticDeclarationListAST
:
#------ Create associated type (@TYPE-element) for lists, maps, ...
  @semanticDeclarationListAST semanticDeclarationList := inSemanticDeclarationList ;
  foreach inSemanticDeclarationList do
    [mSemanticDeclaration addAssociatedElement !?semanticDeclarationList] ;
  end foreach ;
#------ Build ordered types list, so that
#  - a class appears after its super class
#  - a map index appears after its associated map
#  - a list map appears after its associated list
  @semanticTypePrecedenceGraph semanticTypePrecedenceGraph [emptyGraph] ;
  @categoryMethodMapForBuildingContext categoryMethodMapForBuildingContext [emptyMap] ;
  @categoryReaderMapForBuildingContext categoryReaderMapForBuildingContext  [emptyMap] ;
  @categoryModifierMapForBuildingContext categoryModifierMapForBuildingContext  [emptyMap] ;
  @semanticDeclarationListAST categoryOverrideDefinitionList [emptyList] ;
  foreach semanticDeclarationList do
    [mSemanticDeclaration enterDeclarationInGraph
      !?semanticTypePrecedenceGraph
      !?categoryMethodMapForBuildingContext
      !?categoryReaderMapForBuildingContext
      !?categoryModifierMapForBuildingContext
      !?categoryOverrideDefinitionList
    ] ;  
  end foreach ;
  if [semanticTypePrecedenceGraph undefinedNodeCount] > 0 then
    foreach [semanticTypePrecedenceGraph undefinedNodeReferenceList] do
      error mValue : "the '" . mValue . "' type is not defined" ;
    end foreach ;
    error inEndOfProjectSourceFile : "semantic analysis not performed, due to undefined type error(s)" : outSemanticContext, outSortedSemanticDeclarationListAST ;
  else
    [semanticTypePrecedenceGraph topologicalSort
      ?outSortedSemanticDeclarationListAST
      ?*
      ?@semanticDeclarationListAST unsortedSemanticDeclarationListAST
      ?@lstringlist unsortedNodeKeyList
    ] ;
    if [unsortedSemanticDeclarationListAST length] > 0 then
      @string s := "semantic analysis not performed, " . [[unsortedSemanticDeclarationListAST length] string] . " declarations are involved in circular definition:" ;
      foreach unsortedSemanticDeclarationListAST do
        s .= "\n-  " . [mSemanticDeclaration keyRepresentation] ;
      end foreach ;
      error inEndOfProjectSourceFile : s : outSemanticContext ;
    else
    #--- Add category override
      outSortedSemanticDeclarationListAST .= categoryOverrideDefinitionList ;
    #--- Build initial semantic context
      outSemanticContext := [@semanticContext default] ;
    #--- Loop throught all declarations
      foreach outSortedSemanticDeclarationListAST do
        [mSemanticDeclaration enterInSemanticContext
          !categoryMethodMapForBuildingContext
          !categoryReaderMapForBuildingContext
          !categoryModifierMapForBuildingContext
          !?outSemanticContext
        ] ;
      end foreach ;
    end if ;
  end if ;
#--- Generate graphviz file
#  const graphvizText := [semanticTypePrecedenceGraph graphviz] ;
#  const graphvizFilePath := [inProjectSourceFile stringByDeletingPathExtension] . "+type-precedence.dot" ;
#  [graphvizText writeToFileWhenDifferentContents !graphvizFilePath ?*] ;
end routine ;

#---------------------------------------------------------------------------*
#! Generation
#---------------------------------------------------------------------------*

local once definitionGroupAmount -> @uint outResult :
  outResult := 100 ;
end once ;

#---------------------------------------------------------------------------*

routine generateSemanticDeclarationsGalgas3
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
#--- Generate specific file
  for () in inSemanticDeclarationSortedListForGeneration do
    [mDeclaration appendSpecificFiles
      !inProductDirectory
      !?ioAllProductFileSet
    ] ;
  end for ;
  if [@uint errorCount] == 0 then
    if [option galgas_cli_options.generateOneHeader value] then
       generateOneBigHeader
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioAllProductFileSet
      ;
    elsif not generateFewHeaderFiles [] then
#    elsif generateFewHeaderFiles [] then
#      generateFewHeaders
#        !inProductDirectory
#        !inSemanticDeclarationSortedListForGeneration
#        !?ioAllProductFileSet
#      ;
#    else
      generateManyHeaders
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioAllProductFileSet
      ;
    end if ;
    if [option galgas_cli_options.generateManyFiles value] then
      generateManyImplementationFiles
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioToolProductFileList
        !?ioAllProductFileSet
      ;
    elsif generateFewHeaderFiles [] then
      generateFewImplementationFilesWithFewHeaders
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioToolProductFileList
        !?ioAllProductFileSet
      ;
    else
      generateFewImplementationFiles
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioToolProductFileList
        !?ioAllProductFileSet
      ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateManyHeaders
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringset ioAllProductFileSet
:
#--- Header files
  var headerInclusionList1 := [@stringlist emptyList] ;
  var headerInclusionList2 := [@stringlist emptyList] ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet1 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerDef1] ;
      var headerIncludes1 := "" ;
      if [inclusionSet1 hasKey !""] then
        message "Empty inclusion in " . [mDeclaration implementationCppFileName] . "headers 1\n" ;
      end if ;
      for (s) in inclusionSet1 do
        headerIncludes1 .= "#include \"" . s . ".h\"\n" ;
      end for ;
      headerIncludes1 += headerDef1 ;
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerDef2] ;
      var headerIncludes2 := "" ;
      if [inclusionSet2 hasKey !""] then
        message "Empty inclusion in " . [mDeclaration implementationCppFileName] . "headers 2\n" ;
      end if ;
      for (s) in inclusionSet2 do
        headerIncludes2 .= "#include \"" . s . ".h\"\n" ;
      end for ;
      headerIncludes2 += headerDef2 ;
    #---
      switch [mDeclaration headerKind]
      when noHeader :
        if headerIncludes1 != "" then
          error ["" nowhere] : "'noHeader' setting for the '" . mMessage . "' declaration, and 'headerIncludes1' string is not empty" ;
        end if ;
        if headerIncludes2 != "" then
          error ["" nowhere] : "'noHeader' setting for the '" . mMessage . "' declaration, and 'headerIncludes2' string is not empty" ;
        end if ;
      when oneHeader :
        if headerIncludes1 == "" then
          error ["" nowhere] : "'oneHeader' setting for the '" . mMessage . "' declaration, and 'headerIncludes1' string is empty" ;
        end if ;
        if headerIncludes2 != "" then
          warning ["" nowhere] : "'oneHeader' setting for the '" . mMessage . "' declaration, and 'headerIncludes2' string is not empty" ;
        end if ;
      when twoHeaders :
        if headerIncludes1 == "" then
          warning ["" nowhere] : "'twoHeaders' setting for the '" . mMessage . "' declaration, and 'headerIncludes1' string is empty" ;
        end if ;
        if headerIncludes2 == "" then
          warning ["" nowhere] : "'twoHeaders' setting for the '" . mMessage . "' declaration, and 'headerIncludes2' string is empty" ;
        end if ;
      end switch ;
    #--- Header 1
      if [mDeclaration headerKind] != [@headerKind noHeader] then
        var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n" ;
        headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= headerIncludes1 ;
        headerString .= "\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= "#endif\n\n" ;
        const headerFileName := [mDeclaration implementationCppFileName] + if [mDeclaration headerKind] == [@headerKind twoHeaders] then "-1" else "" end ;
        headerInclusionList1 += !headerFileName ;
        ioAllProductFileSet += !headerFileName . ".h" ;
        [@string generateFile
          !inProductDirectory
          !headerFileName . ".h"
          !headerString
        ] ;
      end if ;
    #--- Header 2
      if [mDeclaration headerKind] == [@headerKind twoHeaders] then
        var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
        headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= "#include \"" . [mDeclaration implementationCppFileName] . "-1.h\"\n" ;
        headerString .= "\n//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= headerIncludes2 ;
        headerString .= "\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= "#endif\n\n" ;
        headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
        ioAllProductFileSet += ![mDeclaration implementationCppFileName] . ".h" ;
        [@string generateFile
          !inProductDirectory
          ![mDeclaration implementationCppFileName] . ".h"
          !headerString
        ] ;
      end if  ;
    end if ;
  end foreach ;
#-------------------------------------- all-declarations.h
  var headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
    !"all-declarations"
    !headerInclusionList1 + headerInclusionList2
  ] ;
  ioAllProductFileSet += !"all-declarations.h" ;
  [@string generateFile
    !inProductDirectory
    !"all-declarations.h"
    !headerString + "#endif\n"
  ] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateOneBigHeader
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringset ioAllProductFileSet
:
  var headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
    !"all-declarations"
    ![@stringlist emptyList]
  ] ;
#--- Declaration 1
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet1 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerString1] ;
      headerString .= headerString1 ;
    end if ;
  end foreach ;
#--- Declaration 2
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerString2] ;
      headerString .= headerString2 ;
    end if ;
  end foreach ;
  ioAllProductFileSet += !"all-declarations.h" ;
  [@string generateFile
    !inProductDirectory
    !"all-declarations.h"
    !headerString + "#endif\n"
  ] ;
end routine ;

#---------------------------------------------------------------------------*

map @headerCompositionMap {
  @stringset mInclusion ;
  @string mHeaderString ;
  insert insertKey error message "the '%K' key is already declared in %L" ;
  search searchKey error message "there is no '%K' key" ;
}

#---------------------------------------------------------------------------*

map @headerRepartitionMap {
  @string mHeaderFileName ;
  insert insertKey error message "the '%K' key is already declared in %L" ;
  search searchKey error message "there is no '%K' key" ;
}

#---------------------------------------------------------------------------*

local routine buildHeader
  ??@headerCompositionMap inHeaderCompositionMap
  ??@string inHeaderFileName
  ??@string inDeclarationName
  ?!@headerRepartitionMap ioHeaderRepartitionMap
  ?!@string ioHeaderString
:
#---
  if not [ioHeaderRepartitionMap hasKey !inDeclarationName] then
    [!?ioHeaderRepartitionMap insertKey ![inDeclarationName nowhere] !inHeaderFileName] ;
    if [inHeaderCompositionMap hasKey !inDeclarationName] then
      [inHeaderCompositionMap searchKey
        ![inDeclarationName nowhere]
        ??@stringset inclusionSet
        ??@string headerString
      ] ;
      ioHeaderString += "//START--- " + inDeclarationName + "\n" ;
      for (s) in inclusionSet do
        buildHeader
          !inHeaderCompositionMap
          !inHeaderFileName
          !s
          !?ioHeaderRepartitionMap
          !?ioHeaderString
        ;
      end for ;
      ioHeaderString += "//--- " + inDeclarationName + "\n" ;
      for (s) in inclusionSet do
        ioHeaderString += "  // " + s + "\n" ;
      end for ;
      ioHeaderString += headerString ;
    else
      ioHeaderString += "#include \"" + inDeclarationName + ".h\"\n" ;
    end if ;
  else
    ioHeaderString += "//--- " + inDeclarationName + " already included\n" ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

#local routine buildSpecificHeader
#  ??@headerCompositionMap inHeaderCompositionMap
#  ??@string inHeaderFileName
#  ??@stringset inInclusionSet
#  ?!@headerRepartitionMap ioHeaderRepartitionMap
#  ?!@string ioHeaderString
#:
##---
#  for (s) in inInclusionSet do
#    if not [ioHeaderRepartitionMap hasKey !inDeclarationName] then
#      [!?ioHeaderRepartitionMap insertKey ![inDeclarationName nowhere] !inHeaderFileName] ;
#      [inHeaderCompositionMap searchKey
#        ![inDeclarationName nowhere]
#        ??@stringset inclusionSet
#        ??@string headerString
#      ] ;
#      ioHeaderString += "//START--- " + inDeclarationName + "\n" ;
#      for (s) in inclusionSet do
#        buildHeader
#          !inHeaderCompositionMap
#          !inHeaderFileName
#          !s
#          !?ioHeaderRepartitionMap
#          !?ioHeaderString
#        ;
#      end for ;
#      ioHeaderString += "//--- " + inDeclarationName + "\n" ;
#      for (s) in inclusionSet do
#        ioHeaderString += "  // " + s + "\n" ;
#      end for ;
#      ioHeaderString += headerString ;
#    else
#      ioHeaderString += "//--- " + inDeclarationName + " already included\n" ;
#    end if ;
#  end for ;
#end routine ;

#---------------------------------------------------------------------------*

#local routine generateFewHeaders
#  ??@string inProductDirectory
#  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
#  ?!@stringset ioAllProductFileSet
#:
##--- Build header composition map
#  @headerCompositionMap headerCompositionMap := {} ;
#  foreach inSemanticDeclarationSortedListForGeneration do
#    if not [mDeclaration isPredefined] then
#      var inclusionSet1 := [@stringset emptySet] ;
#      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerString1] ;
#      var inclusionSet2 := [@stringset emptySet] ;
#      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerString2] ;
#      if [mDeclaration headerKind] != [@headerKind noHeader] then
#        const headerFileName := [mDeclaration implementationCppFileName] + if [mDeclaration headerKind] == [@headerKind twoHeaders] then "-1" else "" end ;
#        [!?headerCompositionMap insertKey
#          ![headerFileName nowhere]
#          !inclusionSet1
#          !headerString1
#        ] ;
#      end if ;
#      if [mDeclaration headerKind] == [@headerKind twoHeaders] then
#        [!?headerCompositionMap insertKey
#          ![[mDeclaration implementationCppFileName] nowhere]
#          !inclusionSet2 | @stringset {![mDeclaration implementationCppFileName] + "-1"}
#          !headerString2
#        ] ;
#      end if ;
#    end if ;
#  end foreach ;
##---
#  var n := 0 ;
#  var fileIdx := 0 ;
#  var headerFileName := "all-declarations-" + fileIdx ;
#  var implementationString := "" ;
#  @headerRepartitionMap headerRepartitionMap := {} ;
#  foreach inSemanticDeclarationSortedListForGeneration do
#    n ++ ;
#    if not [mDeclaration isPredefined] then
#      if [mDeclaration headerKind] == [@headerKind twoHeaders] then
#        buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName] +"-1" !?headerRepartitionMap !?implementationString ;
#        buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName]  !?headerRepartitionMap !?implementationString ;
#      elsif [mDeclaration headerKind] == [@headerKind oneHeader] then
#        buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName]  !?headerRepartitionMap !?implementationString ;
#      end if ;
#    end if ;
#    if n == definitionGroupAmount [] then
#      const headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
#        !headerFileName
#        !if fileIdx == 0 then {} else {!"all-declarations-" + (fileIdx-1)} end
#      ] ;
#      [@string generateFile
#        !inProductDirectory
#        !headerFileName + ".h"
#        !headerString + implementationString + "#endif\n"
#      ] ;
#      ioAllProductFileSet += !headerFileName + ".h" ;
#      n := 0 ;
#      fileIdx ++ ;
#      headerFileName := "all-declarations-" + fileIdx ;
#      implementationString := "" ;
#    end if ;
#  end foreach ;
##---
#  const headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
#    !headerFileName
#    !{!"all-declarations-" + (fileIdx-1)}
#  ] ;
#  [@string generateFile
#    !inProductDirectory
#    !headerFileName + ".h"
#    !headerString + implementationString + "#endif\n"
#  ] ;
#  ioAllProductFileSet += !headerFileName + ".h" ;
##---
#  [@string generateFile
#    !inProductDirectory
#    !"all-declarations.h"
#    ![filewrapper semanticFileGenerationTemplate.semanticFileHeader
#       !"all-declarations"
#       !{!"all-declarations-" + fileIdx}
#     ] + "#endif\n"
#  ] ;
#  ioAllProductFileSet += !"all-declarations.h" ;
#end routine ;
#
#---------------------------------------------------------------------------*

local routine generateFewImplementationFiles
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
  const useOneHugeHeader := [option galgas_cli_options.generateOneHeader value] ;
#------------- all-declarations.cpp
  var n := 0 ;
  var fileIdx := 0 ;
  var implementationString := "" ;
  @stringset inclusionSet := {} ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      [mDeclaration appendSpecificImplementation !?inclusionSet ??@string code] ;
      if [inclusionSet hasKey !""] then
        message "Empty inclusion in " . [mDeclaration implementationCppFileName] . " cpp headers\n" ;
      end if ;
      implementationString += code ;
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      n ++ ;
      if n == definitionGroupAmount [] then
        if useOneHugeHeader then
          inclusionSet := [@stringset setWithString !"all-declarations"] ;
#        elsif generateFewHeaderFiles [] then
#          inclusionSet := {!"all-declarations-" . fileIdx} ;
        end if ;
#        for () in inSemanticContext->mGrammarMap do
#          inclusionSet += !"grammar-" . lkey->string ;
#        end for ;
        const header := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
          ![inclusionSet stringList]
        ] ;
        const fileName := "all-declarations-" . fileIdx . ".cpp" ;
        ioToolProductFileList := [@stringlist listWithValue !fileName] + ioToolProductFileList ;
        ioAllProductFileSet += !fileName ;
        [@string generateFile
          !inProductDirectory
          !fileName
          !header + implementationString
        ] ;
        n := 0 ;
        fileIdx ++ ;
        implementationString := "" ;
        inclusionSet := [@stringset emptySet] ;
      end if ;
    end if ;
  end foreach ;
#--- Last file
  if implementationString != "" then
    if useOneHugeHeader then
      inclusionSet := [@stringset setWithString !"all-declarations"] ;
    end if ;
#    for () in inSemanticContext->mGrammarMap do
#      inclusionSet += !"grammar-" . lkey->string ;
#    end for ;
    const header := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
#      !if generateFewHeaderFiles [] then {!"all-declarations-" . fileIdx} else [inclusionSet stringList] end
      ![inclusionSet stringList]
    ] ;
    const fileName := "all-declarations-" . fileIdx . ".cpp" ;
    ioToolProductFileList := [@stringlist listWithValue !fileName] + ioToolProductFileList ;
    ioAllProductFileSet += !fileName ;
    [@string generateFile
      !inProductDirectory
      !fileName
      !header + implementationString
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateFewImplementationFilesWithFewHeaders
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
  const useOneHugeHeader := [option galgas_cli_options.generateOneHeader value] ;
  @headerCompositionMap headerCompositionMap := {} ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet1 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerString1] ;
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerString2] ;
      if [mDeclaration headerKind] != [@headerKind noHeader] then
        const headerFileName := [mDeclaration implementationCppFileName] + if [mDeclaration headerKind] == [@headerKind twoHeaders] then "-1" else "" end ;
        [!?headerCompositionMap insertKey
          ![headerFileName nowhere]
          !inclusionSet1
          !headerString1
        ] ;
      end if ;
      if [mDeclaration headerKind] == [@headerKind twoHeaders] then
        [!?headerCompositionMap insertKey
          ![[mDeclaration implementationCppFileName] nowhere]
          !inclusionSet2 | @stringset {![mDeclaration implementationCppFileName] + "-1"}
          !headerString2
        ] ;
      end if ;
    end if ;
  end foreach ;
#------------- all-declarations.cpp
  @headerRepartitionMap headerRepartitionMap := {} ;
  var fileIdx := 0 ;
  var implementationString := "" ;
  var headerString := "" ;
  @stringset inclusionSet := {} ;
  var headerFileName := "all-declarations-" + fileIdx ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      if not [mDeclaration isPredefined] then
        if [mDeclaration headerKind] == [@headerKind twoHeaders] then
          buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName] +"-1" !?headerRepartitionMap !?headerString ;
          buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName] !?headerRepartitionMap !?headerString ;
        elsif [mDeclaration headerKind] == [@headerKind oneHeader] then
          buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName] !?headerRepartitionMap !?headerString ;
        end if ;
      end if ;
      [mDeclaration appendSpecificImplementation !?inclusionSet ??@string code] ;
      for (s) in inclusionSet do
        buildHeader !headerCompositionMap !headerFileName !s !?headerRepartitionMap !?headerString ;
      end for ;
      implementationString += code ;
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      if [implementationString length] > 1000000 then
        if useOneHugeHeader then
          inclusionSet := [@stringset setWithString !"all-declarations"] ;
#        elsif generateFewHeaderFiles [] then
        else
          inclusionSet := {!"all-declarations-" . fileIdx} ;
        end if ;
#        for () in inSemanticContext->mGrammarMap do
#          inclusionSet += !"grammar-" . lkey->string ;
#        end for ;
     #---
        const cppHeader := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
          ![inclusionSet stringList]
        ] ;
        const fileName := "all-declarations-" . fileIdx . ".cpp" ;
        ioToolProductFileList := [@stringlist listWithValue !fileName] + ioToolProductFileList ;
        ioAllProductFileSet += !fileName ;
        [@string generateFile
          !inProductDirectory
          !fileName
          !cppHeader + implementationString
        ] ;
      #---
        ioAllProductFileSet += !headerFileName + ".h" ;
        const startOfHeader := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
          !headerFileName
          !if fileIdx == 0 then {} else {!"all-declarations-" + (fileIdx-1)} end
        ] ;
        [@string generateFile
          !inProductDirectory
          !headerFileName + ".h"
          !startOfHeader + headerString + "#endif\n"
        ] ;
      #---
        fileIdx ++ ;
        implementationString := "" ;
        headerString := "" ;
        headerFileName := "all-declarations-" + fileIdx ;
        inclusionSet := [@stringset emptySet] ;
      end if ;
    end if ;
  end foreach ;
#  message [[includeConfigurationSet count] string] . " include header configurations.\n" ;
#--- Last file
  if implementationString != "" then
    if useOneHugeHeader then
      inclusionSet := [@stringset setWithString !"all-declarations"] ;
    end if ;
#    for () in inSemanticContext->mGrammarMap do
#      inclusionSet += !"grammar-" . lkey->string ;
#    end for ;
    const header := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
#      !if generateFewHeaderFiles [] then {!"all-declarations-" . fileIdx} else [inclusionSet stringList] end
      !{!"all-declarations-" . fileIdx}
    ] ;
    const fileName := "all-declarations-" . fileIdx . ".cpp" ;
    ioToolProductFileList := [@stringlist listWithValue !fileName] + ioToolProductFileList ;
    ioAllProductFileSet += !fileName ;
    [@string generateFile
      !inProductDirectory
      !fileName
      !header + implementationString
    ] ;
  #---
    ioAllProductFileSet += !headerFileName + ".h" ;
    const startOfHeader := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
      !headerFileName
      !if fileIdx == 0 then {} else {!"all-declarations-" + (fileIdx-1)} end
    ] ;
    [@string generateFile
      !inProductDirectory
      !headerFileName + ".h"
      !startOfHeader + headerString + "#endif\n"
    ] ;
  end if ;
#--- all declarations header
  ioAllProductFileSet += !"all-declarations.h" ;
  const startOfAllDeclarationsHeader := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
    !headerFileName
    !{!"all-declarations-" + fileIdx}
  ] ;
  [@string generateFile
    !inProductDirectory
    !"all-declarations.h"
    !startOfAllDeclarationsHeader + "#endif\n"
  ] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateManyImplementationFiles
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
  const useOneHugeHeader := [option galgas_cli_options.generateOneHeader value] ;
  foreach inSemanticDeclarationSortedListForGeneration do
    var inclusionSet := [@stringset emptySet] ;
    if not [mDeclaration isPredefined] then
      [mDeclaration appendSpecificImplementation !?inclusionSet ?@string implementationString] ;
      if [mDeclaration hasCppHeaderFile] then
        inclusionSet += ![mDeclaration implementationCppFileName] ;
      end if ;
      if useOneHugeHeader then
        inclusionSet := [@stringset setWithString !"all-declarations"] ;
#        for () in inSemanticContext->mGrammarMap do
#          inclusionSet += !"grammar-" . lkey->string ;
#        end for ;
      end if ;
      const header := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
        ![inclusionSet stringList]
      ] ;
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      ioAllProductFileSet += ![mDeclaration implementationCppFileName] . ".cpp" ;
      [@string generateFile
        !inProductDirectory
        ![mDeclaration implementationCppFileName] . ".cpp"
        !header + implementationString
      ] ;
      ioToolProductFileList += ![mDeclaration implementationCppFileName] . ".cpp" ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
