#---------------------------------------------------------------------------*
#                                                                           *
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics galgas3SemanticDeclarationCompilation :
import "optionTypesForAST.gSemantics" ;
import "semanticAnalysis.gSemantics" ;
import "predefinedTypes.gSemantics" ;
import "semanticsCompilation.gSemantics" ;
import "projectGlobalCheckings.gSemantics" ;

#---------------------------------------------------------------------------*

routine compileSemanticDeclarationsGalgas3
  ??@location inEndOfProjectSourceFile
  ??@semanticDeclarationListAST inSemanticDeclarationList
  ??@galgas3OptionComponentListAST inOptionComponentList
  ??@galgas3LexiqueComponentListAST inLexiqueComponentList
  ??@galgas3GrammarComponentListAST inGrammarComponentList
  !@semanticContext outSemanticContext
  !@semanticDeclarationSortedListForGeneration outSemanticDeclarationSortedListForGeneration
:
  message "*** Building context\n" ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := inSemanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  buildGalgas3SemanticContext
    !semanticDeclarationListWithPredefinedTypes
    !inEndOfProjectSourceFile
    ?outSemanticContext
    ??@semanticDeclarationListAST sortedSemanticDeclarationListAST
  ;
#---
  if [option .verbose_output value] then
    message "*** Semantic analysis\n" ;
  end if ;
#------ Build option component map for analysis
  var implementationFileIncludeList := [@stringlist emptyList] ;
  buildGalgas3OptionComponentMapForSemanticAnalysis
    !inOptionComponentList
    ??@optionComponentMapForSemanticAnalysis optionComponentMapForSemanticAnalysis
  ;
  outSemanticContext->mOptionComponentMapForSemanticAnalysis := optionComponentMapForSemanticAnalysis ;
  for () in optionComponentMapForSemanticAnalysis do
    if not mIsPredefined then
      implementationFileIncludeList += !"option-" + lkey->string ;
    end if ;
  end for ;
#--- Build lexique component map for semantic analysis
  for lexiqueAST in inLexiqueComponentList do
    buildTerminalMap !lexiqueAST ??@terminalMap terminalMap ;
    [!?outSemanticContext->mLexiqueComponentMapForSemanticAnalysis insertKey
       !lexiqueAST->mLexiqueComponentName
       !terminalMap
       !lexiqueAST->mIndexingListAST
       !lexiqueAST->mIndexingDirectory
    ] ;
  end for ;
#------ Perform semantic analysis of grammar components
  buildGalgas3GrammarComponentMapForSemanticAnalysis
    !inGrammarComponentList
    !?outSemanticContext
  ;
#------ Check there is no undefined types
  foreach [outSemanticContext->mTypeMap unsolvedProxyList] do
    error mValue : "the '" . mValue . "' type is undefined" ;
  end foreach ;
#------ Semantic Analysis
  outSemanticDeclarationSortedListForGeneration := [@semanticDeclarationSortedListForGeneration emptySortedList] ;
  if [@uint errorCount] == 0 then
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!outSemanticContext] ;
    foreach sortedSemanticDeclarationListAST do
      [mSemanticDeclaration semanticAnalysis
        !outSemanticContext
        !predefinedTypes
        !?outSemanticDeclarationSortedListForGeneration
      ] ;
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine buildGalgas3GrammarComponentMapForSemanticAnalysis
  ??@galgas3GrammarComponentListAST inGrammarComponentList
  ?!@semanticContext ioSemanticContext
:
#--- Perform semantic analysis of grammar components
  foreach inGrammarComponentList do
  #--- Analyze start symbol labels
    @grammarLabelMap grammarLabelMap [emptyMap] ;
    foreach mStartSymbolLabelList do
    #--- Analyze signature
      @formalParameterSignature formalArgumentList [emptyList] ;
      foreach mFormalArgumentList do
        formalArgumentList +=
          !mFormalSelector
          ![@unifiedTypeMapProxy searchKey !ioSemanticContext->mTypeMap !mFormalArgumentTypeName]
          !mFormalArgumentPassingMode
          !mFormalArgumentName->string
        ;
      end foreach ;
      [!?grammarLabelMap insertKey
        !mLabelName
        !formalArgumentList
      ] ;
    end foreach ;
  #--- Insert grammar in grammar map
    [!?ioSemanticContext->mGrammarMap insertGrammar
      !mGrammarComponentName
      !grammarLabelMap
      !mHasIndexing->bool
      !mHasTranslateFeature
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    B U I L D    S E M A N T I C    C O N T E X T                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildGalgas3SemanticContext
  ??@semanticDeclarationListAST inSemanticDeclarationList
  ??@location inEndOfProjectSourceFile
  !@semanticContext outSemanticContext
  !@semanticDeclarationListAST outSortedSemanticDeclarationListAST
:
#------ Create associated type (@TYPE-element) for lists, maps, ...
  @semanticDeclarationListAST semanticDeclarationList := inSemanticDeclarationList ;
  foreach inSemanticDeclarationList do
    [mSemanticDeclaration addAssociatedElement !?semanticDeclarationList] ;
  end foreach ;
#------ Build ordered types list, so that
#  - a class appears after its super class
#  - a map index appears after its associated map
#  - a list map appears after its associated list
  @semanticTypePrecedenceGraph semanticTypePrecedenceGraph [emptyGraph] ;
  @categoryMethodMapForBuildingContext categoryMethodMapForBuildingContext [emptyMap] ;
  @categoryReaderMapForBuildingContext categoryReaderMapForBuildingContext  [emptyMap] ;
  @categoryModifierMapForBuildingContext categoryModifierMapForBuildingContext  [emptyMap] ;
  @semanticDeclarationListAST categoryOverrideDefinitionList [emptyList] ;
  foreach semanticDeclarationList do
    [mSemanticDeclaration enterDeclarationInGraph
      !?semanticTypePrecedenceGraph
      !?categoryMethodMapForBuildingContext
      !?categoryReaderMapForBuildingContext
      !?categoryModifierMapForBuildingContext
      !?categoryOverrideDefinitionList
    ] ;  
  end foreach ;
  if [semanticTypePrecedenceGraph undefinedNodeCount] > 0 then
    foreach [semanticTypePrecedenceGraph undefinedNodeReferenceList] do
      error mValue : "the '" . mValue . "' type is not defined" ;
    end foreach ;
    error inEndOfProjectSourceFile : "semantic analysis not performed, due to undefined type error(s)" : outSemanticContext, outSortedSemanticDeclarationListAST ;
  else
    [semanticTypePrecedenceGraph topologicalSort
      ?outSortedSemanticDeclarationListAST
      ?*
      ?@semanticDeclarationListAST unsortedSemanticDeclarationListAST
      ?@lstringlist unsortedNodeKeyList
    ] ;
    if [unsortedSemanticDeclarationListAST length] > 0 then
      @string s := "semantic analysis not performed, " . [[unsortedSemanticDeclarationListAST length] string] . " declarations are involved in circular definition:" ;
      foreach unsortedSemanticDeclarationListAST do
        s .= "\n-  " . [mSemanticDeclaration keyRepresentation] ;
      end foreach ;
      error inEndOfProjectSourceFile : s : outSemanticContext ;
    else
    #--- Add category override
      outSortedSemanticDeclarationListAST .= categoryOverrideDefinitionList ;
    #--- Build initial semantic context
      outSemanticContext := [@semanticContext new
        ![@unifiedTypeMap emptyMap]
        ![@routineMap emptyMap]
        ![@functionMap emptyMap]
        ![@filewrapperMap emptyMap]
        ![@grammarMap emptyMap]
        ![@optionComponentMapForSemanticAnalysis emptyMap]
        ![@lexiqueComponentMapForSemanticAnalysis emptyMap]
      ] ;
    #--- Loop throught all declarations
      foreach outSortedSemanticDeclarationListAST do
        [mSemanticDeclaration enterInSemanticContext
          !categoryMethodMapForBuildingContext
          !categoryReaderMapForBuildingContext
          !categoryModifierMapForBuildingContext
          !?outSemanticContext
        ] ;
      end foreach ;
    end if ;
  end if ;
#--- Generate graphviz file
#  const graphvizText := [semanticTypePrecedenceGraph graphviz] ;
#  const graphvizFilePath := [inProjectSourceFile stringByDeletingPathExtension] . "+type-precedence.dot" ;
#  [graphvizText writeToFileWhenDifferentContents !graphvizFilePath ?*] ;
end routine ;

#---------------------------------------------------------------------------*

routine buildGalgas3OptionComponentMapForSemanticAnalysis
  ??@galgas3OptionComponentListAST inOptionComponentList
  !@optionComponentMapForSemanticAnalysis outOptionComponentMapForSemanticAnalysis
:
  outOptionComponentMapForSemanticAnalysis := [@optionComponentMapForSemanticAnalysis emptyMap] ;
  foreach inOptionComponentList do
    var boolOptionMap := [@commandLineOptionMap emptyMap] ;
    var uintOptionMap := [@commandLineOptionMap emptyMap] ;
    var stringOptionMap := [@commandLineOptionMap emptyMap] ;
    @stringset optionNameSet [emptySet] ;
    foreach mOptions do
      if [optionNameSet hasKey ![mOptionInternalName string]] then
        error mOptionInternalName: "the '" + [mOptionInternalName string] + "' command line option has been already declared" ;
      elsif [mOptionTypeName string] == "bool" then
        [!?boolOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          !"false"
        ] ;
        if mOptionDefaultValueKind != [@optionDefaultValueEnumAST noDefaultValue] then
          error mOptionDefaultValue:"an @bool option cannot have a default value (default value is allways false)" ;      
        end if ;
      elsif [mOptionTypeName string] == "uint" then
        [!?uintOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          !if [mOptionDefaultValue string] == "" then "0" else [mOptionDefaultValue string] end
        ] ;
        if mOptionDefaultValueKind == [@optionDefaultValueEnumAST stringDefaultValue] then
          error mOptionDefaultValue:"an @uint option default value cannot be an @string value" ;      
        end if ;
      elsif [mOptionTypeName string] == "string" then
        [!?stringOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          ![mOptionDefaultValue string]
        ] ;
        if mOptionDefaultValueKind == [@optionDefaultValueEnumAST unsignedDefaultValue] then
          error mOptionDefaultValue:"an @string option default value cannot be an @uint value" ;      
        end if ;
      else
        error mOptionTypeName: "only the @bool, @uint or @string types are allowed here" ;
      end if ;
      optionNameSet += ![mOptionInternalName string] ;
    end foreach ;
    [!?outOptionComponentMapForSemanticAnalysis insertKey
      !mOptionComponentName
      !false # Is not predefined
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ] ;
  end foreach ;
#--- Add predefined option component
  if not [outOptionComponentMapForSemanticAnalysis hasKey !"galgas_builtin_options"] then
    @2stringlist optionNameList := [@application boolOptionNameList] ;
    @commandLineOptionMap boolOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?boolOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application boolOptionInvocationLetter !mValue0 !mValue1]
        ![@application boolOptionInvocationString !mValue0 !mValue1]
        ![@application boolOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #--- 
    optionNameList := [@application uintOptionNameList] ;
    @commandLineOptionMap uintOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?uintOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application uintOptionInvocationLetter !mValue0 !mValue1]
        ![@application uintOptionInvocationString !mValue0 !mValue1]
        ![@application uintOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #--- 
    optionNameList := [@application stringOptionNameList] ;
    @commandLineOptionMap stringOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?stringOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application stringOptionInvocationLetter !mValue0 !mValue1]
        ![@application stringOptionInvocationString !mValue0 !mValue1]
        ![@application stringOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #---
    [!?outOptionComponentMapForSemanticAnalysis insertKey
      ![@lstring new !"galgas_builtin_options" !here]
      !true # Is predefined
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#! Generation
#---------------------------------------------------------------------------*

local once definitionGroupAmount -> @uint outResult :
  outResult := 100 ;
end once ;

#---------------------------------------------------------------------------*

local once generateFewHeaderFiles -> @bool outResult :
  outResult := false ;
end once ;

#---------------------------------------------------------------------------*

routine generateSemanticDeclarationsGalgas3
  ??@string inProductDirectory
  ??@semanticContext inSemanticContext
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
  if [@uint errorCount] == 0 then
    if [option galgas_cli_options.generateOneHeader value] then
       generateOneBigHeader
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioAllProductFileSet
      ;
    elsif generateFewHeaderFiles [] then
      generateFewHeaders
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioAllProductFileSet
      ;
    else
      generateManyHeaders
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioAllProductFileSet
      ;
    end if ;
    if [option galgas_cli_options.generateManyFiles value] then
      generateManyImplementationFiles
        !inProductDirectory
        !inSemanticContext
        !inSemanticDeclarationSortedListForGeneration
        !?ioToolProductFileList
        !?ioAllProductFileSet
      ;
    else
      generateFewImplementationFiles
        !inProductDirectory
        !inSemanticContext
        !inSemanticDeclarationSortedListForGeneration
        !?ioToolProductFileList
        !?ioAllProductFileSet
      ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateManyHeaders
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringset ioAllProductFileSet
:
#--- Header files
  var headerInclusionList1 := [@stringlist emptyList] ;
  var headerInclusionList2 := [@stringlist emptyList] ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet1 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerDef1] ;
      var headerIncludes1 := "" ;
      for (s) in inclusionSet1 do
        headerIncludes1 .= "#include \"" . s . ".h\"\n" ;
      end for ;
      headerIncludes1 += headerDef1 ;
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerDef2] ;
      var headerIncludes2 := "" ;
      for (s) in inclusionSet2 do
        headerIncludes2 .= "#include \"" . s . ".h\"\n" ;
      end for ;
      headerIncludes2 += headerDef2 ;
    #---
      switch [mDeclaration headerKind]
      when noHeader :
        if headerIncludes1 != "" then
          error ["" nowhere] : "'noHeader' setting for the '" . mMessage . "' declaration, and 'headerIncludes1' string is not empty" ;
        end if ;
        if headerIncludes2 != "" then
          error ["" nowhere] : "'noHeader' setting for the '" . mMessage . "' declaration, and 'headerIncludes2' string is not empty" ;
        end if ;
      when oneHeader :
        if headerIncludes1 == "" then
          error ["" nowhere] : "'oneHeader' setting for the '" . mMessage . "' declaration, and 'headerIncludes1' string is empty" ;
        end if ;
        if headerIncludes2 != "" then
          warning ["" nowhere] : "'oneHeader' setting for the '" . mMessage . "' declaration, and 'headerIncludes2' string is not empty" ;
        end if ;
      when twoHeaders :
        if headerIncludes1 == "" then
          warning ["" nowhere] : "'twoHeaders' setting for the '" . mMessage . "' declaration, and 'headerIncludes1' string is empty" ;
        end if ;
        if headerIncludes2 == "" then
          warning ["" nowhere] : "'twoHeaders' setting for the '" . mMessage . "' declaration, and 'headerIncludes2' string is empty" ;
        end if ;
      end switch ;
    #--- Header 1
      if [mDeclaration headerKind] != [@headerKind noHeader] then
        var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n" ;
        headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= headerIncludes1 ;
        headerString .= "\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= "#endif\n\n" ;
        const headerFileName := [mDeclaration implementationCppFileName] + if [mDeclaration headerKind] == [@headerKind twoHeaders] then "-1" else "" end ;
        headerInclusionList1 += !headerFileName ;
        ioAllProductFileSet += !headerFileName . ".h" ;
        [@string generateFileWithPattern
          !inProductDirectory
          !headerFileName . ".h"
          !"//"
          !"\n\n" # Defaut user zone1
          !headerString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
      end if ;
    #--- Header 2
      if [mDeclaration headerKind] == [@headerKind twoHeaders] then
        var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
        headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= "#include \"" . [mDeclaration implementationCppFileName] . "-1.h\"\n" ;
        headerString .= "\n//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= headerIncludes2 ;
        headerString .= "\n" ;
        headerString .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
        headerString .= "#endif\n\n" ;
        headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
        ioAllProductFileSet += ![mDeclaration implementationCppFileName] . ".h" ;
        [@string generateFileWithPattern
          !inProductDirectory
          ![mDeclaration implementationCppFileName] . ".h"
          !"//"
          !"\n\n" # Defaut user zone1
          !headerString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
      end if  ;
    end if ;
  end foreach ;
#-------------------------------------- all-declarations.h
  var headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
    !"all-declarations"
    !headerInclusionList1 + headerInclusionList2
  ] ;
  ioAllProductFileSet += !"all-declarations.h" ;
  [@string generateFileWithPattern
    !inProductDirectory
    !"all-declarations.h"
    !"//"
    !"\n\n" # Defaut user zone1
    !headerString
    !"\n\n" # Defaut user zone2
    !"#endif\n"
  ] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateOneBigHeader
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringset ioAllProductFileSet
:
  var headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
    !"all-declarations"
    ![@stringlist emptyList]
  ] ;
#--- Declaration 1
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet1 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerString1] ;
      headerString .= headerString1 ;
    end if ;
  end foreach ;
#--- Declaration 2
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerString2] ;
      headerString .= headerString2 ;
    end if ;
  end foreach ;
  ioAllProductFileSet += !"all-declarations.h" ;
  [@string generateFileWithPattern
    !inProductDirectory
    !"all-declarations.h"
    !"//"
    !"\n\n" # Defaut user zone1
    !headerString
    !"\n\n" # Defaut user zone2
    !"#endif\n"
  ] ;
end routine ;

#---------------------------------------------------------------------------*

map @headerCompositionMap {
  @stringset mInclusion ;
  @string mHeaderString ;
  insert insertKey error message "the '%K' key is already declared in %L" ;
  search searchKey error message "there is no '%K' key" ;
}

#---------------------------------------------------------------------------*

map @headerRepartitionMap {
  @string mHeaderFileName ;
  insert insertKey error message "the '%K' key is already declared in %L" ;
  search searchKey error message "there is no '%K' key" ;
}

#---------------------------------------------------------------------------*

local routine buildHeader
  ??@headerCompositionMap inHeaderCompositionMap
  ??@string inHeaderFileName
  ??@string inDeclarationName
  ?!@headerRepartitionMap ioHeaderRepartitionMap
  ?!@string ioHeaderString
:
#---
  if not [ioHeaderRepartitionMap hasKey !inDeclarationName] then
    [!?ioHeaderRepartitionMap insertKey ![inDeclarationName nowhere] !inHeaderFileName] ;
    [inHeaderCompositionMap searchKey
      ![inDeclarationName nowhere]
      ??@stringset inclusionSet
      ??@string headerString
    ] ;
    ioHeaderString += "//START--- " + inDeclarationName + "\n" ;
    for (s) in inclusionSet do
      buildHeader
        !inHeaderCompositionMap
        !inHeaderFileName
        !s
        !?ioHeaderRepartitionMap
        !?ioHeaderString
      ;
    end for ;
    ioHeaderString += "//--- " + inDeclarationName + "\n" ;
    for (s) in inclusionSet do
      ioHeaderString += "  // " + s + "\n" ;
    end for ;
    ioHeaderString += headerString ;
  else
    ioHeaderString += "//--- " + inDeclarationName + " already included\n" ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateFewHeaders
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringset ioAllProductFileSet
:
#--- Build header composition map
  @headerCompositionMap headerCompositionMap := {} ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet1 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerString1] ;
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerString2] ;
      if [mDeclaration headerKind] != [@headerKind noHeader] then
        const headerFileName := [mDeclaration implementationCppFileName] + if [mDeclaration headerKind] == [@headerKind twoHeaders] then "-1" else "" end ;
        [!?headerCompositionMap insertKey
          ![headerFileName nowhere]
          !inclusionSet1
          !headerString1
        ] ;
      end if ;
      if [mDeclaration headerKind] == [@headerKind twoHeaders] then
        [!?headerCompositionMap insertKey
          ![[mDeclaration implementationCppFileName] nowhere]
          !inclusionSet2 | @stringset {![mDeclaration implementationCppFileName] + "-1"}
          !headerString2
        ] ;
      end if ;
    end if ;
  end foreach ;
#---
  var n := 0 ;
  var fileIdx := 0 ;
  var headerFileName := "all-declarations-" + fileIdx ;
  var implementationString := "" ;
  @headerRepartitionMap headerRepartitionMap := {} ;
  foreach inSemanticDeclarationSortedListForGeneration do
    n ++ ;
    if not [mDeclaration isPredefined] then
      if [mDeclaration headerKind] == [@headerKind twoHeaders] then
        buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName] +"-1" !?headerRepartitionMap !?implementationString ;
        buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName]  !?headerRepartitionMap !?implementationString ;
      elsif [mDeclaration headerKind] == [@headerKind oneHeader] then
        buildHeader !headerCompositionMap !headerFileName ![mDeclaration implementationCppFileName]  !?headerRepartitionMap !?implementationString ;
      end if ;
    end if ;
    if n == definitionGroupAmount [] then
      const headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
        !headerFileName
        !if fileIdx == 0 then {} else {!"all-declarations-" + (fileIdx-1)} end
      ] ;
      [@string generateFileWithPattern
        !inProductDirectory
        !headerFileName + ".h"
        !"//"
        !"\n\n" # Defaut user zone1
        !headerString + implementationString
        !"\n\n" # Defaut user zone2
        !"#endif\n"
      ] ;
      ioAllProductFileSet += !headerFileName + ".h" ;
      n := 0 ;
      fileIdx ++ ;
      headerFileName := "all-declarations-" + fileIdx ;
      implementationString := "" ;
    end if ;
  end foreach ;
#---
  const headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
    !headerFileName
    !{!"all-declarations-" + (fileIdx-1)}
  ] ;
  [@string generateFileWithPattern
    !inProductDirectory
    !headerFileName + ".h"
    !"//"
    !"\n\n" # Defaut user zone1
    !headerString + implementationString
    !"\n\n" # Defaut user zone2
    !"#endif\n"
  ] ;
  ioAllProductFileSet += !headerFileName + ".h" ;
#---
  [@string generateFileWithPattern
    !inProductDirectory
    !"all-declarations.h"
    !"//"
    !"\n\n" # Defaut user zone1
    ![filewrapper semanticFileGenerationTemplate.semanticFileHeader
       !"all-declarations"
       !{!"all-declarations-" + fileIdx}
     ]
    !"\n\n" # Defaut user zone2
    !"#endif\n"
  ] ;
  ioAllProductFileSet += !"all-declarations.h" ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateFewImplementationFiles
  ??@string inProductDirectory
  ??@semanticContext inSemanticContext
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
  const useOneHugeHeader := [option galgas_cli_options.generateOneHeader value] ;
#------------- all-declarations.cpp
  var n := 0 ;
  var fileIdx := 0 ;
  var implementationString := "" ;
  @stringset inclusionSet := {} ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      [mDeclaration appendSpecificImplementation !?inclusionSet ??@string code] ;
      implementationString += code ;
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      n ++ ;
      if n == definitionGroupAmount [] then
        if useOneHugeHeader then
          inclusionSet := [@stringset setWithString !"all-declarations"] ;
        elsif generateFewHeaderFiles [] then
          inclusionSet := {!"all-declarations-" . fileIdx} ;
        end if ;
        for () in inSemanticContext->mOptionComponentMapForSemanticAnalysis do
          if not mIsPredefined then
            inclusionSet += !"option-" + lkey->string ;
          end if ;
        end for ;
        for () in inSemanticContext->mGrammarMap do
          inclusionSet += !"grammar-" . lkey->string ;
        end for ;
        const header := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
          ![inclusionSet stringList]
        ] ;
        const fileName := "all-declarations-" . fileIdx . ".cpp" ;
        ioToolProductFileList := [@stringlist listWithValue !fileName] + ioToolProductFileList ;
        ioAllProductFileSet += !fileName ;
        [@string generateFileWithPattern
          !inProductDirectory
          !fileName
          !"//"
          !"\n\n" # Defaut user zone1
          !header + implementationString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
        n := 0 ;
        fileIdx ++ ;
        implementationString := "" ;
        inclusionSet := [@stringset emptySet] ;
      end if ;
    end if ;
  end foreach ;
#  message [[includeConfigurationSet count] string] . " include header configurations.\n" ;
#--- Last file
  if implementationString != "" then
    if useOneHugeHeader then
      inclusionSet := [@stringset setWithString !"all-declarations"] ;
    end if ;
    for () in inSemanticContext->mOptionComponentMapForSemanticAnalysis do
      if not mIsPredefined then
        inclusionSet += !"option-" + lkey->string ;
      end if ;
    end for ;
    for () in inSemanticContext->mGrammarMap do
      inclusionSet += !"grammar-" . lkey->string ;
    end for ;
    const header := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
      !if generateFewHeaderFiles [] then {!"all-declarations-" . fileIdx} else [inclusionSet stringList] end
    ] ;
    const fileName := "all-declarations-" . fileIdx . ".cpp" ;
    ioToolProductFileList := [@stringlist listWithValue !fileName] + ioToolProductFileList ;
    ioAllProductFileSet += !fileName ;
    [@string generateFileWithPattern
      !inProductDirectory
      !fileName
      !"//"
      !"\n\n" # Defaut user zone1
      !header + implementationString
      !"\n\n" # Defaut user zone2
      !"\n"
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateManyImplementationFiles
  ??@string inProductDirectory
  ??@semanticContext inSemanticContext
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
  const useOneHugeHeader := [option galgas_cli_options.generateOneHeader value] ;
  foreach inSemanticDeclarationSortedListForGeneration do
    var inclusionSet := [@stringset emptySet] ;
    if not [mDeclaration isPredefined] then
      [mDeclaration appendSpecificImplementation !?inclusionSet ?@string implementationString] ;
      if [mDeclaration hasCppHeaderFile] then
        inclusionSet += ![mDeclaration implementationCppFileName] ;
      end if ;
      if useOneHugeHeader then
        inclusionSet := [@stringset setWithString !"all-declarations"] ;
        for () in inSemanticContext->mOptionComponentMapForSemanticAnalysis do
          if not mIsPredefined then
            inclusionSet += !"option-" + lkey->string ;
          end if ;
        end for ;
        for () in inSemanticContext->mGrammarMap do
          inclusionSet += !"grammar-" . lkey->string ;
        end for ;
      end if ;
      const header := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
        ![inclusionSet stringList]
      ] ;
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      ioAllProductFileSet += ![mDeclaration implementationCppFileName] . ".cpp" ;
      [@string generateFileWithPattern
        !inProductDirectory
        ![mDeclaration implementationCppFileName] . ".cpp"
        !"//"
        !"\n\n" # Defaut user zone1
        !header + implementationString
        !"\n\n" # Defaut user zone2
        !"\n"
      ] ;
      ioToolProductFileList += ![mDeclaration implementationCppFileName] . ".cpp" ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
