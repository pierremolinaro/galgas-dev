#---------------------------------------------------------------------------*
#                                                                           *
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics galgas3SemanticDeclarationCompilation :
import "optionTypesForAST.gSemantics" ;
import "semanticAnalysis.gSemantics" ;
import "predefinedTypes.gSemantics" ;
import "semanticsCompilation.gSemantics" ;
import "projectGlobalCheckings.gSemantics" ;

#---------------------------------------------------------------------------*

routine compileSemanticDeclarationsGalgas3
  ??@string inProjectSourceFile
  ??@location inEndOfProjectSourceFile
  ??@semanticDeclarationListAST inSemanticDeclarationList
  ??@galgas3OptionComponentListAST inOptionComponentList
  ??@galgas3LexiqueComponentListAST inLexiqueComponentList
  ??@galgas3GrammarComponentListAST inGrammarComponentList
  ?!@stringlist ioToolProductFileList
  !@semanticContext outSemanticContext
:
  message "*** Building context\n" ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := inSemanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  buildGalgas3SemanticContext
    !inProjectSourceFile
    !semanticDeclarationListWithPredefinedTypes
    !inEndOfProjectSourceFile
    ?outSemanticContext
    ??@semanticDeclarationListAST sortedSemanticDeclarationListAST
  ;
#------ Build option component map for analysis
  var implementationFileIncludeList := [@stringlist emptyList] ;
  buildGalgas3OptionComponentMapForSemanticAnalysis
    !inOptionComponentList
    ??@optionComponentMapForSemanticAnalysis optionComponentMapForSemanticAnalysis
  ;
  outSemanticContext->mOptionComponentMapForSemanticAnalysis := optionComponentMapForSemanticAnalysis ;
  for * in optionComponentMapForSemanticAnalysis do
    if not mIsPredefined then
      implementationFileIncludeList += !"option-" + lkey->string ;
    end if ;
  end for ;
#--- Build lexique component map for semantic analysis
  for lexiqueAST in inLexiqueComponentList do
    buildTerminalMap !lexiqueAST ??@terminalMap terminalMap ;
    [!?outSemanticContext->mLexiqueComponentMapForSemanticAnalysis insertKey
       !lexiqueAST->mLexiqueComponentName
       !terminalMap
       !lexiqueAST->mIndexingListAST
       !lexiqueAST->mIndexingDirectory
    ] ;
  end for ;
#------ Perform semantic analysis of grammar components
  buildGalgas3GrammarComponentMapForSemanticAnalysis
    !inGrammarComponentList
    !?outSemanticContext
  ;
  
#------ Semantic Analysis
  message "*** Semantic analysis\n" ;
#------ Check there is no undefined types
  foreach [outSemanticContext->mTypeMap unsolvedProxyList] do
    error mValue : "the '" . mValue . "' type is undefined" ;
  end foreach ;
#---
  var decoratedDeclarationListForGeneration := [@semanticDeclarationSortedListForGeneration emptySortedList] ;
  if [@uint errorCount] == 0 then
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!outSemanticContext] ;
    foreach sortedSemanticDeclarationListAST do
      [mSemanticDeclaration semanticAnalysis
        !outSemanticContext
        !predefinedTypes
        !?decoratedDeclarationListForGeneration
      ] ;
    end foreach ;
  end if ;
#---------------------------------- Perform global checkings
  if [@uint errorCount] == 0 then
    if [option .verbose_output value] then
      message "*** Perform global checkings\n" ;
    end if ;
    performGalgas3ProjectGlobalCheckings
      !outSemanticContext
      !inSemanticDeclarationList
      !inProjectSourceFile
    ;
  end if ;
#--- Generate type files
  message "*** Generating files\n" ;
  const productDirectory := [inProjectSourceFile stringByDeletingLastPathComponent] . "/build/output" ;
#------ Generate Header Files
  if [@uint errorCount] == 0 then
  #--- Header files
    var headerInclusionList1 := [@stringlist emptyList] ;
    var headerInclusionList2 := [@stringlist emptyList] ;
    foreach decoratedDeclarationListForGeneration do
      if not [mDeclaration isPredefined] then
        const headerString1 := [mDeclaration appendDeclaration1 !true] ;
        const headerString2 := [mDeclaration appendDeclaration2 !productDirectory !true] ;
      #--- Header 1
        var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n" ;
        headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n\n" ;
        headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
        [mDeclaration addHeaderInclusions !?headerString] ;
        headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
        headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
        headerString .= headerString1 ;
        headerString .= "#endif\n\n" ;
        [@string generateFileWithPattern
          !productDirectory
          ![mDeclaration implementationCppFileName] . "-1.h"
          !"//"
          !"\n\n" # Defaut user zone1
          !headerString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
        headerInclusionList1 += ![mDeclaration implementationCppFileName] . "-1" ;
      #--- Header 2
        headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
        headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
        headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
        headerString .= "#include \"" . [mDeclaration implementationCppFileName] . "-1.h\"\n" ;
        [mDeclaration addHeaderInclusions !?headerString] ;
        headerString .= "\n//-----------------------------------------------------------------------------*\n\n" ;
        headerString .= headerString2 ;
        headerString .= "#endif\n\n" ;
        [@string generateFileWithPattern
          !productDirectory
          ![mDeclaration implementationCppFileName] . ".h"
          !"//"
          !"\n\n" # Defaut user zone1
          !headerString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
        headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
      end if ;
    end foreach ;
#    foreach decoratedDeclarationListForGeneration do
#      if not [mDeclaration isPredefined] then
#        const headerString1 := [mDeclaration appendDeclaration1 !true] ;
#        const headerString2 := [mDeclaration appendDeclaration2 !productDirectory !true] ;
#        const hasHeader := (headerString1 != "") | (headerString2 != "") ;
#        if hasHeader != [mDeclaration hasCppHeaderFile] then
#          log mDeclaration ;
#        end if ;
#        if (headerString1 != "") & (headerString2 == "") then
#          var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
#          headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          [mDeclaration addHeaderInclusions !?headerString] ;
#          headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= headerString1 ;
#          headerString .= "#endif\n\n" ;
#          [@string generateFileWithPattern
#            !productDirectory
#            ![mDeclaration implementationCppFileName] . ".h"
#            !"//"
#            !"\n\n" # Defaut user zone1
#            !headerString
#            !"\n\n" # Defaut user zone2
#            !"\n"
#          ] ;
#          headerInclusionList1 += ![mDeclaration implementationCppFileName] ;
#        elsif (headerString1 == "") & (headerString2 != "") then
#          var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
#          headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          [mDeclaration addHeaderInclusions !?headerString] ;
#          headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= headerString2 ;
#          headerString .= "#endif\n\n" ;
#          [@string generateFileWithPattern
#            !productDirectory
#            ![mDeclaration implementationCppFileName] . ".h"
#            !"//"
#            !"\n\n" # Defaut user zone1
#            !headerString
#            !"\n\n" # Defaut user zone2
#            !"\n"
#          ] ;
#          headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
#        elsif (headerString1 != "") & (headerString2 != "") then
#          var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n" ;
#          headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n\n" ;
#          headerString .= headerString1 ;
#          headerString .= "#endif\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          [@string generateFileWithPattern
#            !productDirectory
#            ![mDeclaration implementationCppFileName] . "-1.h"
#            !"//"
#            !"\n\n" # Defaut user zone1
#            !headerString
#            !"\n\n" # Defaut user zone2
#            !"\n"
#          ] ;
#          headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
#          headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= "#include \"" . [mDeclaration implementationCppFileName] . "-1.h\"\n" ;
#          [mDeclaration addHeaderInclusions !?headerString] ;
#          headerString .= "\n//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= headerString2 ;
#          headerString .= "#endif\n\n" ;
#          [@string generateFileWithPattern
#            !productDirectory
#            ![mDeclaration implementationCppFileName] . ".h"
#            !"//"
#            !"\n\n" # Defaut user zone1
#            !headerString
#            !"\n\n" # Defaut user zone2
#            !"\n"
#          ] ;
#          headerInclusionList1 += ![mDeclaration implementationCppFileName] . "-1" ;
#          headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
#        end if ;
#      end if ;
#    end foreach ;
  #--- AZERTYUIOP.h
    var headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
      !"AZERTYUIOP"
      !headerInclusionList1 + headerInclusionList2
      ![@stringlist emptyList]
    ] ;
    [@string generateFileWithPattern
      !productDirectory
      !"AZERTYUIOP.h"
      !"//"
      !"\n\n" # Defaut user zone1
      !headerString
      !"\n\n" # Defaut user zone2
      !"#endif\n"
    ] ;
  end if ;
#---------------------------------- Generate Implementation Files
  if [@uint errorCount] == 0 then
  #-------------
    foreach decoratedDeclarationListForGeneration do
      if not [mDeclaration isPredefined] then
        var implementationFileIncludes := [@stringlist emptyList] ;
        if [mDeclaration hasCppHeaderFile] then
          implementationFileIncludes += ![mDeclaration implementationCppFileName] ;
        end if ;
        [mDeclaration addInclusionForCPPFile !?implementationFileIncludes] ;
        @string implementationString := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
          ![mDeclaration implementationCppFileName]
          !implementationFileIncludes
        ] ;
        implementationString .= [mDeclaration appendSpecificImplementation] ;
        implementationString .= [mDeclaration appendTypeGenericImplementation] ;
        [@string generateFileWithPattern
          !productDirectory
          ![mDeclaration implementationCppFileName] . ".cpp"
          !"//"
          !"\n\n" # Defaut user zone1
          !implementationString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
        ioToolProductFileList += ![mDeclaration implementationCppFileName] . ".cpp" ;
      end if ;
    end foreach ;
  
  #------------- AZERTYUIOP.cpp
#    ioToolProductFileList += !"AZERTYUIOP.cpp" ;
#    for * in outSemanticContext->mGrammarMap do
#      implementationFileIncludeList += !"grammar-" . lkey->string ;
#    end for ;
#    @string implementationString := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
#      !"AZERTYUIOP"
#      !implementationFileIncludeList
#    ] ;
#    foreach decoratedDeclarationListForGeneration do
#      if not mIsPredefined then
#        implementationString .= [mDeclaration appendSpecificImplementation] ;
#        implementationString .= [mDeclaration appendTypeGenericImplementation] ;
#      end if ;
#    end foreach ;
#    [@string generateFileWithPattern
#      !productDirectory
#      !"AZERTYUIOP.cpp"
#      !"//"
#      !"\n\n" # Defaut user zone1
#      !implementationString
#      !"\n\n" # Defaut user zone2
#      !"\n"
#    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine buildGalgas3GrammarComponentMapForSemanticAnalysis
  ??@galgas3GrammarComponentListAST inGrammarComponentList
  ?!@semanticContext ioSemanticContext
:
#--- Perform semantic analysis of grammar components
  foreach inGrammarComponentList do
  #--- Analyze start symbol labels
    @grammarLabelMap grammarLabelMap [emptyMap] ;
    foreach mStartSymbolLabelList do
    #--- Analyze signature
      @formalParameterSignature formalArgumentList [emptyList] ;
      foreach mFormalArgumentList do
        formalArgumentList +=
          ![@unifiedTypeMapProxy searchKey !ioSemanticContext->mTypeMap !mFormalArgumentTypeName]
          !mFormalArgumentPassingMode
          !mFormalArgumentName->string
        ;
      end foreach ;
      [!?grammarLabelMap insertKey
        !mLabelName
        !formalArgumentList
      ] ;
    end foreach ;
  #--- Insert grammar in grammar map
    [!?ioSemanticContext->mGrammarMap insertGrammar
      !mGrammarComponentName
      !grammarLabelMap
      !mHasIndexing->bool
      !mHasTranslateFeature
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    B U I L D    S E M A N T I C    C O N T E X T                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildGalgas3SemanticContext
  ??@string inProjectSourceFile
  ??@semanticDeclarationListAST inSemanticDeclarationList
  ??@location inEndOfProjectSourceFile
  !@semanticContext outSemanticContext
  !@semanticDeclarationListAST outSortedSemanticDeclarationListAST
:
#------ Create associated type (@TYPE.element) for lists, maps, ...
  @semanticDeclarationListAST semanticDeclarationList := inSemanticDeclarationList ;
  foreach inSemanticDeclarationList do
    [mSemanticDeclaration addAssociatedElement !?semanticDeclarationList] ;
  end foreach ;
#------ Build ordered types list, so that
#  - a class appears after its super class
#  - a map index appears after its associated map
#  - a list map appears after its associated list
  @semanticTypePrecedenceGraph semanticTypePrecedenceGraph [emptyGraph] ;
  @categoryMethodMapForBuildingContext categoryMethodMapForBuildingContext [emptyMap] ;
  @categoryReaderMapForBuildingContext categoryReaderMapForBuildingContext  [emptyMap] ;
  @categoryModifierMapForBuildingContext categoryModifierMapForBuildingContext  [emptyMap] ;
  @semanticDeclarationListAST categoryOverrideDefinitionList [emptyList] ;
  foreach semanticDeclarationList do
    [mSemanticDeclaration enterDeclarationInGraph
      !?semanticTypePrecedenceGraph
      !?categoryMethodMapForBuildingContext
      !?categoryReaderMapForBuildingContext
      !?categoryModifierMapForBuildingContext
      !?categoryOverrideDefinitionList
    ] ;  
  end foreach ;
  if [semanticTypePrecedenceGraph undefinedNodeCount] > 0 then
    foreach [semanticTypePrecedenceGraph undefinedNodeReferenceList] do
      error mValue : "the '" . mValue . "' type is not defined" ;
    end foreach ;
    error inEndOfProjectSourceFile : "semantic analysis not performed, due to undefined type error(s)" : outSemanticContext, outSortedSemanticDeclarationListAST ;
  else
    [semanticTypePrecedenceGraph topologicalSort
      ?outSortedSemanticDeclarationListAST
      ?*
      ?@semanticDeclarationListAST unsortedSemanticDeclarationListAST
      ?@lstringlist unsortedNodeKeyList
    ] ;
    if [unsortedSemanticDeclarationListAST length] > 0 then
      @string s := "semantic analysis not performed, " . [[unsortedSemanticDeclarationListAST length] string] . " declarations are involved in circular definition:" ;
      foreach unsortedSemanticDeclarationListAST do
        s .= "\n-  " . [mSemanticDeclaration keyRepresentation] ;
      end foreach ;
      error inEndOfProjectSourceFile : s : outSemanticContext ;
    else
    #--- Add category override
      outSortedSemanticDeclarationListAST .= categoryOverrideDefinitionList ;
    #--- Build initial semantic context
      outSemanticContext := [@semanticContext new
        !inProjectSourceFile
        ![@unifiedTypeMap emptyMap]
        ![@routineMap emptyMap]
        ![@functionMap emptyMap]
        ![@filewrapperMap emptyMap]
        ![@grammarMap emptyMap]
        ![@optionComponentMapForSemanticAnalysis emptyMap]
        ![@lexiqueComponentMapForSemanticAnalysis emptyMap]
        ![@optionMapForSemanticAnalysis emptyMap]
      ] ;
    #--- Loop throught all declarations
      foreach outSortedSemanticDeclarationListAST do
        [mSemanticDeclaration enterInSemanticContext
          !categoryMethodMapForBuildingContext
          !categoryReaderMapForBuildingContext
          !categoryModifierMapForBuildingContext
          !?outSemanticContext
        ] ;
      end foreach ;
    end if ;
  end if ;
#--- Generate graphviz file
#  const graphvizText := [semanticTypePrecedenceGraph graphviz] ;
#  const graphvizFilePath := [inProjectSourceFile stringByDeletingPathExtension] . "+type-precedence.dot" ;
#  [graphvizText writeToFileWhenDifferentContents !graphvizFilePath ?*] ;
end routine ;

#---------------------------------------------------------------------------*

routine buildGalgas3OptionComponentMapForSemanticAnalysis
  ??@galgas3OptionComponentListAST inOptionComponentList
  !@optionComponentMapForSemanticAnalysis outOptionComponentMapForSemanticAnalysis
:
  outOptionComponentMapForSemanticAnalysis := [@optionComponentMapForSemanticAnalysis emptyMap] ;
  foreach inOptionComponentList do
    var boolOptionMap := [@commandLineOptionMap emptyMap] ;
    var uintOptionMap := [@commandLineOptionMap emptyMap] ;
    var stringOptionMap := [@commandLineOptionMap emptyMap] ;
    @stringset optionNameSet [emptySet] ;
    foreach mOptions do
      if [optionNameSet hasKey ![mOptionInternalName string]] then
        error mOptionInternalName: "the '" + [mOptionInternalName string] + "' command line option has been already declared" ;
      elsif [mOptionTypeName string] == "bool" then
        [!?boolOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          !"false"
        ] ;
        if mOptionDefaultValueKind != [@optionDefaultValueEnumAST noDefaultValue] then
          error mOptionDefaultValue:"an @bool option cannot have a default value (default value is allways false)" ;      
        end if ;
      elsif [mOptionTypeName string] == "uint" then
        [!?uintOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          !if [mOptionDefaultValue string] == "" then "0" else [mOptionDefaultValue string] end
        ] ;
        if mOptionDefaultValueKind == [@optionDefaultValueEnumAST stringDefaultValue] then
          error mOptionDefaultValue:"an @uint option default value cannot be an @string value" ;      
        end if ;
      elsif [mOptionTypeName string] == "string" then
        [!?stringOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          ![mOptionDefaultValue string]
        ] ;
        if mOptionDefaultValueKind == [@optionDefaultValueEnumAST unsignedDefaultValue] then
          error mOptionDefaultValue:"an @string option default value cannot be an @uint value" ;      
        end if ;
      else
        error mOptionTypeName: "only the @bool, @uint or @string types are allowed here" ;
      end if ;
      optionNameSet += ![mOptionInternalName string] ;
    end foreach ;
    [!?outOptionComponentMapForSemanticAnalysis insertKey
      !mOptionComponentName
      !false # Is not predefined
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ] ;
  end foreach ;
#--- Add predefined option component
  if not [outOptionComponentMapForSemanticAnalysis hasKey !"galgas_builtin_options"] then
    @2stringlist optionNameList := [@application boolOptionNameList] ;
    @commandLineOptionMap boolOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?boolOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application boolOptionInvocationLetter !mValue0 !mValue1]
        ![@application boolOptionInvocationString !mValue0 !mValue1]
        ![@application boolOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #--- 
    optionNameList := [@application uintOptionNameList] ;
    @commandLineOptionMap uintOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?uintOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application uintOptionInvocationLetter !mValue0 !mValue1]
        ![@application uintOptionInvocationString !mValue0 !mValue1]
        ![@application uintOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #--- 
    optionNameList := [@application stringOptionNameList] ;
    @commandLineOptionMap stringOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?stringOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application stringOptionInvocationLetter !mValue0 !mValue1]
        ![@application stringOptionInvocationString !mValue0 !mValue1]
        ![@application stringOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #---
    [!?outOptionComponentMapForSemanticAnalysis insertKey
      ![@lstring new !"galgas_builtin_options" !here]
      !true # Is predefined
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
