#---------------------------------------------------------------------------*
#                                                                           *
#  Copyright (C) 2014, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics galgas3SemanticDeclarationCompilation :
import "optionTypesForAST.gSemantics" ;
import "semanticAnalysis.gSemantics" ;
import "predefinedTypes.gSemantics" ;
import "semanticsCompilation.gSemantics" ;
import "projectGlobalCheckings.gSemantics" ;

#---------------------------------------------------------------------------*

enum @generationKind {
  someFiles, manyManyFiles
}

#---------------------------------------------------------------------------*

routine compileSemanticDeclarationsGalgas3
  ??@string inProjectSourceFile
  ??@location inEndOfProjectSourceFile
  ??@semanticDeclarationListAST inSemanticDeclarationList
  ??@galgas3OptionComponentListAST inOptionComponentList
  ??@galgas3LexiqueComponentListAST inLexiqueComponentList
  ??@galgas3GrammarComponentListAST inGrammarComponentList
  !@semanticContext outSemanticContext
  !@semanticDeclarationSortedListForGeneration outSemanticDeclarationSortedListForGeneration
:
  message "*** Building context\n" ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := inSemanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  buildGalgas3SemanticContext
    !inProjectSourceFile
    !semanticDeclarationListWithPredefinedTypes
    !inEndOfProjectSourceFile
    ?outSemanticContext
    ??@semanticDeclarationListAST sortedSemanticDeclarationListAST
  ;
#---
  if [option .verbose_output value] then
    message "*** Semantic analysis\n" ;
  end if ;
#------ Build option component map for analysis
  var implementationFileIncludeList := [@stringlist emptyList] ;
  buildGalgas3OptionComponentMapForSemanticAnalysis
    !inOptionComponentList
    ??@optionComponentMapForSemanticAnalysis optionComponentMapForSemanticAnalysis
  ;
  outSemanticContext->mOptionComponentMapForSemanticAnalysis := optionComponentMapForSemanticAnalysis ;
  for * in optionComponentMapForSemanticAnalysis do
    if not mIsPredefined then
      implementationFileIncludeList += !"option-" + lkey->string ;
    end if ;
  end for ;
#--- Build lexique component map for semantic analysis
  for lexiqueAST in inLexiqueComponentList do
    buildTerminalMap !lexiqueAST ??@terminalMap terminalMap ;
    [!?outSemanticContext->mLexiqueComponentMapForSemanticAnalysis insertKey
       !lexiqueAST->mLexiqueComponentName
       !terminalMap
       !lexiqueAST->mIndexingListAST
       !lexiqueAST->mIndexingDirectory
    ] ;
  end for ;
#------ Perform semantic analysis of grammar components
  buildGalgas3GrammarComponentMapForSemanticAnalysis
    !inGrammarComponentList
    !?outSemanticContext
  ;
#------ Semantic Analysis
#------ Check there is no undefined types
  foreach [outSemanticContext->mTypeMap unsolvedProxyList] do
    error mValue : "the '" . mValue . "' type is undefined" ;
  end foreach ;
#---
  outSemanticDeclarationSortedListForGeneration := [@semanticDeclarationSortedListForGeneration emptySortedList] ;
  if [@uint errorCount] == 0 then
    const @predefinedTypes predefinedTypes := buildPredefinedTypes [!outSemanticContext] ;
    foreach sortedSemanticDeclarationListAST do
      [mSemanticDeclaration semanticAnalysis
        !outSemanticContext
        !predefinedTypes
        !?outSemanticDeclarationSortedListForGeneration
      ] ;
    end foreach ;
  end if ;
#---------------------------------- Perform global checkings
  if [@uint errorCount] == 0 then
    performGalgas3ProjectGlobalCheckings
      !outSemanticContext
      !inSemanticDeclarationList
      !inProjectSourceFile
    ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine buildGalgas3GrammarComponentMapForSemanticAnalysis
  ??@galgas3GrammarComponentListAST inGrammarComponentList
  ?!@semanticContext ioSemanticContext
:
#--- Perform semantic analysis of grammar components
  foreach inGrammarComponentList do
  #--- Analyze start symbol labels
    @grammarLabelMap grammarLabelMap [emptyMap] ;
    foreach mStartSymbolLabelList do
    #--- Analyze signature
      @formalParameterSignature formalArgumentList [emptyList] ;
      foreach mFormalArgumentList do
        formalArgumentList +=
          ![@unifiedTypeMapProxy searchKey !ioSemanticContext->mTypeMap !mFormalArgumentTypeName]
          !mFormalArgumentPassingMode
          !mFormalArgumentName->string
        ;
      end foreach ;
      [!?grammarLabelMap insertKey
        !mLabelName
        !formalArgumentList
      ] ;
    end foreach ;
  #--- Insert grammar in grammar map
    [!?ioSemanticContext->mGrammarMap insertGrammar
      !mGrammarComponentName
      !grammarLabelMap
      !mHasIndexing->bool
      !mHasTranslateFeature
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#    B U I L D    S E M A N T I C    C O N T E X T                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine buildGalgas3SemanticContext
  ??@string inProjectSourceFile
  ??@semanticDeclarationListAST inSemanticDeclarationList
  ??@location inEndOfProjectSourceFile
  !@semanticContext outSemanticContext
  !@semanticDeclarationListAST outSortedSemanticDeclarationListAST
:
#------ Create associated type (@TYPE.element) for lists, maps, ...
  @semanticDeclarationListAST semanticDeclarationList := inSemanticDeclarationList ;
  foreach inSemanticDeclarationList do
    [mSemanticDeclaration addAssociatedElement !?semanticDeclarationList] ;
  end foreach ;
#------ Build ordered types list, so that
#  - a class appears after its super class
#  - a map index appears after its associated map
#  - a list map appears after its associated list
  @semanticTypePrecedenceGraph semanticTypePrecedenceGraph [emptyGraph] ;
  @categoryMethodMapForBuildingContext categoryMethodMapForBuildingContext [emptyMap] ;
  @categoryReaderMapForBuildingContext categoryReaderMapForBuildingContext  [emptyMap] ;
  @categoryModifierMapForBuildingContext categoryModifierMapForBuildingContext  [emptyMap] ;
  @semanticDeclarationListAST categoryOverrideDefinitionList [emptyList] ;
  foreach semanticDeclarationList do
    [mSemanticDeclaration enterDeclarationInGraph
      !?semanticTypePrecedenceGraph
      !?categoryMethodMapForBuildingContext
      !?categoryReaderMapForBuildingContext
      !?categoryModifierMapForBuildingContext
      !?categoryOverrideDefinitionList
    ] ;  
  end foreach ;
  if [semanticTypePrecedenceGraph undefinedNodeCount] > 0 then
    foreach [semanticTypePrecedenceGraph undefinedNodeReferenceList] do
      error mValue : "the '" . mValue . "' type is not defined" ;
    end foreach ;
    error inEndOfProjectSourceFile : "semantic analysis not performed, due to undefined type error(s)" : outSemanticContext, outSortedSemanticDeclarationListAST ;
  else
    [semanticTypePrecedenceGraph topologicalSort
      ?outSortedSemanticDeclarationListAST
      ?*
      ?@semanticDeclarationListAST unsortedSemanticDeclarationListAST
      ?@lstringlist unsortedNodeKeyList
    ] ;
    if [unsortedSemanticDeclarationListAST length] > 0 then
      @string s := "semantic analysis not performed, " . [[unsortedSemanticDeclarationListAST length] string] . " declarations are involved in circular definition:" ;
      foreach unsortedSemanticDeclarationListAST do
        s .= "\n-  " . [mSemanticDeclaration keyRepresentation] ;
      end foreach ;
      error inEndOfProjectSourceFile : s : outSemanticContext ;
    else
    #--- Add category override
      outSortedSemanticDeclarationListAST .= categoryOverrideDefinitionList ;
    #--- Build initial semantic context
      outSemanticContext := [@semanticContext new
        !inProjectSourceFile
        ![@unifiedTypeMap emptyMap]
        ![@routineMap emptyMap]
        ![@functionMap emptyMap]
        ![@filewrapperMap emptyMap]
        ![@grammarMap emptyMap]
        ![@optionComponentMapForSemanticAnalysis emptyMap]
        ![@lexiqueComponentMapForSemanticAnalysis emptyMap]
      ] ;
    #--- Loop throught all declarations
      foreach outSortedSemanticDeclarationListAST do
        [mSemanticDeclaration enterInSemanticContext
          !categoryMethodMapForBuildingContext
          !categoryReaderMapForBuildingContext
          !categoryModifierMapForBuildingContext
          !?outSemanticContext
        ] ;
      end foreach ;
    end if ;
  end if ;
#--- Generate graphviz file
#  const graphvizText := [semanticTypePrecedenceGraph graphviz] ;
#  const graphvizFilePath := [inProjectSourceFile stringByDeletingPathExtension] . "+type-precedence.dot" ;
#  [graphvizText writeToFileWhenDifferentContents !graphvizFilePath ?*] ;
end routine ;

#---------------------------------------------------------------------------*

routine buildGalgas3OptionComponentMapForSemanticAnalysis
  ??@galgas3OptionComponentListAST inOptionComponentList
  !@optionComponentMapForSemanticAnalysis outOptionComponentMapForSemanticAnalysis
:
  outOptionComponentMapForSemanticAnalysis := [@optionComponentMapForSemanticAnalysis emptyMap] ;
  foreach inOptionComponentList do
    var boolOptionMap := [@commandLineOptionMap emptyMap] ;
    var uintOptionMap := [@commandLineOptionMap emptyMap] ;
    var stringOptionMap := [@commandLineOptionMap emptyMap] ;
    @stringset optionNameSet [emptySet] ;
    foreach mOptions do
      if [optionNameSet hasKey ![mOptionInternalName string]] then
        error mOptionInternalName: "the '" + [mOptionInternalName string] + "' command line option has been already declared" ;
      elsif [mOptionTypeName string] == "bool" then
        [!?boolOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          !"false"
        ] ;
        if mOptionDefaultValueKind != [@optionDefaultValueEnumAST noDefaultValue] then
          error mOptionDefaultValue:"an @bool option cannot have a default value (default value is allways false)" ;      
        end if ;
      elsif [mOptionTypeName string] == "uint" then
        [!?uintOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          !if [mOptionDefaultValue string] == "" then "0" else [mOptionDefaultValue string] end
        ] ;
        if mOptionDefaultValueKind == [@optionDefaultValueEnumAST stringDefaultValue] then
          error mOptionDefaultValue:"an @uint option default value cannot be an @string value" ;      
        end if ;
      elsif [mOptionTypeName string] == "string" then
        [!?stringOptionMap insertKey
          !mOptionInternalName
          ![mOptionInvocationLetter char]
          ![mOptionInvocationString string]
          ![mOptionComment string]
          ![mOptionDefaultValue string]
        ] ;
        if mOptionDefaultValueKind == [@optionDefaultValueEnumAST unsignedDefaultValue] then
          error mOptionDefaultValue:"an @string option default value cannot be an @uint value" ;      
        end if ;
      else
        error mOptionTypeName: "only the @bool, @uint or @string types are allowed here" ;
      end if ;
      optionNameSet += ![mOptionInternalName string] ;
    end foreach ;
    [!?outOptionComponentMapForSemanticAnalysis insertKey
      !mOptionComponentName
      !false # Is not predefined
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ] ;
  end foreach ;
#--- Add predefined option component
  if not [outOptionComponentMapForSemanticAnalysis hasKey !"galgas_builtin_options"] then
    @2stringlist optionNameList := [@application boolOptionNameList] ;
    @commandLineOptionMap boolOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?boolOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application boolOptionInvocationLetter !mValue0 !mValue1]
        ![@application boolOptionInvocationString !mValue0 !mValue1]
        ![@application boolOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #--- 
    optionNameList := [@application uintOptionNameList] ;
    @commandLineOptionMap uintOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?uintOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application uintOptionInvocationLetter !mValue0 !mValue1]
        ![@application uintOptionInvocationString !mValue0 !mValue1]
        ![@application uintOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #--- 
    optionNameList := [@application stringOptionNameList] ;
    @commandLineOptionMap stringOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?stringOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application stringOptionInvocationLetter !mValue0 !mValue1]
        ![@application stringOptionInvocationString !mValue0 !mValue1]
        ![@application stringOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #---
    [!?outOptionComponentMapForSemanticAnalysis insertKey
      ![@lstring new !"galgas_builtin_options" !here]
      !true # Is predefined
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
#! Generation
#---------------------------------------------------------------------------*

routine generateSemanticDeclarationsGalgas3
  ??@string inProductDirectory
  ??@generationKind inGenerationKind
  ??@semanticContext inSemanticContext
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
#------ Generate Header Files
  if [@uint errorCount] == 0 then
    switch inGenerationKind
    when someFiles : 
       generateOneFile
        !inProductDirectory
        !inSemanticContext
        !inSemanticDeclarationSortedListForGeneration
        !?ioToolProductFileList
        !?ioAllProductFileSet
      ;
   when manyManyFiles :
      generateManyFiles
        !inProductDirectory
        !inSemanticDeclarationSortedListForGeneration
        !?ioToolProductFileList
        !?ioAllProductFileSet
      ;
    end switch ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine generateOneFile
  ??@string inProductDirectory
  ??@semanticContext inSemanticContext
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
#--- Header files
  var headerInclusionList1 := [@stringlist emptyList] ;
  var headerInclusionList2 := [@stringlist emptyList] ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet1 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerString1] ;
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerString2] ;
    #--- Header 1
      var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n" ;
      headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n\n" ;
      headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
      [mDeclaration addHeaderInclusions !?headerString] ;
      for (s) in inclusionSet1 do
        headerString .= "#include \"" . s . ".h\"\n" ;
      end for ;
      headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
      headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
      headerString .= headerString1 ;
      headerString .= "#endif\n\n" ;
      ioAllProductFileSet += ![mDeclaration implementationCppFileName] . "-1.h" ;
      [@string generateFileWithPattern
        !inProductDirectory
        ![mDeclaration implementationCppFileName] . "-1.h"
        !"//"
        !"\n\n" # Defaut user zone1
        !headerString
        !"\n\n" # Defaut user zone2
        !"\n"
      ] ;
      headerInclusionList1 += ![mDeclaration implementationCppFileName] . "-1" ;
    #--- Header 2
      headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
      headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
      headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
      for (s) in inclusionSet2 do
        headerString .= "#include \"" . s . ".h\"\n" ;
      end for ;
      headerString .= "#include \"" . [mDeclaration implementationCppFileName] . "-1.h\"\n" ;
      [mDeclaration addHeaderInclusions !?headerString] ;
      headerString .= "\n//-----------------------------------------------------------------------------*\n\n" ;
      headerString .= headerString2 ;
      headerString .= "#endif\n\n" ;
      ioAllProductFileSet += ![mDeclaration implementationCppFileName] . ".h" ;
      [@string generateFileWithPattern
        !inProductDirectory
        ![mDeclaration implementationCppFileName] . ".h"
        !"//"
        !"\n\n" # Defaut user zone1
        !headerString
        !"\n\n" # Defaut user zone2
        !"\n"
      ] ;
      headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
    end if ;
  end foreach ;
#    foreach decoratedDeclarationListForGeneration do
#      if not [mDeclaration isPredefined] then
#        const headerString1 := [mDeclaration appendDeclaration1 !true] ;
#        const headerString2 := [mDeclaration appendDeclaration2 !inProductDirectory !true] ;
#        const hasHeader := (headerString1 != "") | (headerString2 != "") ;
#        if hasHeader != [mDeclaration hasCppHeaderFile] then
#          log mDeclaration ;
#        end if ;
#        if (headerString1 != "") & (headerString2 == "") then
#          var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
#          headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          [mDeclaration addHeaderInclusions !?headerString] ;
#          headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= headerString1 ;
#          headerString .= "#endif\n\n" ;
#          [@string generateFileWithPattern
#            !inProductDirectory
#            ![mDeclaration implementationCppFileName] . ".h"
#            !"//"
#            !"\n\n" # Defaut user zone1
#            !headerString
#            !"\n\n" # Defaut user zone2
#            !"\n"
#          ] ;
#          headerInclusionList1 += ![mDeclaration implementationCppFileName] ;
#        elsif (headerString1 == "") & (headerString2 != "") then
#          var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
#          headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          [mDeclaration addHeaderInclusions !?headerString] ;
#          headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= headerString2 ;
#          headerString .= "#endif\n\n" ;
#          [@string generateFileWithPattern
#            !inProductDirectory
#            ![mDeclaration implementationCppFileName] . ".h"
#            !"//"
#            !"\n\n" # Defaut user zone1
#            !headerString
#            !"\n\n" # Defaut user zone2
#            !"\n"
#          ] ;
#          headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
#        elsif (headerString1 != "") & (headerString2 != "") then
#          var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n" ;
#          headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n\n" ;
#          headerString .= headerString1 ;
#          headerString .= "#endif\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          [@string generateFileWithPattern
#            !inProductDirectory
#            ![mDeclaration implementationCppFileName] . "-1.h"
#            !"//"
#            !"\n\n" # Defaut user zone1
#            !headerString
#            !"\n\n" # Defaut user zone2
#            !"\n"
#          ] ;
#          headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
#          headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
#          headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= "#include \"" . [mDeclaration implementationCppFileName] . "-1.h\"\n" ;
#          [mDeclaration addHeaderInclusions !?headerString] ;
#          headerString .= "\n//-----------------------------------------------------------------------------*\n\n" ;
#          headerString .= headerString2 ;
#          headerString .= "#endif\n\n" ;
#          [@string generateFileWithPattern
#            !inProductDirectory
#            ![mDeclaration implementationCppFileName] . ".h"
#            !"//"
#            !"\n\n" # Defaut user zone1
#            !headerString
#            !"\n\n" # Defaut user zone2
#            !"\n"
#          ] ;
#          headerInclusionList1 += ![mDeclaration implementationCppFileName] . "-1" ;
#          headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
#        end if ;
#      end if ;
#    end foreach ;
#--- all-declarations.h
  var headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
    !"all-declarations"
    !headerInclusionList1 + headerInclusionList2
    ![@stringlist emptyList]
  ] ;
  ioAllProductFileSet += !"all-declarations.h" ;
  [@string generateFileWithPattern
    !inProductDirectory
    !"all-declarations.h"
    !"//"
    !"\n\n" # Defaut user zone1
    !headerString
    !"\n\n" # Defaut user zone2
    !"#endif\n"
  ] ;
#------------- all-declarations.cpp
  var n := 0 ;
  var fileIdx := 0 ;
  var implementationString := "" ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      if implementationString == "" then
        var implementationFileIncludeList := [@stringlist listWithValue !"all-declarations"] ;
        for * in inSemanticContext->mOptionComponentMapForSemanticAnalysis do
          if not mIsPredefined then
            implementationFileIncludeList += !"option-" + lkey->string ;
          end if ;
        end for ;
        for * in inSemanticContext->mGrammarMap do
          implementationFileIncludeList += !"grammar-" . lkey->string ;
        end for ;
        implementationString := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
          !"all-declarations"
          !implementationFileIncludeList
        ] ;
      end if ;
      implementationString .= [mDeclaration appendSpecificImplementation !false] ;
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      n ++ ;
      if n == 100 then
        const fileName := "all-declarations-" . fileIdx . ".cpp" ;
        ioToolProductFileList := [@stringlist listWithValue !fileName] + ioToolProductFileList ;
        ioAllProductFileSet += !fileName ;
        [@string generateFileWithPattern
          !inProductDirectory
          !fileName
          !"//"
          !"\n\n" # Defaut user zone1
          !implementationString
          !"\n\n" # Defaut user zone2
          !"\n"
        ] ;
        n := 0 ;
        fileIdx ++ ;
        implementationString := "" ;
      end if ;
    end if ;
  end foreach ;
#--- Last file
  if implementationString != "" then
    const fileName := "all-declarations-" . fileIdx . ".cpp" ;
    ioToolProductFileList := [@stringlist listWithValue !fileName] + ioToolProductFileList ;
    ioAllProductFileSet += !fileName ;
    [@string generateFileWithPattern
      !inProductDirectory
      !fileName
      !"//"
      !"\n\n" # Defaut user zone1
      !implementationString
      !"\n\n" # Defaut user zone2
      !"\n"
    ] ;
  end if ;

#  ioToolProductFileList := [@stringlist listWithValue !"all-declarations.cpp"] + ioToolProductFileList ;
#  ioAllProductFileSet += !"all-declarations.cpp" ;
#  var implementationFileIncludeList := [@stringlist listWithValue !"all-declarations"] ;
#  for * in inSemanticContext->mOptionComponentMapForSemanticAnalysis do
#    if not mIsPredefined then
#      implementationFileIncludeList += !"option-" + lkey->string ;
#    end if ;
#  end for ;
#  for * in inSemanticContext->mGrammarMap do
#    implementationFileIncludeList += !"grammar-" . lkey->string ;
#  end for ;
#  @string implementationString := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
#    !"all-declarations"
#    !implementationFileIncludeList
#  ] ;
#  var n := 0 ;
#  foreach inSemanticDeclarationSortedListForGeneration do
#    if not [mDeclaration isPredefined] then
#      n++ ;
#      implementationString .= [mDeclaration appendSpecificImplementation !false] ;
#      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
#    end if ;
#  end foreach ;
#  [@string generateFileWithPattern
#    !inProductDirectory
#    !"all-declarations.cpp"
#    !"//"
#    !"\n\n" # Defaut user zone1
#    !implementationString
#    !"\n\n" # Defaut user zone2
#    !"\n"
#  ] ;
#  log n ;
end routine ;

#---------------------------------------------------------------------------*

routine generateManyFiles
  ??@string inProductDirectory
  ??@semanticDeclarationSortedListForGeneration inSemanticDeclarationSortedListForGeneration
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
#--- Header files
  var headerInclusionList1 := [@stringlist emptyList] ;
  var headerInclusionList2 := [@stringlist emptyList] ;
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var inclusionSet1 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string headerString1] ;
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !true !inProductDirectory !?inclusionSet2 ??@string headerString2] ;
    #--- Header 1
      var headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n" ;
      headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_1_DEFINED\n\n" ;
      headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
      [mDeclaration addHeaderInclusions !?headerString] ;
      for (s) in inclusionSet1 do
        headerString .= "#include \"" . s . ".h\"\n" ;
      end for ;
      headerString .= "#include \"galgas2/predefined-types.h\"\n\n" ;
      headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
      headerString .= headerString1 ;
      headerString .= "#endif\n\n" ;
      ioAllProductFileSet += ![mDeclaration implementationCppFileName] . "-1.h" ;
      [@string generateFileWithPattern
        !inProductDirectory
        ![mDeclaration implementationCppFileName] . "-1.h"
        !"//"
        !"\n\n" # Defaut user zone1
        !headerString
        !"\n\n" # Defaut user zone2
        !"\n"
      ] ;
      headerInclusionList1 += ![mDeclaration implementationCppFileName] . "-1" ;
    #--- Header 2
      headerString := "#ifndef " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n" ;
      headerString .= "#define " . [[mDeclaration implementationCppFileName] identifierRepresentation] . "_DEFINED\n\n" ;
      headerString .= "//-----------------------------------------------------------------------------*\n\n" ;
      for (s) in inclusionSet2 do
        headerString .= "#include \"" . s . ".h\"\n" ;
      end for ;
      headerString .= "#include \"" . [mDeclaration implementationCppFileName] . "-1.h\"\n" ;
      [mDeclaration addHeaderInclusions !?headerString] ;
      headerString .= "\n//-----------------------------------------------------------------------------*\n\n" ;
      headerString .= headerString2 ;
      headerString .= "#endif\n\n" ;
      ioAllProductFileSet += ![mDeclaration implementationCppFileName] . ".h" ;
      [@string generateFileWithPattern
        !inProductDirectory
        ![mDeclaration implementationCppFileName] . ".h"
        !"//"
        !"\n\n" # Defaut user zone1
        !headerString
        !"\n\n" # Defaut user zone2
        !"\n"
      ] ;
      headerInclusionList2 += ![mDeclaration implementationCppFileName] ;
    end if ;
  end foreach ;
#--- all-declarations.h
  var headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
    !"all-declarations"
    !headerInclusionList1 + headerInclusionList2
    ![@stringlist emptyList]
  ] ;
  ioAllProductFileSet += !"all-declarations.h" ;
  [@string generateFileWithPattern
    !inProductDirectory
    !"all-declarations.h"
    !"//"
    !"\n\n" # Defaut user zone1
    !headerString
    !"\n\n" # Defaut user zone2
    !"#endif\n"
  ] ;
#---------------------------------- Generate Implementation Files
  foreach inSemanticDeclarationSortedListForGeneration do
    if not [mDeclaration isPredefined] then
      var implementationFileIncludes := [@stringlist emptyList] ;
      if [mDeclaration hasCppHeaderFile] then
        implementationFileIncludes += ![mDeclaration implementationCppFileName] ;
      end if ;
      var implementationString := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
        ![mDeclaration implementationCppFileName]
        !implementationFileIncludes
      ] ;
      implementationString .= [mDeclaration appendSpecificImplementation !true] ;
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      ioAllProductFileSet += ![mDeclaration implementationCppFileName] . ".cpp" ;
      [@string generateFileWithPattern
        !inProductDirectory
        ![mDeclaration implementationCppFileName] . ".cpp"
        !"//"
        !"\n\n" # Defaut user zone1
        !implementationString
        !"\n\n" # Defaut user zone2
        !"\n"
      ] ;
      ioToolProductFileList += ![mDeclaration implementationCppFileName] . ".cpp" ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
