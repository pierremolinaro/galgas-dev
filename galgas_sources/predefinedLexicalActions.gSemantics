#---------------------------------------------------------------------------*
#                                                                           *
#  'lexique' component metamodel                                            *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics predefinedLexicalActions :
import "lexiqueSemantics.gSemantics" ;

#---------------------------------------------------------------------------*

reader @lexicalTypeEnum lexicalTypeBaseName -> @string outResult :
  switch selfcopy
    when lexicalType_string : outResult := "string" ;
    when lexicalType_char   : outResult := "char" ;
    when lexicalType_uint   : outResult := "uint" ;
    when lexicalType_uint64 : outResult := "uint64" ;
    when lexicalType_sint   : outResult := "sint" ;
    when lexicalType_sint64 : outResult := "sint64" ;
    when lexicalType_double : outResult := "double" ;
  end switch ;
end reader ;

#---------------------------------------------------------------------------*
#                         buildLexicalRoutineMap                            *
#---------------------------------------------------------------------------*

routine buildLexicalRoutineMap !@lexicalRoutineMap outLexicalRoutineMap :
  outLexicalRoutineMap := [@lexicalRoutineMap emptyMap] ;
#--- enterHexDigitIntoASCIIcharacter
  @lexicalRoutineFormalArgumentList mLexicalRoutineFormalArgumentList [emptyList] ;
  @stringlist mErrorMessageList [emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_char] !"ioASCIICharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inHexDigitCharacter" ;
  mErrorMessageList += !"inErrorCodeGreaterThan255" ;
  mErrorMessageList += !"inErrorNotHexDigitCharacter" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterHexDigitIntoASCIIcharacter" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterDigitIntoASCIIcharacter
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_char] !"ioASCIICharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inDecimalDigitCharacter" ;
  mErrorMessageList += !"inErrorCodeGreaterThan255" ;
  mErrorMessageList += !"inErrorNotDecimalDigitCharacter" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterDigitIntoASCIIcharacter" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterCharacterIntoString
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_string] !"ioString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inCharacter" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterCharacterIntoString" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- resetString
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"resetString" !here]
    !{![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_string] !"ioString"}
    !{}
    !false # Is not extern
  ] ;
#--- convertStringToDouble
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_double] !"ioDouble" ;
  mErrorMessageList += !"inConversionError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertStringToDouble" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterCharacterIntoCharacter
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_char] !"ioCharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inCharacter" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterCharacterIntoCharacter" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- negateSInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_sint] !"ioNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"negateSInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- negateSInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_sint64] !"ioNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"negateSInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertUIntToSInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_uint] !"inUnsignedNumber" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_sint] !"ioSignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertUIntToSInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertUInt64ToSInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_uint64] !"inUnsignedNumber" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_sint64] !"ioSignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertUInt64ToSInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterDigitIntoUInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inDecimalDigitCharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotDecimalDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterDigitIntoUInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterDigitIntoUInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inDecimalDigitCharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint64] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotDecimalDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterDigitIntoUInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterHexDigitIntoUInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inHexDigitCharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotHexDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterHexDigitIntoUInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterHexDigitIntoUInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inHexDigitCharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint64] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotHexDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterHexDigitIntoUInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertDecimalStringIntoUInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotDecimalDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertDecimalStringIntoUInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertDecimalStringIntoSInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_sint] !"ioSignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotDecimalDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertDecimalStringIntoSInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertDecimalStringIntoUInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint64] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotDecimalDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertDecimalStringIntoUInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertDecimalStringIntoSInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_sint64] !"ioSignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotDecimalDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertDecimalStringIntoSInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterBinDigitIntoUInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inCharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotBinDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterBinDigitIntoUInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterBinDigitIntoUInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inCharacter" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint64] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotBinDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterBinDigitIntoUInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterOctDigitIntoUInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotOctDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterOctDigitIntoUInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- enterOctDigitIntoUInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_char] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint64] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotOctDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"enterOctDigitIntoUInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- multiplyUInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_uint] !"inUnsignedNumber"  ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inResultTooLargeError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"multiplyUInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- multiplyUInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_uint]!"inUnsignedNumber" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint64] !"ioUnsignedNumber" ;
  mErrorMessageList += !"inResultTooLargeError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"multiplyUInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertHexStringIntoUInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint]!"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotHexDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertHexStringIntoUInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertHexStringIntoUInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string] !"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint64]!"ioUnsignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotHexDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertHexStringIntoUInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertHexStringIntoSInt
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string]!"inString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_sint]!"ioSignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotHexDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertHexStringIntoSInt" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertHexStringIntoSInt64
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string]!"inString"  ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_sint64]!"ioSignedNumber" ;
  mErrorMessageList += !"inNumberTooLargeError" ;
  mErrorMessageList += !"inCharacterIsNotHexDigitError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertHexStringIntoSInt64" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertUnsignedNumberToUnicodeChar
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_uint] !"inUnsignedNumber" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_char] !"ioUnicodeCharacter" ;
  mErrorMessageList += !"inUnassignedUnicodeValueError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertUnsignedNumberToUnicodeChar" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- convertHTMLSequenceToUnicodeCharacter
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_string] !"inString";
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_char] !"ioUnicodeCharacter" ;
  mErrorMessageList += !"inUnassignedHTMLSequenceError" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"convertHTMLSequenceToUnicodeCharacter" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
#--- codePointToUnicode
  mLexicalRoutineFormalArgumentList := [@lexicalRoutineFormalArgumentList emptyList] ;
  mErrorMessageList := [@stringlist emptyList] ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputMode] ![@lexicalTypeEnum lexicalType_string] !"inCodePointString" ;
  mLexicalRoutineFormalArgumentList += ![@lexicalArgumentModeAST lexicalInputOutputMode] ![@lexicalTypeEnum lexicalType_string] !"ioString" ;
  [!?outLexicalRoutineMap insertKey
    ![@lstring new !"codePointToUnicode" !here]
    !mLexicalRoutineFormalArgumentList
    !mErrorMessageList
    !false # Is not extern
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                         buildLexicalFunctionMap                           *
#---------------------------------------------------------------------------*

routine buildLexicalFunctionMap !@lexicalFunctionMap outLexicalFunctionMap :
  outLexicalFunctionMap := [@lexicalFunctionMap emptyMap] ;
#--- toLower
  @lexicalFunctionFormalArgumentList lexicalTypeList [emptyList] ;
  lexicalTypeList += ![@lexicalTypeEnum lexicalType_char] !"inCharacter" ;
  [!?outLexicalFunctionMap insertKey
    ![@lstring new !"toLower" !here]
    !lexicalTypeList
    ![@lexicalTypeEnum lexicalType_char]
    !""
    !false # Is not extern
  ] ;
#--- toUpper
  lexicalTypeList := [@lexicalFunctionFormalArgumentList emptyList] ;
  lexicalTypeList += ![@lexicalTypeEnum lexicalType_char] !"inCharacter" ;
  [!?outLexicalFunctionMap insertKey
    ![@lstring new !"toUpper" !here]
    !lexicalTypeList
    ![@lexicalTypeEnum lexicalType_char]
    !""
    !false # Is not extern
  ] ;
end routine ;

#---------------------------------------------------------------------------*
#                    printPredefinedLexicalActions                          *
#---------------------------------------------------------------------------*

routine printPredefinedLexicalActions :
#--------------------------------------- Build lexical routine map
  @lexicalRoutineMap lexicalRoutineMap ;
  buildLexicalRoutineMap ?lexicalRoutineMap ;
#--------------------------------------- Display lexical routines
  @string s := "" ;
  s .= "**************** Prefined lexical routines  ****************\n" ;
  foreach lexicalRoutineMap do
    s .= [lkey string] ;
    foreach mLexicalRoutineFormalArgumentList do
      s .= " " . [mLexicalFormalArgumentMode lexicalFormalModeName] . "@" . [mLexicalFormalArgumentType lexicalTypeBaseName] . " " . mArgumentNameForComment ;
    end foreach ;
    foreach mErrorMessageList
    before s .= " error" ;
    do s .= " " . mValue ;
    between s .= "," ;
    end foreach ;
    s .= " ;\n\n" ;
  end foreach ;
#--------------------------------------- Build lexical function map
  @lexicalFunctionMap lexicalFunctionMap ;
  buildLexicalFunctionMap ?lexicalFunctionMap ;
#--------------------------------------- Display lexical functions
  s .= "**************** Prefined lexical functions ****************\n" ;
  foreach lexicalFunctionMap do
    s .= [lkey string] ;
    foreach mLexicalTypeList do
      s .= " ?@" . [mLexicalType lexicalTypeBaseName]. " " . mArgumentNameForComment ;
    end foreach ;
    s .= " -> @" . [mReturnedLexicalType lexicalTypeBaseName] . " ;\n" ;
    if mReplacementFunctionName != "" then
      s .= "Note: the '" . lkey . "' function is obsolete: use '" . mReplacementFunctionName . "' function.\n" ;
    end if ;
    s .= "\n" ;
  end foreach ;
#--------------------------------------- Display
  s .= "************************************************************\n" ;
  message s ;
end routine ;

#---------------------------------------------------------------------------*


end semantics ;