#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS program component parser definition                               *
#                                                                           *
#  Copyright (C) 1997-2006 Pierre Molinaro.                                 *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax program_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics common_semantics in "common_semantics.ggs" ;

#--------------------------------------------------------------------------------*

rule <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <parse_grammar_component_for_importing>
  ??@lstring inFileName
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

rule <program_attributes_declaration>
  ?!@typeListeAttributsAxiome listeDesAttributs
label parse
;

action generatePRGM
  ?@lstring nomPRGMprincipal
  ?@lstring versionString
  ?@L_grammarDescriptorForProgram inGrammarDescriptorForProgramList
  ?@luint nombreMaxErreurs
  ?@luint nombreMaxAlertes
;

#--------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
#--- Program header
  $program$ ;
#--- Get program name
  @lstring nomPRGMprincipal ; # nom fichier programme principal
  $identifier$ ? nomPRGMprincipal ;
#--- Title
  @lstring versionString ;
  $literal_string$ ? versionString ;
  $:$ ;
#--- Import clauses
  @M_grammarComponents grammarComponentsMap := ioGrammarComponentsMap ;
  $import$ ;
  repeat
    select
      $grammar$ ;
      @lstring grammarName ;
      $identifier$ ? grammarName ;
      select
      or
        $in$ ;
        @lstring sourceFileName ;
        $literal_string$ ? sourceFileName ;
        <parse_grammar_component_for_importing>
          !sourceFileName
          !?grammarComponentsMap
          !?ioMetamodelComponentMap
          !?ioConstraintComponentMap
        ;
      end select ;
      $;$ ;
    or
      $metamodel$ ;
      @lstring metamodelComponentName ;
      $identifier$ ? metamodelComponentName ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioConstraintComponentMap
        ;
      end select ;
      $;$ ;
    or
      $constraint$ ;
      @lstring constraintComponentName ;
      $identifier$ ? constraintComponentName ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
#         <parse_semantics_component_for_importing> 
#            !sourceFile
#            !?ioSemanticsComponentsMap
#            !?ioMetamodelComponentMap
#            !?ioConstraintComponentMap
#          ;
      end select ;
      $;$ ;
    end select ;
  while
    $import$ ;
  end repeat ;
#--- Max errors count
  $error$ ;
  @luint nombreMaxErreurs ; # Nombre maximum d'erreurs
  $unsigned_literal_integer$ ? nombreMaxErreurs ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  @luint nombreMaxAlertes ; # Nombre maximum d'alertes
  $unsigned_literal_integer$ ? nombreMaxAlertes ;
  $;$ ;
#--- WHEN clauses
  @L_grammarDescriptorForProgram grammarDescriptorForProgramList [emptyList] ;
  $when$ ;
   repeat
  #--- Source file extension definition
    $.$ ;
    @lstring extensionSource ; # extension fichiers source
    $literal_string$ ? extensionSource ;
    $:$ ;
    @lstring grammarName ;
    $identifier$ ? grammarName ;
    @lstring lexiqueClassName ;
    @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap ;
    @M_optionComponents optionsComponentsMap ;
    [grammarComponentsMap searchKey !grammarName ?nonterminalSymbolParametersMap  ?lexiqueClassName ?optionsComponentsMap] ;
    @lstring altName := [@lstring new !"" !here] ;
    @L_signature startSymbolSignature ;
    @lstring returnedMetamodel ;
    [nonterminalSymbolParametersMap searchKey !altName ?startSymbolSignature ?returnedMetamodel] ;
  #--- Liste des attributs
    @typeListeAttributsAxiome listeDesAttributs [emptyList] ;
    <program_attributes_declaration> !?listeDesAttributs ;
  #--- Verifier que le nombre d'attributs est correct
    if [listeDesAttributs length] < [startSymbolSignature length] then
      error here : "one or more parameters missing" ;
    elsif [listeDesAttributs length] > [startSymbolSignature length] then
      error here : "too much parameters" ;
    end if ;
    @string postfix := "" ;
  #--- Metamodel ?
    @lstring metamodelName ;
    @lstring rootEntityName ;
    @L_lstringList contraintListForMetamodel [emptyList] ;
    select
      metamodelName := [@lstring new !"" !here] ;
      rootEntityName := [@lstring new !"" !here] ;
    or
      $metamodel$ ;
      $identifier$ ? metamodelName ;
      select
      or
        $($ ;
        repeat
          @lstring constraintComponentName ;
          $identifier$ ? constraintComponentName ;
          contraintListForMetamodel += !constraintComponentName ;
        while
          $,$ ;
        end repeat ;
        $)$ ;
      end select ;
      if [metamodelName string] != [returnedMetamodel string] then
        error metamodelName: "the '" . [returnedMetamodel string] . "' metamodel was expected here" ;
       end if ;
      [ioMetamodelComponentMap searchKey !metamodelName ?rootEntityName ?* ?* ?*] ;
    end select ;
    $;$ ;
  #--- Send grammar descriptor
    grammarDescriptorForProgramList +=
      !postfix
      !grammarName
      !startSymbolSignature
      !listeDesAttributs
      !lexiqueClassName
      !returnedMetamodel
      !rootEntityName
      !contraintListForMetamodel
      !extensionSource
      !optionsComponentsMap
    ;
  while
    $when$ ;
  end repeat ;
#--- Engendrer le programme principal
  action generatePRGM
    !nomPRGMprincipal
    !versionString
    !grammarDescriptorForProgramList
    !nombreMaxErreurs
    !nombreMaxAlertes
  ;
  $end$ ;
  $program$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
#--- Program header
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Grammar definitiuon
  $import$ ;
  repeat
    select
      $grammar$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
       <parse_grammar_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
        or
        $in$ ;
        $literal_string$ ?* ;
        <parse_semantics_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $constraint$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ?* ;
      end select ;
      $;$ ;
    end select ;
  while
    $import$ ;
  end repeat ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    $:$ ;
    $identifier$ ? * ; # Grammar name
    <program_attributes_declaration> parse ;
    select
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
      or
        $($ ;
        repeat
          $identifier$ ? * ;
        while
          $,$ ;
        end repeat ;
        $)$ ;
      end select ;
    end select ;
    $;$ ;
  while
    $when$ ;
  end repeat ;
#--- End program
  $end$ ;
  $program$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Grammar definitiuon
  $import$ ;
  repeat
    select
      $grammar$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
       <parse_grammar_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
        or
        $in$ ;
        $literal_string$ ?* ;
        <parse_semantics_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $constraint$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ?* ;
      end select ;
      $;$ ;
    end select ;
  while
    $import$ ;
  end repeat ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    $:$ ;
    $identifier$ ? * ; # Grammar name
    <program_attributes_declaration> parse ;
    select
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
      or
        $($ ;
        repeat
          $identifier$ ? * ;
        while
          $,$ ;
        end repeat ;
        $)$ ;
      end select ;
    end select ;
    $;$ ;
  while
    $when$ ;
  end repeat ;
  $end$ ;
  $program$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
  $import$ ;
  repeat
    select
      $grammar$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
       <parse_grammar_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
        or
        $in$ ;
        $literal_string$ ?* ;
        <parse_semantics_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $constraint$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ?* ;
      end select ;
      $;$ ;
    end select ;
  while
    $import$ ;
  end repeat ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    $:$ ;
    $identifier$ ? * ; # Grammar name
    <program_attributes_declaration> parse ;
    select
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
      or
        $($ ;
        repeat
          $identifier$ ? * ;
        while
          $,$ ;
        end repeat ;
        $)$ ;
      end select ;
    end select ;
    $;$ ;
  while
    $when$ ;
  end repeat ;
  $end$ ;
  $program$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents unused ioConstraintComponentMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
  $import$ ;
  repeat
    select
      $grammar$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
       <parse_grammar_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
        or
        $in$ ;
        $literal_string$ ?* ;
        <parse_semantics_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $constraint$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ?* ;
      end select ;
      $;$ ;
    end select ;
  while
    $import$ ;
  end repeat ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    $:$ ;
    $identifier$ ? * ; # Grammar name
    <program_attributes_declaration> parse ;
    select
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
      or
        $($ ;
        repeat
          $identifier$ ? * ;
        while
          $,$ ;
        end repeat ;
        $)$ ;
      end select ;
    end select ;
    $;$ ;
  while
    $when$ ;
  end repeat ;
  $end$ ;
  $program$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
  $import$ ;
  repeat
    select
      $grammar$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
       <parse_grammar_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
        or
        $in$ ;
        $literal_string$ ?* ;
        <parse_semantics_component_for_importing> parse ;
      end select ;
      $;$ ;
    or
      $constraint$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ?* ;
      end select ;
      $;$ ;
    end select ;
  while
    $import$ ;
  end repeat ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    $:$ ;
    $identifier$ ? * ; # Grammar name
    <program_attributes_declaration> parse ;
    select
    or
      $metamodel$ ;
      $identifier$ ? * ;
      select
      or
        $($ ;
        repeat
          $identifier$ ? * ;
        while
          $,$ ;
        end repeat ;
        $)$ ;
      end select ;
    end select ;
    $;$ ;
  while
    $when$ ;
  end repeat ;
  $end$ ;
  $program$ ;
  $;$ ;
end rule ;

#--------------------------------------------------------------------------------*

rule <program_attributes_declaration>
  ?!@typeListeAttributsAxiome listeDesAttributs
:
  select
  or
    $($ ;
    repeat
      @lstring texte ;
      $identifier$ ? texte ;
      listeDesAttributs += !texte ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
  end select ;
end rule ;

#--------------------------------------------------------------------------------*

end syntax ;
