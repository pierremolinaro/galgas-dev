#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS program component parser definition                               *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax program_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#--------------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  !@entityToImplementMap outAllMetamodelClassMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
label parse
;

nonterminal <program_attributes_declaration>
  !@L_lstringList outAttributeList
  !@stringset outAttributeSet
label parse
;

nonterminal <semantic_instructions_list>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label parse
;

action generatePRGM
  ??@lstring nomPRGMprincipal
  ??@lstring versionString
  ??@L_grammarDescriptorForProgram inGrammarDescriptorForProgramList
  ??@ruleDescriptorForProgramList inRuleDescriptorForProgramList
  ??@luint nombreMaxErreurs
  ??@luint nombreMaxAlertes
  ??@stringlist inGrammarNameList
  ??@M_optionComponents inOptionsComponentsMap
;

#--------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
:
#--- Program header
  $program$ ;
#--- Get program name
  @lstring nomPRGMprincipal ; # nom fichier programme principal
  $identifier$ ? nomPRGMprincipal ;
#--- Title
  @lstring versionString ;
  $literal_string$ ? versionString ;
  $:$ ;
#--- Import clauses
  @ModelMap modelMap [emptyMap] ;
  @ActionMap actionMap [emptyMap] ;
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @M_semanticsEntitiesForUse componentEntitiesMap ;
  @stringset classNamesSet [emptySet] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedGrammarComponents ;
  @entityToImplementMap allMetamodelClassMap ;
  @M_optionComponents optionsComponentsMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedMetamodelComponents
    ?includedOptionComponents
    ?includedGrammarComponents
    !?ioSemanticsComponentsMap
    !?ioMetamodelComponentMap
    !?ioTreewalkingComponentMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?optionsComponentsMap
    ?modelMap
    ?actionMap
    ?componentEntitiesMap
    ?tableEnAvant
    ?allMetamodelClassMap
  ;
#--- Max errors count
  $error$ ;
  @luint nombreMaxErreurs ; # Nombre maximum d'erreurs
  $unsigned_literal_integer$ ? nombreMaxErreurs ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  @luint nombreMaxAlertes ; # Nombre maximum d'alertes
  $unsigned_literal_integer$ ? nombreMaxAlertes ;
  $;$ ;
#--- WHEN clauses
  @L_grammarDescriptorForProgram grammarDescriptorForProgramList [emptyList] ;
  @ruleDescriptorForProgramList ruleDescriptorForProgramList [emptyList] ;
  $when$ ;
   repeat
  #--- Source file extension definition
    $.$ ;
    @lstring sourceExtension ;
    $literal_string$ ? sourceExtension ;
  #--- Check source extension
    if [[sourceExtension string] length] == 0 then
      error sourceExtension: "the source extension should not be empty" ;
    else
      @uint index := 0 ;
      @bool ok := true ;
      loop [[sourceExtension string] length] + 1 :
      while (index < [[sourceExtension string] length]) & ok do
        @char c := [[sourceExtension string] characterAtIndex !index] ;
        ok := ((c >= 'a') & (c <= 'z')) | ((c >= 'A') & (c <= 'Z')) | ((c >= '0') & (c <= '9')) | (c == '_') ;
        index ++ ;
      end loop ;
      if not ok then
        error sourceExtension: "the source extension should contains only lower case letters, upper case letters, digits and underscore characters" ;
      end if ;
    end if ;
    select
    #--- Help message
      @string helpMessage ;
      $message$ ;
      @lstring messageString ;
      $literal_string$ ? messageString ;
      helpMessage := [messageString string] ;
    #--- Argument
      @typeVariablesMap variablesMap [emptyMap] ;
      $??$ ;
      @lstring parameterTypeName ;
      $type_name$ ? parameterTypeName ;
      if [parameterTypeName string] != "lstring" then
        error parameterTypeName: "only the '@lstring' type is allowed here" ;
      end if ;
      @lstring argumentName ;
      $identifier$ ? argumentName ;
      [!?variablesMap insertConstInArgument
        !argumentName
        ![@typeGalgas_lstring new]
        ![@typeAutomaticName new !argumentName]
      ] ;
    #--- Instruction list
      ${$ ;
      @typeInstructionList instructionList [emptyList] ;
      @typeTableEnAvant tableEnAvant [emptyMap] ;
      @entityToImplementMap metamodelEntityMap [emptyMap] ;
      @entityPropertyMap currentTreewalkingRoutinePropertyMap [emptyMap] ;
      @treewalkingRoutineHeaderMap treewalkingRoutineHeaderMap [emptyMap] ;
      <semantic_instructions_list>
        !treewalkingRoutineHeaderMap
        !tableEnAvant
        !componentEntitiesMap
        !optionsComponentsMap
        !?variablesMap
        !?instructionList
        !currentTreewalkingRoutinePropertyMap
        !metamodelEntityMap
        !ioTreewalkingComponentMap
      ;
      $}$ ;
      ruleDescriptorForProgramList += 
        !sourceExtension
        !helpMessage
        !argumentName
        !instructionList
      ;
    or
      $:$ ;
      @string helpMessage ;
      select
        helpMessage := "" ;
      or
        $message$ ;
        @lstring messageString ;
        $literal_string$ ? messageString ;
        helpMessage := [messageString string] ;
      end select ;
      $grammar$ ;
      @lstring grammarName ;
      $identifier$ ? grammarName ;
      @AC_semanticsEntity e ;
      [componentEntitiesMap searchKey !grammarName ?e] ;
      @M_nonterminalSymbolAlts grammarAltMap ;
      @lstring lexiqueClassName ;
      extract e->@C_grammarForSemantics (?grammarAltMap ?lexiqueClassName) error grammarName  : messageTypeEntite ;
      @lstring altName := [@lstring new !"" !here] ;
      @L_EXsignature startSymbolSignature ;
      @lstring returnedMetamodel ;
      [grammarAltMap searchKey !altName ?startSymbolSignature ?returnedMetamodel] ;
    #--- Liste des attributs
      @L_lstringList grammarAttributeList ;
      @stringset grammarAttributeSet ;
      <program_attributes_declaration>
        ?grammarAttributeList
        ?grammarAttributeSet
      ;
      warning here: "old style construct; now use the following construct:\n"
       . "  when . \"" . [sourceExtension string] . "\" message \"an '." . [sourceExtension string] . "' source file\" ??@lstring inSourceFile {\n"
       . "    grammar " . [grammarName string] . " in inSourceFile;\n"
       . "  }\n" ;
    #--- Verifier que le nombre d'attributs est correct
      if [grammarAttributeList length] < [startSymbolSignature length] then
        error here : "one or more parameters missing" ;
      elsif [grammarAttributeList length] > [startSymbolSignature length] then
        error here : "too much parameters" ;
      end if ;
      @string postfix := "" ;
    #--- Metamodel ?
      @lstring metamodelName ;
      @lstring rootEntityName ;
      @stringset contraintStringsetForMetamodel [emptySet] ;
      select
        metamodelName := [@lstring new !"" !here] ;
        rootEntityName := [@lstring new !"" !here] ;
      or
        $metamodel$ ;
        $identifier$ ? metamodelName ;
        select
        or
          $($ ;
          repeat
            @lstring constraintComponentName ;
            $identifier$ ? constraintComponentName ;
            contraintStringsetForMetamodel += ![constraintComponentName string] ;
          while
            $,$ ;
          end repeat ;
          $)$ ;
        end select ;
        if [metamodelName string] != [returnedMetamodel string] then
          error metamodelName: "the '" . [returnedMetamodel string] . "' metamodel was expected here" ;
         end if ;
        [ioMetamodelComponentMap searchKey !metamodelName ?rootEntityName ?* ?*] ;
      end select ;
      $;$ ;
    #--- Send grammar descriptor
      grammarDescriptorForProgramList +=
        !postfix
        !grammarName
        !startSymbolSignature
        !grammarAttributeList
        !lexiqueClassName
        !returnedMetamodel
        !rootEntityName
        !sourceExtension
        !helpMessage
      ;
    end select ;
  while
    $when$ ;
  end repeat ;
#--- List of all grammars names
  @stringlist grammarNameList [emptyList] ;
  foreach ioGrammarComponentsMap (@lstring kKey 3*) :
    grammarNameList += ![kKey string] ;
  end foreach ;
#--- Engendrer le programme principal
  action generatePRGM
    !nomPRGMprincipal
    !versionString
    !grammarDescriptorForProgramList
    !ruleDescriptorForProgramList
    !nombreMaxErreurs
    !nombreMaxAlertes
    !grammarNameList
    !optionsComponentsMap
  ;
  $end$ ;
  $program$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
#--- Program header
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    select
    #--- Help message
      $message$ ;
      $literal_string$ ? * ;
    #--- Argument
      $??$ ;
      $type_name$ ? * ;
      $identifier$ ? * ;
    #--- Instruction list
      ${$ ;
      <semantic_instructions_list> parse ;
     $}$ ; 
    or
      $:$ ;
      select
      or
        $message$ ;
        $literal_string$ ? * ;
      end select ;
      $grammar$ ;
      $identifier$ ? * ; # Grammar name
      <program_attributes_declaration> parse ;
      select
      or
        $metamodel$ ;
        $identifier$ ? * ;
        select
        or
          $($ ;
          repeat
            $identifier$ ? * ;
          while
            $,$ ;
          end repeat ;
          $)$ ;
        end select ;
      end select ;
      $;$ ;
    end select ;
  while
    $when$ ;
  end repeat ;
#--- End program
  $end$ ;
  $program$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    select
    #--- Help message
      $message$ ;
      $literal_string$ ? * ;
    #--- Argument
      $??$ ;
      $type_name$ ? * ;
      $identifier$ ? * ;
    #--- Instruction list
      ${$ ;
      <semantic_instructions_list> parse ;
     $}$ ; 
    or
      $:$ ;
      select
      or
        $message$ ;
        $literal_string$ ? * ;
      end select ;
      $grammar$ ;
      $identifier$ ? * ; # Grammar name
      <program_attributes_declaration> parse ;
      select
      or
        $metamodel$ ;
        $identifier$ ? * ;
        select
        or
          $($ ;
          repeat
            $identifier$ ? * ;
          while
            $,$ ;
          end repeat ;
          $)$ ;
        end select ;
      end select ;
      $;$ ;
    end select ;
  while
    $when$ ;
  end repeat ;
  $end$ ;
  $program$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    select
    #--- Help message
      $message$ ;
      $literal_string$ ? * ;
    #--- Argument
      $??$ ;
      $type_name$ ? * ;
      $identifier$ ? * ;
    #--- Instruction list
      ${$ ;
      <semantic_instructions_list> parse ;
     $}$ ; 
    or
      $:$ ;
      select
      or
        $message$ ;
        $literal_string$ ? * ;
      end select ;
      $grammar$ ;
      $identifier$ ? * ; # Grammar name
      <program_attributes_declaration> parse ;
      select
      or
        $metamodel$ ;
        $identifier$ ? * ;
        select
        or
          $($ ;
          repeat
            $identifier$ ? * ;
          while
            $,$ ;
          end repeat ;
          $)$ ;
        end select ;
      end select ;
      $;$ ;
    end select ;
  while
    $when$ ;
  end repeat ;
  $end$ ;
  $program$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    select
    #--- Help message
      $message$ ;
      $literal_string$ ? * ;
    #--- Argument
      $??$ ;
      $type_name$ ? * ;
      $identifier$ ? * ;
    #--- Instruction list
      ${$ ;
      <semantic_instructions_list> parse ;
     $}$ ; 
    or
      $:$ ;
      select
      or
        $message$ ;
        $literal_string$ ? * ;
      end select ;
      $grammar$ ;
      $identifier$ ? * ; # Grammar name
      <program_attributes_declaration> parse ;
      select
      or
        $metamodel$ ;
        $identifier$ ? * ;
        select
        or
          $($ ;
          repeat
            $identifier$ ? * ;
          while
            $,$ ;
          end repeat ;
          $)$ ;
        end select ;
      end select ;
      $;$ ;
    end select ;
  while
    $when$ ;
  end repeat ;
  $end$ ;
  $program$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  $error$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- Max warnings count
  $warning$ ;
  $unsigned_literal_integer$ ? * ;
  $;$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
    select
    #--- Help message
      $message$ ;
      $literal_string$ ? * ;
    #--- Argument
      $??$ ;
      $type_name$ ? * ;
      $identifier$ ? * ;
    #--- Instruction list
      ${$ ;
      <semantic_instructions_list> parse ;
     $}$ ; 
    or
      $:$ ;
      select
      or
        $message$ ;
        $literal_string$ ? * ;
      end select ;
      $grammar$ ;
      $identifier$ ? * ; # Grammar name
      <program_attributes_declaration> parse ;
      select
      or
        $metamodel$ ;
        $identifier$ ? * ;
        select
        or
          $($ ;
          repeat
            $identifier$ ? * ;
          while
            $,$ ;
          end repeat ;
          $)$ ;
        end select ;
      end select ;
      $;$ ;
    end select ;
  while
    $when$ ;
  end repeat ;
  $end$ ;
  $program$ ;
  $;$ ;
end rule ;

#--------------------------------------------------------------------------------*

rule <program_attributes_declaration>
  !@L_lstringList outAttributeList
  !@stringset outAttributeSet
:
  outAttributeList := [@L_lstringList emptyList] ;
  outAttributeSet := [@stringset emptySet] ;
  select
  or
    $($ ;
    repeat
      @lstring attributeName ;
      $identifier$ ? attributeName ;
      outAttributeList += ! attributeName ;
      outAttributeSet += ![attributeName string] ;
    while
      $,$ ;
    end repeat ;
    $)$ ;
  end select ;
end rule ;

#--------------------------------------------------------------------------------*

end syntax ;
