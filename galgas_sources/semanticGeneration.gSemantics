#---------------------------------------------------------------------------*
#                                                                           *
#  Generate predefined types                                                *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticGeneration :
  import "semanticInstructionGeneration.gSemantics" ;
  import "templateCodeGeneration.gSemantics" ;

  import semantics templateCodeGeneration in "templateCodeGeneration.gSemantics" ;
  import semantics semanticInstructionGeneration in "semanticInstructionGeneration.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
# P R O C E D U R E    I M P L E M E N A T I O N                            *
#                                                                           *
#---------------------------------------------------------------------------*

function generateProcedure
  ??@string inProcedureName
  ??@formalParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  ??@bool inProcedureIsConst
  ??@string inCompilerTypeName
  ??@bool inGenerateLocationArgs
  ??@bool inGenerateResetTemplateString
  ->@string outGeneratedCode
:
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  if not inGenerateResetTemplateString then
    unusedVariableCppNameSet += !compilerCppName [] ;
  end if ;
  foreach inFormalArgumentList do
    if mFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentOut] then
      unusedVariableCppNameSet += !mFormalArgumentCppName ;
    end if ;
  end foreach ;
#--- Generate body
  @uint temporaryVariableIndex := 0 ;
  @string routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction !?temporaryVariableIndex !?unusedVariableCppNameSet !?routineBody] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate header
  outGeneratedCode := "void " . inProcedureName . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
#---
  foreach inFormalArgumentList do
    switch mFormalArgumentPassingMode 
    when argumentConstantIn :
      outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    when argumentInOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentIn :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    end switch ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  end foreach ;
#--- Compiler argument
  outGeneratedCode .= inCompilerTypeName . " * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  if inGenerateLocationArgs then
    outGeneratedCode .= "\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
    outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS" ;
  end if ;
  outGeneratedCode .= ")" ;
  if inProcedureIsConst then
    outGeneratedCode .= " const" ;
  end if ;
  outGeneratedCode .= " {\n" ;
#--- Release 'out' arguments
  foreach inFormalArgumentList do
    switch mFormalArgumentPassingMode 
    when argumentOut :
      outGeneratedCode .= "  " . mFormalArgumentCppName . ".drop () ; // Release 'out' argument\n" ;
    when argumentConstantIn, argumentIn, argumentInOut :
    end switch ;
  end foreach ;
#--- Generate routine body
  outGeneratedCode .= routineBody ;
#---
  if inGenerateResetTemplateString then
    outGeneratedCode .= "  " . compilerCppName [] . "->resetTemplateString () ;\n" ;
  end if ;
#---
  outGeneratedCode .= "}\n\n" ;
end function ;

#---------------------------------------------------------------------------*
#                                                                           *
# F U N C T I O N    I M P L E M E N A T I O N                              *
#                                                                           *
#---------------------------------------------------------------------------*

function generateFunction
  ??@string inProcedureName
  ??@formalInputParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  ??@string inCompilerTypeName
  ??@string inResultTypeName
  ??@string inResultVariableCppName
  ??@bool inIsStatic
  ->@string outGeneratedCode
:
  outGeneratedCode := "" ;
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  unusedVariableCppNameSet += !compilerCppName [] ;
#--- Release 'in' and 'const in' arguments at the end of the routine
  foreach inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName ;
  end foreach ;
#--- Generate body
  @uint temporaryVariableIndex := 0 ;
  @string routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction !?temporaryVariableIndex !?unusedVariableCppNameSet !?routineBody] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate header
  if inIsStatic then
    outGeneratedCode .= "static " ;
  end if ;
  outGeneratedCode .= "GALGAS_" . [inResultTypeName identifierRepresentation] . " " ;
  outGeneratedCode .= inProcedureName . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
#---
  foreach inFormalArgumentList do
    outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  end foreach ;
#--- Compiler argument
  outGeneratedCode .= inCompilerTypeName . " * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  outGeneratedCode .= "\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS)" ;
  outGeneratedCode .= " {\n" ;
#--- Declare returned variable
  outGeneratedCode .= "  GALGAS_" . [inResultTypeName identifierRepresentation]
                   .  " " . inResultVariableCppName . " ; // Returned variable\n" ;
#--- Generate routine body
  outGeneratedCode .= routineBody ;
#--- Generate return instruction
  outGeneratedCode .= "//---\n" ;
  outGeneratedCode .= "  return " . inResultVariableCppName . " ;\n" ;
#---
  outGeneratedCode .= "}\n\n" ;
end function ;

#---------------------------------------------------------------------------*
#                                                                           *
# C A T E G O R Y    M E T H O D    I M P L E M E N A T I O N               *
#                                                                           *
#---------------------------------------------------------------------------*

function generateCategoryMethod
  ??@string inClassName
  ??@string inBaseClassName
  ??@string inMethodName
  ??@formalParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  ->@string outGeneratedCode
:
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  unusedVariableCppNameSet += !compilerCppName [] ;
  unusedVariableCppNameSet += !selfMarkName [] ;
  foreach inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName ;
  end foreach ;
#--- Generate body
  @uint temporaryVariableIndex := 0 ;
  @string routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction !?temporaryVariableIndex !?unusedVariableCppNameSet !?routineBody] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate header
  outGeneratedCode := "static void categoryMethod_" . [inClassName identifierRepresentation] . "_" . [inMethodName identifierRepresentation] . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
  if inBaseClassName == "" then
    outGeneratedCode .= "const cPtr_" . [inClassName identifierRepresentation] . " * " ;
  else
    outGeneratedCode .= "const cPtr_" . [inBaseClassName identifierRepresentation] . " * " ;
  end if ;
  const @bool currentObjectIsUnused := [unusedVariableCppNameSet hasKey !selfMarkName []] ;
  if currentObjectIsUnused then
    outGeneratedCode .= "/* inObject */" ;
  else
    outGeneratedCode .= "inObject" ;
  end if ;
#---
  foreach inFormalArgumentList do
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
    switch mFormalArgumentPassingMode 
    when argumentConstantIn :
      outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    when argumentInOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentIn :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    end switch ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
  end foreach ;
#--- Compiler argument
  outGeneratedCode .= ",\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "C_Compiler * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  outGeneratedCode .= "\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS" ;
  outGeneratedCode .= ") {\n" ;
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode .= "  const cPtr_" . [inClassName identifierRepresentation] . " * object = inObject ;\n" ;
    else
      outGeneratedCode .= "  const cPtr_" . [inClassName identifierRepresentation] . " * object = (const cPtr_" . [inClassName identifierRepresentation] . " *) inObject ;\n" ;
    end if ;
    outGeneratedCode .= "  macroValidObject (object, const cPtr_" . [inClassName identifierRepresentation] . ") ;\n" ;
  end if ;
  outGeneratedCode .= routineBody ;
#---
  outGeneratedCode .= "}" ;
end function ;

#---------------------------------------------------------------------------*
#                                                                           *
# C A T E G O R Y    R E A D E R    I M P L E M E N A T I O N               *
#                                                                           *
#---------------------------------------------------------------------------*

function generateCategoryReader
  ??@string inClassName
  ??@string inBaseClassName
  ??@string inReaderName
  ??@formalInputParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  ??@string inCompilerTypeName
  ??@string inResultTypeName
  ??@string inResultVariableCppName
  ->@string outGeneratedCode
:
  outGeneratedCode := "" ;
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  unusedVariableCppNameSet += !compilerCppName [] ;
  unusedVariableCppNameSet += !selfMarkName [] ;
  foreach inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName ;
  end foreach ;
#--- Generate body
  @uint temporaryVariableIndex := 0 ;
  @string routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction !?temporaryVariableIndex !?unusedVariableCppNameSet !?routineBody] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate header
  outGeneratedCode .= "static GALGAS_" . [inResultTypeName identifierRepresentation] . " categoryReader_" ;
  outGeneratedCode .= [inClassName identifierRepresentation] . "_" . [inReaderName identifierRepresentation] . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
  if inBaseClassName == "" then
    outGeneratedCode .= "const cPtr_" . [inClassName identifierRepresentation] . " * " ;
  else
    outGeneratedCode .= "const cPtr_" . [inBaseClassName identifierRepresentation] . " * " ;
  end if ;
  const @bool currentObjectIsUnused := [unusedVariableCppNameSet hasKey !selfMarkName []] ;
  if currentObjectIsUnused then
    outGeneratedCode .= "/* inObject */" ;
  else
    outGeneratedCode .= "inObject" ;
  end if ;
  outGeneratedCode .= ",\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
#---
  foreach inFormalArgumentList do
    outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  end foreach ;
#--- Compiler argument
  outGeneratedCode .= inCompilerTypeName . " * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  outGeneratedCode .= "\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS)" ;
  outGeneratedCode .= " {\n" ;
#--- Declare returned variable
  outGeneratedCode .= "  GALGAS_" . [inResultTypeName identifierRepresentation]
                   .  " " . inResultVariableCppName . " ; // Returned variable\n" ;
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode .= "  const cPtr_" . [inClassName identifierRepresentation] . " * object = inObject ;\n" ;
    else
      outGeneratedCode .= "  const cPtr_" . [inClassName identifierRepresentation] . " * object = (const cPtr_" . [inClassName identifierRepresentation] . " *) inObject ;\n" ;
    end if ;
    outGeneratedCode .= "  macroValidObject (object, const cPtr_" . [inClassName identifierRepresentation] . ") ;\n" ;
  end if ;
  outGeneratedCode .= routineBody ;
#--- Generate return instruction
  outGeneratedCode .= "//---\n" ;
  outGeneratedCode .= "  return " . inResultVariableCppName . " ;\n" ;
#---
  outGeneratedCode .= "}\n\n" ;
end function ;

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper typeGenerationTemplate in "../generation_templates/type_generation" {
} {
  
  template unifiedClassBodyForType "unified-class-body-for-type.h.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@bool IS_CONCRETE # false if abstract class
    ?@constructorMap CONSTRUCTOR_MAP
    ?@readerMap READER_MAP
    ?@modifierMap MODIFIER_MAP
    ?@instanceMethodMap INSTANCE_METHOD_MAP
    ?@classMethodMap CLASS_METHOD_MAP
    ?@enumerationDescriptorList ENUMERATION_DESCRIPTOR_LIST # Empty List if cannot be enumerated
    ?@uint SUPPORTED_OPERATORS
    ?@unifiedTypeMapProxyList ADD_ASSIGN_ARGUMENT_LIST # Empty list if operator is not supported
    ?@withAccessorMap WITH_ACCESSOR_MAP
  ;

  template genericTypeImplementation "generic-type.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMapProxy SUPER_TYPE_INDEX
    ?@uint SUPPORTED_OPERATORS
  ;

#---------- STRUCTURE
  template structTypeHeader1 "GALGAS_struct.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template structTypeSpecificImplementation "GALGAS_struct.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

#---------- LIST
  template listTypeHeader1 "GALGAS_list.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template listTypeSpecificImplementation "GALGAS_list.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

#---------- SORTED LIST
  template sortedlistTypeHeader1 "GALGAS_sortedlist.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template sortedlistTypeSpecificImplementation "GALGAS_sortedlist.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@sortDescriptorListForGeneration SORT_ATTRIBUTE_LIST
  ;

#---------- ENUM
  template enumTypeHeader1 "GALGAS_enum.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@stringlist CONSTANT_LIST
  ;

  template enumTypeSpecificImplementation "GALGAS_enum.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@stringlist CONSTANT_LIST
    ?@enumMessageListForGeneration ENUM_MESSAGE_LIST
  ;

#---------- MAP
  template mapTypeHeader1 "GALGAS_map.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template mapTypeHeader2 "GALGAS_map.h2.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template mapTypeSpecificImplementation "GALGAS_map.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@insertMethodListAST INSERT_METHOD_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
    ?@mapRemoveMethodListAST REMOVE_METHOD_LIST
    ?@bool HAS_INSERT_OR_REPLACE 
    ?@withAccessorMap WITH_ACCESSOR_MAP
  ;

#---------- Class
  template classTypeHeader1 "GALGAS_class.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedAttributeList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
  ;

  template classTypeHeader2 "GALGAS_class.h2.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedAttributeList CURRENT_ATTRIBUTE_LIST
    ?@typedAttributeList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@abstractMethodDefinitionListForGeneration ABSTRACT_METHOD_LIST
    ?@methodDefinitionListForGeneration CONCRETE_METHOD_LIST
  ;

  template classTypeSpecificImplementation "GALGAS_class.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedAttributeList CURRENT_ATTRIBUTE_LIST
    ?@typedAttributeList ALL_ATTRIBUTE_LIST
    ?@typedAttributeList INHERITED_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@abstractMethodDefinitionListForGeneration ABSTRACT_METHOD_LIST
    ?@methodDefinitionListForGeneration CONCRETE_METHOD_LIST
    ?@instanceMethodMap INSTANCE_METHOD_MAP
  ;

  template listmapTypeSpecificImplementation "GALGAS_listmap.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@string ASSOCIATED_LISTTYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template mapProxyTypeSpecificImplementation "GALGAS_mapproxy.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ASSOCIATED_MAP_TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper semanticComponentGenerationTemplate in "../generation_templates/semantic_generation" {
} {
  template abstractCategoryReaderDeclaration "abstract-category-reader.h.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapProxy RETURN_TYPE
  ;
  
  template abstractCategoryReaderImplementation "abstract-category-reader.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapProxy RETURN_TYPE
  ;
  
  template categoryReaderDeclaration "category-reader.h.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapProxy RETURN_TYPE
  ;

  template categoryReaderImplementation "category-reader.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapProxy RETURN_TYPE
    ?@string READER_IMPLEMENTATION
  ;
  
  template overridingCategoryReaderImplementation "overriding-category-reader.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@unifiedTypeMapProxy RETURN_TYPE
    ?@string READER_IMPLEMENTATION
  ;
  
  template abstractCategoryMethodDeclaration "abstract-category-method.h.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;
  
  template abstractCategoryMethodImplementation "abstract-category-method.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;
  
  template categoryMethodDeclaration "category-method.h.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template categoryMethodImplementation "category-method.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string METHOD_IMPLEMENTATION
  ;
  
  template overridingCategoryMethodImplementation "overriding-category-method.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION
  ;
  
  template filewrapperDeclaration "filewrapper-declaration.h.gTemplate"
    ?@stringlist FILE_INDEX_STRING_LIST
    ?@string FILEWRAPPER_NAME
  ;
  
  template filewrapperImplementation "filewrapper-implementation.cpp.gTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string FILEWRAPPER_IMPLEMENTATION
  ;
  
  template routineDeclaration "routine-declaration.h.gTemplate"
    ?@string ROUTINE_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template functionDeclaration "function-declaration.h.gTemplate"
    ?@string FUNCTION_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER
  ;

  template routineImplementation "routine-implementation.cpp.gTemplate"
    ?@string ROUTINE_NAME
    ?@string ROUTINE_IMPLEMENTATION
  ;

  template functionImplementation "function-implementation.cpp.gTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER
  ;

  template onceFunctionImplementation "once-function-implementation.cpp.gTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER
  ;

  template filewrapperTemplateDeclaration "filewrapper-template.h.gTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template filewrapperTemplateImplementation "filewrapper-template.cpp.gTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@bool USES_COMPILER_ARGUMENT
    ?@bool USES_COLUMN_MARKER
    ?@string GENERATED_INSTRUCTION_STRING
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
# A P P E N D    D E C L A R A T I O N    1                                 *
#                                                                           *
#---------------------------------------------------------------------------*

reader @semanticDeclarationForGeneration appendDeclaration1 -> @string outHeader :
  outHeader := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @routinePrototypeDeclarationForGeneration appendDeclaration1 -> @string outHeader :
  outHeader := [filewrapper semanticComponentGenerationTemplate.routineDeclaration
    !mRoutineName
    !mFormalArgumentList
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @functionPrototypeDeclarationForGeneration appendDeclaration1 -> @string outHeader :
  outHeader := [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !mFunctionName
    !mFormalArgumentList
    ![mReturnType identifierRepresentation]
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @onceFunctionDeclarationForGeneration appendDeclaration1 -> @string outHeader :
  outHeader := [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !mFunctionName
    ![@formalInputParameterListForGeneration emptyList]
    ![mReturnType identifierRepresentation]
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @classTypeForGeneration appendDeclaration1 ->@string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.classTypeHeader1
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
    !mAllTypedAttributeList
    !mIsAbstract
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mWithAccessorMap]
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @mapTypeForGeneration appendDeclaration1 ->@string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.mapTypeHeader1
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mWithAccessorMap]
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @structTypeForGeneration appendDeclaration1 ->@string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.structTypeHeader1
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mWithAccessorMap]
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @listTypeForGeneration appendDeclaration1 ->@string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.listTypeHeader1
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mWithAccessorMap]
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @sortedListTypeForGeneration appendDeclaration1 ->@string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.sortedlistTypeHeader1
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mWithAccessorMap]
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @enumTypeForGeneration appendDeclaration1 ->@string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.enumTypeHeader1
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mConstantList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mWithAccessorMap]
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

routine recursivlyEnumerateRegularFile
  ??@wrapperFileMap inFilewrapperFileMap
  ??@wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@stringlist ioRegularFileIndexStringList
:
  foreach inFilewrapperFileMap do
    ioRegularFileIndexStringList += ![[ioRegularFileIndexStringList length] string] ;
  end foreach ;
  foreach inFilewrapperDirectoryMap do
    recursivlyEnumerateRegularFile
      !mRegularFileMap
      !mDirectoryMap
      !?ioRegularFileIndexStringList
    ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

override reader @filewrapperDeclarationForGeneration appendDeclaration1 -> @string outHeader :
  @stringlist regularFileIndexStringList [emptyList] ;
  recursivlyEnumerateRegularFile
    !mFilewrapperFileMap
    !mFilewrapperDirectoryMap
    !?regularFileIndexStringList
  ;
  outHeader := [filewrapper semanticComponentGenerationTemplate.filewrapperDeclaration
    !regularFileIndexStringList
    !mFilewrapperName
  ] ; 
#--- template generation
  foreach mFilewrapperTemplateListForGeneration do
    outHeader .= [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateDeclaration
      !mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
    ] ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

override reader @abstractCategoryMethodForGeneration appendDeclaration1 -> @string outHeader :
  outHeader := [filewrapper semanticComponentGenerationTemplate.abstractCategoryMethodDeclaration
    !mTypeName
    !mAbstractCategoryMethodName
    !mAbstractCategoryMethodFormalParameterList
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @categoryMethodForGeneration appendDeclaration1 -> @string outHeader :
  outHeader := [filewrapper semanticComponentGenerationTemplate.categoryMethodDeclaration
    !mTypeName
    !mCategoryMethodName
    !mCategoryMethodFormalParameterList
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @abstractCategoryReaderForGeneration appendDeclaration1 -> @string outHeader :
  outHeader := [filewrapper semanticComponentGenerationTemplate.abstractCategoryReaderDeclaration
    !mTypeName
    !mAbstractCategoryReaderName
    !mAbstractCategoryReaderFormalParameterList
    !mResultType
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @categoryReaderForGeneration appendDeclaration1 -> @string outHeader :
  outHeader := [filewrapper semanticComponentGenerationTemplate.categoryReaderDeclaration
    !mTypeName
    !mCategoryReaderName
    !mCategoryReaderFormalParameterList
    !mResultType
  ] ; 
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
# A P P E N D    D E C L A R A T I O N    2                                 *
#                                                                           *
#---------------------------------------------------------------------------*

reader @semanticDeclarationForGeneration appendDeclaration2 -> @string outHeader :
  outHeader := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @mapTypeForGeneration appendDeclaration2 ->@string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.mapTypeHeader2
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @classTypeForGeneration appendDeclaration2 ->@string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.classTypeHeader2
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
    !mTypedAttributeList
    !mAllTypedAttributeList
    !mIsAbstract
    !mAbstractMethodList
    !mMethodList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
# A P P E N D    G E N E R I C    T Y P E    I M P L E M E N T A T I O N    *
#                                                                           *
#  This code is common for all types                                        *
#---------------------------------------------------------------------------*

reader @semanticDeclarationForGeneration appendTypeGenericImplementation ->@string outImplementation :
  outImplementation := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @semanticTypeForGeneration appendTypeGenericImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.genericTypeImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mSuperType]
    ![mTypeIndex mHandledOperatorFlags]
  ] ;
end reader ;


#---------------------------------------------------------------------------*
#                                                                           *
# A P P E N D    S P E C I F I C    I M P L E M E N T A T I O N             *
#                                                                           *
#---------------------------------------------------------------------------*

reader @semanticDeclarationForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @listmapTypeForGeneration appendSpecificImplementation ->@string outImplementation :
#  message "@listmapTypeForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper typeGenerationTemplate.listmapTypeSpecificImplementation
    ![mTypeIndex identifierRepresentation]
    ![mAssociatedListTypeIndex identifierRepresentation]
    !mAssociatedListTypedAttributeList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @mapTypeForGeneration appendSpecificImplementation ->@string outImplementation :
#  message "@mapTypeForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper typeGenerationTemplate.mapTypeSpecificImplementation
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
    !mInsertMethodList
    !mSearchMethodList
    !mRemoveMethodList
    !mHasInsertOrReplaceModifier
    !mWithAccessorMap
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @sortedListTypeForGeneration appendSpecificImplementation ->@string outImplementation :
#  message "@soprtedListTypeForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper typeGenerationTemplate.sortedlistTypeSpecificImplementation
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
    !mSortDescriptorList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @enumTypeForGeneration appendSpecificImplementation ->@string outImplementation :
#  message "@enumTypeForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper typeGenerationTemplate.enumTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mConstantList
    !mEnumMessageList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @mapProxyTypeForGeneration appendSpecificImplementation ->@string outImplementation :
#  message "@mapProxyTypeForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper typeGenerationTemplate.mapProxyTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mAssociatedMapTypeProxy identifierRepresentation]
    !mAssociatedMapTypedAttributeList
    !mSearchMethodList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @classTypeForGeneration appendSpecificImplementation ->@string outImplementation :
#  message "@classTypeForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper typeGenerationTemplate.classTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
    !mTypedAttributeList
    !mAllTypedAttributeList
    ![mAllTypedAttributeList subListWithRange !0 ![mAllTypedAttributeList length] - [mTypedAttributeList length]]
    !mIsAbstract
    !mAbstractMethodList
    !mMethodList
    !mInstanceMethodMap
  ] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @structTypeForGeneration appendSpecificImplementation ->@string outImplementation :
#  message "@structTypeForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper typeGenerationTemplate.structTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @listTypeForGeneration appendSpecificImplementation ->@string outImplementation :
#  message "@listTypeForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper typeGenerationTemplate.listTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @routineImplementationForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@routineImplementationForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.routineImplementation
    !mRoutineName
    !generateProcedure [
      !"routine_" . [mRoutineName identifierRepresentation]
      !mFormalArgumentList
      !mRoutineInstructionList
      !false # Do not generate 'const' qualifier
      !"C_Compiler"
      !true # Generate location Argument
      !false # Do not generate 'resetTemplateString'
    ]
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @functionImplementationForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@functionImplementationForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.functionImplementation
    !mFunctionName
    !generateFunction [
      !"function_" . [mFunctionName identifierRepresentation]
      !mFormalArgumentList
      !mFunctionInstructionList
      !"C_Compiler"
      ![mReturnType key]
      !mResultVariableCppName
      !false # is not static
    ]
    !mFormalArgumentList
    ![mReturnType identifierRepresentation]
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @onceFunctionDeclarationForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@onceImplementationForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.onceFunctionImplementation
    !mFunctionName
    !generateFunction [
      !"onceFunction_" . [mFunctionName identifierRepresentation]
      ![@formalInputParameterListForGeneration emptyList]
      !mFunctionInstructionList
      !"C_Compiler"
      ![mReturnType key]
      !mResultVariableCppName
      !true # is static
    ]
    ![@formalInputParameterListForGeneration emptyList]
    ![mReturnType identifierRepresentation]
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @abstractCategoryMethodForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@abstractCategoryMethodForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.abstractCategoryMethodImplementation
    !mTypeName
    !mAbstractCategoryMethodName
    !mAbstractCategoryMethodFormalParameterList
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @categoryMethodForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@categoryMethodForGeneration appendSpecificImplementation\n" ;
  const @string methodImplementation := generateCategoryMethod [
    !mTypeName
    !""
    !mCategoryMethodName
    !mCategoryMethodFormalParameterList
    !mSemanticInstructionListForGeneration
  ] ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.categoryMethodImplementation
    !mTypeName
    !mCategoryMethodName
    !mCategoryMethodFormalParameterList
    !methodImplementation
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @overridingCategoryMethodForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@overridingCategoryMethodForGeneration appendSpecificImplementation\n" ;
  const @string methodImplementation := generateCategoryMethod [
    !mTypeName
    !mBaseTypeName
    !mCategoryMethodName
    !mCategoryMethodFormalParameterList
    !mSemanticInstructionListForGeneration
  ] ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.overridingCategoryMethodImplementation
    !mTypeName
    !mCategoryMethodName
    !methodImplementation
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @abstractCategoryReaderForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@abstractCategoryReaderForGeneration appendSpecificImplementation\n" ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.abstractCategoryReaderImplementation
    !mTypeName
    !mAbstractCategoryReaderName
    !mAbstractCategoryReaderFormalParameterList
    !mResultType
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @categoryReaderForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@categoryReaderForGeneration appendSpecificImplementation\n" ;
  const @string categoryReaderCode := generateCategoryReader [
    !mTypeName
    !""
    !mCategoryReaderName
    !mCategoryReaderFormalParameterList
    !mSemanticInstructionListForGeneration
    !"C_Compiler"
    ![mResultType key]
    !mResultVarCppName
  ] ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.categoryReaderImplementation
    !mTypeName
    !mCategoryReaderName
    !mCategoryReaderFormalParameterList
    !mResultType
    !categoryReaderCode
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @overrideCategoryReaderForGeneration appendSpecificImplementation -> @string outImplementation :
#  message "@overrideCategoryReaderForGeneration appendSpecificImplementation\n" ;
  const @string categoryReaderCode := generateCategoryReader [
    !mTypeName
    !mBaseTypeName
    !mOverridingCategoryReaderName
    !mOverridingCategoryReaderFormalParameterList
    !mSemanticInstructionListForGeneration
    !"C_Compiler"
    ![mResultType key]
    !mResultVarCppName
  ] ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.overridingCategoryReaderImplementation
    !mTypeName
    !mOverridingCategoryReaderName
    !mResultType
    !categoryReaderCode
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

routine generateWrapperContents
  ??@string inFilewrapperName
  ??@string inFilewrapperDirectory
  ??@uint inFilewrapperDirectoryIndex
  ??@wrapperFileMap inFilewrapperRegularFileMap
  ??@wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@string ioImplementation
:
#--- Generate regular files
  foreach inFilewrapperRegularFileMap do
    const @string contents := [@string stringWithContentsOfFile !mAbsoluteFilePath] ;
    ioImplementation .= "//--- File '" . inFilewrapperDirectory . "/" . lkey . "'\n\n"
    .  "const char * gWrapperFileContent_"
    . [mWrapperFileIndex string] . "_"
    . [inFilewrapperName identifierRepresentation] . " = "
    . [contents utf8Representation] . " ;\n\n"
    . "static const cRegularFileWrapper gWrapperFile_" . [mWrapperFileIndex string]. "_"
    . [inFilewrapperName identifierRepresentation] . " (\n"
    . "  " . [lkey utf8Representation] . ",\n"
    . "  " . [[lkey pathExtension] utf8Representation] . ",\n"
    . "  gWrapperFileContent_" . [mWrapperFileIndex string] . "_" . [inFilewrapperName identifierRepresentation] ."\n"
    . ") ;\n\n" ;
  end foreach ;
#--- Generate sub-directories
  foreach inFilewrapperDirectoryMap do
    generateWrapperContents
      !inFilewrapperName
      ![lkey string]
      !mWrapperDirectoryIndex
      !mRegularFileMap
      !mDirectoryMap
      !?ioImplementation
    ;
  end foreach ;
#--- Generate all Filewrapper list
  ioImplementation .= "//--- All files of '" . inFilewrapperDirectory . "' directory\n\n"
  . "static const cRegularFileWrapper * gWrapperAllFiles_"
  . [inFilewrapperName identifierRepresentation] . "_" . [inFilewrapperDirectoryIndex string]
  . " [" . [[inFilewrapperRegularFileMap count] + 1 string] . "] = {\n" ;
  foreach inFilewrapperRegularFileMap do
    ioImplementation .= "  & gWrapperFile_" . [mWrapperFileIndex string] . "_" . [inFilewrapperName identifierRepresentation] . ",\n" ;
  end foreach ;  
  ioImplementation .= "  NULL\n"
  ."} ;\n\n" ;
#--- Generate all directory wrapper list
  ioImplementation .= "//--- All sub-directories of '" . inFilewrapperDirectory . "' directory\n\n"
  . "static const cDirectoryWrapper * gWrapperAllDirectories_"
  . [inFilewrapperName identifierRepresentation] . "_" . [inFilewrapperDirectoryIndex string]
  . " [" . [[inFilewrapperDirectoryMap count] + 1 string] . "] = {\n" ;
  foreach inFilewrapperDirectoryMap do
    ioImplementation .= "  & gWrapperDirectory_" . [mWrapperDirectoryIndex string] . "_" . [inFilewrapperName identifierRepresentation] . ",\n" ;
  end foreach ;
  ioImplementation .= "  NULL\n"
  . "} ;\n\n" ;
#--- Generate directory wrapper
  ioImplementation .= "//--- Directory '" . inFilewrapperDirectory . "'\n\n"
  . "const cDirectoryWrapper gWrapperDirectory_" . [inFilewrapperDirectoryIndex string] . "_"
  . [inFilewrapperName identifierRepresentation] . " (\n"
  . "  " . [inFilewrapperDirectory utf8Representation] . ",\n"
  . "  " . [[inFilewrapperRegularFileMap count] string] . ",\n"
  . "  gWrapperAllFiles_" . [inFilewrapperName identifierRepresentation] . "_" . [inFilewrapperDirectoryIndex string] . ",\n"
  . "  " . [[inFilewrapperDirectoryMap count] string] . ",\n"
  . "  gWrapperAllDirectories_" . [inFilewrapperName identifierRepresentation] . "_" . [inFilewrapperDirectoryIndex string] . "\n"
  . ") ;\n\n" ;
end routine ;
  
#---------------------------------------------------------------------------*

override reader @filewrapperDeclarationForGeneration appendSpecificImplementation -> @string outImplementation :
  @string filewrapperImplementation := "" ;
  generateWrapperContents
    !mFilewrapperName
    !""
    !0
    !mFilewrapperFileMap
    !mFilewrapperDirectoryMap
    !?filewrapperImplementation
  ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.filewrapperImplementation
    !mFilewrapperName
    !filewrapperImplementation
  ] ;
#--- template generation
  foreach mFilewrapperTemplateListForGeneration do
  #--- Build generated code for instruction list
    @string generatedCodeForInstructionList := "" ;
    @uint temporaryVariableIndex := 0 ;
    @stringset unusedVariableCppNameSet [emptySet] ;
    unusedVariableCppNameSet += !compilerCppName [] ;
    @bool useColumnMarker := false ;
    templateCodeGenerationForListInstruction
      !mTemplateInstructionListForGeneration
      !?generatedCodeForInstructionList
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !?useColumnMarker
    ;
  #---
    outImplementation .= [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateImplementation
      !mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
      !not [unusedVariableCppNameSet hasKey !compilerCppName []]
      !useColumnMarker
      !generatedCodeForInstructionList
    ] ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

end semantics ;
