#---------------------------------------------------------------------------*
#                                                                           *
#  Generate predefined types                                                *
#                                                                           *
#  Copyright (C) 2010, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticGeneration :
  import "templateCodeGeneration.gSemantics" ;
  import "galgas_cli_options.gOption" ;
  import "optionCompilation.gSemantics" ;
  import "predefinedTypes.gSemantics" ;


#---------------------------------------------------------------------------*
#! Grammar
#---------------------------------------------------------------------------*

override reader @grammarForGeneration implementationCppFileName -> @string outName
:
  outName := "grammar-" + mGrammarName ;
end reader ;

#---------------------------------------------------------------------------*

override reader @grammarForGeneration hasCppHeaderFile -> @bool outHasHeader
:
  outHasHeader := false ;
end reader ;

#---------------------------------------------------------------------------*

override reader @grammarForGeneration headerKind -> @headerKind outHeaderKind
:
  outHeaderKind := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @grammarForGeneration isPredefined -> @bool outResult :
  outResult := false ;
end reader ;

#---------------------------------------------------------------------------*
#! Syntax
#---------------------------------------------------------------------------*

override reader @syntaxDeclarationForGeneration implementationCppFileName -> @string outName
:
  outName := "syntax-" + mSyntaxComponentName ;
end reader ;

#---------------------------------------------------------------------------*

override reader @syntaxDeclarationForGeneration hasCppHeaderFile -> @bool outHasHeader
:
  outHasHeader := false ;
end reader ;

#---------------------------------------------------------------------------*

override reader @syntaxDeclarationForGeneration headerKind -> @headerKind outHeaderKind
:
  outHeaderKind := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @syntaxDeclarationForGeneration isPredefined -> @bool outResult :
  outResult := false ;
end reader ;

#---------------------------------------------------------------------------*

override method @syntaxDeclarationForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader
:
  ioInclusionSet += !"lexique-" + mLexiqueName ;
  @uintlist selectMethodList [emptyList] ;
  @uint idx := 0 ;
  loop mSelectMethodCount + 1 :
  while idx < mSelectMethodCount do
    selectMethodList += !idx ;
    idx ++ ;
  end loop ;
  outHeader := [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
    !mSyntaxComponentName
    ![mLexiqueName identifierRepresentation]
    !mNonterminalDeclarationMap
    !mRuleDeclarationList
    !selectMethodList
    !mHasIndexing
    !mHasTranslateFeature
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override method @syntaxDeclarationForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += !"syntax-" + mSyntaxComponentName ;
  outImplementation := [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementationGalgas3
    !{}
  ] ;
#---
  const lexiqueCppName := "C_Lexique_" . [mLexiqueName identifierRepresentation] ;
  foreach mRuleDeclarationList do
  #--- Generate rule label implementation
    foreach mLabelImplementationList do
      const @string ruleName := "cParser_" . [mSyntaxComponentName identifierRepresentation]
        . "::rule_" . [mSyntaxComponentName identifierRepresentation] . "_"
        . [mNonterminalName identifierRepresentation]
        . "_i" . [mRuleIndex string] . "_" . [mLabelName identifierRepresentation]
      ;
      outImplementation .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
      generateProcedure
        !static:false
        !ruleName
        !?ioInclusionSet
        !mSignatureForGeneration
        !mInstructionListForGeneration
        !false
        !lexiqueCppName
        !false # Do not generate location Argument
        !false # Do not generate 'resetTemplateString'
        !mHasTranslateFeature
        ??@string code
      ;
      outImplementation .= code ;
    end foreach ;
  #--- Generate "parse" label
    @semanticInstructionListForGeneration instructionList ;
    [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
    const @string ruleName := "cParser_" . [mSyntaxComponentName identifierRepresentation]
    . "::rule_" . [mSyntaxComponentName identifierRepresentation] . "_"
    . [mNonterminalName identifierRepresentation]
    . "_i" . [mRuleIndex string] . "_parse" ;
    outImplementation .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
    generateProcedure
      !static:false
      !ruleName
      !?ioInclusionSet
      ![@formalParameterListForGeneration emptyList]
      !syntaxSignatureOfInstructionList [!"parse" !instructionList]
      !false
      !lexiqueCppName
      !false # Do not generate location Argument
      !true # Generate 'resetTemplateString'
      !mHasTranslateFeature
      ??@string code
    ;
    outImplementation .= code ;
  #--- Generate indexing code
    if mHasIndexing then
      @semanticInstructionListForGeneration instructionList ;
      [mLabelImplementationList first ?* ?* ?* ?* ?instructionList] ;
      const @string ruleName := "cParser_" . [mSyntaxComponentName identifierRepresentation]
      . "::rule_" . [mSyntaxComponentName identifierRepresentation] . "_"
      . [mNonterminalName identifierRepresentation]
      . "_i" . [mRuleIndex string] . "_indexing" ;
      outImplementation .= "//---------------------------------------------------------------------------------------------------------------------*\n\n" ;
      generateProcedure
        !static:false
        !ruleName
        !?ioInclusionSet
        ![@formalParameterListForGeneration emptyList]
        !syntaxSignatureOfInstructionList [!"indexing" !instructionList]
        !false
        !lexiqueCppName
        !false # Do not generate location Argument
        !false # Do not generate 'resetTemplateString'
        !false # Do not generate syntaxDirectedTranslationString argument
        ??@string code
      ;  
      outImplementation .= code ;
    end if ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
# P R O C E D U R E    I M P L E M E N A T I O N                            *
#                                                                           *
#---------------------------------------------------------------------------*

routine generateProcedure
  ??static:@bool inGenerateStatic
  ??@string inProcedureName
  ?!@stringset ioInclusionSet
  ?@formalParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  ??@bool inProcedureIsConst
  ??@string inCompilerTypeName
  ??@bool inGenerateLocationArgs
  ??@bool inGenerateResetTemplateString
  ??@bool inGenerateSyntaxDirectedTranslationString
  !@string outGeneratedCode
:
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  if inGenerateSyntaxDirectedTranslationString then
    unusedVariableCppNameSet += !syntaxDirectedTranslationResultVarName [] ;
  end if ;
  if not inGenerateResetTemplateString then
    unusedVariableCppNameSet += !compilerCppName [] ;
  end if ;
  foreach inFormalArgumentList do
    if mFormalArgumentPassingMode != [@formalArgumentPassingModeAST argumentOut] then
      unusedVariableCppNameSet += !mFormalArgumentCppName ;
    end if ;
  end foreach ;
#--- Generate body
  var temporaryVariableIndex := 0 ;
  var routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate inclusions
  foreach inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
  end foreach ;
#--- Generate header
  outGeneratedCode := "" ;
  if inGenerateStatic then
    outGeneratedCode += "static " ;
  end if ;
  outGeneratedCode += "void " . inProcedureName . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
#---
  foreach inFormalArgumentList do
    switch mFormalArgumentPassingMode 
    when argumentConstantIn :
      outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    when argumentInOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentIn :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    end switch ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  end foreach ;
#--- Syntax directed argument ?
  if inGenerateSyntaxDirectedTranslationString then
    if [unusedVariableCppNameSet hasKey !syntaxDirectedTranslationResultVarName []] then
      outGeneratedCode .= "C_String & /* " . syntaxDirectedTranslationResultVarName [] . " */,\n" ;
    else
      outGeneratedCode .= "C_String & " . syntaxDirectedTranslationResultVarName [] . ",\n" ;
    end if ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  end if ;
#--- Compiler argument
  outGeneratedCode .= inCompilerTypeName . " * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  if inGenerateLocationArgs then
    outGeneratedCode .= "\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
    outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS" ;
  end if ;
  outGeneratedCode .= ")" ;
  if inProcedureIsConst then
    outGeneratedCode .= " const" ;
  end if ;
  outGeneratedCode .= " {\n" ;
#--- Release 'out' arguments
  foreach inFormalArgumentList do
    switch mFormalArgumentPassingMode 
    when argumentOut :
      outGeneratedCode .= "  " . mFormalArgumentCppName . ".drop () ; // Release 'out' argument\n" ;
    when argumentConstantIn, argumentIn, argumentInOut :
    end switch ;
  end foreach ;
#--- Generate routine body
  outGeneratedCode .= routineBody ;
#---
  if inGenerateResetTemplateString then
    outGeneratedCode .= "  " . compilerCppName [] . "->resetTemplateString () ;\n" ;
  end if ;
#---
  outGeneratedCode .= "}\n\n" ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
# F U N C T I O N    I M P L E M E N A T I O N                              *
#                                                                           *
#---------------------------------------------------------------------------*

routine generateFunction
  ??@string inFunctionCppRepresentationName
  ?!@stringset ioInclusionSet
  ??@formalInputParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  ??@string inCompilerTypeName
  ??@unifiedTypeMapProxy inResultType
  ??@string inResultVariableCppName
  ??@bool inIsStatic
  !@string outGeneratedCode
:
  outGeneratedCode := "" ;
  [inResultType addHeaderFileName !?ioInclusionSet] ;
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  unusedVariableCppNameSet += !compilerCppName [] ;
#--- Release 'in' and 'const in' arguments at the end of the routine
  foreach inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
    unusedVariableCppNameSet += !mFormalArgumentCppName ;
  end foreach ;
#--- Generate body
  @uint temporaryVariableIndex := 0 ;
  @string routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate header
  if inIsStatic then
    outGeneratedCode .= "static " ;
  end if ;
  outGeneratedCode .= "GALGAS_" . [inResultType identifierRepresentation] . " " ;
  outGeneratedCode .= inFunctionCppRepresentationName . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
#---
  foreach inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & "  ;
    else
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    end if ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  end foreach ;
#--- Compiler argument
  outGeneratedCode .= inCompilerTypeName . " * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  outGeneratedCode .= "\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS)" ;
  outGeneratedCode .= " {\n" ;
#--- Declare returned variable
  outGeneratedCode .= "  GALGAS_" . [inResultType identifierRepresentation]
                   .  " " . inResultVariableCppName . " ; // Returned variable\n" ;
#--- Generate routine body
  outGeneratedCode .= routineBody ;
#--- Generate return instruction
  outGeneratedCode .= "//---\n" ;
  outGeneratedCode .= "  return " . inResultVariableCppName . " ;\n" ;
#---
  outGeneratedCode .= "}\n\n" ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
# C A T E G O R Y    M O D I F I E R    I M P L E M E N A T I O N           *
#                                                                           *
#---------------------------------------------------------------------------*

routine generateCategoryModifier
  ??@string inClassName
  ??@string inBaseClassName
  ??@string inMethodName
  ?!@stringset ioInclusionSet
  ??@formalParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  !@string outGeneratedCode
:
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  unusedVariableCppNameSet += !compilerCppName [] ;
  unusedVariableCppNameSet += !"object" ;
  foreach inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName ;
  end foreach ;
#--- Generate body
  var temporaryVariableIndex := 0 ;
  var routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate header
  outGeneratedCode := "static void categoryModifier_" . [inClassName identifierRepresentation] . "_" . [inMethodName identifierRepresentation] . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
  if inBaseClassName == "" then
    outGeneratedCode .= "cPtr_" . [inClassName identifierRepresentation] . " * " ;
  else
    outGeneratedCode .= "cPtr_" . [inBaseClassName identifierRepresentation] . " * " ;
  end if ;
  const @bool currentObjectIsUnused := [unusedVariableCppNameSet hasKey !"object"] ;
  if currentObjectIsUnused then
    outGeneratedCode .= "/* inObject */" ;
  else
    outGeneratedCode .= "inObject" ;
  end if ;
#---
  foreach inFormalArgumentList do
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
    switch mFormalArgumentPassingMode 
    when argumentConstantIn :
      outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    when argumentInOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentIn :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    end switch ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
  end foreach ;
#--- Compiler argument
  outGeneratedCode .= ",\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "C_Compiler * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  outGeneratedCode .= "\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS" ;
  outGeneratedCode .= ") {\n" ;
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode .= "  cPtr_" . [inClassName identifierRepresentation] . " * object = inObject ;\n" ;
    else
      outGeneratedCode .= "  cPtr_" . [inClassName identifierRepresentation] . " * object = (cPtr_" . [inClassName identifierRepresentation] . " *) inObject ;\n" ;
    end if ;
    outGeneratedCode .= "  macroValidSharedObject (object, cPtr_" . [inClassName identifierRepresentation] . ") ;\n" ;
  end if ;
  outGeneratedCode .= routineBody ;
#---
  outGeneratedCode .= "}" ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
# C A T E G O R Y    M E T H O D    I M P L E M E N A T I O N               *
#                                                                           *
#---------------------------------------------------------------------------*

routine generateCategoryMethod
  ??@unifiedTypeMapProxy inReceiverType
  ??@string inBaseClassName
  ?!@stringset ioInclusionSet
  ??@string inMethodName
  ??@formalParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  !@string outGeneratedCode
:
  const className := [inReceiverType key] ;
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  unusedVariableCppNameSet += !compilerCppName [] ;
  unusedVariableCppNameSet += !"object" ;
  foreach inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName ;
  end foreach ;
#--- Generate body
  @uint temporaryVariableIndex := 0 ;
  @string routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate inclusions
  @unifiedTypeMapProxy baseType := inReceiverType ;
  @bool searching := true ;
  loop [@uint max] : while searching do
    if not [[baseType mSuperType] isNull] then
      if [[[baseType mSuperType] mInstanceMethodMap] hasKey !inMethodName] then
        baseType := [baseType mSuperType] ;
      else
        searching := false ;
      end if ;
    else
      searching := false ;
    end if ;  
  end loop ;
  ioInclusionSet += !"method-" . [baseType key] . "-" . inMethodName ;
  [inReceiverType addHeaderFileName !?ioInclusionSet] ;
  foreach inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
  end foreach ;
#--- Generate header
  outGeneratedCode := "static void categoryMethod_" . [className identifierRepresentation] . "_" . [inMethodName identifierRepresentation] . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
  if inBaseClassName == "" then
    outGeneratedCode .= "const cPtr_" . [className identifierRepresentation] . " * " ;
  else
    outGeneratedCode .= "const cPtr_" . [inBaseClassName identifierRepresentation] . " * " ;
  end if ;
  const @bool currentObjectIsUnused := [unusedVariableCppNameSet hasKey !"object"] ;
  if currentObjectIsUnused then
    outGeneratedCode .= "/* inObject */" ;
  else
    outGeneratedCode .= "inObject" ;
  end if ;
#---
  foreach inFormalArgumentList do
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
    switch mFormalArgumentPassingMode 
    when argumentConstantIn :
      outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    when argumentInOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    when argumentIn :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    end switch ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
  end foreach ;
#--- Compiler argument
  outGeneratedCode .= ",\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "C_Compiler * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  outGeneratedCode .= "\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS" ;
  outGeneratedCode .= ") {\n" ;
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode .= "  const cPtr_" . [className identifierRepresentation] . " * object = inObject ;\n" ;
    else
      outGeneratedCode .= "  const cPtr_" . [className identifierRepresentation] . " * object = (const cPtr_" . [className identifierRepresentation] . " *) inObject ;\n" ;
    end if ;
    outGeneratedCode .= "  macroValidSharedObject (object, cPtr_" . [className identifierRepresentation] . ") ;\n" ;
  end if ;
  outGeneratedCode .= routineBody ;
#---
  outGeneratedCode .= "}" ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
# C A T E G O R Y    R E A D E R    I M P L E M E N A T I O N               *
#                                                                           *
#---------------------------------------------------------------------------*

routine generateCategoryReader
  ??@unifiedTypeMapProxy inReceiverType
  ??@string inBaseClassName
  ?!@stringset ioInclusionSet
  ??@string inReaderName
  ??@formalInputParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  ??@string inCompilerTypeName
  ??@string inResultTypeName
  ??@string inResultVariableCppName
  !@string outGeneratedCode
:
  const className := [inReceiverType key] ;
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  unusedVariableCppNameSet += !compilerCppName [] ;
  unusedVariableCppNameSet += !"object" ;
  foreach inFormalArgumentList do
    unusedVariableCppNameSet += !mFormalArgumentCppName ;
  end foreach ;
#--- Generate body
  @uint temporaryVariableIndex := 0 ;
  @string routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false # inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate inclusions
  [inReceiverType addHeaderFileName !?ioInclusionSet] ;
  @unifiedTypeMapProxy baseType := inReceiverType ;
  @bool searching := true ;
  loop [@uint max] : while searching do
    if not [[baseType mSuperType] isNull] then
      if [[[baseType mSuperType] mReaderMap] hasKey !inReaderName] then
        baseType := [baseType mSuperType] ;
      else
        searching := false ;
      end if ;
    else
      searching := false ;
    end if ;  
  end loop ;
  ioInclusionSet += !"getter-" . [baseType key] . "-" . inReaderName ;
  [inReceiverType addHeaderFileName !?ioInclusionSet] ;
  foreach inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
  end foreach ;
#--- Generate header
  outGeneratedCode := "static GALGAS_" . [inResultTypeName identifierRepresentation] . " categoryReader_" ;
  outGeneratedCode .= [className identifierRepresentation] . "_" . [inReaderName identifierRepresentation] . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
  if inBaseClassName == "" then
    outGeneratedCode .= "const cPtr_" . [className identifierRepresentation] . " * " ;
  else
    outGeneratedCode .= "const cPtr_" . [inBaseClassName identifierRepresentation] . " * " ;
  end if ;
  const @bool currentObjectIsUnused := [unusedVariableCppNameSet hasKey !"object"] ;
  if currentObjectIsUnused then
    outGeneratedCode .= "/* inObject */" ;
  else
    outGeneratedCode .= "inObject" ;
  end if ;
  outGeneratedCode .= ",\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
#---
  foreach inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode .= "const GALGAS_" . [mFormalArgumentType identifierRepresentation] . " & " ;
    else
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " " ;
    end if ;
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode .= "/* " . mFormalArgumentCppName . " */" ;
    else
      outGeneratedCode .= mFormalArgumentCppName ;
    end if ;
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  end foreach ;
#--- Compiler argument
  outGeneratedCode .= inCompilerTypeName . " * " ;
  if [unusedVariableCppNameSet hasKey !compilerCppName []] then
    outGeneratedCode .= "/* " . compilerCppName [] . " */" ;
  else
    outGeneratedCode .= compilerCppName [] ;
  end if ;
  outGeneratedCode .= "\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS)" ;
  outGeneratedCode .= " {\n" ;
#--- Declare returned variable
  outGeneratedCode .= "  GALGAS_" . [inResultTypeName identifierRepresentation]
                   .  " " . inResultVariableCppName . " ; // Returned variable\n" ;
#--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode .= "  const cPtr_" . [className identifierRepresentation] . " * object = inObject ;\n" ;
    else
      outGeneratedCode .= "  const cPtr_" . [className identifierRepresentation] . " * object = (const cPtr_" . [className identifierRepresentation] . " *) inObject ;\n" ;
    end if ;
    outGeneratedCode .= "  macroValidSharedObject (object, cPtr_" . [className identifierRepresentation] . ") ;\n" ;
  end if ;
  outGeneratedCode .= routineBody ;
#--- Generate return instruction
  outGeneratedCode .= "//---\n" ;
  outGeneratedCode .= "  return " . inResultVariableCppName . " ;\n" ;
#---
  outGeneratedCode .= "}\n\n" ;
end routine ;

#---------------------------------------------------------------------------*

sortedlist @keySortedList {
  @string mKey ;
  @uint mOrder ;
}{
  mOrder <
}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper typeGenerationTemplate in "../generation_templates/type_generation" {
}{
}{
  template unifiedClassBodyForType "unified-class-body-for-type.h.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@bool IS_CONCRETE # false if abstract class
    ?@constructorMap CONSTRUCTOR_MAP
    ?@readerMap READER_MAP
    ?@modifierMap MODIFIER_MAP
    ?@instanceMethodMap INSTANCE_METHOD_MAP
    ?@classMethodMap CLASS_METHOD_MAP
    ?@enumerationDescriptorList ENUMERATION_DESCRIPTOR_LIST # Empty List if cannot be enumerated
    ?@uint SUPPORTED_OPERATORS
    ?@functionSignature ADD_ASSIGN_ARGUMENT_LIST # Empty list if operator is not supported
    ?@unifiedTypeMapProxy ENUMERATED_OBJECT_TYPE
  ;

  template genericTypeImplementation "generic-type.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMapProxy SUPER_TYPE_INDEX
    ?@uint SUPPORTED_OPERATORS
  ;

#---------- STRUCTURE
  template structTypeHeader1 "GALGAS_struct.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@bool HAS_DEFAULT_CONSTRUCTOR
  ;

  template structTypeSpecificImplementation "GALGAS_struct.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@bool HAS_DEFAULT_CONSTRUCTOR
  ;

#---------- Extern Type
  template externTypeHeader1 "GALGAS_extern_type.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string PRE_DECLARATION
    ?@string CODE
  ;


#---------- Graph
  template graphTypeHeader1 "GALGAS_graph.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
  ;

  template graphTypeSpecificImplementation "GALGAS_graph.cpp.gTemplate"
    ?@unifiedTypeMapProxy TYPE
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMapProxy ASSOCIATED_LIST_TYPE
    ?@graphInsertModifierList INSERT_MODIFIER_LIST
  ;

#---------- Array
  template arrayTypeHeader1 "GALGAS_array.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ELEMENT_TYPE_IDENTIFIER
    ?@uint DIMENSION
  ;

  template arrayTypeSpecificImplementation "GALGAS_array.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ELEMENT_TYPE_IDENTIFIER
    ?@uint DIMENSION
    ?@stringlist DIMENSION_LIST
  ;

#---------- LIST MAP
  template listmapTypeHeader1 "GALGAS_listmap.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
  ;

  template listmapTypeSpecificImplementation "GALGAS_listmap.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@string ASSOCIATED_LIST_TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

#---------- LIST
  template listTypeHeader1 "GALGAS_list.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template listTypeSpecificImplementation "GALGAS_list.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

#---------- SORTED LIST
  template sortedlistTypeHeader1 "GALGAS_sortedlist.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template sortedlistTypeSpecificImplementation "GALGAS_sortedlist.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@sortDescriptorListForGeneration SORT_ATTRIBUTE_LIST
  ;

#---------- ENUM
  template enumTypeHeader1 "GALGAS_enum.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES
  ;

  template enumTypeHeader2 "GALGAS_enum.h2.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES
  ;

  template enumTypeSpecificImplementation "GALGAS_enum.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@enumConstantListForGeneration CONSTANT_LIST
    ?@bool HAS_ASSOCIATED_VALUES
  ;

#---------- MAP PROXY
  template mapProxyTypeHeader1 "GALGAS_mapproxy.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
  ;

  template mapProxyTypeSpecificImplementation "GALGAS_mapproxy.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ASSOCIATED_MAP_TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
  ;

#---------- MAP
  template mapTypeHeader1 "GALGAS_map.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
  ;

  template mapTypeHeader2 "GALGAS_map.h2.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template mapTypeSpecificImplementation "GALGAS_map.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@insertMethodListAST INSERT_METHOD_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
    ?@mapRemoveMethodListAST REMOVE_METHOD_LIST
    ?@bool HAS_INSERT_OR_REPLACE 
#    ?@withAccessorMap WITH_ACCESSOR_MAP
  ;

#---------- UNIQUE MAP
  template uniqueMapTypeHeader1 "GALGAS_uniqueMap.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
  ;

  template uniqueMapTypeHeader2 "GALGAS_uniqueMap.h2.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template uniqueMapTypeSpecificImplementation "GALGAS_uniqueMap.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@insertMethodListAST INSERT_METHOD_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
#    ?@withAccessorMap WITH_ACCESSOR_MAP
    ?@mapAutomatonStateMap MAP_AUTOMATON_STATE_MAP
    ?@mapAutomatonActionMap MAP_AUTOMATON_ACTION_MAP
    ?@mapStateSortedList MAP_AUTOMATON_DEFINITION_SORTEDLIST
    ?@mapOverrideList MAP_OVERRIDE_LIST
    ?@keySortedList MAP_AUTOMATON_STATE_MAP_ORDERED_LIST
  ;

#---------- Class
  template classTypeHeader1 "GALGAS_class.h1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedAttributeList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR
  ;

  template classTypeHeader2part1 "GALGAS_class.h2-part1.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedAttributeList CURRENT_ATTRIBUTE_LIST
    ?@typedAttributeList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
  ;

  template classTypeHeader2part2 "GALGAS_class.h2-part2.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedAttributeList CURRENT_ATTRIBUTE_LIST
    ?@typedAttributeList ALL_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
  ;

  template classTypeSpecificImplementation "GALGAS_class.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedAttributeList CURRENT_ATTRIBUTE_LIST
    ?@typedAttributeList ALL_ATTRIBUTE_LIST
    ?@typedAttributeList INHERITED_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@bool HAS_DEFAULT_CONSTRUCTOR
  ;

}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper semanticComponentGenerationTemplate in "../generation_templates/semantic_generation" {
}{
}{
#------------ Category reader
  template abstractCategoryReaderDeclaration "abstract-category-reader.h.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapProxy RETURN_TYPE
  ;
  
  template abstractCategoryReaderImplementation "abstract-category-reader.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapProxy RETURN_TYPE
  ;
  
  template categoryReaderDeclaration "category-reader.h.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapProxy RETURN_TYPE
  ;

  template categoryReaderImplementation "category-reader.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapProxy RETURN_TYPE
    ?@string READER_IMPLEMENTATION
  ;
  
  template overridingCategoryReaderImplementation "overriding-category-reader.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string READER_NAME
    ?@unifiedTypeMapProxy RETURN_TYPE
    ?@string READER_IMPLEMENTATION
  ;
  
#------------ Category modifier
  template abstractCategoryModifierDeclaration "abstract-category-modifier.h.gTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;
  
  template abstractCategoryModifierImplementation "abstract-category-modifier.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;
  
  template categoryModifierDeclaration "category-modifier.h.gTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template categoryModifierImplementation "category-modifier.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string MODIFIER_IMPLEMENTATION
  ;

  template overridingCategoryModifierImplementation "overriding-category-modifier.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@string MODIFIER_IMPLEMENTATION
  ;
  

#------------ Category method
  template abstractCategoryMethodDeclaration "abstract-category-method.h.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;
  
  template abstractCategoryMethodImplementation "abstract-category-method.cpp.gTemplate"
    ?@unifiedTypeMapProxy RECEIVER_TYPE
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;
  
  template categoryMethodDeclaration "category-method.h.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template categoryMethodImplementation "category-method.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string METHOD_IMPLEMENTATION
  ;
  
  template overridingCategoryMethodImplementation "overriding-category-method.cpp.gTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION
  ;
  
  template filewrapperDeclaration "filewrapper-declaration.h.gTemplate"
    ?@stringlist FILE_INDEX_STRING_LIST
    ?@stringlist DIRECTORY_INDEX_STRING_LIST
    ?@stringlist TEXT_CONTENT_INDEX_STRING_LIST
    ?@stringlist BINARY_CONTENT_INDEX_STRING_LIST
    ?@string FILEWRAPPER_NAME
  ;
  
  template filewrapperImplementation "filewrapper-implementation.cpp.gTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string FILEWRAPPER_IMPLEMENTATION
  ;
  
#--- Category reader implemented as function
  template categoryReaderAsFunctionDeclaration "category-reader-as-function-declaration.h.gTemplate"
    ?@string TYPE_NAME
    ?@string READER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER
  ;

  template categoryReaderAsFunctionImplementation "category-reader-as-function-implementation.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string READER_NAME
    ?@string FUNCTION_IMPLEMENTATION
  ;

#--- Category method implemented as function
  template categoryMethodAsFunctionDeclaration "category-method-as-function.h.gTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template categoryMethodAsFunctionImplementation "category-method-as-function.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION
  ;
  

#--- Category modifier implemented as function
  template categoryModifierAsFunctionDeclaration "category-modifier-as-function.h.gTemplate"
    ?@string TYPE_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template categoryMmodifierAsFunctionImplementation "category-modifier-as-function.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string MODIFIER_NAME
    ?@string MODIFIER_IMPLEMENTATION
  ;
  

#--- Function
  template functionDeclaration "function-declaration.h.gTemplate"
    ?@string FUNCTION_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER
  ;

  template functionImplementation "function-implementation.cpp.gTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER
  ;

#--- Routine
  template routineDeclaration "routine-declaration.h.gTemplate"
    ?@string ROUTINE_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template routineImplementation "routine-implementation.cpp.gTemplate"
    ?@string ROUTINE_NAME
    ?@string ROUTINE_IMPLEMENTATION
  ;


  template onceFunctionImplementation "once-function-implementation.cpp.gTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER
  ;

  template filewrapperTemplateDeclaration "filewrapper-template.h.gTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template filewrapperTemplateImplementation "filewrapper-template.cpp.gTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@stringset UNUSED_VAR_SET
    ?@bool USES_COLUMN_MARKER
    ?@string GENERATED_INSTRUCTION_STRING
  ;
}

#---------------------------------------------------------------------------*
#! Proc
#---------------------------------------------------------------------------*

override reader @routinePrototypeDeclarationForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @routinePrototypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper semanticComponentGenerationTemplate.routineDeclaration
    !mRoutineName
    !mFormalArgumentList
  ] ; 
end method ;

#---------------------------------------------------------------------------*
#! func
#---------------------------------------------------------------------------*

override reader @functionPrototypeDeclarationForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @functionPrototypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !mFunctionName
    !mFormalArgumentList
    ![mReturnType identifierRepresentation]
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override reader @onceFunctionDeclarationForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @onceFunctionDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !mFunctionName
    ![@formalInputParameterListForGeneration emptyList]
    ![mReturnType identifierRepresentation]
  ] ; 
end method ;

#---------------------------------------------------------------------------*
#! Extern type
#---------------------------------------------------------------------------*

override method @externTypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper typeGenerationTemplate.externTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mCppPreDeclarationCode
    !mCppClassCode
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Semantic Type
#---------------------------------------------------------------------------*

override reader @semanticTypeForGeneration appendTypeGenericImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.genericTypeImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mSuperType]
    ![mTypeProxy mHandledOperatorFlags]
  ] ;
end reader ;

#---------------------------------------------------------------------------*
#! Array
#---------------------------------------------------------------------------*

override method @arrayTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper typeGenerationTemplate.arrayTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mElementTypeProxy identifierRepresentation]
    !mDimension
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @arrayTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  [mElementTypeProxy addHeaderFileName !?ioInclusionSet] ;

  @stringlist suffixList [emptyList] ;
  @uint idx := 0 ;
  loop mDimension : while idx < mDimension do
    suffixList += ![idx string] ;
    idx ++ ;
  end loop ;
  outImplementation := [filewrapper typeGenerationTemplate.arrayTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mElementTypeProxy identifierRepresentation]
    !mDimension
    !suffixList
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! List map
#---------------------------------------------------------------------------*

override method @listmapTypeForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader
:
#  ioInclusionSet += !"galgas2/AC_GALGAS_map" ;
  for (t ...) in mAssociatedListTypedAttributeList do
    [t addHeaderFileName1 !?ioInclusionSet] ;
  end for ;

  outHeader := [filewrapper typeGenerationTemplate.listmapTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @listmapTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  [mAssociatedListMapElementTypeIndex addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.listmapTypeSpecificImplementation
    ![mTypeProxy identifierRepresentation]
    ![mAssociatedListTypeIndex identifierRepresentation]
    !mAssociatedListTypedAttributeList
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Map
#---------------------------------------------------------------------------*

override method @mapTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
#  ioInclusionSet += !"galgas2/AC_GALGAS_map" ;
#  for (t ...) in mTypedAttributeList do
#    [t addHeaderFileName1 !?ioInclusionSet] ;
#  end for ;

  outHeader := [filewrapper typeGenerationTemplate.mapTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    !mSearchMethodList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @mapTypeForGeneration appendDeclaration2
  ??@bool unused inGenerateForGalgas3
  ??@string unused inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader
:
  for (t ...) in mTypedAttributeList do
    [t addHeaderFileName1 !?ioInclusionSet] ;
  end for ;

  outHeader := [filewrapper typeGenerationTemplate.mapTypeHeader2
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @mapTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  [mElementTypeProxy addHeaderFileName !?ioInclusionSet] ;
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.mapTypeSpecificImplementation
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    !mInsertMethodList
    !mSearchMethodList
    !mRemoveMethodList
    !mHasInsertOrReplaceModifier
#    !mWithAccessorMap
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Unique Map
#---------------------------------------------------------------------------*

override method @uniqueMapTypeForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader
:
#  ioInclusionSet += !"galgas2/AC_GALGAS_uniqueMap" ;
  for (t ...) in mTypedAttributeList do
    [t addHeaderFileName1 !?ioInclusionSet] ;
  end for ;

  outHeader := [filewrapper typeGenerationTemplate.uniqueMapTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    !mSearchMethodList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @uniqueMapTypeForGeneration appendDeclaration2
  ??@bool unused inGenerateForGalgas3
  ??@string unused inOutputDirectory
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper typeGenerationTemplate.uniqueMapTypeHeader2
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @uniqueMapTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  @keySortedList keySortedList [emptySortedList] ;
  foreach mMapAutomatonStateMap do
    keySortedList += !lkey->string !mStateIndex ;
  end foreach ;
  outImplementation := [filewrapper typeGenerationTemplate.uniqueMapTypeSpecificImplementation
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    !mInsertMethodList
    !mSearchMethodList
#    !mWithAccessorMap
    !mMapAutomatonStateMap
    !mMapAutomatonActionMap
    !mMapStateSortedList
    !mMapOverrideList
    !keySortedList
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Sorted List
#---------------------------------------------------------------------------*

override method @sortedListTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper typeGenerationTemplate.sortedlistTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @sortedListTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  for (t ...) in mTypedAttributeList do
    [t addHeaderFileName !?ioInclusionSet] ;
  end for ;
  [mListElementTypeIndex addHeaderFileName !?ioInclusionSet] ;
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.sortedlistTypeSpecificImplementation
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    !mSortDescriptorList
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Enum
#---------------------------------------------------------------------------*

override method @enumTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  @bool hasAssociatedValues := false ;
  for () in mConstantList while not hasAssociatedValues do
    hasAssociatedValues := [mAssociatedValueTypeList length] > 0 ;
  end for ;
  outHeader := [filewrapper typeGenerationTemplate.enumTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mConstantList
    !hasAssociatedValues
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @enumTypeForGeneration appendDeclaration2
  ??@bool unused inGenerateForGalgas3
  ??@string unused inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader
:
  @bool hasAssociatedValues := false ;
  for () in mConstantList while not hasAssociatedValues do
    hasAssociatedValues := [mAssociatedValueTypeList length] > 0 ;
  end for ;
  for () in mConstantList do
    for () in mAssociatedValueTypeList do
      [mType addHeaderFileName !?ioInclusionSet] ;
    end for ;
  end for ;
  outHeader := [filewrapper typeGenerationTemplate.enumTypeHeader2
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mConstantList
    !hasAssociatedValues
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @enumTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  @bool hasAssociatedValues := false ;
  for () in mConstantList while not hasAssociatedValues do
    hasAssociatedValues := [mAssociatedValueTypeList length] > 0 ;
  end for ;
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.enumTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mConstantList
    !hasAssociatedValues
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Map proxy
#---------------------------------------------------------------------------*

override method @mapProxyTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
#  for (t ...) in [mTypeProxy mCurrentTypedAttributeList] do
#    [t addHeaderFileName1 !?ioInclusionSet] ;
#  end for ;

  outHeader := [filewrapper typeGenerationTemplate.mapProxyTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
  ] ; 
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @mapProxyTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  [mAssociatedMapTypeProxy addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.mapProxyTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mAssociatedMapTypeProxy identifierRepresentation]
    !mAssociatedMapTypedAttributeList
    !mSearchMethodList
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Struct
#---------------------------------------------------------------------------*

override method @structTypeForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader
:
  for (t ...) in mTypedAttributeList do
    [t addHeaderFileName1 !?ioInclusionSet] ;
  end for ;

  outHeader := [filewrapper typeGenerationTemplate.structTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    ![mTypeProxy mDefaultConstructorName] != ""
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @structTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.structTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
    ![mTypeProxy mDefaultConstructorName] != ""
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! List
#---------------------------------------------------------------------------*

override method @listTypeForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper typeGenerationTemplate.listTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @listTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  for (t ...) in mTypedAttributeList do
    [t addHeaderFileName !?ioInclusionSet] ;
  end for ;
  [mListElementTypeIndex addHeaderFileName !?ioInclusionSet] ;
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.listTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !mTypedAttributeList
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Graph
#---------------------------------------------------------------------------*

override method @graphDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper typeGenerationTemplate.graphTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
#    ![mTypeProxy mWithAccessorMap]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @graphDeclarationForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  [mAssociatedListTypeProxy addHeaderFileName !?ioInclusionSet] ;
  [mAssociatedListElementTypeProxy addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.graphTypeSpecificImplementation
    !mTypeProxy
    ![mTypeProxy identifierRepresentation]
    !mAssociatedListTypeProxy
    !mInsertModifierList
  ] ;
 end method ;

#---------------------------------------------------------------------------*
#! Class
#---------------------------------------------------------------------------*

override method @classTypeForGeneration appendDeclaration1
  ?!@stringset ioInclusionSet
  !@string outHeader
:
  if not [mSuperClass isNull] then
    [mSuperClass addHeaderFileName !?ioInclusionSet] ;
  end if ;

  outHeader := [filewrapper typeGenerationTemplate.classTypeHeader1
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
    !mAllTypedAttributeList
    !mIsAbstract
    ![mTypeProxy mDefaultConstructorName] != ""
  ] ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
 end method ;

#---------------------------------------------------------------------------*

override method @classTypeForGeneration appendDeclaration2
  ??@bool inGenerateForGalgas3
  ??@string inOutputDirectory
  ?!@stringset ioInclusionSet
  !@string outHeader
:
  for (t ...) in mTypedAttributeList do
    [t addHeaderFileName !?ioInclusionSet] ;
  end for ;

  if mGenerateHeaderInSeparateFile then
    const part1 := [filewrapper typeGenerationTemplate.classTypeHeader2part1
      ![mTypeProxy key]
      ![mTypeProxy identifierRepresentation]
      !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
      !mTypedAttributeList
      !mAllTypedAttributeList
      !mIsAbstract
    ] ;
    const part2 := [filewrapper typeGenerationTemplate.classTypeHeader2part2
      ![mTypeProxy key]
      ![mTypeProxy identifierRepresentation]
      !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
      !mTypedAttributeList
      !mAllTypedAttributeList
      !mIsAbstract
    ] ;
    const headerFileName := "separateHeaderFor_" . [mTypeProxy identifierRepresentation] . ".h" ;
    [@string generateFileWithPattern
      !inOutputDirectory + if inGenerateForGalgas3 then "/../user-headers" else "" end
      !headerFileName
      !"//"
      !"\n\n" # Defaut user zone1
      !part1
      !"\n\n" # Defaut user zone2
      !part2
    ] ;
    outHeader := "#include \"" . headerFileName . "\"\n\n" ;
  else
    outHeader := [filewrapper typeGenerationTemplate.classTypeHeader2part1
      ![mTypeProxy key]
      ![mTypeProxy identifierRepresentation]
      !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
      !mTypedAttributeList
      !mAllTypedAttributeList
      !mIsAbstract
    ] ;
    outHeader .= [filewrapper typeGenerationTemplate.classTypeHeader2part2
      ![mTypeProxy key]
      ![mTypeProxy identifierRepresentation]
      !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
      !mTypedAttributeList
      !mAllTypedAttributeList
      !mIsAbstract
    ] ;
  end if ;
 end method ;

#---------------------------------------------------------------------------*

override method @classTypeForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  [mTypeProxy addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper typeGenerationTemplate.classTypeSpecificImplementation
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    !if [mSuperClass isNull] then "" else [mSuperClass identifierRepresentation] end
    !mTypedAttributeList
    !mAllTypedAttributeList
    ![mAllTypedAttributeList subListWithRange ![@range new !0 ![mAllTypedAttributeList length] - [mTypedAttributeList length]]]
    !mIsAbstract
    ![mTypeProxy mDefaultConstructorName] != ""
  ] ;
end method ;

#---------------------------------------------------------------------------*
#! Sub programs
#---------------------------------------------------------------------------*

override method @routineImplementationForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  if mHasHeader then
    ioInclusionSet += !"proc-" . mRoutineName ;
  end if ;
  generateProcedure
    !static:mGenerateStatic
    !"routine_" . [mRoutineName identifierRepresentation]
    !?ioInclusionSet
    !mFormalArgumentList
    !mRoutineInstructionList
    !false # Do not generate 'const' qualifier
    !"C_Compiler"
    !true # Generate location Argument
    !false # Do not generate 'resetTemplateString'
    !false # Do not generate syntaxDirectedTranslationString argument
    ??@string code
  ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.routineImplementation
    !mRoutineName
    !code
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override method @functionImplementationForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += !"func-" . mFunctionName ;
  generateFunction
    !"function_" . [mFunctionName identifierRepresentation]
    !?ioInclusionSet
    !mFormalArgumentList
    !mFunctionInstructionList
    !"C_Compiler"
    !mReturnType
    !mResultVariableCppName
    !false # is not static
    ??@string code
  ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.functionImplementation
    !mFunctionName
    !code
    !mFormalArgumentList
    ![mReturnType identifierRepresentation]
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override method @onceFunctionDeclarationForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += !"func-" . mFunctionName ;
  generateFunction
    !"onceFunction_" . [mFunctionName identifierRepresentation]
    !?ioInclusionSet
    ![@formalInputParameterListForGeneration emptyList]
    !mFunctionInstructionList
    !"C_Compiler"
    !mReturnType
    !mResultVariableCppName
    !true # is static
    ??@string code
  ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.onceFunctionImplementation
    !mFunctionName
    !code
    ![@formalInputParameterListForGeneration emptyList]
    ![mReturnType identifierRepresentation]
  ] ; 
end method ;

#---------------------------------------------------------------------------*

#! Method

#---------------------------------------------------------------------------*

override method @abstractCategoryMethodForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper semanticComponentGenerationTemplate.abstractCategoryMethodDeclaration
    ![mReceiverType key]
    !mAbstractCategoryMethodName
    !mAbstractCategoryMethodFormalParameterList
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override reader @abstractCategoryMethodForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @abstractCategoryMethodForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += !"method-" . [mReceiverType key]. "-" . mAbstractCategoryMethodName ;
  [mReceiverType addHeaderFileName !?ioInclusionSet] ;
  for () in mAbstractCategoryMethodFormalParameterList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
  end for ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.abstractCategoryMethodImplementation
    !mReceiverType
    !mAbstractCategoryMethodName
    !mAbstractCategoryMethodFormalParameterList
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override reader @categoryMethodForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @categoryMethodForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  if mImplementedAsFunction then
    outHeader := [filewrapper semanticComponentGenerationTemplate.categoryMethodAsFunctionDeclaration
      ![mReceiverType key]
      !mCategoryMethodName
      !mCategoryMethodFormalParameterList
    ] ; 
  else
    outHeader := [filewrapper semanticComponentGenerationTemplate.categoryMethodDeclaration
      ![mReceiverType key]
      !mCategoryMethodName
      !mCategoryMethodFormalParameterList
    ] ; 
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @categoryMethodForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  if mImplementedAsFunction then
    @formalParameterListForGeneration categoryMethodFormalParameterList := mCategoryMethodFormalParameterList ;
    [!?categoryMethodFormalParameterList insertAtIndex
      !["" nowhere]
      ![@formalArgumentPassingModeAST argumentConstantIn]
      !mReceiverType
      ![@lstring new !"self" !here]
      !"inObject"
      !0
    ] ;
    ioInclusionSet += !"method-" . [mReceiverType key]. "-" . mCategoryMethodName ;
    generateProcedure
      !static:false
      !"categoryMethod_" . [mCategoryMethodName identifierRepresentation]
      !?ioInclusionSet
      !categoryMethodFormalParameterList
      !mSemanticInstructionListForGeneration
      !false # is not const
      !"C_Compiler"
      !true # Generate location Argument
      !false # Do not generate 'resetTemplateString'
      !false # Do not generate syntaxDirectedTranslationString argument
      ??@string code
    ;
    outImplementation := [filewrapper semanticComponentGenerationTemplate.categoryMethodAsFunctionImplementation
      ![mReceiverType key]
      !mCategoryMethodName
      !code
    ] ; 
  else
    [mReceiverType addHeaderFileName !?ioInclusionSet] ;
    for () in mCategoryMethodFormalParameterList do
      [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
    end for ;
    @unifiedTypeMapProxy baseType := mReceiverType ;
    @bool searching := true ;
    loop [@uint max] : while searching do
      if not [[baseType mSuperType] isNull] then
        if [[[baseType mSuperType] mInstanceMethodMap] hasKey !mCategoryMethodName] then
          baseType := [baseType mSuperType] ;
        else
          searching := false ;
        end if ;
      else
        searching := false ;
      end if ;  
    end loop ;
    ioInclusionSet += !"method-" . [baseType key]. "-" . mCategoryMethodName ;
    generateCategoryMethod
      !mReceiverType
      !""
      !?ioInclusionSet
      !mCategoryMethodName
      !mCategoryMethodFormalParameterList
      !mSemanticInstructionListForGeneration
      ??@string methodImplementation
    ;
    outImplementation := [filewrapper semanticComponentGenerationTemplate.categoryMethodImplementation
      ![mReceiverType key]
      !mCategoryMethodName
      !mCategoryMethodFormalParameterList
      !methodImplementation
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override reader @overridingCategoryMethodForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind noHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @overridingCategoryMethodForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  generateCategoryMethod
    !mReceiverType
    !mBaseTypeName
    !?ioInclusionSet
    !mCategoryMethodName
    !mCategoryMethodFormalParameterList
    !mSemanticInstructionListForGeneration
    ??@string methodImplementation
  ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.overridingCategoryMethodImplementation
    ![mReceiverType key]
    !mCategoryMethodName
    !methodImplementation
  ] ; 
end method ;

#---------------------------------------------------------------------------*

#! Setter

#---------------------------------------------------------------------------*

override reader @abstractCategoryModifierForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @abstractCategoryModifierForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper semanticComponentGenerationTemplate.abstractCategoryModifierDeclaration
    ![mReceiverType key]
    !mAbstractCategoryModifierName
    !mAbstractCategoryModifierFormalParameterList
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryModifierForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += !"setter-" . [mReceiverType key]. "-" . mAbstractCategoryModifierName ;
  [mReceiverType addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.abstractCategoryModifierImplementation
    ![mReceiverType key]
    !mAbstractCategoryModifierName
    !mAbstractCategoryModifierFormalParameterList
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override reader @categoryModifierForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @categoryModifierForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  if mImplementedAsFunction then
    outHeader := [filewrapper semanticComponentGenerationTemplate.categoryModifierAsFunctionDeclaration
      ![mReceiverType key]
      !mCategoryModifierName
      !mCategoryModifierFormalParameterList
    ] ; 
  else
    outHeader := [filewrapper semanticComponentGenerationTemplate.categoryModifierDeclaration
      ![mReceiverType key]
      !mCategoryModifierName
      !mCategoryModifierFormalParameterList
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @categoryModifierForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  if mImplementedAsFunction then
    @formalParameterListForGeneration categoryModifierFormalParameterList := mCategoryModifierFormalParameterList ;
    [!?categoryModifierFormalParameterList insertAtIndex
      !["" nowhere]
      ![@formalArgumentPassingModeAST argumentInOut]
      !mReceiverType
      ![@lstring new !"self" !here]
      !"ioObject"
      !0
    ] ;
    ioInclusionSet += !"setter-" . [mReceiverType key] . "-" . mCategoryModifierName ;
    generateProcedure
      !static:false
      !"categoryModifier_" . [mCategoryModifierName identifierRepresentation]
      !?ioInclusionSet
      !categoryModifierFormalParameterList
      !mSemanticInstructionListForGeneration
      !false # is not const
      !"C_Compiler"
      !true # Generate location Argument
      !false # Do not generate 'resetTemplateString'
      !false # Do not generate syntaxDirectedTranslationString argument
      ??@string code
    ;
    outImplementation := [filewrapper semanticComponentGenerationTemplate.categoryMethodAsFunctionImplementation
      ![mReceiverType key]
      !mCategoryModifierName
      !code
    ] ; 
  else
    @unifiedTypeMapProxy baseType := mReceiverType ;
    @bool searching := true ;
    loop [@uint max] : while searching do
      if not [[baseType mSuperType] isNull] then
        if [[[baseType mSuperType] mModifierMap] hasKey !mCategoryModifierName] then
          baseType := [baseType mSuperType] ;
        else
          searching := false ;
        end if ;
      else
        searching := false ;
      end if ;  
    end loop ;
    ioInclusionSet += !"setter-" . [baseType key]. "-" . mCategoryModifierName ;
    [baseType addHeaderFileName !?ioInclusionSet] ;
    generateCategoryModifier
      ![mReceiverType key]
      !""
      !mCategoryModifierName
      !?ioInclusionSet
      !mCategoryModifierFormalParameterList
      !mSemanticInstructionListForGeneration
      ??@string modifierImplementation
    ;
    outImplementation := [filewrapper semanticComponentGenerationTemplate.categoryModifierImplementation
      ![mReceiverType key]
      !mCategoryModifierName
      !mCategoryModifierFormalParameterList
      !modifierImplementation
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override reader @overridingCategoryModifierForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind noHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @overridingCategoryModifierForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  generateCategoryModifier
    ![mReceiverType key]
    !mBaseTypeName
    !mCategoryModifierName
    !?ioInclusionSet
    !mCategoryModifierFormalParameterList
    !mSemanticInstructionListForGeneration
    ??@string methodImplementation
  ;
  @unifiedTypeMapProxy baseType := mReceiverType ;
  @bool searching := true ;
  loop [@uint max] : while searching do
    if not [[baseType mSuperType] isNull] then
      if [[[baseType mSuperType] mModifierMap] hasKey !mCategoryModifierName] then
        baseType := [baseType mSuperType] ;
      else
        searching := false ;
      end if ;
    else
      searching := false ;
    end if ;  
  end loop ;
  ioInclusionSet += !"setter-" . [baseType key]. "-" . mCategoryModifierName ;
  [mReceiverType addHeaderFileName !?ioInclusionSet] ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.overridingCategoryModifierImplementation
    ![mReceiverType key]
    !mCategoryModifierName
    !methodImplementation
  ] ; 
end method ;

#---------------------------------------------------------------------------*

#! Getter

#---------------------------------------------------------------------------*

override reader @abstractCategoryReaderForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @abstractCategoryReaderForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := [filewrapper semanticComponentGenerationTemplate.abstractCategoryReaderDeclaration
    ![mReceiverType key]
    !mAbstractCategoryReaderName
    !mAbstractCategoryReaderFormalParameterList
    !mResultType
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override method @abstractCategoryReaderForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += !"getter-" . [mReceiverType key]. "-" . mAbstractCategoryReaderName ;
  [mResultType addHeaderFileName !?ioInclusionSet] ;
  [mReceiverType addHeaderFileName !?ioInclusionSet] ;
  for () in mAbstractCategoryReaderFormalParameterList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
  end for ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.abstractCategoryReaderImplementation
    ![mReceiverType key]
    !mAbstractCategoryReaderName
    !mAbstractCategoryReaderFormalParameterList
    !mResultType
  ] ; 
end method ;

#---------------------------------------------------------------------------*

override reader @categoryReaderForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @categoryReaderForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  if mImplementedAsFunction then
    outHeader := [filewrapper semanticComponentGenerationTemplate.categoryReaderAsFunctionDeclaration
      ![mReceiverType key]
      !mCategoryReaderName
      !mCategoryReaderFormalParameterList
      ![mResultType identifierRepresentation]
    ] ; 
  else
    outHeader := [filewrapper semanticComponentGenerationTemplate.categoryReaderDeclaration
      ![mReceiverType key]
      !mCategoryReaderName
      !mCategoryReaderFormalParameterList
      !mResultType
    ] ;
  end if ; 
end method ;

#---------------------------------------------------------------------------*

override method @categoryReaderForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  if mImplementedAsFunction then
    @formalInputParameterListForGeneration categoryReaderFormalParameterList := mCategoryReaderFormalParameterList ;
    [!?categoryReaderFormalParameterList insertAtIndex
      !["" nowhere]
      !mReceiverType
      !"inObject"
      ![@lstring new !"self" !here]
      !true  
      !0    
    ] ;
    ioInclusionSet += !"getter-" . [mReceiverType key]. "-" . mCategoryReaderName ;
    generateFunction
      !"categoryReader_" . [mCategoryReaderName identifierRepresentation]
      !?ioInclusionSet
      !categoryReaderFormalParameterList
      !mSemanticInstructionListForGeneration
      !"C_Compiler"
      !mResultType
      !mResultVarCppName
      !false # is not static
      ??@string code
    ;
    outImplementation := [filewrapper semanticComponentGenerationTemplate.categoryReaderAsFunctionImplementation
      ![mReceiverType key]
      !mCategoryReaderName
      !code
    ] ; 
  else
    [mResultType addHeaderFileName !?ioInclusionSet] ; 
    [mReceiverType addHeaderFileName !?ioInclusionSet] ;
    for () in mCategoryReaderFormalParameterList do
      [mFormalArgumentType addHeaderFileName !?ioInclusionSet] ;
    end for ;
    @unifiedTypeMapProxy baseType := mReceiverType ;
    @bool searching := true ;
    loop [@uint max] : while searching do
      if not [[baseType mSuperType] isNull] then
        if [[[baseType mSuperType] mReaderMap] hasKey !mCategoryReaderName] then
          baseType := [baseType mSuperType] ;
        else
          searching := false ;
        end if ;
      else
        searching := false ;
      end if ;  
    end loop ;
    ioInclusionSet += !"getter-" . [baseType key]. "-" . mCategoryReaderName ;
    generateCategoryReader
      !mReceiverType
      !""
      !?ioInclusionSet
      !mCategoryReaderName
      !mCategoryReaderFormalParameterList
      !mSemanticInstructionListForGeneration
      !"C_Compiler"
      ![mResultType key]
      !mResultVarCppName
      ??@string categoryReaderCode
    ;
    outImplementation := [filewrapper semanticComponentGenerationTemplate.categoryReaderImplementation
      ![mReceiverType key]
      !mCategoryReaderName
      !mCategoryReaderFormalParameterList
      !mResultType
      !categoryReaderCode
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override reader @overrideCategoryReaderForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind noHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @overrideCategoryReaderForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  generateCategoryReader
    !mReceiverType
    !mBaseTypeName
    !?ioInclusionSet
    !mOverridingCategoryReaderName
    !mOverridingCategoryReaderFormalParameterList
    !mSemanticInstructionListForGeneration
    !"C_Compiler"
    ![mResultType key]
    !mResultVarCppName
    ??@string categoryReaderCode
  ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.overridingCategoryReaderImplementation
    ![mReceiverType key]
    !mOverridingCategoryReaderName
    !mResultType
    !categoryReaderCode
  ] ; 
end method ;

#---------------------------------------------------------------------------*

#! Option component

#---------------------------------------------------------------------------*

override reader @optionComponentForGeneration isPredefined -> @bool outResult :
  outResult := mIsPredefined ;
end reader ;

#---------------------------------------------------------------------------*

override reader @optionComponentForGeneration headerKind ->@headerKind outResult :
  outResult := if mIsPredefined then [@headerKind noHeader] else [@headerKind oneHeader] end ;
end reader ;

#---------------------------------------------------------------------------*

override method @optionComponentForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  if mIsPredefined then
    outHeader := "" ;
  else
    outHeader := [filewrapper optionGenerationTemplates.optionHeaderZone3
      !mOptionComponentName
      !mBoolOptionMap
      !mUIntOptionMap
      !mStringOptionMap
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @optionComponentForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  if mIsPredefined then
    outImplementation := "" ;
  else
    ioInclusionSet += !"option-" + mOptionComponentName ;
    outImplementation := [filewrapper optionGenerationTemplates.optionImplementationGalgas3
      !mOptionComponentName
      !mBoolOptionMap
      !mUIntOptionMap
      !mStringOptionMap
    ] ;
  end if ;
end method ;

#---------------------------------------------------------------------------*

override method @optionComponentForGeneration appendSpecificFiles
  ??@string inProductDirectory
  ?!@stringset ioAllProductFileSet
:
#--- Generate Cocoa header
  if [@uint errorCount] == 0 && not mIsPredefined then
    ioAllProductFileSet += !"option-" . mOptionComponentName . "-cocoa.h" ;
    [@string generateFileWithPattern
      !inProductDirectory
      !"option-" . mOptionComponentName . "-cocoa.h"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper optionGenerationTemplates.optionHeaderCocoaZone2
        !mOptionComponentName
      ]
      !"\n\n" # Defaut user zone2
      ![filewrapper optionGenerationTemplates.optionHeaderCocoaZone3
        !mOptionComponentName
      ]
    ] ;
  #--- Generate Cocoa Implementation
    ioAllProductFileSet += !"option-" . mOptionComponentName . "-cocoa.m" ;
    [@string generateFileWithPattern
      !inProductDirectory
      !"option-" . mOptionComponentName . "-cocoa.m"
      !"//"
      !"\n\n" # Defaut user zone1
      ![filewrapper optionGenerationTemplates.optionImplementationCocoa
        !"option-" . mOptionComponentName . "-cocoa"
        !mOptionComponentName
        !mBoolOptionMap
        !mUIntOptionMap
        !mStringOptionMap
      ]
      !"\n\n" # Defaut user zone2
      !"\n\n" # User Zone 3
    ] ;
 end if ;
end method ;

#---------------------------------------------------------------------------*
#! Lexique
#---------------------------------------------------------------------------*

override reader @lexiqueDeclarationForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @lexiqueDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  outHeader := mHeaderContents ;
end method ;

#---------------------------------------------------------------------------*

override method @lexiqueDeclarationForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outHeader
:
  ioInclusionSet += !"lexique-" + mLexiqueName ;
  outHeader := mCppContents ;
end method ;

#---------------------------------------------------------------------------*

override method @lexiqueDeclarationForGeneration appendSpecificFiles
  ??@string inProductDirectory
  ?!@stringset ioAllProductFileSet
:
#--- Generate cocoa header file
  ioAllProductFileSet += !"lexique-" + mLexiqueName . "-cocoa.h" ;
  [@string generateFileWithPattern
    !inProductDirectory
    !"lexique-" + mLexiqueName . "-cocoa.h"
    !"//"
    !"\n\n" # Defaut user zone1
    !mCocoaHeader
    !"\n\n" # Defaut user zone2
    !"\n"
  ] ;
#--- Generate Cocoa implementation file
#      ioAppProductFileList += !"lexique-" + mLexiqueName + "-cocoa.m" ;
  ioAllProductFileSet += !"lexique-" + mLexiqueName . "-cocoa.m" ;
  [@string generateFileWithPattern
    !inProductDirectory
    !"lexique-" + mLexiqueName . "-cocoa.m"
    !"//"
    !"\n\n" # Defaut user zone1
    !mCocoaImplementation
    !"\n\n" # Defaut user zone2
    !"\n\n" # Zone 3
  ] ;
end method ;

#---------------------------------------------------------------------------*
#! Program
#---------------------------------------------------------------------------*

override reader @programComponentForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind noHeader] ;
end reader ;

#---------------------------------------------------------------------------*

override method @programComponentForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += mInclusionSet ;
  outImplementation := mImplementationString ;
end method ;

#---------------------------------------------------------------------------*

#! Filewrapper

#---------------------------------------------------------------------------*

override reader @filewrapperDeclarationForGeneration headerKind ->@headerKind outResult :
  outResult := [@headerKind oneHeader] ;
end reader ;

#---------------------------------------------------------------------------*

routine recursivlyEnumerateRegularFile
  ??@wrapperFileMap inFilewrapperFileMap
  ??@wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@stringlist ioRegularFileIndexStringList
  ?!@stringlist ioDirectoryIndexStringList
  ?!@stringlist ioRegularTextContentIndexStringList
  ?!@stringlist ioRegularBinaryContentIndexStringList
:
  ioDirectoryIndexStringList += ![[ioDirectoryIndexStringList length] string] ;
  foreach inFilewrapperFileMap do
    ioRegularFileIndexStringList += ![[ioRegularFileIndexStringList length] string] ;
    if mIsTextFile then
      ioRegularTextContentIndexStringList += ![mWrapperFileIndex string] ;
    else
      ioRegularBinaryContentIndexStringList += ![mWrapperFileIndex string] ;
    end if ;
  end foreach ;
  for () in inFilewrapperDirectoryMap do
    recursivlyEnumerateRegularFile
      !mRegularFileMap
      !mDirectoryMap
      !?ioRegularFileIndexStringList
      !?ioDirectoryIndexStringList
      !?ioRegularTextContentIndexStringList
      !?ioRegularBinaryContentIndexStringList
    ;
  end for ;
end routine ;

#---------------------------------------------------------------------------*

override method @filewrapperDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader
:
  @stringlist regularFileIndexStringList [emptyList] ;
  @stringlist regularBinaryContentIndexStringList [emptyList] ;
  @stringlist regularTextContentIndexStringList [emptyList] ;
  @stringlist directoryIndexStringList [emptyList] ;
  recursivlyEnumerateRegularFile
    !mFilewrapperFileMap
    !mFilewrapperDirectoryMap
    !?regularFileIndexStringList
    !?directoryIndexStringList
    !?regularTextContentIndexStringList
    !?regularBinaryContentIndexStringList
  ;
  outHeader := [filewrapper semanticComponentGenerationTemplate.filewrapperDeclaration
    !regularFileIndexStringList
    !directoryIndexStringList
    !regularTextContentIndexStringList
    !regularBinaryContentIndexStringList
    !mFilewrapperName
  ] ; 
#--- template generation
  foreach mFilewrapperTemplateListForGeneration do
    outHeader .= [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateDeclaration
      !mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
    ] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*

routine generateWrapperContents
  ??@string inFilewrapperName
  ??@string inFilewrapperDirectory
  ??@uint inFilewrapperDirectoryIndex
  ??@wrapperFileMap inFilewrapperRegularFileMap
  ??@wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@string ioImplementation
:
#--- Generate regular files
  foreach inFilewrapperRegularFileMap do
    if mIsTextFile then
      const @string contents := [@string stringWithContentsOfFile !mAbsoluteFilePath] ;
      ioImplementation .= "//--- File '" . inFilewrapperDirectory . "/" . lkey . "'\n\n"
      .  "const char * gWrapperFileContent_"
      . [mWrapperFileIndex string] . "_"
      . [inFilewrapperName identifierRepresentation] . " = "
      . [contents utf8Representation] . " ;\n\n"
      . "const cRegularFileWrapper gWrapperFile_" . [mWrapperFileIndex string]. "_"
      . [inFilewrapperName identifierRepresentation] . " (\n"
      . "  " . [lkey utf8Representation] . ",\n"
      . "  " . [[lkey pathExtension] utf8Representation] . ",\n"
      . "  true, // Text file\n"
      . "  " . [contents length] . ", // Text length\n"
      . "  gWrapperFileContent_" . [mWrapperFileIndex string] . "_" . [inFilewrapperName identifierRepresentation] ."\n"
      . ") ;\n\n" ;
    else
      const @data contents := [@data dataWithContentsOfFile !mAbsoluteFilePath] ;
      ioImplementation .= "//--- File '" . inFilewrapperDirectory . "/" . lkey . "'\n\n"
      .  "const uint8_t gWrapperFileContent_"
      . [mWrapperFileIndex string] . "_"
      . [inFilewrapperName identifierRepresentation] . " [" . [contents length] . "] = {"
      . [contents cStringRepresentation] . "} ;\n\n"
      . "const cRegularFileWrapper gWrapperFile_" . [mWrapperFileIndex string]. "_"
      . [inFilewrapperName identifierRepresentation] . " (\n"
      . "  " . [lkey utf8Representation] . ",\n"
      . "  " . [[lkey pathExtension] utf8Representation] . ",\n"
      . "  false, // binary file\n"
      . "  " . [contents length] . ", // Length\n"
      . "  (const char *) gWrapperFileContent_" . [mWrapperFileIndex string] . "_" . [inFilewrapperName identifierRepresentation] ."\n"
      . ") ;\n\n" ;
    end if ;
  end foreach ;
#--- Generate sub-directories
  foreach inFilewrapperDirectoryMap do
    generateWrapperContents
      !inFilewrapperName
      ![lkey string]
      !mWrapperDirectoryIndex
      !mRegularFileMap
      !mDirectoryMap
      !?ioImplementation
    ;
  end foreach ;
#--- Generate all Filewrapper list
  ioImplementation .= "//--- All files of '" . inFilewrapperDirectory . "' directory\n\n"
  . "static const cRegularFileWrapper * gWrapperAllFiles_"
  . [inFilewrapperName identifierRepresentation] . "_" . [inFilewrapperDirectoryIndex string]
  . " [" . [[inFilewrapperRegularFileMap count] + 1 string] . "] = {\n" ;
  foreach inFilewrapperRegularFileMap do
    ioImplementation .= "  & gWrapperFile_" . [mWrapperFileIndex string] . "_" . [inFilewrapperName identifierRepresentation] . ",\n" ;
  end foreach ;  
  ioImplementation .= "  NULL\n"
  ."} ;\n\n" ;
#--- Generate all directory wrapper list
  ioImplementation .= "//--- All sub-directories of '" . inFilewrapperDirectory . "' directory\n\n"
  . "static const cDirectoryWrapper * gWrapperAllDirectories_"
  . [inFilewrapperName identifierRepresentation] . "_" . [inFilewrapperDirectoryIndex string]
  . " [" . [[inFilewrapperDirectoryMap count] + 1 string] . "] = {\n" ;
  foreach inFilewrapperDirectoryMap do
    ioImplementation .= "  & gWrapperDirectory_" . [mWrapperDirectoryIndex string] . "_" . [inFilewrapperName identifierRepresentation] . ",\n" ;
  end foreach ;
  ioImplementation .= "  NULL\n"
  . "} ;\n\n" ;
#--- Generate directory wrapper
  ioImplementation .= "//--- Directory '" . inFilewrapperDirectory . "'\n\n"
  . "const cDirectoryWrapper gWrapperDirectory_" . [inFilewrapperDirectoryIndex string] . "_"
  . [inFilewrapperName identifierRepresentation] . " (\n"
  . "  " . [inFilewrapperDirectory utf8Representation] . ",\n"
  . "  " . [[inFilewrapperRegularFileMap count] string] . ",\n"
  . "  gWrapperAllFiles_" . [inFilewrapperName identifierRepresentation] . "_" . [inFilewrapperDirectoryIndex string] . ",\n"
  . "  " . [[inFilewrapperDirectoryMap count] string] . ",\n"
  . "  gWrapperAllDirectories_" . [inFilewrapperName identifierRepresentation] . "_" . [inFilewrapperDirectoryIndex string] . "\n"
  . ") ;\n\n" ;
end routine ;
  
#---------------------------------------------------------------------------*

override method @filewrapperDeclarationForGeneration appendSpecificImplementation
  ?!@stringset ioInclusionSet
  !@string outImplementation
:
  ioInclusionSet += !"filewrapper-" + mFilewrapperName ;
  @string filewrapperImplementation := "" ;
  generateWrapperContents
    !mFilewrapperName
    !""
    !0
    !mFilewrapperFileMap
    !mFilewrapperDirectoryMap
    !?filewrapperImplementation
  ;
  outImplementation := [filewrapper semanticComponentGenerationTemplate.filewrapperImplementation
    !mFilewrapperName
    !filewrapperImplementation
  ] ;
#--- template generation
  foreach mFilewrapperTemplateListForGeneration do
  #--- Build generated code for instruction list
    @string generatedCodeForInstructionList := "" ;
    @uint temporaryVariableIndex := 0 ;
    @stringset unusedVariableCppNameSet [emptySet] ;
    unusedVariableCppNameSet += !compilerCppName [] ;
    foreach mFilewrapperTemplateFormalInputParameters do
      unusedVariableCppNameSet += !mFormalArgumentCppName ;
    end foreach ;
    @bool useColumnMarker := false ;
    templateCodeGenerationForListInstruction
      !mTemplateInstructionListForGeneration
      !?generatedCodeForInstructionList
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !?useColumnMarker
    ;
  #---
    outImplementation .= [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateImplementation
      !mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
      !unusedVariableCppNameSet
      !useColumnMarker
      !generatedCodeForInstructionList
    ] ;
  end foreach ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper predefinedTypeGenerationTemplate in "../generation_templates/type_generation" {
}{
}{
  template predefinedTypesImplementation "predefined_types.cpp.gTemplate" ;


  template primitiveTypesHeaderPrologue "predefined-types-file-header.h.gTemplate"
    ?@stringset TYPE_LIST
  ;

  template predefinedTypeSeparation "predefined-types-separation.h.gTemplate"  ;

  template sint_type "sint-type.h.gTemplate" ;
  
  template sint64_type "sint64-type.h.gTemplate" ;
  
  template object_type "object-type.h.gTemplate" ;
  
  template uint_type "uint-type.h.gTemplate" ;
  
  template uint64_type "uint64-type.h.gTemplate" ;
  
  template bool_type "bool-type.h.gTemplate" ;
  
  template binaryset_type "binaryset-type.h.gTemplate" ;
  
  template function_type "function-type.h.gTemplate" ;
  
  template type_type "type-type.h.gTemplate" ;
  
  template location_type "location-type.h.gTemplate" ;
  
  template data_type "data-type.h.gTemplate" ;
  
  template char_type "char-type.h.gTemplate" ;
  
  template double_type "double-type.h.gTemplate" ;
  
  template string_type "string-type.h.gTemplate" ;
  
  template stringset_type "stringset-type.h.gTemplate" ;

  template filewrapper_type "filewrapper-type.h.gTemplate" ;

  template application_type "application-type.h.gTemplate" ;
}

#---------------------------------------------------------------------------*

override reader @primitiveTypeForGeneration appendPrimitiveTypeDeclaration -> @string outHeader :
  switch mKind
  when predefined_object :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.object_type] ;
  when predefined_uint :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.uint_type] ;
  when predefined_uint64 :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.uint64_type] ;
  when predefined_sint :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.sint_type] ;
  when predefined_sint64 :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.sint64_type] ;
  when predefined_char :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.char_type] ;
  when predefined_double :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.double_type] ;
  when predefined_string :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.string_type] ;
  when predefined_stringset :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.stringset_type] ;
  when predefined_bool :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.bool_type] ;
  when predefined_binaryset :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.binaryset_type] ;
  when predefined_function :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.function_type] ;
  when predefined_location :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.location_type] ;
  when predefined_type :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.type_type] ;
  when predefined_data :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.data_type] ;
  when predefined_filewrapper :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.filewrapper_type] ;
  when predefined_application :
    outHeader := [filewrapper predefinedTypeGenerationTemplate.application_type] ;
  end switch ;
  outHeader .= [filewrapper typeGenerationTemplate.unifiedClassBodyForType
    ![mTypeProxy key]
    ![mTypeProxy identifierRepresentation]
    ![mTypeProxy mIsConcrete]
    ![mTypeProxy mConstructorMap]
    ![mTypeProxy mReaderMap]
    ![mTypeProxy mModifierMap]
    ![mTypeProxy mInstanceMethodMap]
    ![mTypeProxy mClassMethodMap]
    ![mTypeProxy mEnumerationDescriptor]
    ![mTypeProxy mHandledOperatorFlags]
    ![mTypeProxy mAddAssignOperatorArguments]
    ![mTypeProxy mTypeForEnumeratedElement]
  ] ;
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
# G E N E R A T E    P R E D E F I N E D    T Y P E    F I L E S            *
#                                                                           *
#---------------------------------------------------------------------------*

routine generatePredefinedTypeFiles ??@string inDirectory :
  if inDirectory != "" then
    if not [inDirectory directoryExists] then
      error here : "the '" . inDirectory . "' directory does not exist" ;
    else
    #------ Add predefined types to semantics declarations
      @semanticDeclarationListAST predefinedTypeASTlist [emptyList] ;
      appendPredefinedTypesASTs !?predefinedTypeASTlist ;
    #------ Build Semantic Context
      buildSemanticContext
        !predefinedTypeASTlist
        ??@semanticContext semanticContext
      ;
    #------ Semantic Analysis
      @semanticDeclarationSortedListForGeneration decoratedDeclarationListForGeneration ;
      performSemanticAnalysis
        !inDirectory
        !predefinedTypeASTlist
        !semanticContext
        ?decoratedDeclarationListForGeneration
      ;
    #------ Generate primitive types declaration file
      @string generatedCode := [filewrapper predefinedTypeGenerationTemplate.primitiveTypesHeaderPrologue
        ![semanticContext->mTypeMap allKeys]
      ] ;
      foreach decoratedDeclarationListForGeneration do
        generatedCode .= [mDeclaration appendPrimitiveTypeDeclaration] ;
      end foreach ;
      foreach decoratedDeclarationListForGeneration do
        var unusedInclusionSet := [@stringset emptySet] ;
        [mDeclaration appendDeclaration1 !?unusedInclusionSet ??@string code] ;
        generatedCode .= code ;
      end foreach ;
      generatedCode .= [filewrapper predefinedTypeGenerationTemplate.predefinedTypeSeparation] ;
      foreach decoratedDeclarationListForGeneration do
        var inclusionSet2 := [@stringset emptySet] ;
        [mDeclaration appendDeclaration2 !false !inDirectory !?inclusionSet2 ??@string headerString2] ;
        generatedCode .= headerString2 ;
      end foreach ;
      if [@uint errorCount] == 0 then
        [@string generateFileWithPattern
          !inDirectory
          !"predefined-types.h"
          !"//"
          !"\n\n" # Defaut user zone1
          !generatedCode
          !"\n\n" # Defaut user zone2
          !"#endif\n"
        ] ;
      end if ;
    #------ Generate predefined types implementation
      generatedCode := [filewrapper predefinedTypeGenerationTemplate.predefinedTypesImplementation] ;
      foreach decoratedDeclarationListForGeneration do
        generatedCode .= [mDeclaration appendTypeGenericImplementation] ;
        var unusedInclusionSet := [@stringset emptySet] ;
        [mDeclaration appendSpecificImplementation !?unusedInclusionSet ??@string code] ;
        generatedCode += code ;
      end foreach ;
      if [@uint errorCount] == 0 then
        [@string generateFileWithPattern
          !inDirectory
          !"predefined-types.cpp"
          !"//"
          !"\n\n" # Defaut user zone1
          !generatedCode
          !"\n\n" # Defaut user zone2
          !""
        ] ;
      end if ;
    end if ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
