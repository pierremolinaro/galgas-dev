#---------------------------------------------------------------------------*
#                                                                           *
#  Generate predefined types                                                *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticGeneration :
  import "semanticInstructionGeneration.gSemantics" ;

  import semantics semanticInstructionGeneration in "semanticInstructionGeneration.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper typeGenerationTemplate in "../generation_templates/semantic_generation" {
} {
  template genericTypeHeader "generic-type.h.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
  ;

  template genericTypeImplementation "generic-type.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMapProxy SUPER_TYPE_INDEX
  ;

  template unifiedTypeHeader "unified-type.h.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@bool IS_CONCRETE # false if abstract class
    ?@unifiedTypeMapProxy SUPER_TYPE_INDEX
    ?@typeKindEnum TYPE_KIND
    ?@typedAttributeList CURRENT_TYPE_ATTRIBUTE_LIST
    ?@typedAttributeList INHERITED_ATTRIBUTE_LIST
    ?@constructorMap CONSTRUCTOR_MAP
    ?@readerMap READER_MAP
    ?@modifierMap MODIFIER_MAP
    ?@instanceMethodMap INSTANCE_METHOD_MAP
    ?@classMethodMap CLASS_METHOD_MAP
    ?@enumerationDescriptorList ENUMERATION_DESCRIPTOR_LIST # Empty List if cannot be enumerated
    ?@uint SUPPORTED_OPERATORS
    ?@unifiedTypeMapProxyList ADD_ASSIGN_ARGUMENT_LIST # Empty list if operator is not supported
    ?@nativeAttributeList NATIVE_ATTRIBUTE_LIST
    ?@lstringlist ENUM_CONSTANT_LIST
    ?@typedAttributeList PRIVATE_DATA_NUMBER_TYPED_LIST
  ;

  template unifiedTypeImplementation "unified-type.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@bool IS_CONCRETE # false if abstract class
    ?@unifiedTypeMapProxy SUPER_TYPE_INDEX
    ?@typeKindEnum TYPE_KIND
    ?@typedAttributeList CURRENT_TYPE_ATTRIBUTE_LIST
    ?@constructorMap CONSTRUCTOR_MAP
    ?@readerMap READER_MAP
    ?@modifierMap MODIFIER_MAP
    ?@instanceMethodMap INSTANCE_METHOD_MAP
    ?@classMethodMap CLASS_METHOD_MAP
    ?@enumerationDescriptorList ENUMERATION_DESCRIPTOR_LIST # Empty List if cannot be enumerated
    ?@uint SUPPORTED_OPERATORS
    ?@unifiedTypeMapProxyList ADD_ASSIGN_ARGUMENT_LIST # Empty list if operator is not supported
    ?@nativeAttributeList NATIVE_ATTRIBUTE_LIST
  ;

  template predefinedTypeSpecificImplementation "predefined-type-specific.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@modifierMap MODIFIER_MAP
    ?@uint SUPPORTED_OPERATORS
    ?@unifiedTypeMapProxyList ADD_ASSIGN_ARGUMENT_LIST # Empty list if operator is not supported
    ?@nativeAttributeList NATIVE_ATTRIBUTE_LIST
  ;

  template enumTypeSpecificImplementation "GALGAS_enum.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@stringlist CONSTANT_LIST
    ?@enumMessageListForGeneration ENUM_MESSAGE_LIST
  ;

  template listTypeSpecificImplementation "GALGAS_list.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template listmapTypeSpecificImplementation "GALGAS_listmap.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@string ASSOCIATED_LISTTYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template mapTypeSpecificImplementation "GALGAS_map.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@insertMethodListAST INSERT_METHOD_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
    ?@mapRemoveMethodListAST REMOVE_METHOD_LIST
    ?@bool HAS_INSERT_OR_REPLACE 
  ;

  template sortedlistTypeSpecificImplementation "GALGAS_sortedlist.cpp.gTemplate"
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@sortDescriptorListForGeneration SORT_ATTRIBUTE_LIST
  ;

  template structTypeSpecificImplementation "GALGAS_struct.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
  ;

  template mapProxyTypeSpecificImplementation "GALGAS_mapproxy.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string ASSOCIATED_MAP_TYPE_IDENTIFIER
    ?@typedAttributeList ATTRIBUTE_LIST
    ?@mapSearchMethodListAST SEARCH_METHOD_LIST
  ;

  template classTypeSpecificImplementation "GALGAS_class.cpp.gTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string SUPER_TYPE_IDENTIFIER
    ?@typedAttributeList CURRENT_ATTRIBUTE_LIST
    ?@typedAttributeList ALL_ATTRIBUTE_LIST
    ?@typedAttributeList INHERITED_ATTRIBUTE_LIST
    ?@bool IS_ABSTRACT
    ?@methodDefinitionListForGeneration CONCRETE_METHOD_LIST
  ;

  template routineDeclaration "routine-declaration.h.gTemplate"
    ?@string ROUTINE_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
  ;

  template routineImplementation "routine-implementation.cpp.gTemplate"
    ?@string ROUTINE_NAME
    ?@string ROUTINE_IMPLEMENTATION
  ;

}

#---------------------------------------------------------------------------*
#                                                                           *
# R O U T I N E    I M P L E M E N A T I O N                                *
#                                                                           *
#---------------------------------------------------------------------------*

function generateRoutine
  ??@string inRoutineName
  ??@formalParameterListForGeneration inFormalArgumentList
  ??@semanticInstructionListForGeneration inInstructionList
  ->@string outGeneratedCode
:
#--- Build unused variable set
  @stringset unusedVariableCppNameSet [emptySet] ;
  foreach inFormalArgumentList index IDX do
    switch mFormalArgumentPassingMode 
    when argumentConstantIn :
      unusedVariableCppNameSet += !"inArgument_" . [mFormalArgumentName identifierRepresentation] ;
    when argumentInOut :
      unusedVariableCppNameSet += !"ioArgument_" . [mFormalArgumentName identifierRepresentation] ;
    when argumentOut :
      unusedVariableCppNameSet += !"outArgument_" . [mFormalArgumentName identifierRepresentation] ;
    when argumentIn :
      unusedVariableCppNameSet += !"inArgument_" . [mFormalArgumentName identifierRepresentation] ;
    end switch ;
  end foreach ;
#--- Generate body
  @uint temporaryVariableIndex := 0 ;
  @string routineBody := "" ;
  [!?routineBody incIndentation !2] ;
  foreach inInstructionList do
    [mInstruction generateInstruction !?temporaryVariableIndex !?unusedVariableCppNameSet !?routineBody] ;
  end foreach ;
  [!?routineBody decIndentation !2] ;
#--- Generate header
  outGeneratedCode := "void routine_" . [inRoutineName identifierRepresentation] . " (" ;
  const @uint colRef := [outGeneratedCode currentColumn] ;
#--- Compiler argument
#  if USES_COMPILER_ARGUMENT then
  outGeneratedCode .= "C_Compiler * inCompiler" ;
#  else
#    %C_Compiler * /* inCompiler */%
#  end if
  foreach inFormalArgumentList index IDX do
    outGeneratedCode .= ",\n" ;
    [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
    switch mFormalArgumentPassingMode 
    when argumentConstantIn :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " * const inArgument_" . [mFormalArgumentName identifierRepresentation] ;
    when argumentInOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " * & ioArgument_" . [mFormalArgumentName identifierRepresentation] ;
    when argumentOut :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " * & outArgument_" . [mFormalArgumentName identifierRepresentation] ;
    when argumentIn :
      outGeneratedCode .= "GALGAS_" . [mFormalArgumentType identifierRepresentation] . " * inArgument_" . [mFormalArgumentName identifierRepresentation] ;
    end switch ;
  end foreach ;
  outGeneratedCode .= "\n" ;
  [!?outGeneratedCode appendSpacesUntilColumn !colRef] ;
  outGeneratedCode .= "COMMA_UNUSED_LOCATION_ARGS) {\n" ;
#--- Generate routine body
  outGeneratedCode .= routineBody ;
#--- Release 'in' arguments
  foreach inFormalArgumentList index IDX do
    if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentIn] then
      outGeneratedCode .= "  macroReleaseObject (inArgument_" . [mFormalArgumentName string] . ") ; // Release 'in' argument\n" ;
    end if ;
  end foreach ;
  outGeneratedCode .= "}\n\n" ;
end function ;

#---------------------------------------------------------------------------*
#                                                                           *
# A P P E N D    D E C L A R A T I O N                                      *
#                                                                           *
#---------------------------------------------------------------------------*

reader @semanticDeclarationForGeneration appendDeclaration -> @string outHeader :
  outHeader := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @routinePrototypeDeclarationForGeneration appendDeclaration -> @string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.routineDeclaration
    !mRoutineName
    !mFormalArgumentList
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

override reader @semanticTypeForGeneration appendDeclaration -> @string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.unifiedTypeHeader
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mSuperType]
    ![mTypeIndex mTypeKindEnum]
    ![mTypeIndex mCurrentTypedAttributeList]
    ![mTypeIndex mInheritedTypedAttributeList]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mNativeAttributeList]
    ![mTypeIndex mEnumConstantList]
    ![mTypeIndex mPrivateDataMemberList]
  ] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @genericTypeForGeneration appendDeclaration -> @string outHeader :
  outHeader := [filewrapper typeGenerationTemplate.genericTypeHeader
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
  ] ;
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
# A P P E N D    G E N E R I C    T Y P E    I M P L E M E N T A T I O N    *
#                                                                           *
#  This code is common for all types                                        *
#---------------------------------------------------------------------------*

reader @semanticDeclarationForGeneration appendTypeGenericImplementation ->@string outImplementation :
  outImplementation := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @semanticTypeForGeneration appendTypeGenericImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.unifiedTypeImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mIsConcrete]
    ![mTypeIndex mSuperType]
    ![mTypeIndex mTypeKindEnum]
    ![mTypeIndex mCurrentTypedAttributeList]
    ![mTypeIndex mConstructorMap]
    ![mTypeIndex mReaderMap]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mInstanceMethodMap]
    ![mTypeIndex mClassMethodMap]
    ![mTypeIndex mEnumerationDescriptor]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mNativeAttributeList]
  ] ;
end reader ;


#---------------------------------------------------------------------------*

override reader @genericTypeForGeneration appendTypeGenericImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.genericTypeImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mSuperType]
  ] ;
end reader ;

#---------------------------------------------------------------------------*
#                                                                           *
# A P P E N D    S P E C I F I C    I M P L E M E N T A T I O N             *
#                                                                           *
#---------------------------------------------------------------------------*

reader @semanticDeclarationForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := "" ;
end reader ;

#---------------------------------------------------------------------------*

override reader @primitiveTypeForGeneration appendSpecificImplementation -> @string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.predefinedTypeSpecificImplementation
    ![mTypeIndex identifierRepresentation]
    ![mTypeIndex mModifierMap]
    ![mTypeIndex mHandledOperatorFlags]
    ![mTypeIndex mAddAssignOperatorArguments]
    ![mTypeIndex mNativeAttributeList]
  ] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @listTypeForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.listTypeSpecificImplementation
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @listmapTypeForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.listmapTypeSpecificImplementation
    ![mTypeIndex identifierRepresentation]
    ![mAssociatedListTypeIndex identifierRepresentation]
    !mAssociatedListTypedAttributeList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @mapTypeForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.mapTypeSpecificImplementation
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
    !mInsertMethodList
    !mSearchMethodList
    !mRemoveMethodList
    !mHasInsertOrReplaceModifier
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @sortedListTypeForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.sortedlistTypeSpecificImplementation
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
    !mSortDescriptorList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @structTypeForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.structTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mTypedAttributeList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @enumTypeForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.enumTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !mConstantList
    !mEnumMessageList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @mapProxyTypeForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.mapProxyTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    ![mAssociatedMapTypeProxy identifierRepresentation]
    !mAssociatedMapTypedAttributeList
    !mSearchMethodList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @classTypeForGeneration appendSpecificImplementation ->@string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.classTypeSpecificImplementation
    ![mTypeIndex key]
    ![mTypeIndex identifierRepresentation]
    !if [mSuperClass isNull] then "class" else [mSuperClass identifierRepresentation] end
    !mTypedAttributeList
    !mAllTypedAttributeList
    ![mAllTypedAttributeList subListWithRange !0 ![mAllTypedAttributeList length] - [mTypedAttributeList length]]
    !mIsAbstract
    !mMethodList
  ] ;
 end reader ;

#---------------------------------------------------------------------------*

override reader @routineImplementationForGeneration appendSpecificImplementation -> @string outImplementation :
  outImplementation := [filewrapper typeGenerationTemplate.routineImplementation
    !mRoutineName
    !generateRoutine [!mRoutineName !mFormalArgumentList !mRoutineInstructionList]
  ] ; 
end reader ;

#---------------------------------------------------------------------------*

end semantics ;
