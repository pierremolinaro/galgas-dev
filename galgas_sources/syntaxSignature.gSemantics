#---------------------------------------------------------------------------*
#                                                                           *
#  Syntax component semantic analysis                                       *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics syntaxSignature :
import "semanticsCompilation.gSemantics" ;
import "lexiqueCompilation.gSemantics" ;
    
#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    S I G N A T U R E                                       *
#                                                                           *
#---------------------------------------------------------------------------*

method @semanticInstructionForGeneration appendSyntaxSignature # Capture all semantic instructions
  ??@string unused inPosfix
  ?!@semanticInstructionListForGeneration unused ioInstructionListForGeneration
 :
end method ;

#---------------------------------------------------------------------------*

function syntaxSignatureOfInstructionList
  ??@string inPosfix
  ??@semanticInstructionListForGeneration inInstructionList
  ->@semanticInstructionListForGeneration outResult
:
  outResult := [@semanticInstructionListForGeneration emptyList] ;
  foreach inInstructionList do
    [mInstruction appendSyntaxSignature !inPosfix !?outResult] ;
  end foreach ;
end function ;

#---------------------------------------------------------------------------*

override method @nonterminalInstructionForGeneration appendSyntaxSignature
  ??@string inPosfix
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
:
  ioInstructionListForGeneration += ![@nonterminalInstructionForGeneration new
    !mInstructionLocation
    !mNonterminalName
    !inPosfix
    ![@actualParameterListForGeneration emptyList]
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @terminalCheckInstructionForGeneration appendSyntaxSignature
  ??@string unused inPosfix
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
:
  ioInstructionListForGeneration += ![@terminalCheckInstructionForGeneration new
    !mInstructionLocation
    !mTerminalName
    !mLexiqueIdentifier
    ![@terminalCheckAssignementList emptyList]
    !mIndexingKeyList
    ![@grammarInstructionSyntaxDirectedTranslationResultNone new]
    ![@grammarInstructionSyntaxDirectedTranslationResultNone new]
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @repeatInstructionForGeneration appendSyntaxSignature
  ??@string inPosfix
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
:
  const @semanticInstructionListForGeneration repeated_instructionList := syntaxSignatureOfInstructionList [!inPosfix !m_repeated_instructionList] ;
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  foreach mListOfSemanticInstructionListForGeneration do
    listOfSemanticInstructionListForGeneration +=
      !syntaxSignatureOfInstructionList [!inPosfix !mInstructionList]
      !mEndOfInstructionList
    ;
  end foreach ;
#---
  ioInstructionListForGeneration += ![@repeatInstructionForGeneration new
    !mInstructionLocation
    !mSyntaxComponentName
    !mChoiceIndex
    !repeated_instructionList
    !mEndOfRepeatedInstructions
    !listOfSemanticInstructionListForGeneration
  ] ;
end method ;

#---------------------------------------------------------------------------*

override method @selectInstructionForGeneration appendSyntaxSignature
  ??@string inPosfix
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
:
  @listOfSemanticInstructionListForGeneration listOfSemanticInstructionListForGeneration [emptyList] ;
  foreach mListOfSemanticInstructionListForGeneration do
    listOfSemanticInstructionListForGeneration +=
      !syntaxSignatureOfInstructionList [!inPosfix !mInstructionList]
      !mEndOfInstructionList
    ;
  end foreach ;
  ioInstructionListForGeneration += ![@selectInstructionForGeneration new
    !mInstructionLocation
    !mSyntaxComponentName
    !mChoiceIndex
    !listOfSemanticInstructionListForGeneration
 ] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseRewindInstructionForGeneration appendSyntaxSignature
  ??@string inPosfix
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
:
  @semanticInstructionListForGeneration instructionList ;
  [mListOfSemanticInstructionListForGeneration first ?instructionList ?*] ;
  ioInstructionListForGeneration .= syntaxSignatureOfInstructionList [!inPosfix !instructionList] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseLoopInstructionForGeneration appendSyntaxSignature
  ??@string inPosfix
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
:
  ioInstructionListForGeneration .= syntaxSignatureOfInstructionList [!inPosfix !mInstructionList] ;
end method ;

#---------------------------------------------------------------------------*

override method @parseWhenInstructionForGeneration appendSyntaxSignature
  ??@string inPosfix
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
:
  ioInstructionListForGeneration .= syntaxSignatureOfInstructionList [!inPosfix !mInstructionList] ;
end method ;

#---------------------------------------------------------------------------*
#                                                                           *
#    S Y N T A X    S I G N A T U R E    C O M P A R I S O N                *
#                                                                           *
#---------------------------------------------------------------------------*

reader @semanticInstructionForGeneration compareSyntaxInstruction
  ??@semanticInstructionForGeneration unused inTestedInstruction
  ->@bool outOk
:
  outOk := true ;
end reader ;

#---------------------------------------------------------------------------*

function compareSyntaxSignature
  ??@semanticInstructionListForGeneration inReferenceSignature
  ??@semanticInstructionListForGeneration inTestedSignature
  ??@location inErrorLocation
  ->@bool outOk
:
  outOk := true ;
  foreach inReferenceSignature : ref_, inTestedSignature : test_ while outOk do
     outOk := [ref_mInstruction compareSyntaxInstruction !test_mInstruction] ;
  end foreach ;
  if outOk & ([inReferenceSignature length] < [inTestedSignature length]) then
    @semanticInstructionForGeneration instruction := [inTestedSignature mInstructionAtIndex ![inReferenceSignature length]] ;
    cast instruction
    when >= @syntaxInstructionForGeneration si :
      error [si mInstructionLocation]
      :"syntax signature error, exceeding instruction; this branch has more syntax instructions than reference branch"
      ;
    else
      error inErrorLocation : "internal error" ;
    end cast ;
  elsif outOk & ([inReferenceSignature length] > [inTestedSignature length]) then
    error inErrorLocation
    :"syntax signature error, missing instruction; this branch has less syntax instructions than reference branch"
    ;
    @semanticInstructionForGeneration instruction := [inReferenceSignature mInstructionAtIndex ![inTestedSignature length]] ;
    cast instruction
    when >= @syntaxInstructionForGeneration si :
      error [si mInstructionLocation]
      :"this is the syntax instruction in reference branch that corresponds to the first missing instruction"
      ;
    else
      error inErrorLocation : "internal error" ;
    end cast ;
  end if ;
end function ;

#---------------------------------------------------------------------------*

override reader @terminalCheckInstructionForGeneration compareSyntaxInstruction
  ??@semanticInstructionForGeneration inTestedInstruction
  ->@bool outOk
:
  cast inTestedInstruction
  when >= @terminalCheckInstructionForGeneration si :
    outOk := [mTerminalName string] == [[si mTerminalName] string] ;
    if not outOk then
      error [si mInstructionLocation]
      :"syntax signature error; the expected syntax instruction here is the '$" . mTerminalName . "$' terminal check"
      ;
    end if ;
  when >= @syntaxInstructionForGeneration si :
    error [si mInstructionLocation]
      :"syntax signature error; the expected syntax instruction here is the '$" . mTerminalName . "$' terminal check"
      ;
    outOk := false ;
  else
    error mInstructionLocation : "internal error" ;
    outOk := false ;
  end cast ;
  if not outOk then
    error mInstructionLocation
    :"reference syntax instruction is here"
    ;
  end if ;  
end reader ;

#---------------------------------------------------------------------------*

override reader @nonterminalInstructionForGeneration compareSyntaxInstruction
  ??@semanticInstructionForGeneration inTestedInstruction
  ->@bool outOk
:
  cast inTestedInstruction
  when >= @nonterminalInstructionForGeneration si :
    outOk := mNonterminalName == [si mNonterminalName] ;
    if not outOk then
      error [si mInstructionLocation]
      :"syntax signature error; the expected syntax instruction here is the '<" . mNonterminalName . ">' nonterminal invocation"
      ;
    end if ;
  when >= @syntaxInstructionForGeneration si :
    error [si mInstructionLocation]
      :"syntax signature error; the expected syntax instruction here is the '<" . mNonterminalName . ">' nonterminal invocation"
      ;
    outOk := false ;
  else
    error mInstructionLocation : "internal error" ;
    outOk := false ;
  end cast ;
  if not outOk then
    error mInstructionLocation
    :"reference syntax instruction is here"
    ;
  end if ;  
end reader ;

#---------------------------------------------------------------------------*

override reader @repeatInstructionForGeneration compareSyntaxInstruction
  ??@semanticInstructionForGeneration inTestedInstruction
  ->@bool outOk
:
  cast inTestedInstruction
  when >= @repeatInstructionForGeneration si :
    outOk := compareSyntaxSignature [!m_repeated_instructionList ![si m_repeated_instructionList] ![si mEndOfRepeatedInstructions]] ;
    if outOk & ([mListOfSemanticInstructionListForGeneration length] != [[si mListOfSemanticInstructionListForGeneration] length]) then
      error [si mInstructionLocation]
        :"syntax signature error; the reference 'repeat' instruction has "
        . [[mListOfSemanticInstructionListForGeneration length] string]
        . " 'while' branche(s), but this instruction has "
        . [[[si mListOfSemanticInstructionListForGeneration] length] string]
        ;
      outOk := false ;
    end if ;
    foreach mListOfSemanticInstructionListForGeneration : ref_, [si mListOfSemanticInstructionListForGeneration] : test_ while outOk do
      outOk := compareSyntaxSignature [!ref_mInstructionList !test_mInstructionList !test_mEndOfInstructionList] ;    
    end foreach ;
  when >= @syntaxInstructionForGeneration si :
    error [si mInstructionLocation]
      :"syntax signature error; the expected syntax instruction here is a 'repeat' instruction"
      ;
    outOk := false ;
  else
    error mInstructionLocation : "internal error" ;
    outOk := false ;
  end cast ;
  if not outOk then
    error mInstructionLocation
    :"reference syntax instruction is here"
    ;
  end if ;  
end reader ;

#---------------------------------------------------------------------------*

override reader @selectInstructionForGeneration compareSyntaxInstruction
  ??@semanticInstructionForGeneration inTestedInstruction
  ->@bool outOk
:
  cast inTestedInstruction
  when >= @selectInstructionForGeneration si :
    outOk := true ;
    if outOk & ([mListOfSemanticInstructionListForGeneration length] != [[si mListOfSemanticInstructionListForGeneration] length]) then
      error [si mInstructionLocation]
        :"syntax signature error; the reference 'select' instruction has "
        . [[mListOfSemanticInstructionListForGeneration length] string]
        . " 'while' branche(s), but this instruction has "
        . [[[si mListOfSemanticInstructionListForGeneration] length] string]
        ;
      outOk := false ;
    end if ;
    foreach mListOfSemanticInstructionListForGeneration : ref_, [si mListOfSemanticInstructionListForGeneration] : test_ while outOk do
      outOk := compareSyntaxSignature [!ref_mInstructionList !test_mInstructionList !test_mEndOfInstructionList] ;    
    end foreach ;
  when >= @syntaxInstructionForGeneration si :
    error [si mInstructionLocation]
      :"syntax signature error; the expected syntax instruction here is a 'select' instruction"
      ;
    outOk := false ;
  else
    error mInstructionLocation : "internal error" ;
    outOk := false ;
  end cast ;
  if not outOk then
    error mInstructionLocation
    :"reference syntax instruction is here"
    ;
  end if ;  
end reader ;

#---------------------------------------------------------------------------*

end semantics ;
