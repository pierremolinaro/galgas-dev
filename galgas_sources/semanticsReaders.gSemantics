#---------------------------------------------------------------------------*
#                                                                           *
#  semantics definitions for semantics component                            *
#                                                                           *
#  Copyright (C) 2009, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticsReaders :
import "semanticsTypes.gSemantics" ;
import semantics semanticsTypes in "semanticsTypes.gSemantics" ;

#---------------------------------------------------------------------------*

enum @readerQualifier {
  constructor isAbstract ;
  constructor isBasic ;
  constructor isInherited ;
  constructor isOverriding ;
}{
}

#---------------------------------------------------------------------------*

map @readerMap {
  @typeList mArgumentTypeList ;
  @bool mHasLexiqueArgument ;
  @ACGalgasType mReturnedType ;
  @readerQualifier mQualifier ;
  insert insertKey error message "the '%K' reader has been already defined" ;
  search searchKey error message "the '%K' reader is not declared" ;
}

#---------------------------------------------------------------------------*

routine enterBaseReaderWithoutArgument
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    ![@typeList emptyList]
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterInheritedReaderWithoutArgument
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    ![@typeList emptyList]
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isInherited]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterBaseReaderWithStringArgument
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  @typeList argList [emptyList] ;
  argList += ![@stringGalgasType new] ;
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    !argList
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterBaseReaderWith2StringArguments
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  @typeList argList [emptyList] ;
  argList += ![@stringGalgasType new] ;
  argList += ![@stringGalgasType new] ;
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    !argList
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterBaseReaderWithBoolArgument
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  @typeList argList [emptyList] ;
  argList += ![@boolGalgasType new] ;
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    !argList
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterBaseReaderWithBoolStringlistArguments
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  @typeList argList [emptyList] ;
  argList += ![@boolGalgasType new] ;
  argList += !build_stringlist_type [] ;
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    !argList
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterBaseReaderWithUintArgument
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  @typeList argList [emptyList] ;
  argList += ![@uintGalgasType new] ;
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    !argList
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterBaseReaderWith2UintArguments
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  @typeList argList [emptyList] ;
  argList += ![@uintGalgasType new] ;
  argList += ![@uintGalgasType new] ;
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    !argList
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterBaseReaderWith3UintArguments
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  @typeList argList [emptyList] ;
  argList += ![@uintGalgasType new] ;
  argList += ![@uintGalgasType new] ;
  argList += ![@uintGalgasType new] ;
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    !argList
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

routine enterBaseReaderWithUintCharArguments
  ?!@readerMap ioReaderMap
  ??@string inName
  ??@ACGalgasType inReturnedType
  ??@bool inHasLexiqueAndLocationArguments
:
  @typeList argList [emptyList] ;
  argList += ![@uintGalgasType new] ;
  argList += ![@charGalgasType new] ;
  [!?ioReaderMap insertKey
    ![@lstring new !inName !here]
    !argList
    !inHasLexiqueAndLocationArguments
    !inReturnedType
    ![@readerQualifier isBasic]
  ] ;
end routine ;

#---------------------------------------------------------------------------*

once commonReaderMapForAllTypes ->@readerMap outMap :
  outMap := [@readerMap emptyMap] ;
  enterInheritedReaderWithoutArgument !?outMap !"description" ![@stringGalgasType new] !false ;
  enterInheritedReaderWithoutArgument !?outMap !"object" ![@objectGalgasType new] !false ;
  enterInheritedReaderWithoutArgument !?outMap !"dynamicType" ![@typeGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

abstract reader @ACGalgasType readerMap ->@readerMap outMap ;

#---------------------------------------------------------------------------*

once readerMapFor_location ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"locationString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationIndex" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"line" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"column" ![@uintGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @locationGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_location [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_string ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"doesEnvironmentVariableExist" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"length" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"identifierRepresentation" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"HTMLRepresentation" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"utf8Representation" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"utf32Representation" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"stringByTrimmingWhiteSpaces" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"md5" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"decimalUnsignedNumber" ![@uintGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"isDecimalUnsignedNumber" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"capacity" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"fileExists" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"directoryExists" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"pathExtension" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"nativePathWithUnixPath" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"unixPathWithNativePath" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"lastPathComponent" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"stringByDeletingPathExtension" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"stringByCapitalizingFirstCharacter" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"firstCharacterOrNul" ![@charGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"stringByDeletingLastPathComponent" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"stringByStandardizingPath" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"lowercaseString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uppercaseString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"reversedString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"system" ![@sintGalgasType new] !false ;
  enterBaseReaderWithUintArgument !?outMap !"characterAtIndex" ![@charGalgasType new] !true ;
  enterBaseReaderWithUintArgument !?outMap !"stringByRemovingCharacterAtIndex" ![@stringGalgasType new] !true ;
  enterBaseReaderWithUintArgument !?outMap !"rightSubString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithUintArgument !?outMap !"leftSubString" ![@stringGalgasType new] !false ;
  enterBaseReaderWith2UintArguments !?outMap !"subString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithStringArgument !?outMap !"absolutePathFromPath" ![@stringGalgasType new] !false ;
  enterBaseReaderWithStringArgument !?outMap !"relativePathFromPath" ![@stringGalgasType new] !false ;
  enterBaseReaderWithStringArgument !?outMap !"componentsSeparatedByString" !build_stringlist_type [] !false ;
  enterBaseReaderWithUintCharArguments !?outMap !"stringByLeftPadding" ![@stringGalgasType new] !false ;
  enterBaseReaderWithUintCharArguments !?outMap !"stringByRightPadding" ![@stringGalgasType new] !false ;
  enterBaseReaderWithUintCharArguments !?outMap !"stringByLeftAndRightPadding" ![@stringGalgasType new] !false ;
  enterBaseReaderWith2StringArguments !?outMap !"stringByReplacingStringByString" ![@stringGalgasType new] !true ;
  enterBaseReaderWithBoolArgument !?outMap !"regularFiles" !build_stringlist_type [] !false ;
  enterBaseReaderWithBoolArgument !?outMap !"hiddenFiles" !build_stringlist_type [] !false ;
  enterBaseReaderWithBoolArgument !?outMap !"directories" !build_stringlist_type [] !false ;
  enterBaseReaderWithBoolStringlistArguments !?outMap !"directoriesWithExtensions" !build_stringlist_type [] !false ;
  enterBaseReaderWithBoolStringlistArguments !?outMap !"regularFilesWithExtensions" !build_stringlist_type [] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @stringGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_string [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_char ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"utf32CharConstantRepresentation" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uint" ![@uintGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"isalnum" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isalpha" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"iscntrl" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isdigit" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"islower" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isupper" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isxdigit" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uintValue" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isUnicodeLetter" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isUnicodeMark" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isUnicodeNumber" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isUnicodeSeparator" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isUnicodeCommand" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isUnicodePunctuation" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isUnicodeSymbol" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"unicodeName" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"unicodeToLower" ![@charGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"unicodeToUpper" ![@charGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @charGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_char [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_bool ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"cString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"ocString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uint" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"sint" ![@sintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uint64" ![@uint64GalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"sint64" ![@sint64GalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @boolGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_bool [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_uint -> @readerMap  outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"double" ![@doubleGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"sint" ![@sintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"sint64" ![@sint64GalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uint64" ![@uint64GalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"lsbIndex" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"significantBitCount" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"hexString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isUnicodeValueAssigned" ![@boolGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @uintGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_uint [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_sint ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"double" ![@doubleGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uint64" ![@uint64GalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"sint64" ![@sint64GalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uint" ![@uintGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @sintGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_sint [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_uint64 ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"double" ![@doubleGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"sint" ![@sintGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"sint64" ![@sint64GalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"uint" ![@uintGalgasType new] !true ;
  enterBaseReaderWith2UintArguments !?outMap !"uintSlice" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"hexString" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @uint64GalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_uint64 [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_sint64 ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"double" ![@doubleGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uint64" ![@uint64GalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"sint" ![@sintGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"uint" ![@uintGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @sint64GalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_sint64 [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_double ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @doubleGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_double [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_lstring ->@readerMap outMap :
  outMap := readerMapFor_string [] ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"location" ![@locationGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationString" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @lstringGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_lstring [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_lchar ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"char" ![@charGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationString" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"location" ![@locationGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @lcharGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_lchar [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_lbool ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"bool" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"location" ![@locationGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @lboolGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_lbool [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_luint ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"uint" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"location" ![@locationGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationString" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @luintGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_luint [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_lsint ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"sint" ![@sintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"location" ![@locationGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationString" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @lsintGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_lsint [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_luint64 ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  @typeList t [emptyList] ;
  enterBaseReaderWithoutArgument !?outMap !"uint64" ![@uint64GalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"location" ![@locationGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationString" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @luint64GalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_luint64 [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_lsint64 ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"sint64" ![@sint64GalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"location" ![@locationGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationString" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @lsint64GalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_lsint64 [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_ldouble ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"double" ![@doubleGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"string" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"location" ![@locationGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationString" ![@stringGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @ldoubleGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_ldouble [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_stringset ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithStringArgument !?outMap !"hasKey" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"count" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"stringList" !build_stringlist_type [] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @stringsetGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_stringset [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_binaryset ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"isFull" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isEmpty" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"significantVariableCount" ![@uintGalgasType new] !false ;
  @typeList t [emptyList] ;
  t += ![@binarysetGalgasType new] ;
  t += ![@binarysetGalgasType new] ;
  [!?outMap insertKey ![@lstring new !"ITE" !here] !t !false ![@binarysetGalgasType new]![@readerQualifier isBasic]] ;
  enterBaseReaderWithUintArgument !?outMap !"forAllOnBitIndex" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWithUintArgument !?outMap !"forAllOnBitIndexAndBeyond" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWithUintArgument !?outMap !"existOnBitIndex" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWithUintArgument !?outMap !"valueCount" ![@uint64GalgasType new] !false  ;
  enterBaseReaderWithoutArgument !?outMap !"compressedValueCount" ![@uint64GalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"uint64ValueList" !build_uint64list_type [] !false ;
  enterBaseReaderWithoutArgument !?outMap !"stringValueList" !build_stringlist_type [] !false ;
  t := [@typeList emptyList] ;
  t += ![@uintGalgasType new] ;
  t += !build_stringlist_type [] ;
  [!?outMap insertKey ![@lstring new !"stringValueListWithNameList" !here] !t !false !build_stringlist_type []![@readerQualifier isBasic]] ;
  enterBaseReaderWithoutArgument !?outMap !"predicateStringValue" ![@stringGalgasType new] !false ;
  enterBaseReaderWithUintArgument !?outMap !"compressedStringValueList" !build_stringlist_type [] !false ;
  enterBaseReaderWith2UintArguments !?outMap !"swap21" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWith3UintArguments !?outMap !"swap132" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWith3UintArguments !?outMap !"swap213" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWith3UintArguments !?outMap !"swap231" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWith3UintArguments !?outMap !"swap312" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWith3UintArguments !?outMap !"swap321" ![@binarysetGalgasType new] !false ;
  enterBaseReaderWithUintArgument !?outMap !"transitiveClosure" ![@binarysetGalgasType new] !false ;
  t := [@typeList emptyList] ;
  t += ![@binarysetGalgasType new] ;
  t += ![@uintGalgasType new] ;
  [!?outMap insertKey ![@lstring new !"accessibleStates" !here] !t !false ![@binarysetGalgasType new] ![@readerQualifier isBasic]] ;
  t := [@typeList emptyList] ;
  t += ![@binarysetGalgasType new] ;
  [!?outMap insertKey ![@lstring new !"equalTo" !here] !t !false ![@binarysetGalgasType new] ![@readerQualifier isBasic]] ;
  [!?outMap insertKey ![@lstring new !"notEqualTo" !here] !t !false ![@binarysetGalgasType new] ![@readerQualifier isBasic]] ;
  [!?outMap insertKey ![@lstring new !"lowerOrEqualTo" !here] !t !false ![@binarysetGalgasType new] ![@readerQualifier isBasic]] ;
  [!?outMap insertKey ![@lstring new !"greaterOrEqualTo" !here] !t !false ![@binarysetGalgasType new] ![@readerQualifier isBasic]] ;
  [!?outMap insertKey ![@lstring new !"greaterThan" !here] !t !false ![@binarysetGalgasType new] ![@readerQualifier isBasic]] ;
  [!?outMap insertKey ![@lstring new !"lowerThan" !here] !t !false ![@binarysetGalgasType new] ![@readerQualifier isBasic]] ;
  enterBaseReaderWith2UintArguments !?outMap !"binarySetByTranslatingFromIndex" ![@binarysetGalgasType new] !false ;
  t := [@typeList emptyList] ;
  t += ![@uint64GalgasType new] ;
  t += ![@uintGalgasType new] ;
  t += ![@uintGalgasType new] ;
  [!?outMap insertKey ![@lstring new !"containsValue" !here] !t !false ![@binarysetGalgasType new] ![@readerQualifier isBasic]] ;
  enterBaseReaderWith2UintArguments !?outMap !"existsOnBitRange" ![@binarysetGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @binarysetGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_binaryset [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_type ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"name" ![@stringGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"isClassType" ![@boolGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"hasSuperclass" ![@boolGalgasType new] !true ;
  enterBaseReaderWithoutArgument !?outMap !"superclass" ![@typeGalgasType new] !true ;
end once ;

#---------------------------------------------------------------------------*

override reader @typeGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_type [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_object ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"objectType" ![@typeGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @objectGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_object [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_data ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"length" ![@uintGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @dataGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_data [] ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_function ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"name" ![@stringGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"resultType" ![@typeGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"formalParameterTypeList" !build_typelist_type [] !false ;
  @typeList typeList [emptyList] ;
  typeList += !build_typelist_type [] ;
  typeList += ![@locationGalgasType new] ;
  [!?outMap insertKey ![@lstring new !"invoke" !here] !typeList !false ![@objectGalgasType new] ![@readerQualifier isBasic]] ;
end once ;

#---------------------------------------------------------------------------*

override reader @functionGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_function [] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @classGalgasType readerMap ->@readerMap outMap :
  if [mSuperClassIndex isNull] then
    outMap := commonReaderMapForAllTypes [] ;
  else
    @ACGalgasType superClassType ;
    [mSuperClassIndex searchKey ?* ?superClassType] ;
    outMap := [superClassType readerMap] ;
  end if ;
  foreach mAttributeList do
    @ACGalgasType t ;
    [mAttributeTypeIndex searchKey ?* ?t] ;
    [!?outMap insertKey
      !mAttributeName
      ![@typeList emptyList]
      !false
      !t
      ![@readerQualifier isBasic]
    ] ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_list ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"length" ![@uintGalgasType new] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @listGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_list [] ;
  enterBaseReaderWithUintArgument !?outMap !"subListFromIndex" !self !false ;
  enterBaseReaderWith2UintArguments !?outMap !"subListWithRange" !self !false ;
  foreach mAttributeList do
    @ACGalgasType t ;
    [mAttributeTypeIndex searchKey ?* ?t] ;
    [!?outMap insertKey
      ![@lstring new ![mAttributeName string] . "AtIndex" ![mAttributeName location]]
      ![@typeList listWithValue ![@uintGalgasType new]]
      !false
      !t
      ![@readerQualifier isBasic]
    ] ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_listmap ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithStringArgument !?outMap !"hasKey" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"allKeys" ![@stringsetGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"count" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"keyList" !build_stringlist_type [] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @listmapGalgasType readerMap ->@readerMap outMap :
  outMap := readerMapFor_listmap [] ;
  @ACGalgasType t ;
  [mAssociatedListTypeIndex searchKey ?* ?t] ;
  enterBaseReaderWithStringArgument !?outMap !"listForKey" !t !false ;
end reader ;

#---------------------------------------------------------------------------*

override reader @structGalgasType readerMap ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  foreach mAttributeList do
    @ACGalgasType t ;
    [mAttributeTypeIndex searchKey ?* ?t] ;
    [!?outMap insertKey
      !mAttributeName
      ![@typeList emptyList]
      !false
      !t
      ![@readerQualifier isBasic]
    ] ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

override reader @sortedlistGalgasType readerMap ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"length" !self !false ;
end reader ;

#---------------------------------------------------------------------------*

once readerMapFor_map ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithStringArgument !?outMap !"hasKey" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"locationForKey" ![@locationGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"count" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"allKeys" ![@stringsetGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"keyList" !build_lstringlist_type [] !false ;
  enterBaseReaderWithoutArgument !?outMap !"unsolvedIndexCount" ![@uintGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"unsolvedIndexKeyStringList" !build_stringlist_type [] !false ;
end once ;

#---------------------------------------------------------------------------*

override reader @mapType readerMap ->@readerMap outMap :
  outMap := readerMapFor_map [] ;
end reader ;

#---------------------------------------------------------------------------*

override reader @mapindexType readerMap ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  enterBaseReaderWithoutArgument !?outMap !"isRegular" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isNull" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"isSolved" ![@boolGalgasType new] !false ;
  enterBaseReaderWithoutArgument !?outMap !"key" ![@lstringGalgasType new] !false ;
end reader ;

#---------------------------------------------------------------------------*

override reader @enumType readerMap ->@readerMap outMap :
  outMap := commonReaderMapForAllTypes [] ;
  foreach mEnumMessageMap do
    enterBaseReaderWithoutArgument !?outMap ![key string] ![@lstringGalgasType new] !false ;
  end foreach ;
end reader ;

#---------------------------------------------------------------------------*

end semantics ;
