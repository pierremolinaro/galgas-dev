#---------------------------------------------------------------------------*

semantics targetGeneration :
  import "projectMetamodel.gSemantics" ;
  import "XcodeProjectGeneration.gSemantics" ;

#---------------------------------------------------------------------------*


local filewrapper targetGenerationFileWrapper in "../generation_templates/target_generation" {
 "bat", "command", "rtf"
} {
  template makefile_macosx_intel_makefile "makefile_macosx_intel/makefile" ?@string PROJECT_NAME ;
  template makefile_macosx_intel_makefile64 "makefile_macosx_intel/makefile64" ?@string PROJECT_NAME ;

  template makefile_macosx_ppc_makefile "makefile_macosx_ppc/makefile" ?@string PROJECT_NAME ;
  template makefile_macosx_ppc_makefile64 "makefile_macosx_ppc/makefile64" ?@string PROJECT_NAME ;

  template makefile_macosx_universal_makefile "makefile_macosx_universal/makefile" ?@string PROJECT_NAME ;
  template makefile_macosx_universal_makefile64 "makefile_macosx_universal/makefile64" ?@string PROJECT_NAME ;

  template makefile_macosx_makefile "makefile_macosx/makefile" ?@string PROJECT_NAME ;
  template makefile_macosx_makefile64 "makefile_macosx/makefile64" ?@string PROJECT_NAME ;

  template makefile_unix_makefile "makefile_unix/makefile" ?@string PROJECT_NAME ;
  template makefile_unix_makefile64 "makefile_unix/makefile64" ?@string PROJECT_NAME ;

  template makefile_i386_linux_on_macosx_makefile "makefile_i386_linux_on_macosx/makefile" ?@string PROJECT_NAME ;

  template makefile_mingw_on_macosx_makefile "makefile_mingw_on_macosx/makefile" ?@string PROJECT_NAME ;

  template makefile_msys_on_win32_makefile "makefile_msys_on_win32/makefile" ?@string PROJECT_NAME ;

  template makefile_info_plist "project_xcode/Info.plist" ?@string PROJECT_NAME ;

  template makefile_info_plist_strings "project_xcode/English.lproj/InfoPlist.strings" ?@string PROJECT_NAME ;

  template makefile_file_list "makefile-file-list.gTemplate"
    ?@stringset HAND_CODED_SOURCE_DIR_SET
    ?@stringlist HAND_CODED_SOURCE_FILE_LIST
    ?@stringlist MAKEFILE_FILE_LIST
  ;
}

#---------------------------------------------------------------------------*

local routine generateMsysOnWin32Target
  ??@string inProjectDirectory
  ??@string inProjectName
:
  const @string dir := inProjectDirectory . "/makefile_msys_on_win32" ;
  [dir makeDirectory] ;
  [[filewrapper targetGenerationFileWrapper."makefile_msys_on_win32/build.bat"] writeToFileWhenDifferentContents !dir ."/build.bat" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_msys_on_win32/clean.bat"] writeToFileWhenDifferentContents !dir ."/clean.bat" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_msys_on_win32/install.bat"] writeToFileWhenDifferentContents !dir ."/install.bat" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_msys_on_win32_makefile !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile" ?*] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateMinGWOnMacOSXTarget
  ??@string inProjectDirectory
  ??@string inProjectName
:
  const @string dir := inProjectDirectory . "/makefile_mingw_on_macosx" ;
  [dir makeDirectory] ;
  [[filewrapper targetGenerationFileWrapper."makefile_mingw_on_macosx/build.command"] writeToExecutableFileWhenDifferentContents !dir ."/build.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_mingw_on_macosx/clean.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_mingw_on_macosx_makefile !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile" ?*] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateMakefileMacOSXTarget
  ??@string inProjectDirectory
  ??@string inProjectName
:
  const @string dir := inProjectDirectory . "/makefile_macosx" ;
  [dir makeDirectory] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx/build.command"] writeToExecutableFileWhenDifferentContents !dir ."/build.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx/clean.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx/build64.command"] writeToExecutableFileWhenDifferentContents !dir ."/build64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx/clean64.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_makefile !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_makefile64 !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile64" ?*] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateMakefileIntelMacOSXTarget
  ??@string inProjectDirectory
  ??@string inProjectName
:
  const @string dir := inProjectDirectory . "/makefile_macosx_intel" ;
  [dir makeDirectory] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_intel/build.command"] writeToExecutableFileWhenDifferentContents !dir ."/build.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_intel/clean.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_intel/build64.command"] writeToExecutableFileWhenDifferentContents !dir ."/build64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_intel/clean64.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_intel_makefile !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_intel_makefile64 !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile64" ?*] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateMakefilePPCMacOSXTarget
  ??@string inProjectDirectory
  ??@string inProjectName
:
  const @string dir := inProjectDirectory . "/makefile_macosx_ppc" ;
  [dir makeDirectory] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_ppc/build.command"] writeToExecutableFileWhenDifferentContents !dir ."/build.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_ppc/clean.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_ppc/build64.command"] writeToExecutableFileWhenDifferentContents !dir ."/build64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_ppc/clean64.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_ppc_makefile !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_ppc_makefile64 !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile64" ?*] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateMakefileUniversalMacOSXTarget
  ??@string inProjectDirectory
  ??@string inProjectName
:
  const @string dir := inProjectDirectory . "/makefile_macosx_universal" ;
  [dir makeDirectory] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_universal/build.command"] writeToExecutableFileWhenDifferentContents !dir ."/build.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_universal/clean.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_universal/build64.command"] writeToExecutableFileWhenDifferentContents !dir ."/build64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_macosx_universal/clean64.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_universal_makefile !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_macosx_universal_makefile64 !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile64" ?*] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateMakefileUnixTarget
  ??@string inProjectDirectory
  ??@string inProjectName
:
  const @string dir := inProjectDirectory . "/makefile_unix" ;
  [dir makeDirectory] ;
  [[filewrapper targetGenerationFileWrapper."makefile_unix/build.command"] writeToExecutableFileWhenDifferentContents !dir ."/build.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_unix/clean.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_unix/build64.command"] writeToExecutableFileWhenDifferentContents !dir ."/build64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_unix/clean64.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean64.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_unix_makefile !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_unix_makefile64 !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile64" ?*] ;
end routine ;

#---------------------------------------------------------------------------*

local routine generateI386LinuxOnMacOSXTarget
  ??@string inProjectDirectory
  ??@string inProjectName
:
  const @string dir := inProjectDirectory . "/makefile_i386_linux_on_macosx" ;
  [dir makeDirectory] ;
  [[filewrapper targetGenerationFileWrapper."makefile_i386_linux_on_macosx/build.command"] writeToExecutableFileWhenDifferentContents !dir ."/build.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper."makefile_i386_linux_on_macosx/clean.command"] writeToExecutableFileWhenDifferentContents !dir ."/clean.command" ?*] ;
  [[filewrapper targetGenerationFileWrapper.makefile_i386_linux_on_macosx_makefile !inProjectName] writeToFileWhenDifferentContents !dir ."/makefile" ?*] ;
end routine ;

#---------------------------------------------------------------------------*

routine updateTargets
  ??@lstring inProjectSourceFilePath
  ??@lstring inProjectName
  ??@string inTargetName
  ??@lstringlist inTargetFeatureList
  ??@projectSourceList inProjectSourceList
:
  const @string projectDirectory := [[inProjectSourceFilePath stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] ;
#--- Check target names, file base name uniqueness, and build target file list
  @stringset externSourceSet_tool [emptySet] ;
  @stringset guiSourceSet_tool [emptySet] ;
  @stringset scannerSourceSet_tool [emptySet] ;
  @stringset optionSourceSet_tool [emptySet] ;
  @stringset semanticsSourceSet_tool [emptySet] ;
  @stringset syntaxSourceSet_tool [emptySet] ;
  @stringset grammarSourceSet_tool [emptySet] ;
  @stringset programSourceSet_tool [emptySet] ;
#---
  @stringset externSourceSet_app [emptySet] ;
  @stringset guiSourceSet_app [emptySet] ;
  @stringset scannerSourceSet_app [emptySet] ;
  @stringset optionSourceSet_app [emptySet] ;
  @stringset semanticsSourceSet_app [emptySet] ;
  @stringset syntaxSourceSet_app [emptySet] ;
  @stringset grammarSourceSet_app [emptySet] ;
  @stringset programSourceSet_app [emptySet] ;
#---
  @stringset sourceFileSet [emptySet] ;
  @stringlist generatedFileListForMakefile [emptyList] ;
  @stringlist handCodedSourceList [emptyList] ;
  @stringset handCodedSourceDirectorySet [emptySet] ;
  foreach inProjectSourceList do
    const @string baseName := [[[mFilePath string] lastPathComponent] stringByDeletingPathExtension] ;
    const @string cppFile := baseName . ".cpp" ;
  #--- Check base name is unique
    if [sourceFileSet hasKey !baseName] then
      error mFilePath: "there is already a file with '" . baseName . "' as base name in the project" ;
    end if ;
    sourceFileSet += !baseName ;
  #---
    switch mSourceKind
    when externSourceFile :
      const @string extension := [mFilePath pathExtension] ;
      if (extension == "cpp") | (extension == "mm") | (extension == "framework") then
        externSourceSet_tool += ![mFilePath string] ;
        handCodedSourceList += ![mFilePath lastPathComponent] ;
        handCodedSourceDirectorySet += !"../hand_coded_sources/" . [mFilePath stringByDeletingLastPathComponent] ;
      elsif extension == "m" then
        externSourceSet_app += ![mFilePath string] ;
        handCodedSourceDirectorySet += !"../hand_coded_sources/" . [mFilePath stringByDeletingLastPathComponent] ;
      else
        error mFilePath:"unhandled extension" ;
      end if ;
    when lexiqueSourceFile :
      generatedFileListForMakefile += !cppFile ;
      scannerSourceSet_tool += !baseName ;
#      scannerSourceSet_app += !baseName ;
    when syntaxSourceFile :
      generatedFileListForMakefile += !cppFile ;
      syntaxSourceSet_tool += !baseName ;
#      syntaxSourceSet_app += !baseName ;
    when semanticsSourceFile :
      generatedFileListForMakefile += !cppFile ;
      semanticsSourceSet_tool += !baseName ;
#      semanticsSourceSet_app += !baseName ;
    when grammarSourceFile :
      generatedFileListForMakefile += !cppFile ;
      grammarSourceSet_tool += !baseName ;
#      grammarSourceSet_app += !baseName ;
    when programSourceFile :
      generatedFileListForMakefile += !cppFile ;
      programSourceSet_tool += !baseName ;
#      programSourceSet_app += !baseName ;
    when optionSourceFile :
      generatedFileListForMakefile += !cppFile ;
      optionSourceSet_tool += !baseName ;
#      optionSourceSet_app += !baseName ;
    when guiSourceFile :
#      guiSourceSet_tool += !baseName ;
      guiSourceSet_app += !baseName ;
    end switch ;
  end foreach ;
#--- Parse features
  message "*** Updating targets\n" ;
  @stringset availableGenerationFeatures [emptySet] ;
  availableGenerationFeatures += !"makefile_macosx_intel" ;
  availableGenerationFeatures += !"makefile_macosx_ppc" ;
  availableGenerationFeatures += !"makefile_macosx_universal" ;
  availableGenerationFeatures += !"makefile_macosx" ;
  availableGenerationFeatures += !"makefile_unix" ;
  availableGenerationFeatures += !"makefile_i386_linux_on_macosx" ;
  availableGenerationFeatures += !"makefile_mingw_on_macosx" ;
  availableGenerationFeatures += !"makefile_msys_on_win32" ;
  availableGenerationFeatures += !"project_xcode" ;
  availableGenerationFeatures += !"xcode_arch:i386" ;
  availableGenerationFeatures += !"xcode_arch:x86_64" ;
  availableGenerationFeatures += !"xcode_arch:ppc64" ;
  availableGenerationFeatures += !"xcode_arch:ppc" ;
  @stringset generationFeatures [emptySet] ;
  foreach inTargetFeatureList do
    if [availableGenerationFeatures hasKey ![mValue string]] then
      if [generationFeatures hasKey ![mValue string]] then
        error mValue: "duplicate '" . mValue . "' feature" ;
      end if ;
      generationFeatures += ![mValue string] ;
    else
      @string s := "" ;
      foreach availableGenerationFeatures do
        s .= "\n  - '" . key . "'" ;
      end foreach ;
      error mValue: "unknown '" . mValue . "' feature; avalaible features are:" . s ;
    end if ;
  end foreach ;
#--- Special case for 'makefile_macosx_universal'
  if [generationFeatures hasKey !"makefile_macosx_universal"] & not [generationFeatures hasKey !"makefile_macosx_ppc"] then
    warning inProjectName : "'feature \"makefile_macosx_ppc\" ;' implicitly added, due to 'feature makefile_macosx_universal'" ;
    generationFeatures += !"makefile_macosx_ppc" ;
  end if ;
  if [generationFeatures hasKey !"makefile_macosx_universal"] & not [generationFeatures hasKey !"makefile_macosx_intel"] then
    warning inProjectName : "'feature \"makefile_macosx_intel\" ;' implicitly added, due to 'feature makefile_macosx_universal'" ;
    generationFeatures += !"makefile_macosx_intel" ;
  end if ;
#--- Check xcode target architectures
  @stringlist architectureList [emptyList] ;
  if [generationFeatures hasKey !"xcode_arch:i386"] then
     architectureList += !"i386" ;
  end if ;
  if [generationFeatures hasKey !"xcode_arch:x86_64"] then
     architectureList += !"x86_64" ;
  end if ;
  if [generationFeatures hasKey !"xcode_arch:ppc64"] then
     architectureList += !"ppc64" ;
  end if ;
  if [generationFeatures hasKey !"xcode_arch:ppc"] then
     architectureList += !"ppc7400" ; # G4
  end if ;
  if [generationFeatures hasKey !"project_xcode"] & ([architectureList length] == 0) then
    warning inProjectName : "'feature \"xcode_arch:i386\" ;' implicitly added, due to 'project_xcode'" ;
    architectureList += !"i386" ;
  end if ;
  if ([architectureList length] > 0) & not [generationFeatures hasKey !"project_xcode"] then
    error inProjectName : "'a 'xcode_arch:...' feature requires the 'project_xcode' feature" ;
  end if ;
#--- Generate projects
  if [generationFeatures hasKey !"makefile_macosx_ppc"] then
    generateMakefilePPCMacOSXTarget !projectDirectory !inTargetName ;
  end if ;
  if [generationFeatures hasKey !"makefile_macosx_intel"] then
    generateMakefileIntelMacOSXTarget !projectDirectory !inTargetName ;
  end if ;
  if [generationFeatures hasKey !"makefile_macosx_universal"] then
    generateMakefileUniversalMacOSXTarget !projectDirectory !inTargetName ;
  end if ;
  if [generationFeatures hasKey !"makefile_macosx"] then
    generateMakefileMacOSXTarget !projectDirectory !inTargetName ;
  end if ;
  if [generationFeatures hasKey !"makefile_unix"] then
    generateMakefileUnixTarget !projectDirectory !inTargetName ;
  end if ;
  if [generationFeatures hasKey !"makefile_i386_linux_on_macosx"] then
    generateI386LinuxOnMacOSXTarget !projectDirectory !inTargetName ;
  end if ;
  if [generationFeatures hasKey !"makefile_mingw_on_macosx"] then
    generateMinGWOnMacOSXTarget !projectDirectory !inTargetName ;
  end if ;
  if [generationFeatures hasKey !"makefile_msys_on_win32"] then
    generateMsysOnWin32Target !projectDirectory !inTargetName ;
  end if ;
#--- Update makefile file list
  const @string newFileListContents := [filewrapper targetGenerationFileWrapper.makefile_file_list
    !handCodedSourceDirectorySet
    !handCodedSourceList
    !generatedFileListForMakefile
  ] ;
  @string fileListPath := [inProjectSourceFilePath stringByDeletingLastPathComponent] . "/GALGAS_OUTPUT/file_list.mke" ;
  [newFileListContents writeToFileWhenDifferentContents !fileListPath ?*] ;
#---------------------- update Xcode project
  if [generationFeatures hasKey !"project_xcode"] then
    const @string dir := projectDirectory . "/project_xcode";
    [dir makeDirectory] ;

    const @string icon_help_file_path := dir ."/adding-icons-to-your-application.rtf" ;
    [[filewrapper targetGenerationFileWrapper."project_xcode/adding-icons-to-your-application.rtf"] writeToFileWhenDifferentContents !icon_help_file_path ?*] ;

    if not [dir ."/Info.plist" fileExists] then
    [[filewrapper targetGenerationFileWrapper.makefile_info_plist !inTargetName] writeToFile !dir ."/Info.plist"] ;
    end if ;

    [dir . "/English.lproj" makeDirectory] ;
    const @string InfoPlist_strings_path := dir ."/English.lproj/InfoPlist.strings" ;
    [[filewrapper targetGenerationFileWrapper.makefile_info_plist_strings !inTargetName] writeToFileWhenDifferentContents !InfoPlist_strings_path ?*] ;
    const @string Credits_rtf_path := dir ."/English.lproj/Credits.rtf" ;
    if not [Credits_rtf_path fileExists] then
      [[filewrapper targetGenerationFileWrapper."project_xcode/English.lproj/Credits.rtf"] writeToFile !Credits_rtf_path] ;
    end if ;
  #--- Make symbolic link
    const @string libpmPosixPath := [[@string stringWithEnvironmentVariable !"LIBPM_PATH"] unixPathWithNativePath] ;
    const @string symbLinkPath := dir . "/libpm" ;
    if not [symbLinkPath isSymbolicLink] then
      [symbLinkPath makeSymbolicLinkWithPath !libpmPosixPath] ;
    elsif [@string stringWithSymbolicLinkContents !symbLinkPath] != libpmPosixPath then
      [@string deleteFile !symbLinkPath] ;
      [symbLinkPath makeSymbolicLinkWithPath !libpmPosixPath] ;
    end if ;
  #--- Enumerate icons
    const @stringlist iconFiles := [dir regularFilesWithExtensions !false ![@stringlist listWithValue !"icns"]] ;
  #--- Build pathes
    const @string xcodeProjectPath := dir . "/" . inTargetName . ".xcodeproj" ; # Actually a directory
    const @string intermediateFilePath := [inProjectSourceFilePath stringByDeletingLastPathComponent] . "/GALGAS_OUTPUT/file_list_for_xcode_project.txt" ;
  #---
    [xcodeProjectPath makeDirectory] ;
  #--- Build intermediate
    generateXcodeProject
      !externSourceSet_tool
      !guiSourceSet_tool
      !scannerSourceSet_tool
      !optionSourceSet_tool
      !semanticsSourceSet_tool
      !syntaxSourceSet_tool
      !grammarSourceSet_tool
      !programSourceSet_tool
      !externSourceSet_app
      !guiSourceSet_app
      !scannerSourceSet_app
      !optionSourceSet_app
      !semanticsSourceSet_app
      !syntaxSourceSet_app
      !grammarSourceSet_app
      !programSourceSet_app
      !inTargetName # XCode project base name
      !xcodeProjectPath # Full Path of xxx.xcodeproj file
      !iconFiles
      !intermediateFilePath
      !architectureList
    ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*
end semantics ;

