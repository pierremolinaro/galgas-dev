#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component parser definition                             *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax expression_parser :

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <concatenation_term>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <relation_term>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <relation_factor>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <simple_expression>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <term>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <factor>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <read_access>
  !@lstring nomAttribut
  !@typeCplusPlusName nomCppEntite
  !@AC_galgasType typeEntite
  ?!@typeVariablesMap ioVariablesMap
label parse
;

nonterminal <output_expression_list>
  !@typeExpressionList outExpressionList 
  ??@typeListeAttributsSemantiques inAttributesList
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
label parse
;

nonterminal <parse_effective_input_parameters_list>
  ?!@typeVariablesMap ioVariablesMap
  ?@typeListeAttributsSemantiques inFormalArgumentsList
  ?@location inVarLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
  !@bool outNoUsedParameter
label parse
;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    &    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchAndOperator
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_binaryset ()  :: @typeGalgas_binaryset () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_bool () :: @typeGalgas_bool () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint () :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 () :: @typeGalgas_uint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_stringset () :: @typeGalgas_stringset () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint () :: @typeGalgas_sint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 () :: @typeGalgas_sint64 () :
    outResultType := inLeftExpressionType ;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGalgasType] .
           " & " . [inRightExpressionType messageGalgasType] . ") is not valid" 
           -> outResultType ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    |    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchOrOperator
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_binaryset ()  :: @typeGalgas_binaryset () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_bool () :: @typeGalgas_bool () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint () :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 () :: @typeGalgas_uint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint () :: @typeGalgas_sint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 () :: @typeGalgas_sint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_stringset () :: @typeGalgas_stringset () :
    outResultType := inLeftExpressionType ;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGalgasType] .
           " | " . [inRightExpressionType messageGalgasType] . ") is not valid" 
           -> outResultType ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    ^    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchXorOperator
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_binaryset ()  :: @typeGalgas_binaryset () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_bool () :: @typeGalgas_bool () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint () :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 () :: @typeGalgas_uint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint () :: @typeGalgas_sint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 () :: @typeGalgas_sint64 () :
    outResultType := inLeftExpressionType ;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGalgasType] .
           " | " . [inRightExpressionType messageGalgasType] . ") is not valid" 
           -> outResultType ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    .    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchConcatOperator
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_string () :: @typeGalgas_string () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_string () :: @typeGalgas_lstring () :
    outResultType := inLeftExpressionType ;
  when @typeGalgasUndefinedListType (@lstring kListType1) :: @typeGalgasUndefinedListType (@lstring kListType2) :
    if [kListType1 string] != [kListType2 string] then
      error here:"concatenation operator error: lists should have the same type (here '@" 
        . [kListType1 string] . "' and '@" . [kListType2 string] . "')" ;
    end if ;
    outResultType := inLeftExpressionType ;
  else
    error here : "concatenation operator error: " . [inLeftExpressionType messageGalgasType] .
           " . " . [inRightExpressionType messageGalgasType] . ") cannot be concatened" 
           -> outResultType ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    N O T    O P E R A T O R                                   *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkNotOperator
  ??@AC_galgasType inOperandType
  !@AC_galgasType outResultType
:
  @typeGalgas_bool gb := (cast inOperandType if >= @typeGalgas_bool else error here) ;
  # ¤ extract inOperandType -> @typeGalgas_bool () error here : messageGalgasType ;
  outResultType := inOperandType ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ~    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkLogicalNegateOperator
  ??@AC_galgasType inOperandType
  !@AC_galgasType outResultType
:
  cast inOperandType :
  when >= @typeGalgas_binaryset do
    outResultType := inOperandType ;
  when >= @typeGalgas_uint do
    outResultType := inOperandType ;
  when >= @typeGalgas_sint do
    outResultType := inOperandType ;
  when >= @typeGalgas_uint64 do
    outResultType := inOperandType ;
  when >= @typeGalgas_sint64 do
    outResultType := inOperandType ;
  else
    error here : "the ~ operator is not defined for an "
    . [inOperandType messageGalgasType] . " object"
    -> outResultType ;
  end cast ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    C O M P A R I S O N S                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine comparison_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_stringset () :: @typeGalgas_stringset () :
  when @typeGalgas_bool ()      :: @typeGalgas_bool () :
  when @typeGalgas_char ()      :: @typeGalgas_char () :
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
  when @typeGalgas_sint ()      :: @typeGalgas_sint () :
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint64 () :
  when @typeGalgas_sint64 ()    :: @typeGalgas_sint64 () :
  when @typeGalgas_double ()    :: @typeGalgas_double () :
  when @typeGalgas_string ()    :: @typeGalgas_string () :
  when @typeGalgas_lbool ()     :: @typeGalgas_lbool () :
  when @typeGalgas_lchar ()     :: @typeGalgas_lchar () :
  when @typeGalgas_luint ()     :: @typeGalgas_luint () :
  when @typeGalgas_lsint ()     :: @typeGalgas_lsint () :
  when @typeGalgas_luint64 ()   :: @typeGalgas_luint64 () :
  when @typeGalgas_lsint64 ()   :: @typeGalgas_lsint64 () :
  when @typeGalgas_ldouble ()   :: @typeGalgas_ldouble () :
  when @typeGalgas_lstring ()   :: @typeGalgas_lstring () :
  when @typeGalgas_location ()  :: @typeGalgas_location () :
  when @typeGalgas_enum (@lstring inTypeName1 * *) :: @typeGalgas_enum (@lstring inTypeName2 * *) :
    if [inTypeName1 string] != [inTypeName2 string] then
      error here : "comparison between an '@" . [inTypeName1 string] .
             "' enumeration and an '@" . [inTypeName2 string] . "' enumeration is not valid"  ;
    end if ;
  when @typeGalgasUndefinedListType (@lstring attNomType1) :: @typeGalgasUndefinedListType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error here: "I was expecting the list type '@" . [attNomType1 string] .
                  "', I have got the list type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedMapType (@lstring attNomType1) :: @typeGalgasUndefinedMapType (@lstring attNomType2) :
    if [attNomType1 string] != [attNomType2 string] then
      error here: "I was expecting the map type '@" . [attNomType1 string] .
                  "', I have got the map type '@" . [attNomType2 string] . "\"" ;
    end if ;

  when @typeGalgasUndefinedClassType (@lstring kNomType1)
    :: @typeGalgasUndefinedClassType (@lstring kNomType2) :
    if [kNomType1 string] != [kNomType2 string] then
      error here: "I was expecting the class type '@" . [kNomType1 string] .
                  "', I have got the class type '@" . [kNomType2 string] . "\"" ;
    end if ;
  else
    error here : "comparison between " . [inLeftExpressionType messageGalgasType] .
           " and " . [inRightExpressionType messageGalgasType] . " is not valid"  ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    <    <=    >    >=   C O M P A R I S O N S     *
#                                                                           *
#---------------------------------------------------------------------------*

routine magnitude_comparison_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_stringset () :: @typeGalgas_stringset () :
  when @typeGalgas_bool ()      :: @typeGalgas_bool () :
  when @typeGalgas_char ()      :: @typeGalgas_char () :
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
  when @typeGalgas_sint ()      :: @typeGalgas_sint () :
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint64 () :
  when @typeGalgas_sint64 ()    :: @typeGalgas_sint64 () :
  when @typeGalgas_double ()    :: @typeGalgas_double () :
  when @typeGalgas_string ()    :: @typeGalgas_string () :
  when @typeGalgas_enum (@lstring inTypeName1 * *) :: @typeGalgas_enum (@lstring inTypeName2 * *) :
    if [inTypeName1 string] != [inTypeName2 string] then
      error here : "comparison between an '@" . [inTypeName1 string] .
             "' enumeration and an '@" . [inTypeName2 string] . "' enumeration is not valid"  ;
    end if ;
  else
    error here : "comparison between " . [inLeftExpressionType messageGalgasType] .
           " and " . [inRightExpressionType messageGalgasType] . " is not valid"  ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S H I F T    O P E R A T O R                               *
#                                                                           *
#---------------------------------------------------------------------------*

routine left_shift_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_binaryset () :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 ()    :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  else
    error here : "shift between " . [inLeftExpressionType messageGalgasType]
      ." and " . [inRightExpressionType messageGalgasType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*

routine right_shift_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_binaryset () :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 ()    :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  else
    error here : "shift between " . [inLeftExpressionType messageGalgasType]
      ." and " . [inRightExpressionType messageGalgasType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    A D D I T I O N    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine addition_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint ()      :: @typeGalgas_sint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 ()    :: @typeGalgas_sint64 () :
    outResultType := inLeftExpressionType ;
  else
    error here : "addition between " . [inLeftExpressionType messageGalgasType]
      ." and " . [inRightExpressionType messageGalgasType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S U B S T R A C T I O N    O P E R A T O R                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine substraction_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint ()      :: @typeGalgas_sint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 ()    :: @typeGalgas_sint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_stringset () :: @typeGalgas_stringset () :
    outResultType := inLeftExpressionType ;
  else
    error here : "substraction between " . [inLeftExpressionType messageGalgasType]
      ." and " . [inRightExpressionType messageGalgasType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M U L T I P L Y    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine multiply_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint ()      :: @typeGalgas_sint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 ()    :: @typeGalgas_sint64 () :
    outResultType := inLeftExpressionType ;
  else
    error here : "multiplication between " . [inLeftExpressionType messageGalgasType]
      ." and " . [inRightExpressionType messageGalgasType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    D I V I D E    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine divide_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint ()      :: @typeGalgas_sint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 ()    :: @typeGalgas_sint64 () :
    outResultType := inLeftExpressionType ;
  else
    error here : "division between " . [inLeftExpressionType messageGalgasType]
      ." and " . [inRightExpressionType messageGalgasType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M O D U L O    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine modulo_types_check
  ??@AC_galgasType inLeftExpressionType
  ??@AC_galgasType inRightExpressionType
  !@AC_galgasType outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when @typeGalgas_uint ()      :: @typeGalgas_uint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint ()      :: @typeGalgas_sint () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_uint64 ()    :: @typeGalgas_uint64 () :
    outResultType := inLeftExpressionType ;
  when @typeGalgas_sint64 ()    :: @typeGalgas_sint64 () :
    outResultType := inLeftExpressionType ;
  else
    error here : "modulo between " . [inLeftExpressionType messageGalgasType]
      ." and " . [inRightExpressionType messageGalgasType] . " is not valid"
      -> outResultType
    ;
  end match ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    U N A R Y    M I N U S    O P E R A T O R                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine unary_minus_type_check
  ??@AC_galgasType inExpressionType
  !@AC_galgasType outResultType
:
  cast inExpressionType :
  when >= @typeGalgas_sint do
    outResultType := inExpressionType ;
  when >= @typeGalgas_sint64 do
    outResultType := inExpressionType ;
  else
    error here : "unary minus for " . [inExpressionType messageGalgasType]
      . " is not valid"
      -> outResultType
    ;
  end cast ;
end routine ;

#------------------------------------------------------------------------------*
#                                                                              *
#   E X P R E S S I O N                                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  <concatenation_term>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?outExpression
    ?outResultType
  ;
  repeat
  while
    @location operatorLocation := here ;
    $.$ ;
    @typeExpression leftOperand := outExpression ;
    @typeExpression rightOperand ;
    @AC_galgasType firstOperandType := outResultType ;
    @AC_galgasType secondOperandType ;
    <concatenation_term>
       !ioEntitiesMap
       !inOptionsComponentsMapForUse
       !?ioVariablesMap
       ?rightOperand
       ?secondOperandType
    ;
   outExpression := [@typeConcatOperation new !operatorLocation !leftOperand !rightOperand] ;
    matchConcatOperator
      !firstOperandType
      !secondOperandType
      ?outResultType
     ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   E X P R E S S I O N                                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <concatenation_term>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  <relation_term>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?outExpression
    ?outResultType
  ;
  repeat
  while
    @location operatorLocation := here ;
    $|$ ;
    @typeExpression leftOperand := outExpression ;
    @typeExpression rightOperand ;
    @AC_galgasType firstOperandType := outResultType ;
    @AC_galgasType secondOperandType ;
    <relation_term>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightOperand
      ?secondOperandType
    ;
    outExpression := [@typeOrOperation new !operatorLocation !leftOperand !rightOperand] ;
    matchOrOperator
      !firstOperandType
      !secondOperandType
      ?outResultType
     ;
  while
    @location operatorLocation := here ;
    $^$ ;
    @typeExpression leftOperand := outExpression ;
    @typeExpression rightOperand ;
    @AC_galgasType firstOperandType := outResultType ;
    @AC_galgasType secondOperandType ;
    <relation_term>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightOperand
      ?secondOperandType
    ;
    outExpression := [@typeXorOperation new !operatorLocation !leftOperand !rightOperand] ;
    matchXorOperator
      !firstOperandType
      !secondOperandType
      ?outResultType
     ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    T E R M                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_term>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  <relation_factor>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?outExpression
    ?outResultType
  ;
  repeat
  while
    @location operatorLocation := here ;
    $&$ ;
    @typeExpression leftOperand := outExpression ;
    @typeExpression rightOperand ;
    @AC_galgasType firstOperandType := outResultType ;
    @AC_galgasType secondOperandType ;
    <relation_factor>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightOperand
      ?secondOperandType
    ;
    outExpression := [@typeAndOperation new !operatorLocation !leftOperand !rightOperand] ;
    matchAndOperator
      !firstOperandType
      !secondOperandType
      ?outResultType
    ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    F A C T O R                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_factor>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  <simple_expression>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?outExpression
    ?outResultType
  ;
  select
  or
    @location operatorLocation := here ;
    $==$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <simple_expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType ;
    comparison_types_check !leftType !rightType ;
    outExpression := [@typeEqualTest new !operatorLocation !leftExpression !rightExpression] ;
    outResultType := [@typeGalgas_bool new] ;
  or
    @location operatorLocation := here ;
    $!=$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <simple_expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    comparison_types_check !leftType !rightType ;
    outExpression := [@typeNonEqualTest new !operatorLocation !leftExpression !rightExpression] ;
    outResultType := [@typeGalgas_bool new] ;
  or
    @location operatorLocation := here ;
    $<=$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <simple_expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    magnitude_comparison_types_check !leftType !rightType ;
    outExpression := [@typeInfOrEqualTest new !operatorLocation !leftExpression !rightExpression] ;
    outResultType := [@typeGalgas_bool new] ;
  or
    @location operatorLocation := here ;
    $>=$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <simple_expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    magnitude_comparison_types_check !leftType !rightType ;
    outExpression := [@typeSupOrEqualTest new !operatorLocation !leftExpression !rightExpression] ;
    outResultType := [@typeGalgas_bool new] ;
  or
    @location operatorLocation := here ;
    $>$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <simple_expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    magnitude_comparison_types_check !leftType !rightType ;
    outExpression := [@typeStrictSupTest new !operatorLocation !leftExpression !rightExpression] ;
    outResultType := [@typeGalgas_bool new] ;
  or
    @location operatorLocation := here ;
    $<$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <simple_expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    magnitude_comparison_types_check !leftType !rightType ;
    outExpression := [@typeStrictInfTest new !operatorLocation !leftExpression !rightExpression] ;
    outResultType := [@typeGalgas_bool new] ;
  end select ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   S I M P L E    E X P R E S S I O N                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <simple_expression>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  <term>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?outExpression
    ?outResultType
  ;
  repeat
  while 
    @location operatorLocation := here ;
    $<<$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <term>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    left_shift_types_check !leftType !rightType ?outResultType ;
    outExpression := [@typeLeftShiftOperation new !operatorLocation !leftExpression !rightExpression] ;
  while 
    @location operatorLocation := here ;
    $>>$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <term>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    right_shift_types_check !leftType !rightType ?outResultType ;
    outExpression := [@typeRightShiftOperation new !operatorLocation !leftExpression !rightExpression] ;
  while 
    @location operatorLocation := here ;
    $+$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <term>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    addition_types_check !leftType !rightType ?outResultType ;
    outExpression := [@typeAddOperation new !operatorLocation !leftExpression !rightExpression] ;
  while 
    @location operatorLocation := here ;
    $-$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <term>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    substraction_types_check !leftType !rightType ?outResultType ;
    outExpression := [@typeSubOperation new !operatorLocation !leftExpression !rightExpression] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   T E R M                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <term>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  <factor>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?outExpression
    ?outResultType
  ;
  repeat
  while 
    @location operatorLocation := here ;
    $*$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <factor>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    multiply_types_check !leftType !rightType ?outResultType ;
    outExpression := [@typeMultiplyOperation new !operatorLocation !leftExpression !rightExpression] ;
  while 
    @location operatorLocation := here ;
    $/$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <factor>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    divide_types_check !leftType !rightType ?outResultType ;
    outExpression := [@typeDivideOperation new !operatorLocation !leftExpression !rightExpression] ;
  while 
    @location operatorLocation := here ;
    $mod$ ;
    @typeExpression leftExpression := outExpression ;
    @AC_galgasType leftType := outResultType ;
    @typeExpression rightExpression ;
    @AC_galgasType rightType ;
    <factor>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?rightExpression
      ?rightType
    ;
    modulo_types_check !leftType !rightType ?outResultType ;
    outExpression := [@typeModuloOperation new !operatorLocation !leftExpression !rightExpression] ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    - factor                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @location operatorLocation := here ;
  $-$ ;
  @typeExpression expression ;
  @AC_galgasType type ;
  <factor>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?expression
    ?type
  ;
  unary_minus_type_check !type ?outResultType ;
  outExpression := [@typeUnaryMinusOperation new !operatorLocation !expression] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    <var>                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @typeCplusPlusName nomCppEntite1 ;
  <read_access> ?* ?nomCppEntite1 ?outResultType !?ioVariablesMap ;
  outExpression := [@typeVarInExpression new !nomCppEntite1] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ( EXPRESSION )                                         *
#                       (cast EXPRESSION if >= @T else error EXPRESSION)       *
#                       (cast EXPRESSION if == @T else error EXPRESSION)       *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  $($ ;
  select
    <expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?outExpression
      ?outResultType
    ;
  or
    $cast$ ;
    @typeExpression castedExpression ;
    @AC_galgasType castExpressionType ;
    <expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?castedExpression
      ?castExpressionType
    ;
  #--- Check the type is a class
    @lstring kSourceExpresionClassName := [(cast castExpressionType if >= @typeGalgasClassType else error here) mClassTypeName] ;
    # ¤ extract castExpressionType->@typeGalgasClassType (?kSourceExpresionClassName ?3* ? classMessageMap ?3*) error here : messageGalgasType ;
    $if$ ;
    @bool checkForKindOfClass ;
    select
      $>=$ ;
      checkForKindOfClass := true ;
    or
      $==$ ;
      checkForKindOfClass := false ;
    end select ;
  #--- Cast type
    @lstring castedTypeName ;
    $type_name$ ?castedTypeName ;
  #--- Check the name 'castedTypeName' refers to a type
    @AC_semanticsEntity entite ;
    [ioEntitiesMap searchKey !castedTypeName ?entite] ;
    outResultType := [(cast entite if >= @typeEntiteType else error castedTypeName) aDefType] ;
    # ¤ extract entite->@typeEntiteType (? outResultType) error castedTypeName : messageTypeEntite ;
  #--- Check the type is a class
    @typeGalgasClassType resultClassType := (cast outResultType if >= @typeGalgasClassType else error castedTypeName) ;
    @typeSuperClassesMap superClassMap := [resultClassType mAncestorClassesMap] ;
    @string classMessage := [resultClassType mClassMessage] ;
    # ¤ extract outResultType->@typeGalgasClassType (?3* ?superClassMap ?3* ?classMessage) error castedTypeName : messageGalgasType ;
  #--- Check class does define a message
    if [classMessage length] == 0 then
      error castedTypeName: "in order to be used in a cast expression, the '@" . castedTypeName . "' class should define a class message" ;
    end if ;
  #--- Verify class is an heir of variable type
    @string sourceExpressionTypeNameString := [kSourceExpresionClassName string] ;
    if not checkForKindOfClass then
      if ([castedTypeName string] != sourceExpressionTypeNameString) & not [superClassMap hasKey ! sourceExpressionTypeNameString] then
        error castedTypeName : "This class is not '@" . sourceExpressionTypeNameString . "' and does inherit from it" ;
      end if ;
    elsif not [superClassMap hasKey !sourceExpressionTypeNameString] then
      error castedTypeName : "This class does not inherit from '@" . sourceExpressionTypeNameString . "'" ;
    end if ;
    $else$ ;
    $error$ ;
    @typeExpression errorLocationExpression ;
    @AC_galgasType errorLocationExpressionType ;
    <expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?errorLocationExpression
      ?errorLocationExpressionType
    ;
  #--- Verifier que la variable est d'une type contenant une location localisant l'error
    [errorLocationExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  #--- Generate instruction
    outExpression := [@typeCastInExpression new
      !castedExpression
      !checkForKindOfClass
      !castedTypeName
      !errorLocationExpression
    ] ;
  end select ;
  $)$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    not FACTOR                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @location operatorLocation := here ;
  $not$ ;
  @typeExpression ifCondition ;
  @AC_galgasType operandType ;
  <factor>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?ifCondition
    ?operandType
  ;
  outExpression := [@typeTestComplement new !operatorLocation !ifCondition] ;
  checkNotOperator !operandType ?outResultType ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ~ FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @location operatorLocation := here ;
  $~$ ;
  @typeExpression ifCondition ;
  @AC_galgasType operandType ;
  <factor>
    !ioEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?ifCondition
    ?operandType
  ;
  outExpression := [@typeLogicalNegate new !operatorLocation !ifCondition] ;
  checkLogicalNegateOperator !operandType ?outResultType ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    true                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  $true$ ;
  outExpression := [@typeTrueBool new] ;
  outResultType := [@typeGalgas_bool new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    false                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  $false$ ;
  outExpression := [@typeFalseBool new] ;
  outResultType := [@typeGalgas_bool new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a literal string "..."                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @stringlist literalStringList [emptyList] ;
  repeat
    @lstring literalString ;
    $literal_string$ ?literalString ;
    literalStringList += ![literalString string] ;
  while
  end repeat ;
  outExpression := [@typeLiteralStringExpression new !literalStringList] ;
  outResultType := [@typeGalgas_string new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 32-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @luint literalInt ;
  $unsigned_literal_integer$ ?literalInt ;
  outExpression := [@typeLiteralUIntExpression new !literalInt] ;
  outResultType := [@typeGalgas_uint new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 32-bit signed literal integer value                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @lsint literalInt ;
  $signed_literal_integer$ ?literalInt ;
  outExpression := [@typeLiteralSIntExpression new !literalInt] ;
  outResultType := [@typeGalgas_sint new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @luint64 literalInt ;
  $unsigned_literal_integer64$ ?literalInt ;
  outExpression := [@typeLiteralUInt64Expression new !literalInt] ;
  outResultType := [@typeGalgas_uint64 new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit signed literal integer value                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @lsint64 literalInt ;
  $signed_literal_integer64$ ?literalInt ;
  outExpression := [@typeLiteralSInt64Expression new !literalInt] ;
  outResultType := [@typeGalgas_sint64 new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a literal character value                              *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @lchar literalChar ;
  $literal_char$ ?literalChar ;
  outExpression := [@typeLiteralCharExpression new !literalChar] ;
  outResultType := [@typeGalgas_char new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a double value                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  @ldouble literalDouble ;
  $literal_double$ ? literalDouble ?* ;
  outExpression := [@typeLiteralDoubleExpression new !literalDouble] ;
  outResultType := [@typeGalgas_double new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    here                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse unused ioEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap unused ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  $here$ ;
  outExpression := [@typeHereExpression new] ;
  outResultType := [@typeGalgas_location new] ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   description         :   [expression description]                           *
#   reader call         :   [expression reader !... ]                          *
#   constructor call    :   [@class method !... ]                              *
#   option value        :   [option option_component_name.option_name]         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
:
  $[$ ;
  select
  #--- Get source identity characteristics
    @typeExpression expressionValue ;
    @AC_galgasType expressionType ;
    <expression>
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expressionValue
      ?expressionType
    ;
    select
      $description$ ;
      outExpression := [@typeDescriptionInExpression new !expressionValue !here] ;
      outResultType := [@typeGalgas_string new] ;
    or
    #--- Get reader name
      @lstring methodName ;
      $identifier$ ? methodName ;
    #--- Search reader for getting formal parameters list
      @typeListeAttributsSemantiques accessorsTypeList ;
      @string conversionMethod ;
      handleReaderCall !expressionType !methodName ?accessorsTypeList ?outResultType ?conversionMethod ;
    #--- Actual parameters
      @typeExpressionList expressionList ;
      <output_expression_list>
        ?expressionList 
        !accessorsTypeList
        !ioEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
      ;
      outExpression := [@typeReaderCallInExpression new !expressionValue !methodName !expressionList !conversionMethod] ;
    end select ;
  or
  #--- Class name
    @lstring className ;
    $type_name$ ?className ;
  #--- Class method name
    @lstring mClassMethodName ;
    $identifier$ ? mClassMethodName ;
    @AC_semanticsEntity e ;
    [ioEntitiesMap searchKey !className ?e] ;
    outResultType := [(cast e if >= @typeEntiteType else error className) aDefType] ;
    # ¤ extract e->@typeEntiteType (?outResultType) error className : messageTypeEntite ;
    @typeListeAttributsSemantiques listeAttributsSemantiques ;
    [outResultType handleConstructorCall !mClassMethodName ?listeAttributsSemantiques] ;
  #--- Actual arguments
    @typeExpressionList expressionList ;
    <output_expression_list>
      ?expressionList
      !listeAttributsSemantiques
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
    ;
    outExpression := [@typeConstructorExpression new
      ![className string]
      ![mClassMethodName string]
      !expressionList
    ] ;
  or
    $option$ ;
    select
      $.$ ;
      @lstring optionName ;
      $identifier$ ?optionName ;
      if ([optionName string] != "verbose_output") then
        error optionName: "this option name does not correspond to a builtin option" ;
      end if ;
       outExpression := [@typeBoolOption new !"generic_galgas_cli_options" !optionName] ;
       outResultType := [@typeGalgas_bool new] ;
    or
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      [inOptionsComponentsMapForUse searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      $.$ ;
      @lstring optionName ;
      $identifier$ ?optionName ;
      if [boolOptionsMap hasKey ![optionName string]] then
        outExpression := [@typeBoolOption new ![optionComponentName string] !optionName] ;
        outResultType := [@typeGalgas_bool new] ;
      elsif [uintOptionsMap hasKey ![optionName string]] then
        outExpression := [@typeUIntOption new ![optionComponentName string] !optionName] ;
        outResultType := [@typeGalgas_uint new] ;
      elsif [stringOptionsMap hasKey ![optionName string]] then
        outExpression := [@typeStringOption new ![optionComponentName string] !optionName] ;
        outResultType := [@typeGalgas_string new] ;
      else
        error optionName : "the '" . [optionComponentName string] . "' option component has no '" . [optionName string] . "' option" 
          -> outExpression, outResultType ;
      end if ;
    end select ;
  end select ;
  $]$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E A D    A C C E S S    T O    A N    E N T I T Y                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <read_access>
  !@lstring nomVariable
  !@typeCplusPlusName nomCppEntite
  !@AC_galgasType typeEntite
  ?!@typeVariablesMap ioVariablesMap
:
  $identifier$ ? nomVariable ;
  [!?ioVariablesMap searchForReadOnlyAccess !nomVariable ?typeEntite ?nomCppEntite] ; 
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E A D    A C C E S S    T O    S E L F                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <read_access>
  !@lstring nomVariable
  !@typeCplusPlusName nomCppEntite
  !@AC_galgasType typeEntite
  ?!@typeVariablesMap ioVariablesMap
:
  $self$ ;
  if [ioVariablesMap hasKey !"self"] then
    nomVariable := [@lstring new !"self" !here] ;
    [!?ioVariablesMap searchForReadOnlyAccess !nomVariable ?typeEntite ?nomCppEntite] ;
  else
    error here: "'self' is not defined in this context"
     -> nomVariable, nomCppEntite, typeEntite ;
  end if ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#   O U T P U T    E X P R E S S I O N    L I S T                              *
#                                                                              *
#------------------------------------------------------------------------------*

rule <output_expression_list>
  !@typeExpressionList outExpressionList 
  ??@typeListeAttributsSemantiques inFormalAttributesList
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
:
  @typeTypesList effectiveTypesList [emptyList] ;
  outExpressionList := [@typeExpressionList emptyList] ;
  repeat
  while
    $!$ ;
    @typeExpression expression ;
    @AC_galgasType resultType ;
    <expression> 
      !ioEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expression
      ?resultType
    ;
    @location errorLocation := here ;
    effectiveTypesList += !resultType !errorLocation ;
    outExpressionList += !expression ;
  end repeat ;
  @location endOfListLocation := here ;
#--- Check types compatibility
  if [inFormalAttributesList length] < [effectiveTypesList length] then 
      error endOfListLocation : "too much expressions" ;
  elsif [inFormalAttributesList length] > [effectiveTypesList length] then
    error endOfListLocation : "one or more expressions missing" ;
  else
    foreach inFormalAttributesList (@AC_galgasType kFormalType @lstring kFormalParameterName),
            effectiveTypesList (@AC_galgasType kEffectiveType @location kErrorLocation) :
      checkAssignmentTypesCompatibility !kFormalType !kEffectiveType !kErrorLocation !true ;
    end foreach ;
  end if ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     I N P U T   P A R A M E T E R S   L IS T                              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <parse_effective_input_parameters_list>
  ?!@typeVariablesMap ioVariablesMap
  ?@typeListeAttributsSemantiques inFormalArgumentsList
  ?@location inVarLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
  !@bool outNoUsedParameter
:
  outNoUsedParameter := true ;
  $($ ;
  @L_nameWithType argumentsList [emptyList] ;
  repeat
  while
     select
      outNoUsedParameter := false ;
      @lstring typeName ;
      $type_name$ ? typeName ;
      @lstring constantName ;
      $identifier$ ? constantName ;
      argumentsList += !typeName !constantName ;
    or
      $*$ ;
      argumentsList += ![@lstring new !"" !here] ![@lstring new !"" !here] ;
    or
      @luint jokerCountWithLocation ;
      $unsigned_literal_integer$ ? jokerCountWithLocation ;
      $*$ ;
      @uint jokerCount := [jokerCountWithLocation uint] ;
      loop jokerCount + 1 :
      while jokerCount > 0 do
        argumentsList += ![@lstring new !"" !here] ![@lstring new !"" !here] ;
        jokerCount -- ;
      end loop ;
    end select ;
  end repeat ;
#--- Ellipsis ?
  @bool ellipsisFound ;
  select
    ellipsisFound := false ;
  or
    $...$ ;
     ellipsisFound := true ;
  end select ;
  $)$ ;
  buildMapWithLocalConstants
    !argumentsList
    !inFormalArgumentsList
    !?ioVariablesMap
    !inVarLocation
    !inLocalConstantStyle
    !ellipsisFound
  ;
end rule ;

#------------------------------------------------------------------------------*

end syntax ;
