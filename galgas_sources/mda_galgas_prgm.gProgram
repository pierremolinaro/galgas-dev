#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS LL1 program definition                                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

program mda_galgas_prgm "version GALGAS_BETA_VERSION" :
  import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
  import semantics optionSemantics in "optionSemantics.gSemantics" ;
  import semantics semanticsSemantics in "semanticsSemantics.gSemantics" ;
  import semantics semantics_semantics in "semantics_semantics.gSemantics" ;
  import semantics mda_galgas_routines in "mda_galgas_routines.gSemantics" ;
  import semantics projectCreation in "projectCreation.gSemantics" ;
  import semantics lexiqueCompilation in "lexiqueCompilation.gSemantics" ;
  import semantics grammarMetamodel in "grammarMetamodel.gSemantics" ;
  import semantics optionMetamodel in "optionMetamodel.gSemantics" ;
  import semantics optionCompilation in "optionCompilation.gSemantics" ;
  import semantics guiMetamodel in "guiMetamodel.gSemantics" ;
  import semantics guiCompilation in "guiCompilation.gSemantics" ;
  import semantics semanticsMetamodel in "semanticsMetamodel.gSemantics" ;
  import semantics syntaxMetamodel in "syntaxMetamodel.gSemantics" ;
  import semantics XcodeProjectGeneration in "XcodeProjectGeneration.gSemantics" ;

  import grammar galgas_LL1_grammar in "galgas_LL1_grammar.gGrammar" ;
  import grammar lexiqueLL1grammar in "lexiqueLL1grammar.gGrammar" ;
  import grammar syntaxSLRgrammar in "syntaxSLRgrammar.gGrammar" ;
  import grammar grammarLL1grammar in "grammarLL1grammar.gGrammar" ;
  import grammar guiLL1grammar in "guiLL1grammar.gGrammar" ;
  import grammar programSLRgrammar in "programSLRgrammar.gGrammar" ;
  import grammar projectLL1grammar in "projectLL1grammar.gGrammar" ;

#---------------------------------------------------------------------------*

before {
  @string creationProjectName := [option galgas_cli_options.create_project] ;
  projectCreation !creationProjectName ;
}

#---------------------------------------------------------------------------*

when . "ggs"
message "a '.ggs' GALGAS source file"
??@lstring inSourceFile {
  fixFileGenerationStartDirectory !inSourceFile ;
  @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
  @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
  @M_syntaxComponents syntaxComponentsMap [emptyMap] ;
  @M_grammarComponents grammarComponentsMap [emptyMap] ;
  @M_optionComponents optionComponentsMap [emptyMap] ;
  @EXsemanticContext semanticContext [new
    ![@M_filewrappers emptyMap]
    ![@stringset emptySet]
    ![@EXcategoryMethodMap emptyMap]
  ] ;
  grammar galgas_LL1_grammar in inSourceFile
    !?lexiqueMapForUse
    !?semanticsComponentsMap
    !?syntaxComponentsMap
    !?grammarComponentsMap
    !?optionComponentsMap
    !?semanticContext
  ;
}

#---------------------------------------------------------------------------*

when . "gOption"
message "a GALGAS option source file"
??@lstring inSourceFile {
  compileOptionComponent !inSourceFile !outputDirectory (!inSourceFile) ;
}

#---------------------------------------------------------------------------*

when . "gLexique"
message "a GALGAS lexique source file"
??@lstring inSourceFile {
  compileLexiqueComponent !inSourceFile !outputDirectory (!inSourceFile) ;
}

#---------------------------------------------------------------------------*

when . "gSemantics"
message "a GALGAS semantics source file"
??@lstring inSourceFile {
  @string outputDirectory ;
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
  ] ;
  compileSemanticsComponent !inSourceFile !outputDirectory (!inSourceFile) !?parsedComponentStruct;
}

#---------------------------------------------------------------------------*

when . "gSyntax"
message "a GALGAS syntax source file"
??@lstring inSourceFile {
  @syntaxComponentRoot syntaxComponentRoot ;
  grammar syntaxSLRgrammar in inSourceFile ? syntaxComponentRoot ;
}

#---------------------------------------------------------------------------*

when . "gGrammar"
message "a GALGAS grammar source file"
??@lstring inSourceFile {
  @grammarComponentRoot grammarComponentRoot ;
  grammar grammarLL1grammar in inSourceFile ?grammarComponentRoot ;
}

#---------------------------------------------------------------------------*

when . "gGui"
message "a GALGAS GUI source file"
??@lstring inSourceFile {
  compileGuiComponent !inSourceFile !outputDirectory (!inSourceFile) ;
}

#---------------------------------------------------------------------------*

when . "gProgram"
message "a GALGAS program source file"
??@lstring inSourceFile {
  @programComponentRoot programComponentRoot ;
  grammar programSLRgrammar in inSourceFile ? programComponentRoot ;
}

#------------------------------------------------------------------------------*
#                                                                              *
#          Project                                                             *
#                                                                              *
#---------------------------------------------------------------------------*

when . "gProject"
message "a GALGAS project source file"
??@lstring inSourceFile {
  @string outputDirectory := outputDirectory (!inSourceFile) ;
#--- Parse metamodel component
  @projectSourceList projectSourceList ;
  @location endOfSourceFile ;
  grammar projectLL1grammar in inSourceFile ?projectSourceList ?endOfSourceFile ;
#--- Check target names, file base name uniqueness, and build target file list
  @sourceFileMap sourceFileMap [emptyMap] ;
  @targetFileListMap targetFileListMap [emptyMap] ;
  foreach projectSourceList do
    @string baseName := [[[mFilePath string] lastPathComponent] stringByDeletingPathExtension] ;
    [!?sourceFileMap insertKey ![@lstring new !baseName ![mFilePath location]] ![mFilePath string] !mSourceKind] ;
    foreach mTargetList do
      if ([mValue string] != "makefile") & ([mValue string] != "xcode") then
        error mValue: "the target name should be \"makefile\" or \"xcode\"" ;
      else
        targetFileListMap += ![mValue string] !baseName ;
      end if ;
    end foreach ;
  end foreach ;
#--- Parset Component struct
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
  ] ;
#--- Parse galgas sources
  foreach projectSourceList do
    @string extension := [mFilePath pathExtension] ;
    @lstring fullFilePath [new
      ![inSourceFile stringByDeletingLastPathComponent] . "/" . [mFilePath string]
      ![mFilePath location]
    ] ;
    if mSourceKind != [@sourceFileKind externSourceFile] then
      message "----- Compiling '" . mFilePath . "'\n" ;
    end if ;
    switch mSourceKind
    when externSourceFile :
    when guiSourceFile :
      if extension == "gGui" then
        compileGuiComponent !fullFilePath !outputDirectory ;
      else
        error mFilePath:"extension of a gui component should be '.gGui'." ;
      end if ;
    when lexiqueSourceFile :
      if extension == "gLexique" then
        compileLexiqueComponent !fullFilePath !outputDirectory ;
      else
        error mFilePath:"extension of a lexique component should be '.gLexique'." ;
      end if ;
    when optionSourceFile :
      if extension == "gOption" then
        compileOptionComponent !fullFilePath !outputDirectory ;
      else
        error mFilePath:"extension of an option component should be '.gOption'." ;
      end if ;
    when semanticsSourceFile :
      if extension == "gSemantics" then
        compileSemanticsComponent !fullFilePath !outputDirectory !?parsedComponentStruct ;
      else
        error mFilePath:"extension of a semantics component should be '.gSemantics'." ;
      end if ;
    when syntaxSourceFile :
      if extension == "gSyntax" then
#        compileSyntaxComponent !fullFilePath !outputDirectory ;
      else
        error mFilePath:"extension of a syntax component should be '.gSyntax'." ;
      end if ;
    when grammarSourceFile :
      if extension == "gGrammar" then
#        compileGrammarComponent !fullFilePath !outputDirectory ;
      else
        error mFilePath:"extension of a grammar component should be '.gGrammar'." ;
      end if ;
    when programSourceFile :
      if extension == "gProgram" then
#       compileProgramComponent !fullFilePath !outputDirectory ;
      else
        error mFilePath:"extension of a program component should be '.gProgram'." ;
      end if ;
    end switch ;
  end foreach ;
#--- Perform global checkings
  if [@uint errorCount] == 0 then
    message "----- Perform global checkings\n" ;
    performProjectGlobalCheckings !parsedComponentStruct !endOfSourceFile ;
  end if ;
#--- Update file list for makefile
  if [@uint errorCount] == 0 then
    @stringlist makefileFiles := [targetFileListMap listForKey !"makefile"] ;
    if [makefileFiles length] > 0 then
      @string externSourceFileList := "" ;
      @string galgasSourceList := "" ;
      @stringset pathSet [emptySet] ;
      pathSet += !"SOURCES_DIR += ../hand_coded_sources\n" ;
      foreach makefileFiles do
        @string fullPath ;
        @sourceFileKind sourceKind ;
        [sourceFileMap searchKey ![@lstring new !mValue !here] ?fullPath ?sourceKind] ;
        @string filePath := [fullPath stringByDeletingLastPathComponent] ;
        if sourceKind == [@sourceFileKind externSourceFile] then
          if [filePath firstCharacterOrNul] == '/' then
            pathSet += !"SOURCES_DIR += " . filePath . "\n" ;
          elsif filePath != "" then
            pathSet += !"SOURCES_DIR += ../hand_coded_sources/" . filePath . "\n" ;
          end if ;
          externSourceFileList .= "SOURCES += " . [fullPath lastPathComponent] . "\n" ;
        else
          galgasSourceList .= "SOURCES += " . [[fullPath lastPathComponent] stringByDeletingPathExtension] . ".cpp\n" ;
        end if ;
      end foreach ;
      @string pathesString := "" ;
      foreach pathSet do
        pathesString .= key ;
      end foreach ;
      @string newFileListContents := [filewrapper fileListTemplateFileWrapper.fileListTemplate
        !pathesString
        !galgasSourceList
        !externSourceFileList
      ] ;
      @string fileListPath := outputDirectory . "/file_list.mke" ;
      [newFileListContents writeToFileWhenDifferentContents !fileListPath ?*] ;
    end if ;
  end if ;
#--- Update Xcode project
  @stringlist xcodeFiles := [targetFileListMap listForKey !"xcode"] ;
  if ([@uint errorCount] == 0) & ([xcodeFiles length] > 0) then
    @string XcodeProjectDir := [[[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] . "/project_xcode" ;
    #log XcodeProjectDir ;
    @stringlist iconFiles := [XcodeProjectDir regularFilesWithExtensions !false ![@stringlist listWithValue !"icns"]] ;
    @stringlist xcodeProjects := [XcodeProjectDir directoriesWithExtensions !false ![@stringlist listWithValue !"xcodeproj"]] ;
    #log xcodeProjects ;
    if [xcodeProjects length] == 0 then
      message "****** Cannot update Xcode project, no project found in '" . XcodeProjectDir . "' directory. ********\n" ;
    elsif [xcodeProjects length] > 1 then
      message "****** Cannot update Xcode project, more than one project exist in '" . XcodeProjectDir . "' directory. ********\n" ;
    elsif [xcodeProjects length] == 1 then
      @string name ; [xcodeProjects first ?name] ;
      @string fullXcodePath := XcodeProjectDir . "/" . name . "/project.pbxproj" ;
      @stringset externSourceSet [emptySet] ;
      @stringset guiSourceSet [emptySet] ;
      @stringset scannerSourceSet [emptySet] ;
      @stringset optionSourceSet [emptySet] ;
      @stringset semanticsSourceSet [emptySet] ;
      @stringset syntaxSourceSet [emptySet] ;
      @stringset grammarSourceSet [emptySet] ;
      @stringset programSourceSet [emptySet] ;
    #--- Build intermediate list
      @string intermediateString := "# Intermediate file for Xcode Project\n" ;
      foreach xcodeFiles do
        intermediateString .= mValue . "\n" ;
      end foreach ;
    #--- Update intermediate file
      @string intermediateFilePath := [inSourceFile string] . "/file_list_for_xcode_project.txt" ;
      @bool written ;
      [intermediateString writeToFileWhenDifferentContents !intermediateFilePath ?written] ;
    #--- If intermediate file did change, update Xcode project
      if written then
        foreach xcodeFiles do
          @string fullPath ;
          @sourceFileKind sourceKind ;
          [sourceFileMap searchKey ![@lstring new !mValue !here] ?fullPath ?sourceKind] ;
          switch sourceKind 
          when externSourceFile :
            externSourceSet += !fullPath ;
          when lexiqueSourceFile :
            scannerSourceSet += !mValue ;
          when guiSourceFile :
            guiSourceSet += !mValue ;
          when optionSourceFile :
            optionSourceSet += !mValue ;
          when syntaxSourceFile :
            syntaxSourceSet += !mValue ;
          when semanticsSourceFile :
            semanticsSourceSet += !mValue ;
          when grammarSourceFile :
            grammarSourceSet += !mValue ;
          when programSourceFile :
            programSourceSet += !mValue ;
          end switch ;
        end foreach ;
      #--- Build intermediate
        generateXcodeProject
          !externSourceSet
          !guiSourceSet
          !scannerSourceSet
          !optionSourceSet
          !semanticsSourceSet
          !syntaxSourceSet
          !grammarSourceSet
          !programSourceSet
          ![name stringByDeletingPathExtension] # XCode project base name
          ![fullXcodePath stringByDeletingLastPathComponent] # Full Path of xxx.xcodeproj file
          !iconFiles
        ;
      end if ;
    end if ;
  end if ;
}

#---------------------------------------------------------------------------*

after {
}

#---------------------------------------------------------------------------*

end program ;

#---------------------------------------------------------------------------*
