#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS scanner component parser definition                               *
#                                                                           *
#  Copyright (C) 1997, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax scanner_parser :

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics scanner_semantics in "scanner_semantics.gSemantics" ;

#-------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

extern routine buildLexicalRulesFromList
  ?!@typeTableMotsReserves keyWordsMap
  ?!@typeListeTestsEtInstructions outLexicalRulesList ;

nonterminal <style_declaration>
  ?!@M_styles ioStylesMap
  ?!@styleList ioStyleList
label parse
;

nonterminal <template_declaration>
  ??@bool inIsTemplate
  ?!@templateDelimiterMap ioTemplateDelimiterMap
label parse
;

nonterminal <replace_declaration>
  ??@bool inIsTemplate
  ?!@templateReplacementMap ioTemplateReplacementMap
label parse
;

nonterminal <attribute_or_terminal_symbol_declaration>
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeLexicalAttributesMap table_attributs
  ?!@M_terminalSymbolsMapForUse ioTerminalSymbolsMapForUse
  ??@EXLexicalTypeMap inLexicalTypeMap
  ??@M_styles ioStylesMap
  ??@bool inIsTemplate
label parse
;

nonterminal <key_words_list_declaration>
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@typeLexicalAttributesMap table_des_attributs
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@M_terminalSymbolsMapForUse ioTerminalSymbolsMapForUse
  ??@M_styles ioStylesMap
  ?!@tokensInListMap ioTokensInListMap
  ??@bool inIsTemplate
label parse
;

nonterminal <lexical_error_message_declaration>
  ?!@typeTableMessagesErreurs tableMessagesErreurs
label parse
;

nonterminal <while_branches_list>
  !@typeListeTestsEtInstructions liste_tests_et_instructions
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
label parse
;

nonterminal <lexical_rule>
  ?!@typeListeTestsEtInstructions ioLexicalRulesList
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
label parse
;

nonterminal <lexical_instructions_list>
  !@tListeInstructionsLexicales listeInstructions
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
  ??@tagMap inTagMap
  ??@bool inCanSendTerminal
label parse
;

nonterminal <lexical_when_branches_list>
  !@typeListeTestsEtInstructions lexicalRulesList
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
  ??@tagMap inTagMap
  ??@bool inCanSendTerminal
label parse
;

nonterminal <lexical_default_branch>
  !@tListeInstructionsLexicales liste_instructions_sinon
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
  ??@tagMap inTagMap
  ??@bool inCanSendTerminal
label parse
;

nonterminal <lexical_test_expression>
  !@typeListeConditionsLexicales listeConditionsLexicales
label parse
;

nonterminal <lexical_test_term>
  !@typeConditionLexicale conditionLexicale
label parse
;

nonterminal <lexical_parameters_non_empty_list>
  !@typeListeArgumentsRoutExterne listeArgumentsRoutExterne
  ?!@typeLexicalAttributesMap tableDesAttributs
label parse
;

nonterminal <lexical_error_messages_list>
  ?!@typeListeMessagesErreur listeMessagesErreur
  ?!@typeTableMessagesErreurs tableMessagesErreurs
  ?!@stringset ioUsedErrorMessageSet
label parse
;

nonterminal <lexical_send_or_error>
  !@typeEmissionParDefaut emissionParDefaut
  ?!@typeTableMessagesErreurs tableMessagesErreurs
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@stringset ioUsedErrorMessageSet
label parse
;

nonterminal <lexical_parameter>
  !@typeArgumentRoutineExterne argumentRoutineExterne
  ?!@typeLexicalAttributesMap table_attributs
label parse
;

nonterminal <lexical_send_instruction>
  !@typeInstructionLexicale instruction
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
label parse
;

extern routine generate_scanner
  ??@bool inIsTemplate
  ??@templateDelimiterMap inTemplateDelimiterMap
  ??@templateReplacementMap inTemplateReplacementMap
  ??@lstring lexiqueName 
  ??@typeLexicalAttributesMap table_attributs
  ??@typeTableDefinitionTerminaux table_des_terminaux
  ??@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ??@typeListeTestsEtInstructions lexicalRulesList
  ??@typeTableMessagesErreurs table_messages
  ??@styleList styleList
  ??@stringset inUsedErrorMessageSet
  ??@tokensInListMap inTokensInListMap
;

nonterminal <extern_routine_or_function_declaration> ;

#-------------------------------------------------------------------*

routine buildLexicalTypeMap !@EXLexicalTypeMap outLexicalTypeMap :
  outLexicalTypeMap := [@EXLexicalTypeMap emptyMap] ;

  [!?outLexicalTypeMap insertKey ![@lstring new !"string" !here] ![@typeGalgas_lstring new]] ;

  [!?outLexicalTypeMap insertKey ![@lstring new !"char" !here] ![@typeGalgas_lchar new]] ;

  [!?outLexicalTypeMap insertKey ![@lstring new !"uint" !here] ![@typeGalgas_luint new]] ;

  [!?outLexicalTypeMap insertKey ![@lstring new !"sint" !here] ![@typeGalgas_lsint new]] ;

  [!?outLexicalTypeMap insertKey ![@lstring new !"uint64" !here] ![@typeGalgas_luint64 new]] ;

  [!?outLexicalTypeMap insertKey ![@lstring new !"sint64" !here] ![@typeGalgas_lsint64 new]] ;

  [!?outLexicalTypeMap insertKey ![@lstring new !"bool" !here] ![@typeGalgas_lbool new]] ;

  [!?outLexicalTypeMap insertKey ![@lstring new !"double" !here] ![@typeGalgas_ldouble new]] ;
end routine ;

#-------------------------------------------------------------------*
#                   Lexical component                               *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
#--- Lexique header
  @bool isTemplate ;
  select
    isTemplate := false ;
  or
    $template$ ;
    isTemplate := true ;
  end select ;
  $lexique$ ;
  @lstring lexiqueName ;
  $identifier$ ? lexiqueName ;
  @string basename := [[[@string stringWithSourceFilePath] lastPathComponent] stringByDeletingPathExtension] ;
  if [lexiqueName string] != basename then
    warning lexiqueName: "GALGAS 1.7.5 and later checks "
      "the component name ('" . [lexiqueName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
  $:$ ;
#--- Errors messages, key words, attributes, terminal symbols and rules
  @M_terminalSymbolsMapForUse terminalSymbolsMapForUse [emptyMap] ;
  @typeLexicalAttributesMap table_attributs [emptyMap] ;
  @typeTableDefinitionTerminaux table_des_terminaux [emptyMap] ;
  @typeTableMessagesErreurs table_messages [emptyMap] ;
  @typeTableTablesDeMotsReserves table_tables_mots_reserves [emptyMap] ;
  @typeListeTestsEtInstructions lexicalRulesList [emptyList] ;
  @stringset usedErrorMessageSet [emptySet] ;
  @tokensInListMap tokensInListMap [emptyMap] ;
  @templateDelimiterMap templateDelimiterMap [emptyMap] ;
  @templateReplacementMap templateReplacementMap [emptyMap] ;
#--- Define lexical types
  @EXLexicalTypeMap lexicalTypeMap ;
  buildLexicalTypeMap ?lexicalTypeMap ;

#-- Styles map
  @M_styles stylesMap [emptyMap] ;
  @lstring defaultStringIdentifier [new !"" !here] ;
  [!?stylesMap insertKey !defaultStringIdentifier] ;
  @styleList styleList [emptyList] ;
  styleList += !"" !"Default style" ;
  repeat
  while 
    <extern_routine_or_function_declaration> ;
  while 
    <style_declaration> !?stylesMap !?styleList ;
  while
    <template_declaration>
     !isTemplate
     !?templateDelimiterMap
    ;
  while
    <replace_declaration>
      !isTemplate
      !?templateReplacementMap
    ;
  while
    <attribute_or_terminal_symbol_declaration>
      !?table_des_terminaux
      !?table_attributs
      !?terminalSymbolsMapForUse
      !lexicalTypeMap
      !stylesMap
      !isTemplate
    ;
  while
    <key_words_list_declaration>
      !?table_tables_mots_reserves
      !?table_attributs
      !?table_des_terminaux
      !?terminalSymbolsMapForUse
      !stylesMap
      !?tokensInListMap
      !isTemplate
    ;
  while
    <lexical_error_message_declaration>
      !?table_messages
    ;
  while
    $rule$ ;
    <lexical_rule>
      !?lexicalRulesList
      !?table_des_terminaux
      !?table_messages
      !?table_attributs
      !?table_tables_mots_reserves
      !?usedErrorMessageSet
    ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
#--- Warn unused error messages
  foreach table_messages (@lstring kKey *) do
    if not [usedErrorMessageSet hasKey ![kKey string]] then
      warning kKey:"this error message is not used" ;
    end if ;
  end foreach ;
#--- Enter lexique in lexique map
  [!?ioLexiqueMapForUse insertKey !lexiqueName !terminalSymbolsMapForUse] ;
#--- For a template lexique, al least one template should be defined
  if isTemplate & ([templateDelimiterMap count] == 0) then
    error here: "a template lexique should define at least one template" ;
  end if ;
#--- Generate scanner
  generate_scanner
    !isTemplate
    !templateDelimiterMap
    !templateReplacementMap
    !lexiqueName 
    !table_attributs
    !table_des_terminaux
    !table_tables_mots_reserves
    !lexicalRulesList
    !table_messages
    !styleList
    !usedErrorMessageSet
    !tokensInListMap
  ;
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
:
  select
  or
    $template$ ;
  end select ;
  $lexique$ ;
  @lstring lexiqueName ;
  $identifier$ ? lexiqueName ;
  $:$ ;
  @M_terminalSymbolsMapForUse terminalSymbolsMapForUse [emptyMap] ;
  @typeLexicalAttributesMap table_attributs [emptyMap] ;
  @typeTableDefinitionTerminaux table_des_terminaux [emptyMap] ;
  @typeTableMessagesErreurs table_messages [emptyMap] ;
  @typeTableTablesDeMotsReserves table_tables_mots_reserves [emptyMap] ;
  @typeListeTestsEtInstructions lexicalRulesList [emptyList] ;
  @tokensInListMap tokensInListMap [emptyMap] ;
#--- Define lexical types
  @EXLexicalTypeMap lexicalTypeMap ;
  buildLexicalTypeMap ?lexicalTypeMap ;
#-- Styles map
  @M_styles stylesMap [emptyMap] ;
  @lstring defaultStringIdentifier [new !"" !here] ;
  [!?stylesMap insertKey !defaultStringIdentifier] ;
  @styleList styleList [emptyList] ;
  styleList += !"" !"Default style" ;
  repeat
  while 
    <extern_routine_or_function_declaration> ;
  while 
    <style_declaration> !? stylesMap !? styleList ;
  while
    <template_declaration> parse ;
  while
    <replace_declaration> parse ;
  while
    <attribute_or_terminal_symbol_declaration>
      !?table_des_terminaux
      !?table_attributs
      !?terminalSymbolsMapForUse
      !lexicalTypeMap
      !stylesMap
      !true # For not raising error messages
    ;
  while
    <key_words_list_declaration>
      !?table_tables_mots_reserves
      !?table_attributs
      !?table_des_terminaux
      !?terminalSymbolsMapForUse
      !stylesMap
      !?tokensInListMap
      !true # For not raising error messages
    ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
#--- Enter lexique in lexique map
  [!?ioLexiqueMapForUse insertKey !lexiqueName !terminalSymbolsMapForUse] ;
  $end$ ;
  $lexique$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  select
  or
    $template$ ;
  end select ;
  $lexique$ ;
  $identifier$ ? * ;
  $:$ ;
  repeat
  while 
    <extern_routine_or_function_declaration> ;
  while 
    <style_declaration> parse;
  while
    <template_declaration> parse ;
  while
    <replace_declaration> parse ;
  while
    <attribute_or_terminal_symbol_declaration> parse ;
  while
    <key_words_list_declaration> parse ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  select
  or
    $template$ ;
  end select ;
  $lexique$ ;
  $identifier$ ? * ;
  $:$ ;
  repeat
  while 
    <extern_routine_or_function_declaration> ;
  while 
    <style_declaration> parse ;
  while
    <template_declaration> parse ;
  while
    <replace_declaration> parse ;
  while
    <attribute_or_terminal_symbol_declaration> parse ;
  while
    <key_words_list_declaration> parse ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  select
  or
    $template$ ;
  end select ;
  $lexique$ ;
  $identifier$ ? * ;
  $:$ ;
  repeat
  while 
    <extern_routine_or_function_declaration> ;
  while 
    <style_declaration> parse ;
  while
    <template_declaration> parse ;
  while
    <replace_declaration> parse ;
  while
    <attribute_or_terminal_symbol_declaration> parse ;
  while
    <key_words_list_declaration> parse ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  select
  or
    $template$ ;
  end select ;
  $lexique$ ;
  $identifier$ ? * ;
  $:$ ;
  repeat
  while 
    <extern_routine_or_function_declaration> ;
  while 
    <style_declaration> parse ;
  while
    <template_declaration> parse ;
  while
    <replace_declaration> parse ;
  while
    <attribute_or_terminal_symbol_declaration> parse ;
  while
    <key_words_list_declaration> parse ;
  while
    <lexical_error_message_declaration> parse ;
  while
    $rule$ ;
    <lexical_rule> parse ;
    $;$ ;
  end repeat ;
  $end$ ;
  $lexique$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#   S T Y L E    D E C L A R A T I O N                              *
#-------------------------------------------------------------------*

rule <style_declaration>
  ?!@M_styles ioStylesMap
  ?!@styleList ioStyleList
:
  $style$ ;
  repeat
    @lstring styleName ;
    $identifier$ ? styleName ;
    $->$ ;
    @lstring title ;
    $literal_string$ ? title ;
    [!?ioStylesMap insertKey !styleName] ;
    ioStyleList += ![styleName string] ![title string] ;
  while $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#           template declaration                                    *
#-------------------------------------------------------------------*

rule <template_declaration>
  ??@bool inIsTemplate
  ?!@templateDelimiterMap ioTemplateDelimiterMap
:
  $template$ ;
#--- Check lexique is declared as template lexique
  if not inIsTemplate then
    error here: "the lexique should be declared as template lexique" ;
  end if ;
  @lstring startString ;
  $literal_string$ ? startString ;
  @bool preservesStartDelimiter ;
  select
    $feature$ ;
    $identifier$ ? @lstring name ;
    if [name string] != "preserved" then
      error name: "only the 'preserved' tag is allowed here" ;
    end if ;
    preservesStartDelimiter := true ;
  or
    preservesStartDelimiter := false ;
  end select ;
  $...$ ;
  @lstring endString ;
  $literal_string$ ? endString ;
  $;$ ;
  [!?ioTemplateDelimiterMap insertKey !startString !preservesStartDelimiter !endString] ;
end rule ;

#-------------------------------------------------------------------*
#           template replacement                                    *
#-------------------------------------------------------------------*

rule <replace_declaration>
  ??@bool inIsTemplate
  ?!@templateReplacementMap ioTemplateReplacementMap
:
  $replace$ ;
#--- Check lexique is declared as template lexique
  if not inIsTemplate then
    error here: "the lexique should be declared as template lexique" ;
  end if ;
  $literal_string$ ? @lstring startString ;
  select
    $...$ ;
    $literal_string$ ? @lstring endString ;
    $:$ ;
    $identifier$ ? @lstring replacementFunction ;
    [!?ioTemplateReplacementMap insertKey !startString !endString !replacementFunction] ;
  or
    $->$ ;
    $literal_string$ ? @lstring endString ;
    [!?ioTemplateReplacementMap insertKey !startString !endString ![@lstring new !"" !here]] ;
  end select ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#           Attribute or terminal symbol declaration                *
#-------------------------------------------------------------------*

rule <attribute_or_terminal_symbol_declaration>
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeLexicalAttributesMap table_des_attributs
  ?!@M_terminalSymbolsMapForUse ioTerminalSymbolsMapForUse
  ??@EXLexicalTypeMap inLexicalTypeMap
  ??@M_styles ioStylesMap
  ??@bool inIsTemplate
:
  select
  #--- semantics attribut
    @lstring typeName ;
    $type_name$ ? typeName ;
    @AC_galgasType attributeType ;
    [inLexicalTypeMap searchKey !typeName ?attributeType] ;
    @lstring attributeName ;
    $identifier$ ?attributeName ;
    [!?table_des_attributs insertKey !attributeName !attributeType] ;
  #--- Terminal symbol
  or
    @lstring nomTerminal ;
    $terminal$ ? nomTerminal ;
    @typeListeAttributsSemantiques attributeList [emptyList];
    repeat
    while
      $!$ ;
      @lstring idf ;
      $identifier$ ? idf ;
      @AC_galgasType t ;
      [table_des_attributs searchKey !idf ?t] ;
      attributeList += !t !idf ;
    end repeat ;
    @lstring errorMessage ;
    $error$ ;
    $message$ ;
    $literal_string$ ? errorMessage ;
    [!?ioTerminalSymbolsMapForUse insertKey !nomTerminal ! attributeList] ;
  #--- Style ?
    @lstring styleName ;
    select
     styleName := [@lstring new !"" !here] ;
    or
      $style$ ;
      $identifier$ ? styleName ;
    end select ;
    @luint styleIndex ;
    [ioStylesMap searchKeyGetID !styleName ?styleIndex] ;
    @string errorMessageString := [errorMessage string] ;
   #--- Template End Mark
    @bool isTemplateEndMark ;
    select
     isTemplateEndMark := false ;
    or
      $feature$ ;
      if not inIsTemplate then
        error here: "for using this construct, the lexique should have been declared as a template lexique" ;       end if ;
      $identifier$ ? @lstring mark ;
      if [mark string] != "templateEndMark" then
        error mark: "only 'templateEndMark' is allowed here" ;
      end if ;
      isTemplateEndMark := true ;
    end select ;
    [!?table_des_terminaux insertKey !nomTerminal !errorMessageString !attributeList !styleIndex !isTemplateEndMark] ;
  end select ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#                declaration des listes de mots reserves            *
#-------------------------------------------------------------------*

rule <key_words_list_declaration>
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@typeLexicalAttributesMap table_des_attributs
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@M_terminalSymbolsMapForUse ioTerminalSymbolsMapForUse
  ??@M_styles ioStylesMap
  ?!@tokensInListMap ioTokensInListMap
  ??@bool inIsTemplate
:
  $list$ ;
  @typeTableMotsReserves entriesMap [emptyMap] ;
#--- List name
  @lstring listName ;
  $identifier$ ? listName ;
#--- Attribute List
  @typeListeAttributsSemantiques attributeList [emptyList];
  repeat
  while
    $!$ ;
    @lstring idf ;
    $identifier$ ? idf ;
    @AC_galgasType t ;
    [table_des_attributs searchKey !idf ?t] ;
    attributeList += !t !idf ;
  end repeat ;
#--- Error message
  $error$ ;
  $message$ ;
  @lstring errorMessage ;
  $literal_string$ ?errorMessage ;
  check_K_escapeCharacters !errorMessage ;
 #--- Style
  @lstring styleName ;
  select
    styleName := [@lstring new !"" !here] ;
  or
    $style$ ;
    $identifier$ ? styleName ;
  end select ;
  @luint styleIndex ;
  [ioStylesMap searchKeyGetID !styleName ?styleIndex] ;
#--- List of entries
  $:$ ;
  repeat
    @lstring listEntry ;
    $literal_string$ ?listEntry ;
  #--- Associated terminal symbol
    @lstring terminalSymbolName ;
    select
      $->$ ;
      $terminal$ ?terminalSymbolName ;
    or
      terminalSymbolName := listEntry ;
    end select ;
  #--- Template End Mark
   @bool isTemplateEndMark ;
   select
    isTemplateEndMark := false ;
   or
     $feature$ ;
     if not inIsTemplate then
       error here: "for using this construct, the lexique should have been declared as a template lexique" ;
     end if ;
     $identifier$ ? @lstring mark ;
     if [mark string] != "templateEndMark" then
       error mark: "only 'templateEndMark' is allowed here" ;
     end if ;
     isTemplateEndMark := true ;
   end select ;
  #--- Build decoder tables
    [!?ioTokensInListMap insertKey !listEntry !terminalSymbolName] ;
  #--- Build error message
    @string specificErrorMessageString := [[errorMessage string] stringByReplacingStringByString !"%K" ![terminalSymbolName string]] ;
  #--- Insert terminal in terminal symbols map
    [!?table_des_terminaux insertKey
      !terminalSymbolName
      !specificErrorMessageString
      !attributeList
      !styleIndex
      !isTemplateEndMark
    ] ;
    [!?ioTerminalSymbolsMapForUse insertKey !terminalSymbolName !attributeList] ;
  #--- Insert entry in the entries map
    [!?entriesMap insertKey !listEntry !terminalSymbolName] ;
  while
    $,$ ;
  end repeat ;
  [!?table_tables_mots_reserves insertKey !listName !entriesMap] ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*
#             declaration de la list des messages d'error           *
#-------------------------------------------------------------------*

rule <lexical_error_message_declaration>
  ?!@typeTableMessagesErreurs table_messages
:
  $message$ ;
  @lstring nom ;
  $identifier$ ? nom ;
  $:$ ;
  @lstring errorMessage ;
  $literal_string$ ?errorMessage ;
  [!?table_messages insertKey !nom !errorMessage] ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <while_branches_list>
  !@typeListeTestsEtInstructions liste_tests_et_instructions
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
:
  liste_tests_et_instructions := [@typeListeTestsEtInstructions emptyList] ;
  repeat
    select
      $while$ ;
      $~$ ;
      @typeListeConditionsLexicales lcl [emptyList] ;
      @lstringlist stringList [emptyList] ;
      repeat
        @lstring ch ;
        $literal_string$ ? ch ;
        stringList += !ch ;
      while
        $,$ ;
      end repeat ;
      $error$ ;
      @lstring errorMessageName ;
      $identifier$ ? errorMessageName ;
      @luint errorMessageIndex ;
      [table_des_messages_erreur searchKeyGetID !errorMessageName ?errorMessageIndex ?*] ;
      ioUsedErrorMessageSet += ![errorMessageName string] ;
      lcl += ![@typeConditionNonChaine new !stringList !errorMessageIndex] ;
      $:$ ;
      @tListeInstructionsLexicales li ;
      <lexical_instructions_list>
        ?li
        !?table_des_terminaux
        !?table_des_messages_erreur
        !?table_attributs
        !?table_tables_mots_reserves
        !?ioUsedErrorMessageSet
        ![@tagMap emptyMap]
        !false
      ;
      liste_tests_et_instructions += !lcl !li ;
    or
      @typeListeConditionsLexicales lcl [emptyList] ;
      $while$ ;
      <lexical_test_expression> ? lcl ;
      $:$ ;
      @tListeInstructionsLexicales li ;
      <lexical_instructions_list>
        ?li
        !?table_des_terminaux
        !?table_des_messages_erreur
        !?table_attributs
        !?table_tables_mots_reserves
        !?ioUsedErrorMessageSet
        ![@tagMap emptyMap]
        !false
      ;
      liste_tests_et_instructions += !lcl !li ;
    end select ;
  while
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_test_expression>
  !@typeListeConditionsLexicales liste_test
:
  liste_test := [@typeListeConditionsLexicales emptyList] ;
  repeat
    @typeConditionLexicale c ;
    <lexical_test_term> ?c ;
    liste_test += !c ;
  while
    $|$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_test_term>
  !@typeConditionLexicale tt
:
  $identifier$ ? @lstring unicodeCharSetName ;
  tt := [@typeUnicodeCharSet new !unicodeCharSetName] ;
#--- Test charset
  @stringset availableCharSet [emptySet] ;
  availableCharSet += !"isUnicodeLetter" ;
  availableCharSet += !"isUnicodeMark" ;
  availableCharSet += !"isUnicodeNumber" ;
  availableCharSet += !"isUnicodeDecimalDigit" ;
  availableCharSet += !"isUnicodeASCIIHexDigit" ;
  availableCharSet += !"isUnicodeSeparator" ;
  availableCharSet += !"isUnicodeCommand" ;
  availableCharSet += !"isUnicodePunctuation" ;
  availableCharSet += !"isUnicodeSymbol" ;
  if not [availableCharSet hasKey ![unicodeCharSetName string]] then
    error unicodeCharSetName:"unknown Unicode character set" ;
  end if ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_test_term>
  !@typeConditionLexicale tt
:
  @lstring ch ;
  $literal_string$ ? ch ;
  tt := [@typeConditionChaine new !ch] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_test_term>
  !@typeConditionLexicale tt
:
  @lchar c ;
  $literal_char$ ? c ;
  select
    tt := [@typeConditionCaractere new !c] ;
  or
    $->$ ;
    @lchar bs ;
    $literal_char$ ? bs ; # borne sup de l'intervalle
    tt := [@typeConditionIntervalle new !c !bs] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_rule>
  ?!@typeListeTestsEtInstructions ioLexicalRulesList
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
:
  @typeListeConditionsLexicales lcl ;
  <lexical_test_expression> ? lcl ;
  $:$ ;
  @tListeInstructionsLexicales li ;
  <lexical_instructions_list>
    ?li
    !?table_des_terminaux
    !?table_des_messages_erreur
    !?table_attributs
    !?table_tables_mots_reserves
    !?ioUsedErrorMessageSet
    ![@tagMap emptyMap]
    !true
  ;
  ioLexicalRulesList += !lcl !li ;
  $end$ ;
  $rule$ ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_rule>
  ?!@typeListeTestsEtInstructions ioLexicalRulesList
  ?!@typeTableDefinitionTerminaux unused table_des_terminaux
  ?!@typeTableMessagesErreurs unused table_des_messages_erreur
  ?!@typeLexicalAttributesMap unused table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset unused ioUsedErrorMessageSet
:
  $list$ ;
#--- Get list name
  @lstring listName ;
  $identifier$ ?listName ;
#--- Search list name
  @typeTableMotsReserves keyWordsMap ;
  [table_tables_mots_reserves searchKey !listName ?keyWordsMap] ;
#--- Build lexical analyser rules
  buildLexicalRulesFromList !?keyWordsMap !?ioLexicalRulesList ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_instructions_list>
  !@tListeInstructionsLexicales li
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
  ??@tagMap inTagMap
  ??@bool inCanSendTerminal
:
  @tagMap tagMap [mapWithMapToOverride !inTagMap] ;
  li := [@tListeInstructionsLexicales emptyList] ;
  repeat
  while
    @lstring nom_routine_externe ;
    $identifier$ ? nom_routine_externe ;
    @typeListeArgumentsRoutExterne lare ;
    <lexical_parameters_non_empty_list> ? lare !?table_attributs ;
    @typeListeMessagesErreur lme [emptyList] ;
    <lexical_error_messages_list>
      !?lme
      !?table_des_messages_erreur
      !?ioUsedErrorMessageSet
    ;
    $;$ ;
    @typeInstructionLexicale e := [@typeInstructionActionExterne new !nom_routine_externe !lare !lme] ;
    li += !e ;
  while
    $select$ ;
    @typeListeTestsEtInstructions list_branches_si ;
    <lexical_when_branches_list> 
      ?list_branches_si
      !?table_des_terminaux
      !?table_des_messages_erreur
      !?table_attributs
      !?table_tables_mots_reserves
      !?ioUsedErrorMessageSet
      !tagMap
      !inCanSendTerminal
    ;
    @tListeInstructionsLexicales liste_instructions_sinon ;
    <lexical_default_branch>
       ?liste_instructions_sinon
       !?table_des_terminaux
       !?table_des_messages_erreur
       !?table_attributs
       !?table_tables_mots_reserves
       !?ioUsedErrorMessageSet
       !tagMap
       !inCanSendTerminal
    ;
    $end$ ;
    $select$ ;
    $;$ ;
    @typeInstructionLexicale e ;
    e := [@typeInstructionSiLexical new !list_branches_si !liste_instructions_sinon] ;
    li += !e ;
  while
    $repeat$ ;
    @tListeInstructionsLexicales lii ;
    <lexical_instructions_list>
      ?lii
      !?table_des_terminaux
      !?table_des_messages_erreur
      !?table_attributs
      !?table_tables_mots_reserves
      !?ioUsedErrorMessageSet
      ![@tagMap emptyMap]
      !false
    ;
    @typeListeTestsEtInstructions ltq ;
    <while_branches_list>
      ?ltq
      !?table_des_terminaux
      !?table_des_messages_erreur
      !?table_attributs
      !?table_tables_mots_reserves
      !?ioUsedErrorMessageSet
    ;
    $end$ ;
    $repeat$ ;
    $;$ ;
    li += ![@typeInstructionRepetitionLexicale new !lii !ltq] ;
  while
    $tag$ ;
    @lstring tagIdentifier ;
    $identifier$ ?tagIdentifier ;
    [!?tagMap insertKey !tagIdentifier] ;
    li += ![@typeLexicalTagInstruction new !tagIdentifier] ;
    $;$ ;
  while
    $log$ ;
    $;$ ;
    li += ![@typeLexicalLogInstruction new] ;
  while
    $rewind$ ;
    if not inCanSendTerminal then
      error here : "the rewind instruction cannot be used within a repeat instruction" ;
    end if ;
    @lstring tagIdentifier ;
    $identifier$ ?tagIdentifier ;
    [tagMap searchKey !tagIdentifier] ;
    $send$ ;
    @lstring nomTerminal ;
    $terminal$ ?nomTerminal ;
    [table_des_terminaux searchKey !nomTerminal ?* ?* ?* ?*] ;
    li += ![@typeLexicalRewindAndSendInstruction new !tagIdentifier !nomTerminal] ;
    $;$ ;
  while
    $drop$ ;
    if not inCanSendTerminal then
      error here : "the drop instruction cannot be used within a repeat instruction" ;
    end if ;
    @lstring nomTerminal ;
    $terminal$ ?nomTerminal ;
    $;$ ;
    [table_des_terminaux searchKey !nomTerminal ?* ?* ?* ?*] ;
    li += ![@typeLexicalDropInstruction new !nomTerminal] ;
  while
    $send$ ;
    if not inCanSendTerminal then
      error here : "the send instruction cannot be used within a repeat instruction" ;
    end if ;
    @typeInstructionLexicale e ;
    <lexical_send_instruction>
      ?e
      !?table_des_terminaux
      !?table_des_messages_erreur
      !?table_attributs
      !?table_tables_mots_reserves
      !?ioUsedErrorMessageSet
    ;
    $;$ ;
    li += !e ;
  while
    $error$ ;
    @lstring errorMessageName ;
    $identifier$ ?errorMessageName ;
    @luint errorMessageIndex ;
    [table_des_messages_erreur searchKeyGetID !errorMessageName ?errorMessageIndex ?*] ;
    ioUsedErrorMessageSet += ![errorMessageName string] ;
    $;$ ;
    @typeInstructionLexicale e := [@typeInstructionErreurLexicale new !errorMessageIndex] ;
    li += !e ;
  while
    $warning$ ;
    @lstring errorMessageName ;
    $identifier$ ?errorMessageName ;
    @luint errorMessageIndex ;
    [table_des_messages_erreur searchKeyGetID !errorMessageName ?errorMessageIndex ?*] ;
    ioUsedErrorMessageSet += ![errorMessageName string] ;
    $;$ ;
    @typeInstructionLexicale e := [@typeInstructionLexicalWarning new !errorMessageIndex] ;
    li += !e ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_error_messages_list>
  ?!@typeListeMessagesErreur unused lme
  ?!@typeTableMessagesErreurs unused table_des_messages_erreur
  ?!@stringset unused ioUsedErrorMessageSet
:
end rule ;

#-------------------------------------------------------------------*

rule <lexical_error_messages_list>
  ?!@typeListeMessagesErreur lme
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@stringset ioUsedErrorMessageSet
:
  $error$ ;
  repeat
    @lstring errorMessageName ;
    $identifier$ ?errorMessageName ;
    @luint errorMessageIndex ;
    [table_des_messages_erreur searchKeyGetID !errorMessageName ?errorMessageIndex ?*] ;
    lme += !errorMessageIndex ;
    ioUsedErrorMessageSet += ![errorMessageName string] ;
  while
    $,$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameters_non_empty_list>
  !@typeListeArgumentsRoutExterne laf
  ?!@typeLexicalAttributesMap table_attributs
:
  laf := [@typeListeArgumentsRoutExterne emptyList] ;
  repeat
  while
    select
      $!?$ ;
    or
      $!$ ;
    end select ;
    @typeArgumentRoutineExterne a ;
    <lexical_parameter> ?a !?table_attributs ;
    laf += !a ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameter>
  !@typeArgumentRoutineExterne a
  ?!@typeLexicalAttributesMap unused table_attributs
:
  $*$ ; # le caractere courant
  a := [@typeArgumentCaractereCourant new] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameter>
  !@typeArgumentRoutineExterne a
  ?!@typeLexicalAttributesMap unused table_attributs
:
  @lchar c ;
  $literal_char$ ? c ; # un caractere particulier
  a := [@typeArgumentCaractere new !c] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameter>
  !@typeArgumentRoutineExterne a
  ?!@typeLexicalAttributesMap unused table_attributs
:
  @luint n ;
  $unsigned_literal_integer$ ? n ; # un nombre particulier
  a := [@typeArgumentEntier new !n] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_parameter>
  !@typeArgumentRoutineExterne a
  ?!@typeLexicalAttributesMap table_attributs
:
  @lstring nom ;
  $identifier$ ? nom ; # an attribute or function call
  select
    @AC_galgasType t ;
    [table_attributs searchKey !nom ?t] ;
    a := [@typeArgumentAttribut new !nom !t] ;
  or
    @typeListeArgumentsRoutExterne lare ;
    $($ ;
    <lexical_parameters_non_empty_list> ?lare !?table_attributs ;
    $)$ ;
    a := [@typeArgumentRoutine new !nom !lare] ;
  end select ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_when_branches_list>
  !@typeListeTestsEtInstructions lbs
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
  ??@tagMap inTagMap
  ??@bool inCanSendTerminal
:
  lbs := [@typeListeTestsEtInstructions emptyList] ;
  $when$ ;
  repeat
    @typeListeConditionsLexicales lcl ;
    <lexical_test_expression> ? lcl ;
    $:$ ;
    @tListeInstructionsLexicales li ;
    <lexical_instructions_list>
      ?li
      !?table_des_terminaux
      !?table_des_messages_erreur
      !?table_attributs
      !?table_tables_mots_reserves
      !?ioUsedErrorMessageSet
      !inTagMap
      !inCanSendTerminal
    ;
    lbs += !lcl !li ;
  while
    $when$ ;
  end repeat ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_default_branch>
  !@tListeInstructionsLexicales liste_instructions_sinon
  ?!@typeTableDefinitionTerminaux unused table_des_terminaux
  ?!@typeTableMessagesErreurs unused table_des_messages_erreur
  ?!@typeLexicalAttributesMap unused table_attributs
  ?!@typeTableTablesDeMotsReserves unused table_tables_mots_reserves
  ?!@stringset unused ioUsedErrorMessageSet
  ??@tagMap unused inTagMap
  ??@bool unused inCanSendTerminal
:
  liste_instructions_sinon := [@tListeInstructionsLexicales emptyList] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_default_branch>
  !@tListeInstructionsLexicales liste_instructions_sinon
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
  ??@tagMap inTagMap
  ??@bool inCanSendTerminal
:
  $default$ ;
  <lexical_instructions_list>
    ?liste_instructions_sinon
    !?table_des_terminaux
    !?table_des_messages_erreur
    !?table_attributs
    !?table_tables_mots_reserves 
    !?ioUsedErrorMessageSet
    !inTagMap
    !inCanSendTerminal
  ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_send_instruction>
  !@typeInstructionLexicale instruction
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs unused table_des_messages_erreur
  ?!@typeLexicalAttributesMap unused table_attributs
  ?!@typeTableTablesDeMotsReserves unused table_tables_mots_reserves
  ?!@stringset unused ioUsedErrorMessageSet
:
  @lstring nomTerminal ;
  $terminal$ ?nomTerminal ;
  [table_des_terminaux searchKey !nomTerminal ?* ?* ?* ?*] ;
  instruction := [@typeInstructionEmettreSimple new !nomTerminal] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_send_instruction>
  !@typeInstructionLexicale instruction
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@typeTableMessagesErreurs table_des_messages_erreur
  ?!@typeLexicalAttributesMap table_attributs
  ?!@typeTableTablesDeMotsReserves table_tables_mots_reserves
  ?!@stringset ioUsedErrorMessageSet
:
  $search$ ;
  @typeListeRecherche lr [emptyList] ;
  repeat
    @lstring nomAttribut ;
    $identifier$ ?nomAttribut ; # nom d'attribut
    @AC_galgasType natureAttribut ;
    [table_attributs searchKey !nomAttribut ?natureAttribut] ;
    @typeGalgas_lstring lgs := (cast natureAttribut if >= @typeGalgas_lstring else error nomAttribut) ;
    $in$ ;
    @lstring listName ;
    $identifier$ ?listName ;
    [table_tables_mots_reserves searchKey !listName ?*] ;
    $default$ ;
    lr += !nomAttribut !listName ;
  while
    $search$ ;
  end repeat ;
  @typeEmissionParDefaut ee ;
  <lexical_send_or_error>
    ?ee
    !?table_des_messages_erreur
    !?table_des_terminaux
    !?ioUsedErrorMessageSet
  ;
  instruction := [@typeInstructionEmettre new !lr !ee] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_send_or_error>
  !@typeEmissionParDefaut emissionParDefaut
  ?!@typeTableMessagesErreurs unused tableMessagesErreurs
  ?!@typeTableDefinitionTerminaux table_des_terminaux
  ?!@stringset unused ioUsedErrorMessageSet
:
  @lstring nomTerminal ;
  $terminal$ ?nomTerminal ;
  [table_des_terminaux searchKey !nomTerminal ?* ?* ?* ?*] ;
  emissionParDefaut := [@typeEmissionTerminalParDefaut new !nomTerminal] ;
end rule ;

#-------------------------------------------------------------------*

rule <lexical_send_or_error>
  !@typeEmissionParDefaut emissionParDefaut
  ?!@typeTableMessagesErreurs tableMessagesErreurs
  ?!@typeTableDefinitionTerminaux unused table_des_terminaux
  ?!@stringset ioUsedErrorMessageSet
:
  $error$ ;
  @lstring errorMessageName ;
  $identifier$ ?errorMessageName ;
  @luint errorMessageIndex ;
  [tableMessagesErreurs searchKeyGetID !errorMessageName ?errorMessageIndex ?*] ;
  ioUsedErrorMessageSet += ![errorMessageName string] ;
  emissionParDefaut := [@typeEmissionErreurParDefaut new !errorMessageIndex] ;
end rule ;

#---------------------------------------------------------------------------*

rule <extern_routine_or_function_declaration>
:
  $extern$ ;
  select
    $routine$ ;
    $identifier$ ?* ;
    repeat
    while
      select
        $?!$ ;
      or
        $?$ ;
      end select ;
      $type_name$ ?* ;
      $identifier$ ?* ;
    end repeat ;
    select
    or
      $error$ ;
      repeat
        $identifier$ ?* ;
      while
        $,$ ;
      end repeat ;
    end select ;
    $;$ ;      
  or
    $function$ ;
    $identifier$ ?* ;
    repeat
    while
      $?$ ;
      $type_name$ ?* ;
      $identifier$ ?* ;
    end repeat ;
    $;$ ;      
  end select ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
