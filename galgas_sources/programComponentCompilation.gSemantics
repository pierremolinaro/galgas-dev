#---------------------------------------------------------------------------*
#                                                                           *
#  Program component compilation                                            *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics programComponentCompilation :
import "semanticAnalysisOfSyntaxComponent.gSemantics" ;
import "programSLRgrammar.gGrammar" ;

import semantics lexiqueCompilation in "lexiqueCompilation.gSemantics" ;
import semantics semanticAnalysisOfSyntaxComponent in "semanticAnalysisOfSyntaxComponent.gSemantics" ;
import grammar programSLRgrammar in "programSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper programFileGenerationTemplate in "../generation_templates/program_generation" {
} {
  template programFileHeader "program-file.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
    ?@lstringlist TYPE_PREDECLARATION_LIST
  ;

  template programFileImplementation "program-file.cpp.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
    ?@programRuleList PROGRAM_RULE_LIST
    ?@string VERSION
  ;

}

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    ' B E F O R E '                                *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileBeforeClause
  ??@analysisContext inAnalysisContext
  ??@programComponentAST inProgramComponentAST
  ?!@semanticDeclarationSortedListForGeneration ioDecoratedDeclarationListForGeneration
:
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  analyzeRoutineBody
    !inAnalysisContext
    ![@formalParameterListAST emptyList] # Routine signature : no argument
    ![@localConstantList emptyList] # No local constant
    ![@typedAttributeList emptyList] # No attribute (not a method)
    !""
    ![inProgramComponentAST mPrologueInstructionList]
    ![inProgramComponentAST mEndOfPrologue]
    ?semanticInstructionListForGeneration
    ?*
  ;
  ioDecoratedDeclarationListForGeneration += ![@routineImplementationForGeneration new
    !"before"
    ![@formalParameterListForGeneration emptyList]
    !semanticInstructionListForGeneration
  ]
  !""
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    P R O G R A M    R U L E S                     *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileProgramRules
  ??@analysisContext inAnalysisContext
  ??@programComponentAST inProgramComponentAST
  ?!@semanticDeclarationSortedListForGeneration ioDecoratedDeclarationListForGeneration
:
  @uint ruleIndex := 0 ;
  foreach [inProgramComponentAST mProgramRules] do
    @formalParameterListAST argumentList [emptyList] ;
    argumentList +=
      ![@formalArgumentPassingModeAST argumentConstantIn]
      ![@lstring new !"lstring" !here]
      !mSourceFileVariableName
      !mSourceFileVariableNameIsUnused
    ;
    @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
    @formalParameterListForGeneration routineSignature ;
    analyzeRoutineBody
      !inAnalysisContext
      !argumentList
      ![@localConstantList emptyList] # No local constant
      ![@typedAttributeList emptyList] # No attribute (not a method)
      !""
      !mInstructionList
      !mEndOfInstructionList
      ?semanticInstructionListForGeneration
      ?routineSignature
    ;
    ioDecoratedDeclarationListForGeneration += ![@routineImplementationForGeneration new
      !"programRule_" . [ruleIndex string]
      !routineSignature
      !semanticInstructionListForGeneration
    ]
  !""
  ;
    ruleIndex ++ ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    ' A F T E R '                                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileAfterClause
  ??@analysisContext inAnalysisContext
  ??@programComponentAST inProgramComponentAST
  ?!@semanticDeclarationSortedListForGeneration ioDecoratedDeclarationListForGeneration
:
  @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
  analyzeRoutineBody
    !inAnalysisContext
    ![@formalParameterListAST emptyList] # Routine signature : no argument
    ![@localConstantList emptyList] # No local constant
    ![@typedAttributeList emptyList] # No attribute (not a method)
    !""
    ![inProgramComponentAST mEpilogueInstructionList]
    ![inProgramComponentAST mEndOfEpilogue]
    ?semanticInstructionListForGeneration
    ?*
  ;
  ioDecoratedDeclarationListForGeneration += ![@routineImplementationForGeneration new
    !"after"
    ![@formalParameterListForGeneration emptyList]
    !semanticInstructionListForGeneration
  ]
  !""
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    P R O G R A M    C O M P O N E N T             *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileProgramComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Parse source file
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  const @lstring basenameKey [new !basename !here] ;
  @programComponentAST programComponentAST ;
  if [ioParsedComponentStruct->mParsedSyntaxComponentMap hasKey !basename] then
    [ioParsedComponentStruct->mParsedProgramComponentMap searchKey !basenameKey ?programComponentAST] ;
  else
    grammar programSLRgrammar in inSourceFile ?programComponentAST ;
    [!?ioParsedComponentStruct->mParsedProgramComponentMap insertKey !basenameKey !programComponentAST] ;
  end if ;
#--- Check component name
  const @lstring componentName := [programComponentAST mProgramComponentName] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--- Recursively parse all imported files
  @semanticDeclarationListAST semanticDeclarationList := [programComponentAST mSemanticDeclarationList] ;
  @stringset parsedFileSet [setWithString ![inSourceFile string]] ;
  @lstringlist optionComponentFileNameList [emptyList] ;
  @grammarComponentASTList grammarComponentASTList [emptyList] ;
  @stringlist headerIncludeList [emptyList] ;
  @stringlist implementationIncludeList [emptyList] ;
  recursivelyImportSemanticComponent
    !?ioParsedComponentStruct
    !?optionComponentFileNameList
    !?grammarComponentASTList
    !?semanticDeclarationList
    !?parsedFileSet
    !?headerIncludeList
    !?implementationIncludeList
    ![programComponentAST mImportedComponentFileNameList]
    ![inSourceFile stringByDeletingLastPathComponent]
  ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := semanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  @semanticContext semanticContext ;
  buildSemanticContext
    ![inSourceFile string]
    !semanticDeclarationListWithPredefinedTypes
    ![programComponentAST mEndOfSourceFile]
    ?semanticContext
  ;
#--- Perform semantic analysis of grammar components
  buildGrammarComponentMapForSemanticAnalysis
    !grammarComponentASTList
    !?semanticContext
  ;
#--- Build option component map for analysis
  buildOptionComponentMapForSemanticAnalysis
    !optionComponentFileNameList
    !?ioParsedComponentStruct
    !?semanticContext->mOptionComponentMapForSemanticAnalysis
  ;
#------ Semantic Analysis
  @semanticDeclarationSortedListForGeneration decoratedDeclarationListForGeneration ;
  performSemanticAnalysis
    ![programComponentAST mSemanticDeclarationList]
    !semanticContext
    ?decoratedDeclarationListForGeneration
  ;
#--- Analysis context
  const @analysisContext analysisContext [new
    !semanticContext
    !buildPredefinedTypes [!semanticContext]
    ![@unifiedTypeMapProxy null]
    !""
  ] ;
#--- Analyse 'before' instructions
  compileBeforeClause
    !analysisContext
    !programComponentAST
    !?decoratedDeclarationListForGeneration
  ;
#--- Analyse program rules
  compileProgramRules
    !analysisContext
    !programComponentAST
    !?decoratedDeclarationListForGeneration
  ;
#--- Analyse 'after' instructions
  compileAfterClause
    !analysisContext
    !programComponentAST
    !?decoratedDeclarationListForGeneration
  ;
#------ Generate Header File
  if [@uint errorCount] == 0 then
    @string headerString := [filewrapper programFileGenerationTemplate.programFileHeader
      ![componentName string]
      !headerIncludeList
      ![semanticContext->mTypeMap allKeyList]
    ] ;
    foreach decoratedDeclarationListForGeneration do
      headerString .= [mDeclaration appendDeclaration1] ;
    end foreach ;
    foreach decoratedDeclarationListForGeneration do
      headerString .= [mDeclaration appendDeclaration2 !inOutputDirectory] ;
    end foreach ;
    [@string generateFile
      !inOutputDirectory
      ![componentName string] . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      !headerString
      !"\n\n" # Defaut user zone2
      !"#endif\n"
    ] ;
  end if ;
#------ Generate Implementation File
  if [@uint errorCount] == 0 then
    @string implementationString := [filewrapper programFileGenerationTemplate.programFileImplementation
      ![componentName string]
      !implementationIncludeList
      ![programComponentAST mProgramRules]
      ![[programComponentAST mVersionString] string]
    ] ;
    foreach decoratedDeclarationListForGeneration do
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
      implementationString .= [mDeclaration appendSpecificImplementation] ;
    end foreach ;
    [@string generateFile
      !inOutputDirectory
      ![componentName string] . ".cpp"
      !"//"
      !"\n\n" # Defaut user zone1
      !implementationString
      !"\n\n" # Defaut user zone2
      !"\n"
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
