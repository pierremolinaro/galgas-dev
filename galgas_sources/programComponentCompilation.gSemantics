#---------------------------------------------------------------------------*
#                                                                           *
#  Program component compilation                                            *
#                                                                           *
#  Copyright (C) 2010, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics programComponentCompilation :
import "semanticAnalysisOfSyntaxComponent.gSemantics" ;
import "programSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*

list @programListForGeneration {
  @semanticDeclarationForGeneration mDeclaration ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper programFileGenerationTemplate in "../generation_templates/program_generation" {
}{
}{
  template programFileHeader "program-file.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
  ;

  template programFileImplementation "program-file.cpp.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
    ?@string BEFORE_AFTER_RULE_IMPLEMENTATION_STRING
    ?@programRuleList PROGRAM_RULE_LIST
    ?@bool HAS_INDEXING
  ;
}

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    ' B E F O R E '                                *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileBeforeClause
  ??@analysisContext inAnalysisContext
  ??@prologueEpilogueList inPrologueList
  ?!@semanticDeclarationSortedListForGeneration ioDecoratedDeclarationListForGeneration
:
#--- Compile 'before' routines
  var semanticInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  for () in inPrologueList do
    analyzeRoutineBody
      !inAnalysisContext
      ![@formalParameterListAST emptyList] # Routine signature : no argument
      ![@localConstantList emptyList] # No local constant
      ![@typedAttributeList emptyList] # No attribute (not a method)
      ![@typedAttributeList emptyList] # No attribute (not a method)
      !""
      !mInstructionList
      !mEndOfInstructionList
      ??@semanticInstructionListForGeneration blockSemanticInstructionListForGeneration
      ?*
    ;
    semanticInstructionListForGeneration += ![@semanticBlockInstructionForGeneration new
      !blockSemanticInstructionListForGeneration
    ] ;
  end for ;
#---
  ioDecoratedDeclarationListForGeneration +=
    !"before"
    ![@routineImplementationForGeneration new
      !false # Has no header
      !"proc-before"
      !"before"
      ![@formalParameterListForGeneration emptyList]
      !false # Do not generate static
      !semanticInstructionListForGeneration
    ]
    !""
  ;
end routine ;

#---------------------------------------------------------------------------*

routine compileBeforeClauseGalgas3
  ??@analysisContext inAnalysisContext
  ??@prologueEpilogueList inPrologueList
  ?!@programListForGeneration ioDecoratedDeclarationListForGeneration
:
#--- Compile 'before' routines
  var semanticInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  for () in inPrologueList do
    analyzeRoutineBody
      !inAnalysisContext
      ![@formalParameterListAST emptyList] # Routine signature : no argument
      ![@localConstantList emptyList] # No local constant
      ![@typedAttributeList emptyList] # No attribute (not a method)
      ![@typedAttributeList emptyList] # No attribute (not a method)
      !""
      !mInstructionList
      !mEndOfInstructionList
      ??@semanticInstructionListForGeneration blockSemanticInstructionListForGeneration
      ?*
    ;
    semanticInstructionListForGeneration += ![@semanticBlockInstructionForGeneration new
      !blockSemanticInstructionListForGeneration
    ] ;
  end for ;
#---
  ioDecoratedDeclarationListForGeneration +=
    ![@routineImplementationForGeneration new
      !false # Has no header
      !"proc-before"
      !"before"
      ![@formalParameterListForGeneration emptyList]
      !true # Generate static
      !semanticInstructionListForGeneration
    ]
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    P R O G R A M    R U L E S                     *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileProgramRules
  ??@analysisContext inAnalysisContext
  ??@programRuleList inProgramRules
  ?!@semanticDeclarationSortedListForGeneration ioDecoratedDeclarationListForGeneration
  ?!@bool ioHasIndexing
:
  @uint ruleIndex := 0 ;
  foreach inProgramRules do
    if mIndexingGrammar->string != "" then
      ioHasIndexing := true ;
      [inAnalysisContext->mSemanticContext->mGrammarMap searchKey !mIndexingGrammar ?* ??@bool hasIndexing ?*] ;
      if not hasIndexing then
        error mIndexingGrammar : "the '" . mIndexingGrammar . "' grammar does not enable indexing" ;
      end if ;
    end if ;
    const @formalParameterListAST argumentList := {
      !["" nowhere]
      ![@formalArgumentPassingModeAST argumentConstantIn]
      ![@lstring new !"lstring" !here]
      !mSourceFileVariableName
      !mSourceFileVariableNameIsUnused
    } ;
    @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
    @formalParameterListForGeneration routineSignature ;
    analyzeRoutineBody
      !inAnalysisContext
      !argumentList
      ![@localConstantList emptyList] # No local constant
      ![@typedAttributeList emptyList] # No attribute (not a method)
      ![@typedAttributeList emptyList] # No attribute (not a method)
      !""
      !mInstructionList
      !mEndOfInstructionList
      ?semanticInstructionListForGeneration
      ?routineSignature
    ;
    ioDecoratedDeclarationListForGeneration +=
      !"source rule " . ruleIndex
      ![@routineImplementationForGeneration new
        !false # Has no header
        !"proc-programrule"
        !"programRule_" . [ruleIndex string]
        !routineSignature
        !false # Do not generate static
        !semanticInstructionListForGeneration
      ]
    !""
    ;
    ruleIndex ++ ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine compileProgramRulesGalgas3
  ??@analysisContext inAnalysisContext
  ??@programRuleList inProgramRules
  ?!@programListForGeneration ioDecoratedDeclarationListForGeneration
  ?!@bool ioHasIndexing
:
  @uint ruleIndex := 0 ;
  foreach inProgramRules do
    if mIndexingGrammar->string != "" then
      ioHasIndexing := true ;
      [inAnalysisContext->mSemanticContext->mGrammarMap searchKey !mIndexingGrammar ?* ??@bool hasIndexing ?*] ;
      if not hasIndexing then
        error mIndexingGrammar : "the '" . mIndexingGrammar . "' grammar does not enable indexing" ;
      end if ;
    end if ;
    const @formalParameterListAST argumentList := {
      !["" nowhere]
      ![@formalArgumentPassingModeAST argumentConstantIn]
      ![@lstring new !"lstring" !here]
      !mSourceFileVariableName
      !mSourceFileVariableNameIsUnused
    } ;
    @semanticInstructionListForGeneration semanticInstructionListForGeneration ;
    @formalParameterListForGeneration routineSignature ;
    analyzeRoutineBody
      !inAnalysisContext
      !argumentList
      ![@localConstantList emptyList] # No local constant
      ![@typedAttributeList emptyList] # No attribute (not a method)
      ![@typedAttributeList emptyList] # No attribute (not a method)
      !""
      !mInstructionList
      !mEndOfInstructionList
      ?semanticInstructionListForGeneration
      ?routineSignature
    ;
    ioDecoratedDeclarationListForGeneration +=
      ![@routineImplementationForGeneration new
        !false # Has no header
        !"proc-programrule"
        !"programRule_" . [ruleIndex string]
        !routineSignature
        !true # Generate static
        !semanticInstructionListForGeneration
      ]
    ;
    ruleIndex ++ ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    ' A F T E R '                                  *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileAfterClause
  ??@analysisContext inAnalysisContext
  ??@prologueEpilogueList inEpilogueList
  ?!@semanticDeclarationSortedListForGeneration ioDecoratedDeclarationListForGeneration
:
#--- Compile 'before' routines
  var semanticInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  for () in inEpilogueList do
    analyzeRoutineBody
      !inAnalysisContext
      ![@formalParameterListAST emptyList] # Routine signature : no argument
      ![@localConstantList emptyList] # No local constant
      ![@typedAttributeList emptyList] # No attribute (not a method)
      ![@typedAttributeList emptyList] # No attribute (not a method)
      !""
      !mInstructionList
      !mEndOfInstructionList
      ??@semanticInstructionListForGeneration blockSemanticInstructionListForGeneration
      ?*
    ;
    semanticInstructionListForGeneration += ![@semanticBlockInstructionForGeneration new
      !blockSemanticInstructionListForGeneration
    ] ;
  end for ;
#---
  ioDecoratedDeclarationListForGeneration +=
    !"after"
    ![@routineImplementationForGeneration new
      !false # Has no header
      !"proc-after"
      !"after"
      ![@formalParameterListForGeneration emptyList]
      !false # Do not generate static
      !semanticInstructionListForGeneration
    ]
    !""
  ;
end routine ;

#---------------------------------------------------------------------------*

routine compileAfterClauseGalgas3
  ??@analysisContext inAnalysisContext
  ??@prologueEpilogueList inEpilogueList
  ?!@programListForGeneration ioDecoratedDeclarationListForGeneration
:
#--- Compile 'before' routines
  var semanticInstructionListForGeneration := [@semanticInstructionListForGeneration emptyList] ;
  for () in inEpilogueList do
    analyzeRoutineBody
      !inAnalysisContext
      ![@formalParameterListAST emptyList] # Routine signature : no argument
      ![@localConstantList emptyList] # No local constant
      ![@typedAttributeList emptyList] # No attribute (not a method)
      ![@typedAttributeList emptyList] # No attribute (not a method)
      !""
      !mInstructionList
      !mEndOfInstructionList
      ??@semanticInstructionListForGeneration blockSemanticInstructionListForGeneration
      ?*
    ;
    semanticInstructionListForGeneration += ![@semanticBlockInstructionForGeneration new
      !blockSemanticInstructionListForGeneration
    ] ;
  end for ;
#---
  ioDecoratedDeclarationListForGeneration +=
    ![@routineImplementationForGeneration new
      !false # Has no header
      !"proc-after"
      !"after"
      ![@formalParameterListForGeneration emptyList]
      !true # Generate static
      !semanticInstructionListForGeneration
    ]
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    P R O G R A M    C O M P O N E N T             *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileProgramComponentFromAST
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ??@programComponentAST inProgramComponentAST
  ?!@parsedComponentStruct ioParsedComponentStruct
:
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
#--- Check component name
  const @lstring componentName := [inProgramComponentAST mProgramComponentName] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--- Recursively parse all imported files
  @semanticDeclarationListAST semanticDeclarationList := [inProgramComponentAST mSemanticDeclarationList] ;
  @stringset parsedFileSet [setWithString ![inSourceFile string]] ;
  @lstringlist optionComponentFileNameList [emptyList] ;
  @grammarComponentASTList grammarComponentASTList [emptyList] ;
  @stringlist headerIncludeList [emptyList] ;
  @stringlist implementationIncludeList := {!componentName->string} ;
  recursivelyImportSemanticComponentAndCheckNoCircularityInImportSemantics
    !inSourceFile
    !?ioParsedComponentStruct
    !?optionComponentFileNameList
    !?grammarComponentASTList
    !?semanticDeclarationList
    !?parsedFileSet
    !?headerIncludeList
    !?implementationIncludeList
    ![inProgramComponentAST mImportedComponentFileNameList]
    ![inSourceFile stringByDeletingLastPathComponent]
  ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := semanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  buildSemanticContext
    !semanticDeclarationListWithPredefinedTypes
    ?@semanticContext semanticContext
  ;
#--- Perform semantic analysis of grammar components
  buildGrammarComponentMapForSemanticAnalysis
    !grammarComponentASTList
    !?semanticContext
  ;
#--- Build option component map for analysis
  buildOptionComponentMapForSemanticAnalysis
    !optionComponentFileNameList
    !?ioParsedComponentStruct
    !?semanticContext->mOptionComponentMapForSemanticAnalysis
  ;
#--- Build lexique component map for semantic analysis
  buildLexiqueComponentMapForSemanticAnalysis
    !ioParsedComponentStruct
    ?@lexiqueComponentMapForSemanticAnalysis lexiqueMap
  ;
  semanticContext->mLexiqueComponentMapForSemanticAnalysis := lexiqueMap ;
#------ Semantic Analysis
  @semanticDeclarationSortedListForGeneration decoratedDeclarationListForGeneration ;
  performSemanticAnalysis
    ![inProgramComponentAST mSemanticDeclarationList]
    !semanticContext
    ?decoratedDeclarationListForGeneration
  ;
#--- Analysis context
  const analysisContext :=  [@analysisContext new
    !semanticContext
    !buildPredefinedTypes [!semanticContext]
    ![@unifiedTypeMapProxy null]
    !""
    ![@unifiedTypeMapProxy null]
  ] ;
#--- Analyse 'before' instructions
  compileBeforeClause
    !analysisContext
    !inProgramComponentAST->mPrologueList
    !?decoratedDeclarationListForGeneration
  ;
#--- Analyse program rules
  @bool hasIndexing := false ;
  compileProgramRules
    !analysisContext
    !inProgramComponentAST->mProgramRules
    !?decoratedDeclarationListForGeneration
    !?hasIndexing
  ;
#--- Analyse 'after' instructions
  compileAfterClause
    !analysisContext
    !inProgramComponentAST->mEpilogueList
    !?decoratedDeclarationListForGeneration
  ;
#------ Generate Header File
  if [@uint errorCount] == 0 then
    @string headerString := [filewrapper programFileGenerationTemplate.programFileHeader
      ![componentName string]
      !headerIncludeList
    ] ;
    foreach decoratedDeclarationListForGeneration do
      var unusedInclusionSet := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?unusedInclusionSet ??@string code] ;
      headerString .= code ;
    end foreach ;
    foreach decoratedDeclarationListForGeneration do
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !false !inOutputDirectory !?inclusionSet2 ??@string headerString2] ;
      headerString .= headerString2 ;
    end foreach ;
    [@string generateFileWithPattern
      !inOutputDirectory
      ![componentName string] . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      !headerString
      !"\n\n" # Defaut user zone2
      !"#endif\n"
    ] ;
  end if ;
#------ Generate Implementation File
  if [@uint errorCount] == 0 then
    var beforAfterRulesImplementationString := "" ;
    foreach decoratedDeclarationListForGeneration do
      beforAfterRulesImplementationString .= [mDeclaration appendTypeGenericImplementation] ;
      var unusedInclusionSet := [@stringset emptySet] ;
      [mDeclaration appendSpecificImplementation !?unusedInclusionSet ??@string code] ;
      beforAfterRulesImplementationString += code ;
    end foreach ;
    const implementationString := [filewrapper programFileGenerationTemplate.programFileImplementation
      ![componentName string]
      !implementationIncludeList
      !beforAfterRulesImplementationString
      ![inProgramComponentAST mProgramRules]
      !hasIndexing
    ] ;
    [@string generateFileWithPattern
      !inOutputDirectory
      ![componentName string] . ".cpp"
      !"//"
      !"\n\n" # Defaut user zone1
      !implementationString
      !"\n\n" # Defaut user zone2
      !"\n"
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine compileProgramComponentFromSourceFile
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Parse source file
  const basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  const basenameKey := [@lstring new !basename !here] ;
  @programComponentAST programComponentAST ;
  if [ioParsedComponentStruct->mParsedProgramComponentMap hasKey !basename] then
    [ioParsedComponentStruct->mParsedProgramComponentMap searchKey !basenameKey ?* ?programComponentAST] ;
  else
    grammar programSLRgrammar in inSourceFile ?programComponentAST ;
    [!?ioParsedComponentStruct->mParsedProgramComponentMap insertKey !basenameKey !inSourceFile !programComponentAST] ;
  end if ;
#---
  compileProgramComponentFromAST
    !inSourceFile
    !inOutputDirectory
    !programComponentAST
    !?ioParsedComponentStruct
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#           C O M P I L E    P R O G R A M    C O M P O N E N T             *
#                                                                           *
#---------------------------------------------------------------------------*

routine compileProgramComponentGalgas3
  ??@prologueEpilogueList inPrologueList
  ??@programRuleList inProgramRules
  ??@prologueEpilogueList inEpilogueList
  ??@semanticContext inSemanticContext
  !@string outCppContents
  !@programComponentForGeneration outProgramComponentForGeneration
:
  const useOneHugeHeader := [option galgas_cli_options.generateOneHeader value] ;
#--- Analysis context
  const analysisContext := [@analysisContext new
    !inSemanticContext
    !buildPredefinedTypes [!inSemanticContext]
    ![@unifiedTypeMapProxy null]
    !""
    ![@unifiedTypeMapProxy null]
  ] ;
#--- Analyse 'before' instructions
  var decoratedDeclarationListForGeneration := [@programListForGeneration emptyList] ;
  compileBeforeClauseGalgas3
    !analysisContext
    !inPrologueList
    !?decoratedDeclarationListForGeneration
  ;
#--- Analyse 'after' instructions
  compileAfterClauseGalgas3
    !analysisContext
    !inEpilogueList
    !?decoratedDeclarationListForGeneration
  ;
#--- Analyse program rules
  @bool hasIndexing := false ;
  compileProgramRulesGalgas3
    !analysisContext
    !inProgramRules
    !?decoratedDeclarationListForGeneration
    !?hasIndexing
  ;
#------ Build Header File
#  outHeaderContents := "" ;
#  if [@uint errorCount] == 0 then
#    if generateFewHeaderFiles [] then
#      outHeaderContents := [filewrapper programFileGenerationTemplate.programFileHeader
#        !"program"
#        !{!"all-declarations"}
#      ] ;
#    else
#      var inclusionSet1 := [@stringset emptySet] ;
#      var inclusionSet2 := [@stringset emptySet] ;
#      var headerString := "" ;
#      foreach decoratedDeclarationListForGeneration do
#        [mDeclaration appendDeclaration1 !?inclusionSet1 ??@string code] ;
#        headerString .= code ;
#      end foreach ;
#      foreach decoratedDeclarationListForGeneration do
#        [mDeclaration appendDeclaration2 !true !inOutputDirectory !?inclusionSet2 ??@string headerString2] ;
#        headerString .= headerString2 ;
#      end foreach ;
#      if useOneHugeHeader then
#        inclusionSet1 := [@stringset setWithString !"all-declarations"] ;
#        inclusionSet2 := [@stringset emptySet] ;
#      end if ;
#      outHeaderContents := [filewrapper programFileGenerationTemplate.programFileHeader
#        !"program"
#        ![inclusionSet1 stringList] + [inclusionSet2 stringList]
#      ] ;
#      outHeaderContents += headerString ;
#    end if ;
#  end if ;
#------------ Build Implementation File
  @stringset inclusionSet := {} ;
  outCppContents := "" ;
  if [@uint errorCount] == 0 then
    var beforeAfterRulesString := "" ;
    foreach decoratedDeclarationListForGeneration do
      beforeAfterRulesString += [mDeclaration appendTypeGenericImplementation] ;
      [mDeclaration appendSpecificImplementation !?inclusionSet ??@string code] ;
      beforeAfterRulesString += code ;
    end foreach ;
    foreach inSemanticContext->mGrammarMap do
      inclusionSet += !"grammar-" . lkey ;
    end foreach ;
    if useOneHugeHeader then
      inclusionSet := [@stringset emptySet] ;
#      for () in inSemanticContext->mOptionComponentMapForSemanticAnalysis do
#        if not mIsPredefined then
#          inclusionSet += !"option-" . lkey->string ;
#        end if ;
#      end for ;
      for () in inSemanticContext->mGrammarMap do
        inclusionSet += !"grammar-" . lkey->string ;
      end for ;
    end if ;
    outCppContents := [filewrapper programFileGenerationTemplate.programFileImplementation
      !"program"
      ![inclusionSet stringList]
      !beforeAfterRulesString
      !inProgramRules
      !hasIndexing
    ] ;

  end if ;
#---
   outProgramComponentForGeneration := [@programComponentForGeneration new
     !false # No header
     !"program"
     !inclusionSet
     !outCppContents
   ] ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
#         G E N E R A T E    P R O G R A M    C O M P O N E N T             *
#                                                                           *
#---------------------------------------------------------------------------*

routine generateProgramComponentGalgas3
  ??@string inOutputDirectory
  ??@string inCppContents
  ?!@stringlist ioToolProductFileList
  ?!@stringset ioAllProductFileSet
:
#------ Generate Header File
  const programFileName := "program" ;
#  if [@uint errorCount] == 0 then
#    ioAllProductFileSet += !programFileName + ".h" ;
#    [@string generateFileWithPattern
#      !inOutputDirectory
#      !programFileName + ".h"
#      !"//"
#      !"\n\n" # Defaut user zone1
#      !inHeaderContents
#      !"\n\n" # Defaut user zone2
#      !"#endif\n"
#    ] ;
#  end if ;
#-------------------------------------------------------- Generate Implementation File
  if [@uint errorCount] == 0 then
    ioToolProductFileList += !programFileName . ".cpp" ;
    ioAllProductFileSet += !programFileName + ".cpp" ;
    [@string generateFileWithPattern
      !inOutputDirectory
      !programFileName . ".cpp"
      !"//"
      !"\n\n" # Defaut user zone1
      !inCppContents
      !"\n\n" # Defaut user zone2
      !"\n"
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
