#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS program component parser definition                               *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax program_parser :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

#--------------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label parse
;

nonterminal <semantic_instructions_list>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
label parse
;

extern routine generatePRGM
  ??@lstring nomPRGMprincipal
  ??@lstring versionString
  ??@typeInstructionList inPrologueInstructionList
  ??@typeInstructionList inEpilogueInstructionList
  ??@ruleDescriptorForProgramList inRuleDescriptorForProgramList
  ??@M_optionComponents inOptionsComponentsMap
  ??@stringset inInclusionsForImplementationFile
;

#--------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
#--- Program header
  $program$ ;
#--- Get program name
  @lstring nomPRGMprincipal ; # nom fichier programme principal
  $identifier$ ? nomPRGMprincipal ;
  @string basename := [[[@string stringWithSourceFilePath] lastPathComponent] stringByDeletingPathExtension] ;
  if [nomPRGMprincipal string] != basename then
    warning nomPRGMprincipal: "GALGAS 1.7.5 and later checks "
      "the component name ('" . [nomPRGMprincipal string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--- Title
  @lstring versionString ;
  $literal_string$ ? versionString ;
  $:$ ;
#--- Import clauses
  @ModelMap modelMap [emptyMap] ;
  @ActionMap actionMap [emptyMap] ;
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @M_semanticsEntitiesForUse componentEntitiesMap ;
  @stringset classNamesSet [emptySet] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedGrammarComponents ;
  @M_optionComponents optionsComponentsMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedMetamodelComponents
    ?includedOptionComponents
    ?includedGrammarComponents
    !?ioLexiqueMapForUse
    !?ioSemanticsComponentsMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?optionsComponentsMap
    ?modelMap
    ?actionMap
    ?componentEntitiesMap
    ?tableEnAvant
    !?ioSemanticContext
  ;
  inclusionsForImplementationFile += ![nomPRGMprincipal string] . ".h" ;
  foreach includedSemanticsComponents do
    inclusionsForImplementationFile += !key . ".h" ;
  end foreach ;
#--- Max errors count
  select
    $error$ ;
    error here: "in GALGAS 1.7.2 and later, the 'error ... ;' declaration is obsolete and should be removed" ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- Max warnings count
  select
    $warning$ ;
    error here: "in GALGAS 1.7.2 and later, the 'warning ... ;' declaration is obsolete and should be removed" ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- prologue routine
  select
    $before$ ;
  or
    $routine$ ;
    warning here: "in GALGAS 1.7.5 and later, the 'routine' keyword that introduces the prologue routine has been replaced by the 'before' keyword" ;
  end select ;
  ${$ ;
  @typeInstructionList prologueInstructionList [emptyList] ;
  @typeVariablesMap prologueVariablesMap [emptyMap] ;
  @typeTableEnAvant prologueTableEnAvant [emptyMap] ;
  <semantic_instructions_list>
    !prologueTableEnAvant
    !componentEntitiesMap
    !optionsComponentsMap
    !?prologueVariablesMap
    !?prologueInstructionList
    !ioSemanticContext
  ;
  $}$ ;
#--- WHEN clauses
  @ruleDescriptorForProgramList ruleDescriptorForProgramList [emptyList] ;
  $when$ ;
   repeat
  #--- Source file extension definition
    $.$ ;
    @lstring sourceExtension ;
    $literal_string$ ? sourceExtension ;
  #--- Check source extension
    if [[sourceExtension string] length] == 0 then
      error sourceExtension: "the source extension should not be empty" ;
    else
      @uint index := 0 ;
      @bool ok := true ;
      loop [[sourceExtension string] length] + 1 :
      while (index < [[sourceExtension string] length]) & ok do
        @char c := [[sourceExtension string] characterAtIndex !index] ;
        ok := ((c >= 'a') & (c <= 'z')) | ((c >= 'A') & (c <= 'Z')) | ((c >= '0') & (c <= '9')) | (c == '_') ;
        index ++ ;
      end loop ;
      if not ok then
        error sourceExtension: "the source extension should contains only lower case letters, upper case letters, digits and underscore characters" ;
      end if ;
    end if ;
  #--- Help message
    @string helpMessage ;
    $message$ ;
    @lstring messageString ;
    $literal_string$ ? messageString ;
    helpMessage := [messageString string] ;
  #--- Argument
    @typeVariablesMap variablesMap [emptyMap] ;
    $??$ ;
    @lstring parameterTypeName ;
    $type_name$ ? parameterTypeName ;
    if [parameterTypeName string] != "lstring" then
      error parameterTypeName: "only the '@lstring' type is allowed here" ;
    end if ;
    @lstring argumentName ;
    $identifier$ ? argumentName ;
    [!?variablesMap insertConstInArgument
      !argumentName
      ![@typeGalgas_lstring new]
      ![@typeAutomaticName new ![argumentName location] ![argumentName string]]
    ] ;
  #--- Instruction list
    ${$ ;
    @typeInstructionList instructionList [emptyList] ;
    @typeTableEnAvant tableEnAvant [emptyMap] ;
    <semantic_instructions_list>
      !tableEnAvant
      !componentEntitiesMap
      !optionsComponentsMap
      !?variablesMap
      !?instructionList
      !ioSemanticContext
    ;
    $}$ ;
    ruleDescriptorForProgramList += 
      !sourceExtension
      !helpMessage
      !argumentName
      !instructionList
    ;
  while
    $when$ ;
  end repeat ;
#--- epilogue routine
  @typeInstructionList epilogueInstructionList [emptyList] ;
  select
    $after$ ;
  or
    $routine$ ;
    warning here: "in GALGAS 1.7.5 and later, the 'routine' keyword that introduces the epilogue routine has been replaced by the 'after' keyword" ;
  end select ;
  ${$ ;
  @typeVariablesMap variablesMap [emptyMap] ;
  @typeTableEnAvant epilogueTableEnAvant [emptyMap] ;
  <semantic_instructions_list>
    !epilogueTableEnAvant
    !componentEntitiesMap
    !optionsComponentsMap
    !?variablesMap
    !?epilogueInstructionList
    !ioSemanticContext
  ;
  $}$ ;
#--- Engendrer le programme principal
  generatePRGM
    !nomPRGMprincipal
    !versionString
    !prologueInstructionList
    !epilogueInstructionList
    !ruleDescriptorForProgramList
    !optionsComponentsMap
    !inclusionsForImplementationFile
  ;
  $end$ ;
  $program$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
#--- Program header
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  select
    $error$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- Max warnings count
  select
    $warning$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- prologue routine
  select
    $before$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
  #--- Help message
    $message$ ;
    $literal_string$ ? * ;
  #--- Argument
    $??$ ;
    $type_name$ ? * ;
    $identifier$ ? * ;
  #--- Instruction list
    ${$ ;
    <semantic_instructions_list> parse ;
    $}$ ; 
  while
    $when$ ;
  end repeat ;
#--- epilogue routine
  select
    $after$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- End program
  $end$ ;
  $program$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  select
    $error$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- Max warnings count
  select
    $warning$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- prologue routine
  select
    $before$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
  #--- Help message
    $message$ ;
    $literal_string$ ? * ;
  #--- Argument
    $??$ ;
    $type_name$ ? * ;
    $identifier$ ? * ;
  #--- Instruction list
    ${$ ;
    <semantic_instructions_list> parse ;
    $}$ ; 
  while
    $when$ ;
  end repeat ;
#--- epilogue routine
  select
    $after$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- End program
  $end$ ;
  $program$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  select
    $error$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- Max warnings count
  select
    $warning$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- prologue routine
  select
    $before$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
  #--- Help message
    $message$ ;
    $literal_string$ ? * ;
  #--- Argument
    $??$ ;
    $type_name$ ? * ;
    $identifier$ ? * ;
  #--- Instruction list
    ${$ ;
    <semantic_instructions_list> parse ;
    $}$ ; 
  while
    $when$ ;
  end repeat ;
#--- epilogue routine
  select
    $after$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- End program
  $end$ ;
  $program$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  select
    $error$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- Max warnings count
  select
    $warning$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- prologue routine
  select
    $before$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
  #--- Help message
    $message$ ;
    $literal_string$ ? * ;
  #--- Argument
    $??$ ;
    $type_name$ ? * ;
    $identifier$ ? * ;
  #--- Instruction list
    ${$ ;
    <semantic_instructions_list> parse ;
    $}$ ; 
  while
    $when$ ;
  end repeat ;
#--- epilogue routine
  select
    $after$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- End program
  $end$ ;
  $program$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $program$ ;
  $identifier$ ? * ;
  $literal_string$ ? * ;
  $:$ ;
#--- Import clauses
  <import_headers_semantics_and_grammars> parse ;
#--- Max errors count
  select
    $error$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- Max warnings count
  select
    $warning$ ;
    $unsigned_literal_integer$ ? * ;
    $;$ ;
  or
  end select ;
#--- prologue routine
  select
    $before$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- when clauses
  $when$ ;
  repeat
  #--- Source file extension definition
    $.$ ;
    $literal_string$ ? * ; # Source file extension
  #--- Help message
    $message$ ;
    $literal_string$ ? * ;
  #--- Argument
    $??$ ;
    $type_name$ ? * ;
    $identifier$ ? * ;
  #--- Instruction list
    ${$ ;
    <semantic_instructions_list> parse ;
    $}$ ; 
  while
    $when$ ;
  end repeat ;
#--- epilogue routine
  select
    $after$ ;
  or
    $routine$ ;
  end select ;
  ${$ ;
  <semantic_instructions_list> parse ;
  $}$ ;
#--- End program
  $end$ ;
  $program$ ;
  $;$ ;
end rule ;

#--------------------------------------------------------------------------------*

end syntax ;
