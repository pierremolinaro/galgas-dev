#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS parser component parser definition                                *
#                                                                           *
#  Copyright (C) 1997-2006 Pierre Molinaro.                                 *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax parser_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics parser_semantics in "parser_semantics.ggs" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
label parse
;

rule <syntax_declaration>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring inSyntaxComponentName
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
label parse
;

rule <parse_lexique_for_importing>
  ??@lstring inFileName
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label parse
;

rule <import_headers_semantics_and_grammars>
  !@stringset ioIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset ioIncludedOptionComponents
  !@stringset ioIncludedGrammarComponents
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponents
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  !@M_semanticsEntitiesForUse ioEntitiesMap
  !@typeTableEnAvant tableEnAvant
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label parse
;

rule <semantic_instruction>
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
label parse
;

rule <syntax_instruction>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
label parse
;

rule <expression>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

rule <input_parameters_list>
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ?@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
label parse
;

rule <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionsList ioInstructionsList

label parse
;

rule <formal_arguments_list>
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignature
label importGrammarForSemantics
  !@L_signature outSignature
label parse
;

rule <syntax_instructions_list>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
label parse
;
 
rule <syntax_instructions_list_no_verif>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
label parse
;

rule <rule_declaration_or_implementation>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeVariablesMap tableVariablesMethode
  ?@L_EXsignature listeDeTypes
  ??@lstring inRuleName
  ??@lstring inReturnedEntityName
  ?@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?@L_signature inSignatureForGrammar
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ??@lstring inSyntaxComponentName
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ??@lstring inNonterminalSymbolName
  ??@L_signature inDefaultSignature
  ??@lstring inReturnedEntity
label parse
;

rule <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
label getLexiqueName
  !@lstring outLexiqueName
label parse
;

action checkLabelSignatures
  ?!@typeAltProductionsMap ioAltProductionMap ;

action checkParseRewindSignatures
  ?!@L_parse_rewind_signature_list ioParseRewindSignature
 ;

#------------------------------------------------------------------------------*
#                                                                              *
#                      SYNTAX COMPONENT                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  @typeEntitiesToGenerateList listeEntitesAengendrer ;
  @typeTableRoutinesAimplementer tableRoutinesAimplementer [empty] ;
  @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [empty] ;
  $syntax$ ;
#--- Get syntax comopnent name
  @lstring componentName ;
  $identifier$ ? componentName ;
  $:$ ;
  @M_terminalSymbolsMapForUse tableTerminaux ;
#--- Define lexique
  @lstring  lexiqueName ;
  <get_lexique_infos>
    ?tableTerminaux
    !?ioLexiqueMapForUse
    ?lexiqueName
  ;
  @string defLexique := [lexiqueName value] ;
#--- Parse Inclusions
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @typeTableEnAvant tableEnAvant ;
  @M_semanticsEntitiesForUse entitiesMap ;
  @M_optionComponents ioOptionsComponentsMapForUse ;
  @stringset includedSemanticsComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedMetamodelComponents
    ?includedGrammarComponents
    !?ioSemanticsComponentsMap
    !?ioMetamodelComponentMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?ioOptionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?entitiesMap
    ?tableEnAvant
  ;
  listeEntitesAengendrer := [@typeEntitiesToGenerateList empty] ;
  @M_nonTerminalSymbolsForGrammar nonTerminalSymbolsMapForGrammar [empty] ;
  @L_productionRules_ForGrammarComponent productionRulesListForGrammar [empty] ;
  @M_nonTerminalSymbolForSyntax nonTerminalSymbolsMapForSyntax [empty] ;
  repeat
  while
    <syntax_declaration>
      !?nonTerminalSymbolsMapForSyntax
      !?entitiesMap
      !?ioOptionsComponentsMapForUse
      !?tableEnAvant
      !?listeEntitesAengendrer
      !?tableTerminaux
      !?nonTerminalSymbolsMapForGrammar
      !?productionRulesListForGrammar
      !componentName
    ;
  while
    <semantics_declaration>
      !?entitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?tableNomRoutinesDeclarees
      !?tableEnAvant
      !?tableRoutinesAimplementer
    ;
  end repeat ;
#--- Check that all routines have been implemented
  foreach tableNomRoutinesDeclarees (??@lstring nomRoutine) :
    if not [tableRoutinesAimplementer hasKey ![nomRoutine value]] then
      error nomRoutine : "the routine '" . [nomRoutine value] .
                         "' is not implemented within the component" ;
    end if ;
  end foreach ;
#--- Enter syntax component into syntax components map
  [!?ioSyntaxComponentsMap insertKey
    !componentName
    !nonTerminalSymbolsMapForGrammar
    !productionRulesListForGrammar
    !lexiqueName
  ] ;
#--- Generate component
  action generateSemanticsComponent
    !?componentName
    !?inclusionsForHeaderFile
    !?defLexique
    !?listeEntitesAengendrer
    !?inclusionsForImplementationFile
  ;
#--- Fin du fichier
  $end$ ;
  $syntax$ ;
  $;$ ;
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  $syntax$ ;
  @lstring syntaxComponentName ;
  $identifier$ ? syntaxComponentName ;
  $:$ ;
#--- Lexique
  @lstring lexiqueName ;
  <get_lexique_infos> getLexiqueName ? lexiqueName ;
#--- Import Semantics, Metamodels
  @M_semanticsComponents semanticsComponentsMap [empty] ;
  @M_grammarComponents grammarComponentsMap [empty] ;
  @M_optionComponents optionsComponentsMap [empty] ;  
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @typeTableEnAvant tableEnAvant ;
  @M_semanticsEntitiesForUse entitiesMap ;
  @M_optionComponents ioOptionsComponentsMapForUse ;
  @stringset includedSemanticsComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedOptionComponents ;
  @stringset includedGrammarComponents ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?includedMetamodelComponents
    ?includedGrammarComponents
    !?semanticsComponentsMap
    !?ioMetamodelComponentMap
    !?grammarComponentsMap
    !?optionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?ioOptionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?entitiesMap
    ?tableEnAvant
  ;
#--- 
  @L_productionRules_ForGrammarComponent productionRulesListForGrammar [empty] ;
  @M_nonTerminalSymbolsForGrammar nonTerminalSymbolsMapForGrammar [empty] ;
  repeat
  while
    <syntax_declaration> importSyntax
      !?nonTerminalSymbolsMapForGrammar
      !?productionRulesListForGrammar
    ;
  while
    <semantics_declaration> parse ;
  end repeat ;
#--- Enter syntax component into syntax components map
  [!?ioSyntaxComponentsMap insertKey !syntaxComponentName !nonTerminalSymbolsMapForGrammar
                                                          !productionRulesListForGrammar
                                                          !lexiqueName] ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $syntax$ ;
  $identifier$ ? * ;
  $:$ ;
  <get_lexique_infos> parse ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <syntax_declaration> parse ;
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $syntax$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#                   GET LEXIQUE INFOS                                          *
#                                                                              *
#------------------------------------------------------------------------------*

rule <get_lexique_infos>
  !@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  !@lstring outLexiqueName
:
#--- Get lexique name
  $import$ ;
  $lexique$ ;
  $identifier$ ?outLexiqueName ;
#--- 'in' clause ?
  @M_lexiqueComponents lexiqueComponentsMap ;
  select
    lexiqueComponentsMap := ioLexiqueMapForUse ;
  or
    $in$ ;
    @lstring fileName ;
    $literal_string$ ? fileName ;
    lexiqueComponentsMap := [@M_lexiqueComponents empty] ;
    <parse_lexique_for_importing>
      !fileName
      !?lexiqueComponentsMap
    ;
  end select ;
  $;$ ;
#--- Get lexique from lexique components map
  [!?lexiqueComponentsMap searchKey !outLexiqueName ?tableTerminaux] ;
label getLexiqueName
  !@lstring outLexiqueName
:
  $import$ ;
  $lexique$ ;
  $identifier$ ? outLexiqueName ;
  select
  or
    $in$ ;
    $literal_string$ ? * ;
    <parse_lexique_for_importing> parse ;
  end select ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                Instruction BLOC                              *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
:
  $block$ ;
#--- Nom de la map
  @lstring nomTable ;
  $identifier$ ? nomTable ;
  @AC_galgasType typeEntite ;
  @typeCplusPlusName nomCppVariableTable ;
  [!?ioVariablesMap searchForReadWriteAccess !nomTable ?typeEntite ?nomCppVariableTable] ; 
  @typeTableBlocsDeTable tableMethodesBloc ;
  extract typeEntite->@typeGalgasMapType (?* ?* ?tableMethodesBloc ?*) error nomTable : messageGalgasType ;
#--- Methode block
  $.$ ;
  @lstring nomMethodeBloc ;
  $identifier$ ? nomMethodeBloc ;
  @L_EXsignature signatureDebut ;
  @L_EXsignature signatureFin ;
  [!?tableMethodesBloc searchKey !nomMethodeBloc ?signatureDebut ?signatureFin] ;
#--- Analyser la list d'arguments du prologue
  @typeExpressionList prologueExpressionList ;
  $($ ;
  <actual_parameters_list>
    !signatureDebut
    ?prologueExpressionList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioEntitiesMap
    !?ioInstructionsList
  ;
  $)$ ;
#--- Generate prologue instruction
  @typeInstruction instruction ;
  instruction := [@typeMapBlockPrologueInstruction new !nomCppVariableTable
                                                      !nomMethodeBloc
                                                      !prologueExpressionList] ;
  ioInstructionsList += !instruction ;
#--- Liste d'instructions incluses
  $:$ ;
  <syntax_instructions_list_no_verif>
    !?ioNonTerminalSymbolMapForSyntax
    !inCheckNonTerminalsAreDeclaredWithParseLabel
    !?ioEntitiesMap
    !?listeEntitesAengendrer
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    !?ioInstructionsList
    !?tableTerminaux
    !?ioSyntaxSignature
  ;
  $end$ ;
  $block$ ;
#--- Analyser la list d'arguments de l'epilogue
  @typeExpressionList epilogueExpressionList ;
  $($ ;
  <actual_parameters_list>
    !signatureFin
    ?epilogueExpressionList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioEntitiesMap
    !?ioInstructionsList
  ;
  $)$ ;
#--- Verifier que la map est toujours accessible en lecture/ecriture
  [!?ioVariablesMap searchForReadWriteAccess !nomTable ?* ?*] ;
#--- Generate epilogue instruction
  instruction := [@typeMapBlockEpilogueInstruction new !nomCppVariableTable
                                                      !nomMethodeBloc
                                                      !epilogueExpressionList] ;
  ioInstructionsList += !instruction ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
:
  $block$ ;
  $identifier$ ? * ;
  $.$ ;
  $identifier$ ? * ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $:$ ;
  <syntax_instructions_list_no_verif> importSyntax !?ioInstructionsList ;
  $end$ ;
  $block$ ;
  $($ ;
  <actual_parameters_list> parse ;
  $)$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#     P A R S I N G   P R O D U C T I O N   R U L E                            *
#------------------------------------------------------------------------------*

rule <syntax_declaration>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ?@lstring inSyntaxComponentName
:
  $rule$ ;
  @lstring ruleName ;
  $<$ ;
  $identifier$ ? ruleName ;
  $>$ ;
  @L_EXsignature listeDeTypesFormels ;
  @typeVariablesMap tableArgumentsMethode [empty] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammar ;
  <formal_arguments_list>
    !?ioEntitiesMap
    ?listeDeTypesFormels 
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammar
  ;
  @lstring returnedEntity ;
  select
    returnedEntity := [@lstring new !"" !here] ;
  or
    $->$ ;
    $type_name$ ? returnedEntity ;
    @AC_semanticsEntity e ;
    [!?ioEntitiesMap searchKey !returnedEntity ?e] ;
    @AC_galgasType type ;
    extract e->@typeEntiteType (?type) error returnedEntity : messageTypeEntite ;
    extract type->@typeGalgas_singleEntity (...) error returnedEntity : messageGalgasType ;
  end select ;
  <rule_declaration_or_implementation>
    !?ioNonTerminalSymbolMapForSyntax
    !?ioEntitiesMap
    !?ioOptionsComponentsMapForUse
    !?tableEnAvant
    !?tableArgumentsMethode
    !listeDeTypesFormels
    !ruleName
    !returnedEntity
    !listeTypeEtNomsArguments
    !?listeEntitesAengendrer
    !?tableTerminaux
    !?ioNonTerminalSymbolsMap
    !signatureForGrammar
    !?ioProductionRulesListForGrammar
    !inSyntaxComponentName
  ;
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
:
  $rule$ ;
  $<$ ;
  @lstring nonterminalSymbolName ;
  $identifier$ ? nonterminalSymbolName ;
  $>$ ;
  @L_signature signature ;
  <formal_arguments_list> importGrammarForSemantics ?signature ;
  @lstring returnedEntity ;
  select
    returnedEntity := [@lstring new !"" !here] ;
  or
    $->$ ;
    $type_name$ ? returnedEntity ;
  end select ;
  <rule_declaration_or_implementation> importSyntax
    !?ioNonTerminalSymbolsMap
    !?ioProductionRulesListForGrammar
    !nonterminalSymbolName
    !signature
    !returnedEntity
  ;
end rule ;

#----------------------------------------------------------------------------*
#   Production rule declaration                                              *
#----------------------------------------------------------------------------*

rule <rule_declaration_or_implementation>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeVariablesMap unused ioVariablesMap
  ?@L_EXsignature listeDeTypes
  ??@lstring inRuleName
  ??@lstring inReturnedEntity
  ?@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMapForGrammar
  ?@L_signature inSignatureForGrammar
  ?!@L_productionRules_ForGrammarComponent unused ioProductionRulesListForGrammar
  ??@lstring unused inSyntaxComponentName
:
  @M_nonterminalSymbolAlts parametersMap [empty] ;
  @M_nonterminalSymbolAltsForGrammar parametersMapForGrammar [empty] ;
  @lstring emptyId := [@lstring new !"" !here] ;
  [!?parametersMap insertKey !emptyId !listeDeTypes !inReturnedEntity] ;
  [!?parametersMapForGrammar insertKey
    !emptyId
    !inSignatureForGrammar
    !inReturnedEntity
    ![@lstring new !"" !here] # No Metamodel Name
  ] ;
  repeat
  while
    $label$ ;
    select
      $parse$ ;
      @L_EXsignature listeDeTypesFormels [empty] ;
      @L_signature signatureForGrammarComponent [empty] ;
      @lstring altName [new !"parse" !here] ;
      [!?parametersMap insertKey !altName !listeDeTypesFormels ![@lstring new !"" !here]] ;
      [!?parametersMapForGrammar insertKey
        !altName
        !signatureForGrammarComponent
        ![@lstring new !"" !here]
        ![@lstring new !"" !here] # No Metamodel Name
      ] ;
    or
      @lstring altName ;
      $identifier$ ? altName ;
      @L_EXsignature listeDeTypesFormels ;
      @typeVariablesMap tableArgumentsMethode [empty] ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @L_signature signatureForGrammarComponent ;
      <formal_arguments_list>
        !?ioEntitiesMap
        ?listeDeTypesFormels 
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      @lstring returnedEntity ;
      select
        returnedEntity := [@lstring new !"" !here] ;
      or
        $->$ ;
        $type_name$ ? returnedEntity ;
        @AC_semanticsEntity e ;
        [!?ioEntitiesMap searchKey !returnedEntity ?e] ;
        @AC_galgasType type ;
        extract e->@typeEntiteType (?type) error returnedEntity : messageTypeEntite ;
        extract type->@typeGalgas_singleEntity (...) error returnedEntity : messageGalgasType ;
      end select ;
      [!?parametersMap insertKey !altName !listeDeTypesFormels !returnedEntity] ;
      [!?parametersMapForGrammar insertKey
        !altName
        !signatureForGrammarComponent
        !returnedEntity
        ![@lstring new !"" !here] # No Metamodel Name
      ] ;
    end select ;
  end repeat ;
  $;$ ;
  [!?ioNonTerminalSymbolsMapForGrammar insertKey !inRuleName !parametersMapForGrammar] ;
  [!?ioNonTerminalSymbolMapForSyntax insertKey !inRuleName !parametersMap] ;
  @typeEntityToGenerate ea := [@typeNonterminalToGenerate new !inRuleName !parametersMap] ;
  listeEntitesAengendrer += !ea ;
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent unused ioProductionRulesListForGrammar
  ??@lstring inNonterminalSymbolName
  ??@L_signature inDefaultSignature
  ??@lstring inReturnedEntity
:
  @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap [empty] ;
  @lstring altName := [@lstring new !"" !here] ;
  [!?nonterminalSymbolParametersMap insertKey
    !altName
    !inDefaultSignature
    !inReturnedEntity
    ![@lstring new !"" !here] # No Metamodel Name
  ] ;
  repeat
  while
    $label$ ;
    select
      $parse$ ;
      @L_signature signature [empty] ;
      @lstring altName [new !"parse" !here] ;
      @lstring noReturnedEntity := [@lstring new !"" !here] ;
      [!?nonterminalSymbolParametersMap insertKey
        !altName
        !signature
        !noReturnedEntity
        ![@lstring new !"" !here] # No Metamodel Name
      ] ;
    or
      $identifier$ ?altName ;
      @L_signature signature ;
      <formal_arguments_list> importGrammarForSemantics ?signature ;
      @lstring returnedEntity ;
      select
        returnedEntity := [@lstring new !"" !here] ;
      or
        $->$ ;
        $type_name$ ? returnedEntity ;
      end select ;
      [!?nonterminalSymbolParametersMap insertKey
        !altName
        !signature
        !returnedEntity
        ![@lstring new !"" !here] # No Metamodel Name
      ] ;
    end select ;
  end repeat ;
  [!?ioNonTerminalSymbolsMap insertKey !inNonterminalSymbolName !nonterminalSymbolParametersMap] ;
  $;$ ;
end rule ;

#----------------------------------------------------------------------------*
#   Production rule implementation                                           *
#----------------------------------------------------------------------------*

rule <rule_declaration_or_implementation>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeVariablesMap ioVariablesMap
  ?@L_EXsignature listeDeTypesFormels
  ??@lstring inRuleName
  ??@lstring inEffectiveReturnedEntity
  ?@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@M_nonTerminalSymbolsForGrammar unused ioNonTerminalSymbolsMapForGrammar
  ?@L_signature inSignatureForGrammar
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ??@lstring unused inSyntaxComponentName
:
#--- Search non terminal symbol definition
  @M_nonterminalSymbolAlts nonterminalSymbolAltMap ;
  [!?ioNonTerminalSymbolMapForSyntax searchKey !inRuleName ?nonterminalSymbolAltMap] ;
#--- Verifier la declaration de la rule et la compatibilite des arguments effectifs avec les arguments formels
  @typeAltProductionsMap altProductionsMap [empty] ;
  @lstring altName := [@lstring new !"" !here] ;
#--- Parse label declared ? If Yes, check that called non terminals are also declared with 'parse' label
  @bool hasParseLabel := [nonterminalSymbolAltMap hasKey !"parse"] ;
  @bool checkNonTerminalsAreDeclaredWithParseLabel := hasParseLabel ;
#--- Parse tag ?
  @string productionTagName ;
  select
    productionTagName := "" ;
  or
    $tag$ ;
    @lstring tagName ;
    $literal_string$ ? tagName ;
    productionTagName := [tagName value] ;
  end select ;
  @location errorLocation := here ;
  $:$ ;
#--- Check rule header
  @L_EXsignature signatureFournieParPrototype ;
  @lstring formalReturnedEntity ;
  [!?nonterminalSymbolAltMap searchKey !altName ?signatureFournieParPrototype ?formalReturnedEntity] ;
  verifierCompatibiliteSignatures
    !signatureFournieParPrototype
    !listeDeTypesFormels
    !errorLocation
  ;
  if ([formalReturnedEntity value] == "") & ([inEffectiveReturnedEntity value] != "") then
    error inEffectiveReturnedEntity: "the non terminal declaration does not name any returned entity" ;
  elsif [inEffectiveReturnedEntity value] != [formalReturnedEntity value] then
    @AC_semanticsEntity e ;
    [!?ioEntitiesMap searchKey !inEffectiveReturnedEntity ?e] ;
    @AC_galgasType type ;
    extract e->@typeEntiteType (?type) error inEffectiveReturnedEntity : messageTypeEntite ;
    @stringset superEntityStringSet ;
    extract type->@typeGalgas_singleEntity (?* ?* ?* ?* ?* ?superEntityStringSet) error inEffectiveReturnedEntity : messageGalgasType ;
    if not [superEntityStringSet hasKey ![formalReturnedEntity value]] then
      error inEffectiveReturnedEntity: "the '@" . [formalReturnedEntity value] . "' entity or one of its inherited entities is expected here" ;
    end if ;
  end if ;
#--- Insert in variable map attributes for returned entity
  @typeInstructionsList listeInstructions [empty] ;
  @entityPropertyMap allPropertiesMap [empty] ;
  if [inEffectiveReturnedEntity value] != "" then
    @AC_semanticsEntity e ;
    [!?ioEntitiesMap searchKey !inEffectiveReturnedEntity ?e] ;
    @AC_galgasType type ;
    extract e->@typeEntiteType (?type) error inEffectiveReturnedEntity : messageTypeEntite ;
    extract type->@typeGalgas_singleEntity (?* ? allPropertiesMap ...) error inEffectiveReturnedEntity : messageGalgasType ;
    foreach allPropertiesMap (??@lstring kKey ??@metamodelPropertyKind kKind ??@lstring kTypeName) :
    #--- Type name
      @AC_semanticsEntity entite ;
      [!?ioEntitiesMap searchKey !kTypeName ?entite] ;
      @AC_galgasType definitionType ;
      extract entite->@typeEntiteType (?definitionType) error inEffectiveReturnedEntity : messageTypeEntite ;
    #--- Type can be used for instanciation ?
      [definitionType typeCanBeUsedInObjectDeclaration] ;
    #--- Variable name
      @lstring nomVariable := [@lstring new ![kKey value] ![inEffectiveReturnedEntity location]] ;
      @typeCplusPlusName nomCppVariable := [@typeAutomaticName new !nomVariable] ;
      if kKind == [@metamodelPropertyKind multipleReferenceProperty] then
        definitionType := [@typeGalgas_multipleEntity new ! kTypeName] ;
         [!?ioVariablesMap insertInArgument !nomVariable !definitionType !nomCppVariable] ;
      else
         [!?ioVariablesMap insertLocalVariable !nomVariable !definitionType !nomCppVariable] ;
      end if ;
      @typeInstruction instruction := [@typeInstructionDeclarationVarLocale new !nomCppVariable !definitionType] ;
      listeInstructions += !instruction ;
    end foreach ;
  end if ;
#--- Parse instructions list
  @L_ruleSyntaxSignature syntaxSignature [empty] ;
  <syntax_instructions_list>
    !?ioNonTerminalSymbolMapForSyntax
    !checkNonTerminalsAreDeclaredWithParseLabel
    !?ioEntitiesMap
    !?listeEntitesAengendrer
    !?ioOptionsComponentsMapForUse
    !?ioVariablesMap
    !?listeInstructions
    !?tableTerminaux
    !?syntaxSignature
  ;
  [!?altProductionsMap insertKey
    !altName
    !listeTypeEtNomsArguments
    !listeInstructions
    !syntaxSignature
    !here
    ![inEffectiveReturnedEntity value]
    !allPropertiesMap
  ] ;
  repeat
  while
    $label$ ;
    $identifier$ ?altName ;
    ioVariablesMap := [@typeVariablesMap empty] ;
    @L_signature signatureForGrammarComponent ;
    <formal_arguments_list>
      !?ioEntitiesMap
      ?listeDeTypesFormels 
      !?ioVariablesMap
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammarComponent # unused
    ;
    @lstring returnedEntity ;
    @entityPropertyMap allPropertiesMap [empty] ;
    select
      returnedEntity := [@lstring new !"" !here] ;
    or
      $->$ ;
      $type_name$ ? returnedEntity ;
      @AC_semanticsEntity e ;
      [!?ioEntitiesMap searchKey !returnedEntity ?e] ;
      @AC_galgasType type ;
      extract e->@typeEntiteType (?type) error returnedEntity : messageTypeEntite ;
      extract type->@typeGalgas_singleEntity (?* ?allPropertiesMap ...) error returnedEntity : messageGalgasType ;
    end select ;
    @location errorLocation := here ;
    $:$ ;
    @L_EXsignature signatureFournieParPrototype ;
    @lstring returnedEntityFromPrototype ;
    [!?nonterminalSymbolAltMap searchKey !altName ?signatureFournieParPrototype ?returnedEntityFromPrototype] ;
    verifierCompatibiliteSignatures
      !signatureFournieParPrototype
      !listeDeTypesFormels
      !errorLocation
    ;
    @typeInstructionsList listeInstructions [empty] ;
    @L_ruleSyntaxSignature syntaxSignature [empty] ;
    <syntax_instructions_list>
      !?ioNonTerminalSymbolMapForSyntax
      !false
      !?ioEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?listeInstructions
      !?tableTerminaux
      !?syntaxSignature
    ;
    [!?altProductionsMap insertKey
      !altName
      !listeTypeEtNomsArguments
      !listeInstructions
      !syntaxSignature
      !here
      ![returnedEntity value]
      !allPropertiesMap
    ] ;
  end repeat ;
  $end$ ;
  $rule$ ;
  $;$ ;
#--- Check if all label rules have the same syntax signature
  action checkLabelSignatures !?altProductionsMap ;
#--- Check that all label rules are implemented
  foreach nonterminalSymbolAltMap (??@lstring nonTerminalAltName ??@L_EXsignature altSignature ??@lstring kReturnedEntity) :
    if [nonTerminalAltName value] != "parse" & not [altProductionsMap hasKey ![nonTerminalAltName value]] then
      error here : "the '" . [nonTerminalAltName value] . "' label is not implemented within the rule" ;
    end if ;
  end foreach ;
#--- Generate production
  @typeEntityToGenerate ea := [@typeProductionAengendrer new
    !inRuleName
    !altProductionsMap
    !productionTagName
    !hasParseLabel
  ] ;
  listeEntitesAengendrer += !ea ;
#--- Generate list for grammar component
  @uint ruleIndex := 0 ;
  ioProductionRulesListForGrammar +=
   !inRuleName
   !ruleIndex
   !syntaxSignature
  ;
label importSyntax
  ?!@M_nonTerminalSymbolsForGrammar unused ioNonTerminalSymbolsMap
  ?!@L_productionRules_ForGrammarComponent ioProductionRulesListForGrammar
  ??@lstring inNonterminalSymbolName
  ??@L_signature unused inDefaultSignature
  ??@lstring unused inReturnedEntity
:
  select
  or
    $tag$ ;
    $literal_string$ ? * ;
  end select ;
  $:$ ;
  @L_ruleSyntaxSignature instructionsList [empty] ;
  <syntax_instructions_list> importSyntax !?instructionsList ;
  repeat
  while
    $label$ ;
    $identifier$ ? * ;
    <formal_arguments_list> parse ;
    select
    or
      $->$ ;
      $type_name$ ? * ;
    end select ;
    $:$ ;
    <syntax_instructions_list> parse ;
  end repeat ;
  @uint leftNonterminalSymbolIndex := 0 ;
  ioProductionRulesListForGrammar += !inNonterminalSymbolName
                                     !leftNonterminalSymbolIndex
                                     !instructionsList ;
  $end$ ;
  $rule$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#              LISTE DES INSTRUCTIONS SYNTAXIQUES D'UNE PRODUCTION             *
#------------------------------------------------------------------------------*

rule <syntax_instructions_list>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
:
  block ioVariablesMap.verifyVariableUsing () :
    <syntax_instructions_list_no_verif>
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !?ioEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionsList
      !?tableTerminaux
      !?ioSyntaxSignature
    ;
    @location positionErreur := here ;
  end block (!positionErreur) ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
:
  <syntax_instructions_list_no_verif> importSyntax !?ioInstructionsList ;
end rule ;

#------------------------------------------------------------------------------*
#          Instruction de verification syntaxique $terminal$ ? ... ;           *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ?!@M_nonTerminalSymbolForSyntax unused ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse unused ioEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents unused ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
:
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  @typeListeAttributsSemantiques listeDesAttributsFormels ;
  [!?tableTerminaux searchKey !terminalSymbolName ?listeDesAttributsFormels] ;
  @L_assignedVariables listeTypeEffectifs ;
  @typeCplusPlusNameList allVariablesList ;
  <input_parameters_list>
    ?listeTypeEffectifs
    ?allVariablesList
    !listeDesAttributsFormels
    !?ioVariablesMap
  ;
  @typeInstruction instruction ;
  instruction := [@typeInstructionVerifSyntaxique new !terminalSymbolName !listeTypeEffectifs] ;
  ioInstructionsList += !instruction ;
  @uint terminalSymbolIndex := 0 ;
  @AC_instruction_ForGrammar i := [@T_terminalInstruction_forGrammarComponent new ![terminalSymbolName location] !terminalSymbolName !terminalSymbolIndex] ;
  ioSyntaxSignature += !i ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
:
  @lstring terminalSymbolName ;
  $terminal$ ? terminalSymbolName ;
  <input_parameters_list> parse ;
  @AC_instruction_ForGrammar i ;
  @uint terminalSymbolIndex := 0 ;
  i := [@T_terminalInstruction_forGrammarComponent new ![terminalSymbolName location] !terminalSymbolName !terminalSymbolIndex] ;
  ioInstructionsList += !i ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#    N O N - T E R M I N A L    C A L L    I N S T R U C T I O N    <p> ...  ; *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse unused tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
:
  $<$ ;
  @lstring nonterminalSymbolName ;
  $identifier$ ? nonterminalSymbolName ;
  $>$ ;
  @lstring altName ;
  select
    altName := [@lstring new !"" !here] ;
  or
    $parse$ ;
    altName := [@lstring new !"parse" !here] ;
  or
    $identifier$ ?altName ;
  end select ;
  @M_nonterminalSymbolAlts nonterminalSymbolAltMap ;
  [!?ioNonTerminalSymbolMapForSyntax searchKey !nonterminalSymbolName ?nonterminalSymbolAltMap] ;
  @L_EXsignature signatureMethode ;
  @lstring returnedEntityFromSignature ;
  [!?nonterminalSymbolAltMap searchKey !altName ?signatureMethode ?returnedEntityFromSignature] ;
#--- Check if parse label is declared ?
  if inCheckNonTerminalsAreDeclaredWithParseLabel & ([altName value] != "parse") then
    if not [nonterminalSymbolAltMap hasKey !"parse"] then
      error here : "As current rule has 'parse' label, every invoked non terminal symbol must be declared with 'parse' label" ;
    end if ;
  end if ;
#--- Parse effective parameter list
  @typeExpressionList parametersExpressionList ;
  <actual_parameters_list>
    !signatureMethode
    ?parametersExpressionList
    !?ioVariablesMap
    !?ioOptionsComponentsMapForUse
    !?ioEntitiesMap
    !?ioInstructionsList
  ;
#--- Parse returned value
  @lstring returnedEntityVariableName ;
  @bool isMultipleEntity := false ;
  select
    returnedEntityVariableName := [@lstring new !"" !here] ;
  or
    $->$ ;
    $identifier$ ? returnedEntityVariableName ;
  or
    $+>$ ;
    $identifier$ ? returnedEntityVariableName ;
    isMultipleEntity := true ;
  end select ;
#--- Check returned value
  if ([returnedEntityFromSignature value] == "") & ([returnedEntityVariableName value] != "") then
    error returnedEntityVariableName: "the non terminal symbol is declared with no returned entity" ;
  elsif ([returnedEntityFromSignature value] != "") & ([returnedEntityVariableName value] == "") then
    error returnedEntityVariableName: "the non terminal symbol is declared to return an instance of '@" .  [returnedEntityFromSignature  value] . "' entity" ;
  elsif ([returnedEntityFromSignature value] != "") & ([returnedEntityVariableName value] != "") then
  #--- Check type consistency
    if isMultipleEntity then
      @AC_galgasType type ;
      [!?ioVariablesMap searchForReadWriteAccess !returnedEntityVariableName ?type ?*] ;
      @lstring typeName ;
      extract type->@typeGalgas_multipleEntity (? typeName) error returnedEntityVariableName : messageGalgasType ;
    else
      @AC_galgasType type ;
      [!?ioVariablesMap searchForWriteAccess !returnedEntityVariableName ?type ?*] ;
      extract type->@typeGalgas_singleEntity (...) error returnedEntityVariableName : messageGalgasType ;
    end if ;
  end if ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@typeInstructionAppelNonTerminal new
    !nonterminalSymbolName
    !parametersExpressionList
    !altName
    !returnedEntityVariableName
    !isMultipleEntity
  ] ;
  ioInstructionsList += !instruction ;
  @AC_instruction_ForGrammar i := [@T_nonterminalInstruction_forGrammarComponent new
    ![nonterminalSymbolName location]
    !nonterminalSymbolName
    !0
  ] ;
  ioSyntaxSignature += !i ;
  $;$ ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
:
  $<$ ;
  @lstring nonterminalSymbolName ;
  $identifier$ ? nonterminalSymbolName ;
  $>$ ;
  select
  or
    $parse$ ;
  or
    $identifier$ ? * ;
  end select ;
  <actual_parameters_list> parse ;
  @AC_instruction_ForGrammar i ;
  @uint nonterminalSymbolIndex := 0 ;
  i := [@T_nonterminalInstruction_forGrammarComponent new ![nonterminalSymbolName location]
                                                          !nonterminalSymbolName
                                                          !nonterminalSymbolIndex] ;
  ioInstructionsList += !i ;
  select
  or
    $->$ ;
    $identifier$ ? * ;
  or
    $+>$ ;
    $identifier$ ? * ;
  end select ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#    S E L E C T    I N S T R U C T I O N                                      *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
:
  $select$ ;
  @location positionDebut := here ;
  @typeListeBranchesInstructions listeBranchesChoix [empty] ;
  @L_branchList_ForGrammarComponent selectList [empty] ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @typeInstructionsList listeInstructionsBrancheChoix [empty] ;
        @L_ruleSyntaxSignature syntaxSignature [empty] ;
        <syntax_instructions_list_no_verif>
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !?ioEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheChoix
          !?tableTerminaux
          !?syntaxSignature
        ;
        listeBranchesChoix += !listeInstructionsBrancheChoix ;
        selectList += !syntaxSignature ;
      end block (!here) ;
    while
      $or$ ;
    end repeat ;
    $end$ ;
    $select$ ;
    $;$ ;
  end block () ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_select_instruction new !listeBranchesChoix !positionDebut] ;
  ioInstructionsList += !instruction ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_selectInstruction_forGrammarComponent new !positionDebut !selectList !v] ;
  ioSyntaxSignature += !i ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
:
  $select$ ;
  @location positionDebut := here ;
  @L_branchList_ForGrammarComponent selectList [empty] ;
  repeat
    @L_ruleSyntaxSignature syntaxSignature [empty] ;
    <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
    selectList += !syntaxSignature ;
  while
    $or$ ;
  end repeat ;
  $end$ ;
  $select$ ;
  $;$ ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_selectInstruction_forGrammarComponent new !positionDebut !selectList !v] ;
  ioInstructionsList += !i ;
end rule ;

#------------------------------------------------------------------------------*
#    R E P E A T    I N S T R U C T I O N                                      *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
:
  $repeat$ ;
  @location positionDebut := here ;
  @typeListeBranchesInstructions listeBranchesRepeter [empty] ;
  @L_branchList_ForGrammarComponent whileList [empty] ;
  block ioVariablesMap.repeatBlock () :
    @typeInstructionsList listeInstructionsPremiereBranche [empty] ;
    @L_ruleSyntaxSignature repeatBranchInstructionsList [empty] ;
    block ioVariablesMap.repeatPart () :
      @L_ruleSyntaxSignature syntaxSignature [empty] ;
      <syntax_instructions_list_no_verif>
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !?ioEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?listeInstructionsPremiereBranche
        !?tableTerminaux
        !?repeatBranchInstructionsList
       ;
      listeBranchesRepeter += !listeInstructionsPremiereBranche ;
      whileList += !repeatBranchInstructionsList ;
      @location positionErreurPremiereBranche := here ;
    end block (!positionErreurPremiereBranche) ;
    $while$ ;
    repeat
      block ioVariablesMap.repeatPart () :
        @typeInstructionsList listeInstructionsBrancheRepeter [empty];
        @L_ruleSyntaxSignature syntaxSignature [empty] ;
        <syntax_instructions_list_no_verif>
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !?ioEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheRepeter
          !?tableTerminaux
          !?syntaxSignature
        ;
        listeBranchesRepeter += !listeInstructionsBrancheRepeter ;
        whileList += !syntaxSignature ;
      end block (!here) ;
    while
      $while$ ;
    end repeat ;
    $end$ ;
    $repeat$ ;
  end block () ;
  $;$ ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_repeat_instruction new !listeBranchesRepeter !positionDebut] ;
  ioInstructionsList += !instruction ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_repeatInstruction_forGrammarComponent new !positionDebut !whileList !v] ;
  ioSyntaxSignature += !i ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
:
  $repeat$ ;
  @location positionDebut := here ;
  @L_branchList_ForGrammarComponent repeatList [empty] ;
  @L_ruleSyntaxSignature syntaxSignature [empty] ;
  <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
  repeatList += !syntaxSignature ;
  $while$ ;
  repeat
    syntaxSignature := [@L_ruleSyntaxSignature empty] ;
    <syntax_instructions_list_no_verif> importSyntax !?syntaxSignature ;
    repeatList += !syntaxSignature ;
  while
    $while$ ;
  end repeat ;
  $end$ ;
  $repeat$ ;
  $;$ ;
  @AC_instruction_ForGrammar i ;
  @uint v := 0 ;
  i := [@T_repeatInstruction_forGrammarComponent new !positionDebut !repeatList !v] ;
  ioInstructionsList += !i ;
end rule ;

#------------------------------------------------------------------------------*
#    P A R S E    D O ...    R E W I N D ...    I N S T R U C T I O N          *
#    P A R S E    W H E N   ...    E L S E  ...    I N S T R U C T I O N       *
#------------------------------------------------------------------------------*

rule <syntax_instruction>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
:
  $parse$ ;
  @typeInstruction instruction ;
  @L_parse_rewind_signature_list parse_rewind_signature_list [empty] ;
  select
    $do$ ;
    @location instructionStartLocation := here ;
    @typeListeBranchesInstructions branchList [empty] ;
  #--- First branch
    @L_branchList_ForGrammarComponent whileList [empty] ;
    @typeInstructionsList firstBranchInstructionsList [empty] ;
    @L_ruleSyntaxSignature firstBranchSyntaxSignature [empty] ;
    <syntax_instructions_list_no_verif>
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !?ioEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?firstBranchInstructionsList
      !?tableTerminaux
      !?firstBranchSyntaxSignature
    ;
    branchList += !firstBranchInstructionsList ;
    parse_rewind_signature_list += !firstBranchSyntaxSignature !instructionStartLocation ;
    foreach firstBranchSyntaxSignature (??@AC_instruction_ForGrammar grammarInstruction) :
      ioSyntaxSignature += !grammarInstruction ;
    end foreach ;
  #--- One or more 'rewind' branches
    repeat
      $rewind$ ;
      @location branchStartLocation := here ;
      @typeInstructionsList instructionsList [empty] ;
      @L_ruleSyntaxSignature syntaxSignature [empty] ;
      <syntax_instructions_list_no_verif>
        !?ioNonTerminalSymbolMapForSyntax
        !inCheckNonTerminalsAreDeclaredWithParseLabel
        !?ioEntitiesMap
        !?listeEntitesAengendrer
        !?ioOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionsList
        !?tableTerminaux
        !?syntaxSignature
      ;
      branchList += !instructionsList ;
      parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
    while
    end repeat ;
    instruction := [@C_parse_rewind_instruction new !here !branchList] ;
  or
  #--- Instruction parse when ... when ... else ... end parse ;
    @L_expression_instructionsList_list branchList [empty] ;
    block ioVariablesMap.testBloc () :
    #--- 'when' branches
      repeat
        block ioVariablesMap.testPart () :
          $when$ ;
          @typeExpression expression ;
          @AC_galgasType resultType ;
          <expression>
            !?ioEntitiesMap
            !?ioOptionsComponentsMapForUse
            !?ioVariablesMap
            ?expression
            ?resultType
          ;
          $:$ ;
          @location branchStartLocation := here ;
          @typeInstructionsList instructionsList [empty] ;
          @L_ruleSyntaxSignature syntaxSignature [empty] ;
          <syntax_instructions_list_no_verif>
            !?ioNonTerminalSymbolMapForSyntax
            !inCheckNonTerminalsAreDeclaredWithParseLabel
            !?ioEntitiesMap
            !?listeEntitesAengendrer
            !?ioOptionsComponentsMapForUse
            !?ioVariablesMap
            !?instructionsList
            !?tableTerminaux
            !?syntaxSignature
          ;
          branchList += !expression !instructionsList ;
          parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
        end block (!here) ;
      while
      end repeat ;
      $else$ ;
      block ioVariablesMap.testPart () :
        @location branchStartLocation := here ;
        @typeInstructionsList elseInstructionsList [empty] ;
        @L_ruleSyntaxSignature syntaxSignature [empty] ;
        <syntax_instructions_list_no_verif>
          !?ioNonTerminalSymbolMapForSyntax
          !inCheckNonTerminalsAreDeclaredWithParseLabel
          !?ioEntitiesMap
          !?listeEntitesAengendrer
          !?ioOptionsComponentsMapForUse
          !?ioVariablesMap
          !?elseInstructionsList
          !?tableTerminaux
          !?syntaxSignature
        ;
        parse_rewind_signature_list += !syntaxSignature  !branchStartLocation ;
        foreach syntaxSignature (??@AC_instruction_ForGrammar grammarInstruction) :
          ioSyntaxSignature += !grammarInstruction ;
        end foreach ;
      end block (!here) ;
    end block () ;
    instruction := [@C_parse_when_else_instruction new !branchList !elseInstructionsList] ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
#--- Generate instruction
  ioInstructionsList += !instruction ;
#--- Check all branches have the same syntax signature
  action checkParseRewindSignatures !?parse_rewind_signature_list ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
:
  $parse$ ;
  select
    $do$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionsList ;
    repeat
      $rewind$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
  or
    repeat
      $when$ ;
      <expression> parse ;
      $:$ ;
      <syntax_instructions_list_no_verif> parse ;
    while
    end repeat ;
    $else$ ;
    <syntax_instructions_list_no_verif> importSyntax !?ioInstructionsList ;
  end select ;
  $end$ ;
  $parse$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*

rule <syntax_instructions_list_no_verif>
  ?!@M_nonTerminalSymbolForSyntax ioNonTerminalSymbolMapForSyntax
  ?@bool inCheckNonTerminalsAreDeclaredWithParseLabel
  ?!@M_semanticsEntitiesForUse ioEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionsList ioInstructionsList
  ?!@M_terminalSymbolsMapForUse tableTerminaux
  ?!@L_ruleSyntaxSignature ioSyntaxSignature
:
  repeat
  while
    <syntax_instruction>
      !?ioNonTerminalSymbolMapForSyntax
      !inCheckNonTerminalsAreDeclaredWithParseLabel
      !?ioEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionsList
      !?tableTerminaux
      !?ioSyntaxSignature
    ;
  while
    <semantic_instruction>
      !?ioEntitiesMap
      !?listeEntitesAengendrer
      !?ioOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionsList
    ;
  end repeat ;
label importSyntax
  ?!@L_ruleSyntaxSignature ioInstructionsList
:
  repeat
  while
    <syntax_instruction> importSyntax !?ioInstructionsList ;
  while
    <semantic_instruction> parse ;
  end repeat ;
end rule ;

#------------------------------------------------------------------------------*

end syntax ;
