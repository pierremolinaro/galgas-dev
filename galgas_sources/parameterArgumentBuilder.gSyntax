#---------------------------------------------------------------------------*
#                                                                           *
#  'expression' component parser, as model builder                          *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax parameterArgumentBuilder :
import lexique galgas_scanner in "galgas_scanner.gLexique" ;
import semantics expressionMetamodel in "expressionMetamodel.gSemantics" ;
import semantics parameterArgumentMetamodel in "parameterArgumentMetamodel.gSemantics" ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression> !@semanticExpression outExpression ;

nonterminal <formal_parameter_list> !@formalParameterList outFormalParameterList ;

nonterminal <formal_input_parameter_list> !@formalInputParameterList outFormalInputParameterList ;

nonterminal <actual_parameter_list> !@actualParameterList outActualParameterList ;

nonterminal <actual_input_parameter_list> !@actualInputParameterList outActualInputParameterList ;

#------------------------------------------------------------------------------*
#                                                                              *
#          F O R M A L    P A R A M E T E R    L I S T                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <formal_parameter_list> !@formalParameterList outFormalParameterList :
  outFormalParameterList := [@formalParameterList emptyList] ;
  repeat
  while
    @formalArgumentPassingMode mFormalParameterPassingMode ;
    select
      $?$ ;
      mFormalParameterPassingMode := [@formalArgumentPassingMode argumentIn] ;
    or
      $??$ ;
      mFormalParameterPassingMode := [@formalArgumentPassingMode argumentConstantIn] ;
    or
      $?!$ ;
      mFormalParameterPassingMode := [@formalArgumentPassingMode argumentInOut] ;
    or
      $!$ ;
      mFormalParameterPassingMode := [@formalArgumentPassingMode argumentOut] ;
    end select ;
    $type_name$ ?@lstring mFormalParameterTypeName ;
    @bool mIsUnused ;
    select
      mIsUnused := false ;
    or
      $unused$ ;
      mIsUnused := true ;
    end select ;
    $identifier$ ?@lstring mFormalParameterName ;
    outFormalParameterList +=
      !mFormalParameterPassingMode
      !mFormalParameterTypeName
      !mFormalParameterName
      !mIsUnused
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  A C T U A L    P A R A M E T E R    L I S T                              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <actual_parameter_list> !@actualParameterList outActualParameterList :
  outActualParameterList := [@actualParameterList emptyList] ;
  repeat
  while
    $?$ ;
    select
      $*$ ;
      outActualParameterList += ![@inputJokerActualParameter new] ;
    or
      @luint count ;
      $unsigned_literal_integer$ ? count ;
      $*$ ;
      @uint n := [count uint] ;
      if n == 0 then
        error count: "the count value should be > 0" ;
      else
        loop n :
        while n > 0 do
          outActualParameterList += ![@inputJokerActualParameter new] ;
          n -- ;
        end loop ;
      end if ;
    end select ;
  while
    $!$ ;
    @semanticExpression e ;
    <expression> ? e ;
    outActualParameterList += ![@outputActualParameter new !e] ;
  while
    $!?$ ;
    @lstring outputInputActualParameterName ;
    $identifier$ ?outputInputActualParameterName ;
    @lstringlist structAttributeList [emptyList] ;
    repeat
    while
      $.$ ;
      $identifier$ ? @lstring structAttributeName ;
      structAttributeList += !structAttributeName ;
    end repeat ;
    outActualParameterList += ![@outputInputActualParameter new !outputInputActualParameterName !structAttributeList] ;
  while
    $?$ ;
    @lstring declarationTypeName ;
    select
      declarationTypeName := [@lstring new !"" !here] ;
    or
      $type_name$ ? declarationTypeName ;
    end select ;
    @lstring inputActualParameterName ;
    $identifier$ ?inputActualParameterName ;
    outActualParameterList += ![@inputActualParameter new !declarationTypeName !inputActualParameterName] ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  F O R M A L    I N P U T    P A R A M E T E R S                          *
#                                                                           *
#---------------------------------------------------------------------------*

rule <formal_input_parameter_list> !@formalInputParameterList outFormalInputParameterList :
  outFormalInputParameterList := [@formalInputParameterList emptyList] ;
  repeat
  while
    $?$ ;
    $type_name$ ?@lstring mFormalParameterTypeName ;
    @bool mIsUnused ;
    select
      mIsUnused := false ;
    or
      $unused$ ;
      mIsUnused := true ;
    end select ;
    $identifier$ ?@lstring mFormalParameterName ;
    outFormalInputParameterList +=
      !mFormalParameterTypeName
      !mFormalParameterName
      !mIsUnused
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  A C T U A L    I N P U T    P A R A M E T E R    L I S T                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <actual_input_parameter_list>
  !@actualInputParameterList outActualInputParameterList
:
  outActualInputParameterList := [@actualInputParameterList emptyList] ;
  repeat
  while
    $?$ ;
    @lstring mActualParameterTypeName ;
    select
      mActualParameterTypeName := [@lstring new !"" !here] ;
    or
      $type_name$ ? mActualParameterTypeName ;
    end select ;
    @lstring mActualParameterName ;
    select
      $identifier$ ?mActualParameterName ;
    or
      $*$ ;
      mActualParameterName := [@lstring new !"" !here] ;
    end select ;
    outActualInputParameterList +=
      !mActualParameterTypeName
      !mActualParameterName
    ;
  end repeat ;
end rule ;  

#---------------------------------------------------------------------------*

end syntax ;
