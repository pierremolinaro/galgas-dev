#---------------------------------------------------------------------------*
#                                                                           *
#  Template parser                                                          *
#                                                                           *
#  Copyright (C) 2008, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax galgasTemplateParser :
import lexique galgasTemplateScanner in "galgasTemplateScanner.gLexique" ;
import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

nonterminal <lexique_component_start_symbol>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
;

nonterminal <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse inEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

#---------------------------------------------------------------------------*

routine enterTemplateString
  ?!@templateInstructionList outResultingInstructionList
:
  @lstring s := [@lstring retrieveAndResetTemplateString]  ;
  if [s length] > 0 then
    outResultingInstructionList += ![@templateInstructionString new ![s string]] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  @typeExpression expression ;
  @AC_galgasType resultType ;
  $($ ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  @typeGalgas_string x := (cast resultType if >= @typeGalgas_string else error here) ;
  ioResultingInstructionList += ![@templateInstructionExpression new !expression] ;
  $)$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  @lstring parameterName ;
  $identifier$ ? parameterName ;
  @AC_galgasType type ;
  @typeCplusPlusName cppName ;
  [!?ioTemplateVariableMap searchForReadOnlyAccess !parameterName ?type ?cppName] ;
  @typeGalgas_string x := (cast type if >= @typeGalgas_string else error parameterName) ;
  ioResultingInstructionList += ![@templateInstructionConstant new !cppName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexique_component_start_symbol>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
:
  outResultingInstructionList := [@templateInstructionList emptyList] ;
  block ioTemplateVariableMap.verifyVariableUsing () :
    enterTemplateString !?outResultingInstructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?outResultingInstructionList
      ;
      enterTemplateString !?outResultingInstructionList ;
    end repeat ;
  end block (!here) ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
