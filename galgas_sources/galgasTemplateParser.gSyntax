#---------------------------------------------------------------------------*
#                                                                           *
#  Template parser                                                          *
#                                                                           *
#  Copyright (C) 2008, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax galgasTemplateParser :
import lexique galgasTemplateScanner in "galgasTemplateScanner.gLexique" ;
import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

nonterminal <lexique_component_start_symbol>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
;

nonterminal <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse inEntitiesMap
  ??@EXsemanticContext inSemanticContext
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioTemplateVariableMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

#---------------------------------------------------------------------------*

routine enterTemplateString
  ?!@templateInstructionList outResultingInstructionList
:
  @lstring s := [@lstring retrieveAndResetTemplateString]  ;
  if [s length] > 0 then
    outResultingInstructionList += ![@templateInstructionString new ![s string]] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $!$ ;
  @typeExpression expression ;
  @AC_galgasType resultType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !?ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  @typeGalgas_string x := (cast resultType if >= @typeGalgas_string else error here) ;
  ioResultingInstructionList += ![@templateInstructionExpression new !expression] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext unused inSemanticContext
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  @lstring parameterName ;
  $identifier$ ? parameterName ;
  warning parameterName:" old style construct, for GALGAS 1.9.3 and later, use '!' prefix" ;
  @AC_galgasType type ;
  @typeCplusPlusName cppName ;
  [!?ioTemplateVariableMap searchForReadOnlyAccess !parameterName ?type ?cppName] ;
  @typeGalgas_string x := (cast type if >= @typeGalgas_string else error parameterName) ;
  ioResultingInstructionList += ![@templateInstructionConstant new !cppName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext unused inSemanticContext
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $:$ ;
  @lstring columnConstantName ;
  $identifier$ ? columnConstantName ;
  @typeCplusPlusName cppName := [@typeAutomaticName new ![columnConstantName location] ![columnConstantName string]] ;
  [!?ioTemplateVariableMap insertConstInArgument
    !columnConstantName
    ![@typeGalgas_string new]
    !cppName
  ] ;
  ioResultingInstructionList += ![@templateInstructionColumnString new !cppName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $block$ ;
  @typeExpression expression ;
  @AC_galgasType resultType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !?ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  @typeGalgas_uint x := (cast resultType if >= @typeGalgas_uint else error here) ;
  $:$ ;
#--- Instruction list
  @templateInstructionList blockInstructionList [emptyList] ;
  enterTemplateString !? blockInstructionList ;
  repeat
  while
    <template_instruction>
      !?ioTemplateVariableMap
      !inSemanticContext
      !inComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?blockInstructionList
    ;
    enterTemplateString !?blockInstructionList ;
  end repeat ;
#---
  $end$ ;
  $block$ ;
  ioResultingInstructionList += ![@templateBlockInstruction new
   !expression
   !here
   !blockInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $foreach$ ;
  @bool ascending ;
  select
    ascending := true ;
  or
    $<$ ;
    ascending := true ;
  or
    $>$ ;
    ascending := false ;
  end select ;
  @typeExpression expression ;
  @AC_galgasType expressionType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !?ioTemplateVariableMap
    ?expression
    ?expressionType
  ;
  @string foreachPrefix ;
  select
    foreachPrefix := "" ;
  or
    $prefixedby$ ;
    $identifier$ ? @lstring prefixString ;
    foreachPrefix := [prefixString string] ;
  end select ;
#---
  @string cppExpressionTypeName ;
  [expressionType getTypeName ?cppExpressionTypeName] ;
#--- Check this variable can be enumerated
  @location instructionLocation := here ;
  @typeListeAttributsSemantiques formalEnumerationList ;
  @localConstantBuildStyleEnum localConstantBuildStyleEnum ;
  @bool iteratorNewStyle ;
  [expressionType acceptForeachInstruction
    !inComponentSemanticsEntitiesMap
    !instructionLocation
    ?formalEnumerationList
    ?localConstantBuildStyleEnum
    ?iteratorNewStyle
  ] ;
#--- before block
  @templateInstructionList beforeInstructionList [emptyList] ;
  select
  or
    $before$ ;
    enterTemplateString !? beforeInstructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?beforeInstructionList
      ;
      enterTemplateString !? beforeInstructionList ;
    end repeat ;
  end select ;
#--- Do block
  block ioTemplateVariableMap.repeatBlock () :
    block ioTemplateVariableMap.repeatPart () :
    #--- Build enumeration variables
      @bool mapStyle := localConstantBuildStyleEnum != [@localConstantBuildStyleEnum listStyle] ;
      @bool firstOne := true ;
      foreach formalEnumerationList do
        @typeCplusPlusName cppName ;
        if (localConstantBuildStyleEnum == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & firstOne then
          cppName := [@typeKeyName new !instructionLocation !iteratorNewStyle] ;
        else
          cppName := [@typeOperandName new !instructionLocation ![mAttributeName string] !mapStyle !iteratorNewStyle] ;
        end if ;
        @lstring implicitVariableName [new !foreachPrefix . mAttributeName ! [mAttributeName location]] ;
        [!?ioTemplateVariableMap insertUsedConstInArgument !implicitVariableName !mAttributType !cppName] ;
        firstOne := false ;
      end foreach ;
      $do$ ;
      @lstring indexIdentifier ;
      select
        indexIdentifier := [@lstring new !"" !here] ;
      or
        $??$ ;
        $identifier$ ? indexIdentifier ;
        @typeCplusPlusName cppName := [@typeAutomaticName new ![indexIdentifier location] ![indexIdentifier string]] ;
        [!?ioTemplateVariableMap insertConstInArgument !indexIdentifier ![@typeGalgas_uint new] !cppName] ;
        $:$ ;
      end select ;
      @templateInstructionList doInstructionList [emptyList] ;
      enterTemplateString !?doInstructionList ;
      repeat
      while
        <template_instruction>
          !?ioTemplateVariableMap
          !inSemanticContext
          !inComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?doInstructionList
        ;
        enterTemplateString !?doInstructionList ;
      end repeat ;
    end block (!here) ;
  end block () ;
#--- between block
  @templateInstructionList betweenInstructionList [emptyList] ;
  select
  or
    $between$ ;
    enterTemplateString !? betweenInstructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?betweenInstructionList
      ;
      enterTemplateString !?betweenInstructionList ;
    end repeat ;
  end select ;
#--- after block
  @templateInstructionList afterInstructionList [emptyList] ;
  select
  or
    $after$ ;
    enterTemplateString !?afterInstructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?beforeInstructionList
      ;
      enterTemplateString !?afterInstructionList ;
    end repeat ;
  end select ;
#---
  $end$ ;
  $foreach$ ;
  ioResultingInstructionList += ![@templateInstructionForeach new
   !ascending
   !cppExpressionTypeName
   !iteratorNewStyle
   !expression
   !instructionLocation
   !beforeInstructionList
   !doInstructionList
   !indexIdentifier
   !betweenInstructionList
   !afterInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $if$ ;
  @templateInstructionIfBranchList templateInstructionIfBranchList [emptyList] ;
  repeat
    @typeExpression expression ;
    @AC_galgasType expressionType ;
    <expression>
      !inComponentSemanticsEntitiesMap
      !inSemanticContext
      !inOptionsComponentsMapForUse
      !?ioTemplateVariableMap
      ?expression
      ?expressionType
    ;
    @typeGalgas_bool x := (cast expressionType if >= @typeGalgas_bool else error here) ;
    $then$ ;
    @templateInstructionList instructionList [emptyList] ;
    enterTemplateString !? instructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?instructionList
      ;
      enterTemplateString !? instructionList ;
    end repeat ;
    templateInstructionIfBranchList += !expression !instructionList ;
  while
    $elsif$ ;
  end repeat ;
#--- else
  @templateInstructionList elseInstructionList [emptyList] ;
  select
  or
    $else$ ;
    enterTemplateString !?elseInstructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?elseInstructionList
      ;
      enterTemplateString !?elseInstructionList ;
    end repeat ;
  end select ;
#---
  $end$ ;
  $if$ ;
  ioResultingInstructionList += ![@templateInstructionIf new
    !templateInstructionIfBranchList
    !elseInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexique_component_start_symbol>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
:
  outResultingInstructionList := [@templateInstructionList emptyList] ;
  block ioTemplateVariableMap.verifyVariableUsing () :
    enterTemplateString !?outResultingInstructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?outResultingInstructionList
      ;
      enterTemplateString !?outResultingInstructionList ;
    end repeat ;
  end block (!here) ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
