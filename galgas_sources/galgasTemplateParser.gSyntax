#---------------------------------------------------------------------------*
#                                                                           *
#  Template parser                                                          *
#                                                                           *
#  Copyright (C) 2008, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax galgasTemplateParser :
with "galgasTemplateScanner.gLexique" ;

import lexique galgasTemplateScanner in "galgasTemplateScanner.gLexique" ;
import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

nonterminal <lexique_component_start_symbol>
  ??@templateVariableMap inTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
;

nonterminal <template_instruction>
  ?!@templateVariableMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse inEntitiesMap
  ??@EXsemanticContext inSemanticContext
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@templateVariableMap inTemplateVariableMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

#---------------------------------------------------------------------------*

routine enterTemplateString
  ?!@templateInstructionList outResultingInstructionList
:
  @lstring s := [@lstring retrieveAndResetTemplateString]  ;
  if [s length] > 0 then
    outResultingInstructionList += ![@templateInstructionString new ![s string]] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $!$ ;
  @typeExpression expression ;
  @AC_galgasType resultType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  @typeGalgas_string x := (cast resultType if >= @typeGalgas_string else error here) ;
  ioResultingInstructionList += ![@templateInstructionExpression new !expression] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMap ioTemplateVariableMap
  ??@EXsemanticContext unused inSemanticContext
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $?$ ;
  @lstring columnConstantName ;
  $identifier$ ? columnConstantName ;
  @typeCplusPlusName cppName := [@typeAutomaticName new ![columnConstantName location] ![columnConstantName string]] ;
  [!?ioTemplateVariableMap insertKey
    !columnConstantName
    ![@typeGalgas_string new]
    !cppName
  ] ;
  ioResultingInstructionList += ![@templateInstructionColumnString new !cppName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $block$ ;
  @typeExpression expression ;
  @AC_galgasType resultType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  @typeGalgas_uint x := (cast resultType if >= @typeGalgas_uint else error here) ;
  $:$ ;
#--- Instruction list
  @templateInstructionList blockInstructionList [emptyList] ;
  enterTemplateString !? blockInstructionList ;
  @templateVariableMap templateVariableMap := ioTemplateVariableMap ;
  repeat
  while
    <template_instruction>
      !?templateVariableMap
      !inSemanticContext
      !inComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?blockInstructionList
    ;
    enterTemplateString !?blockInstructionList ;
  end repeat ;
#---
  $end$ ;
  $block$ ;
  ioResultingInstructionList += ![@templateBlockInstruction new
   !expression
   !here
   !blockInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $foreach$ ;
  @bool ascending ;
  select
    ascending := true ;
  or
    $<$ ;
    ascending := true ;
  or
    $>$ ;
    ascending := false ;
  end select ;
  @typeExpression expression ;
  @AC_galgasType expressionType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !ioTemplateVariableMap
    ?expression
    ?expressionType
  ;
  @string foreachPrefix ;
  select
    foreachPrefix := "" ;
  or
    $prefixedby$ ;
    $identifier$ ? @lstring prefixString ;
    foreachPrefix := [prefixString string] ;
  end select ;
#---
  @string cppExpressionTypeName ;
  [expressionType getTypeName ?cppExpressionTypeName] ;
#--- Check this variable can be enumerated
  @location instructionLocation := here ;
  @typeListeAttributsSemantiques formalEnumerationList ;
  @localConstantBuildStyleEnum localConstantBuildStyleEnum ;
  @bool iteratorNewStyle ;
  [expressionType acceptForeachInstruction
    !inComponentSemanticsEntitiesMap
    !instructionLocation
    ?formalEnumerationList
    ?localConstantBuildStyleEnum
    ?iteratorNewStyle
  ] ;
#--- before block
  @templateInstructionList beforeInstructionList [emptyList] ;
  select
  or
    $before$ ;
    enterTemplateString !? beforeInstructionList ;
    @templateVariableMap templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?beforeInstructionList
      ;
      enterTemplateString !? beforeInstructionList ;
    end repeat ;
  end select ;
#--- Do block
  @templateVariableMap templateVariableMap := ioTemplateVariableMap ;
#--- Build enumeration variables
  @bool mapStyle := localConstantBuildStyleEnum != [@localConstantBuildStyleEnum listStyle] ;
  @bool firstOne := true ;
  foreach formalEnumerationList do
    @typeCplusPlusName cppName ;
    if (localConstantBuildStyleEnum == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & firstOne then
      cppName := [@typeKeyName new !instructionLocation !iteratorNewStyle] ;
    else
      cppName := [@typeOperandName new !instructionLocation ![mAttributeName string] !mapStyle !iteratorNewStyle] ;
    end if ;
    @lstring implicitVariableName [new !foreachPrefix . mAttributeName ! [mAttributeName location]] ;
    [!?templateVariableMap insertKey !implicitVariableName !mAttributType !cppName] ;
    firstOne := false ;
  end foreach ;
  $do$ ;
  @lstring indexIdentifier ;
  select
    indexIdentifier := [@lstring new !"" !here] ;
  or
    $index$ ;
    $identifier$ ? indexIdentifier ;
    @typeCplusPlusName cppName := [@typeAutomaticName new ![indexIdentifier location] ![indexIdentifier string]] ;
    [!?templateVariableMap insertKey !indexIdentifier ![@typeGalgas_uint new] !cppName] ;
  end select ;
  @templateInstructionList doInstructionList [emptyList] ;
  enterTemplateString !?doInstructionList ;
  repeat
  while
    <template_instruction>
      !?templateVariableMap
      !inSemanticContext
      !inComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?doInstructionList
    ;
    enterTemplateString !?doInstructionList ;
  end repeat ;
#--- between block
  @templateInstructionList betweenInstructionList [emptyList] ;
  select
  or
    $between$ ;
    enterTemplateString !? betweenInstructionList ;
    @templateVariableMap templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?betweenInstructionList
      ;
      enterTemplateString !?betweenInstructionList ;
    end repeat ;
  end select ;
#--- after block
  @templateInstructionList afterInstructionList [emptyList] ;
  select
  or
    $after$ ;
    enterTemplateString !?afterInstructionList ;
    @templateVariableMap templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?beforeInstructionList
      ;
      enterTemplateString !?afterInstructionList ;
    end repeat ;
  end select ;
#---
  $end$ ;
  $foreach$ ;
  ioResultingInstructionList += ![@templateInstructionForeach new
   !ascending
   !cppExpressionTypeName
   !iteratorNewStyle
   !expression
   !instructionLocation
   !beforeInstructionList
   !doInstructionList
   !indexIdentifier
   !betweenInstructionList
   !afterInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMap ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $if$ ;
  @templateInstructionIfBranchList templateInstructionIfBranchList [emptyList] ;
  repeat
    @typeExpression expression ;
    @AC_galgasType expressionType ;
    <expression>
      !inComponentSemanticsEntitiesMap
      !inSemanticContext
      !inOptionsComponentsMapForUse
      !ioTemplateVariableMap
      ?expression
      ?expressionType
    ;
    @typeGalgas_bool x := (cast expressionType if >= @typeGalgas_bool else error here) ;
    $then$ ;
    @templateInstructionList instructionList [emptyList] ;
    enterTemplateString !? instructionList ;
    @templateVariableMap templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?instructionList
      ;
      enterTemplateString !? instructionList ;
    end repeat ;
    templateInstructionIfBranchList += !expression !instructionList ;
  while
    $elsif$ ;
  end repeat ;
#--- else
  @templateInstructionList elseInstructionList [emptyList] ;
  select
  or
    $else$ ;
    enterTemplateString !?elseInstructionList ;
    @templateVariableMap templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?elseInstructionList
      ;
      enterTemplateString !?elseInstructionList ;
    end repeat ;
  end select ;
#---
  $end$ ;
  $if$ ;
  ioResultingInstructionList += ![@templateInstructionIf new
    !templateInstructionIfBranchList
    !elseInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexique_component_start_symbol>
  ??@templateVariableMap inTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
:
  outResultingInstructionList := [@templateInstructionList emptyList] ;
  @templateVariableMap templateVariableMap := inTemplateVariableMap ;
  enterTemplateString !?outResultingInstructionList ;
  repeat
  while
    <template_instruction>
      !?templateVariableMap
      !inSemanticContext
      !inComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?outResultingInstructionList
    ;
    enterTemplateString !?outResultingInstructionList ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
