#---------------------------------------------------------------------------*
#                                                                           *
#  Template parser                                                          *
#                                                                           *
#  Copyright (C) 2008, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax galgasTemplateParser :
with "galgasTemplateScanner.gLexique" ;

import lexique galgasTemplateScanner in "galgasTemplateScanner.gLexique" ;
import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

nonterminal <lexique_component_start_symbol>
  ??@templateVariableMapEX inTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
  !@bool outUsesColumnMarker
;

nonterminal <template_instruction>
  ?!@templateVariableMapEX ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
  ?!@bool ioUsesColumnMarker
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse inEntitiesMap
  ??@EXsemanticContext inSemanticContext
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@templateVariableMapEX inTemplateVariableMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
;

#---------------------------------------------------------------------------*

routine enterTemplateStringEX
  ?!@templateInstructionList outResultingInstructionList
:
  @lstring s := [@lstring retrieveAndResetTemplateString]  ;
  if [s length] > 0 then
    outResultingInstructionList += ![@templateInstructionString new ![s string]] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMapEX ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
  ?!@bool unused ioUsesColumnMarker
:
  $!$ ;
  @typeExpression expression ;
  @AC_galgasType resultType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  @typeGalgas_string x := (cast resultType if >= @typeGalgas_string else error here) ;
  ioResultingInstructionList += ![@templateInstructionExpression new !expression] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMapEX unused ioTemplateVariableMap
  ??@EXsemanticContext unused inSemanticContext
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
  ?!@bool ioUsesColumnMarker
:
  $?^$ ;
  ioResultingInstructionList += ![@templateInstructionGetColumnLocation new] ;
  ioUsesColumnMarker := true ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMapEX unused ioTemplateVariableMap
  ??@EXsemanticContext unused inSemanticContext
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
  ?!@bool ioUsesColumnMarker
:
  $!^$ ;
  ioResultingInstructionList += ![@templateInstructionGotoColumnLocation new] ;
  ioUsesColumnMarker := true ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMapEX ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
  ?!@bool ioUsesColumnMarker
:
  $block$ ;
  @typeExpression expression ;
  @AC_galgasType resultType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  @typeGalgas_uint x := (cast resultType if >= @typeGalgas_uint else error here) ;
  $:$ ;
#--- Instruction list
  @templateInstructionList blockInstructionList [emptyList] ;
  enterTemplateStringEX !? blockInstructionList ;
  @templateVariableMapEX templateVariableMap := ioTemplateVariableMap ;
  repeat
  while
    <template_instruction>
      !?templateVariableMap
      !inSemanticContext
      !inComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?blockInstructionList
      !?ioUsesColumnMarker
    ;
    enterTemplateStringEX !?blockInstructionList ;
  end repeat ;
#---
  $end$ ;
  $block$ ;
  ioResultingInstructionList += ![@templateBlockInstruction new
   !expression
   !here
   !blockInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMapEX ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
  ?!@bool ioUsesColumnMarker
:
  $foreach$ ;
  @bool ascending ;
  select
    ascending := true ;
  or
    $<$ ;
    ascending := true ;
  or
    $>$ ;
    ascending := false ;
  end select ;
  @typeExpression expression ;
  @AC_galgasType expressionType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !ioTemplateVariableMap
    ?expression
    ?expressionType
  ;
  @string foreachPrefix ;
  select
    foreachPrefix := "" ;
  or
    $prefixedby$ ;
    $identifier$ ? @lstring prefixString ;
    foreachPrefix := [prefixString string] ;
  end select ;
#---
  @string cppExpressionTypeName ;
  [expressionType getTypeName ?cppExpressionTypeName] ;
#--- Check this variable can be enumerated
  @location instructionLocation := here ;
  @typeListeAttributsSemantiques formalEnumerationList ;
  @localConstantBuildStyleEnum localConstantBuildStyleEnum ;
  @bool iteratorNewStyle ;
  [expressionType acceptForeachInstruction
    !inComponentSemanticsEntitiesMap
    !instructionLocation
    ?formalEnumerationList
    ?localConstantBuildStyleEnum
    ?iteratorNewStyle
  ] ;
#--- before block
  @templateInstructionList beforeInstructionList [emptyList] ;
  select
  or
    $before$ ;
    enterTemplateStringEX !? beforeInstructionList ;
    @templateVariableMapEX templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?beforeInstructionList
        !?ioUsesColumnMarker
      ;
      enterTemplateStringEX !? beforeInstructionList ;
    end repeat ;
  end select ;
#--- Do block
  @templateVariableMapEX templateVariableMap := ioTemplateVariableMap ;
#--- Build enumeration variables
  @bool mapStyle := localConstantBuildStyleEnum != [@localConstantBuildStyleEnum listStyle] ;
  @bool firstOne := true ;
  foreach formalEnumerationList do
    @typeCplusPlusName cppName ;
    if (localConstantBuildStyleEnum == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & firstOne then
      cppName := [@typeKeyName new !instructionLocation !iteratorNewStyle] ;
    else
      cppName := [@typeOperandName new !instructionLocation ![mAttributeName string] !mapStyle !iteratorNewStyle] ;
    end if ;
    @lstring implicitVariableName [new !foreachPrefix . mAttributeName !here] ;
    [!?templateVariableMap insertKey !implicitVariableName !mAttributType !cppName] ;
    firstOne := false ;
  end foreach ;
  $do$ ;
  @lstring indexIdentifier ;
  select
    indexIdentifier := [@lstring new !"" !here] ;
  or
    $index$ ;
    $identifier$ ? indexIdentifier ;
    @typeCplusPlusName cppName := [@typeAutomaticName new ![indexIdentifier location] ![indexIdentifier string]] ;
    [!?templateVariableMap insertKey !indexIdentifier ![@typeGalgas_uint new] !cppName] ;
  end select ;
  @templateInstructionList doInstructionList [emptyList] ;
  enterTemplateStringEX !?doInstructionList ;
  repeat
  while
    <template_instruction>
      !?templateVariableMap
      !inSemanticContext
      !inComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?doInstructionList
      !?ioUsesColumnMarker
    ;
    enterTemplateStringEX !?doInstructionList ;
  end repeat ;
#--- between block
  @templateInstructionList betweenInstructionList [emptyList] ;
  select
  or
    $between$ ;
    enterTemplateStringEX !? betweenInstructionList ;
    @templateVariableMapEX templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?betweenInstructionList
        !?ioUsesColumnMarker
      ;
      enterTemplateStringEX !?betweenInstructionList ;
    end repeat ;
  end select ;
#--- after block
  @templateInstructionList afterInstructionList [emptyList] ;
  select
  or
    $after$ ;
    enterTemplateStringEX !?afterInstructionList ;
    @templateVariableMapEX templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?beforeInstructionList
        !?ioUsesColumnMarker
      ;
      enterTemplateStringEX !?afterInstructionList ;
    end repeat ;
  end select ;
#---
  $end$ ;
  $foreach$ ;
  ioResultingInstructionList += ![@templateInstructionForeach new
   !ascending
   !cppExpressionTypeName
   !iteratorNewStyle
   !expression
   !instructionLocation
   !beforeInstructionList
   !doInstructionList
   !indexIdentifier
   !betweenInstructionList
   !afterInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMapEX ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
  ?!@bool ioUsesColumnMarker
:
  $if$ ;
  @templateInstructionIfBranchList templateInstructionIfBranchList [emptyList] ;
  repeat
    @typeExpression expression ;
    @AC_galgasType expressionType ;
    <expression>
      !inComponentSemanticsEntitiesMap
      !inSemanticContext
      !inOptionsComponentsMapForUse
      !ioTemplateVariableMap
      ?expression
      ?expressionType
    ;
    @typeGalgas_bool x := (cast expressionType if >= @typeGalgas_bool else error here) ;
    $then$ ;
    @templateInstructionList instructionList [emptyList] ;
    enterTemplateStringEX !? instructionList ;
    @templateVariableMapEX templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?instructionList
        !?ioUsesColumnMarker
      ;
      enterTemplateStringEX !? instructionList ;
    end repeat ;
    templateInstructionIfBranchList += !expression !instructionList ;
  while
    $elsif$ ;
  end repeat ;
#--- else
  @templateInstructionList elseInstructionList [emptyList] ;
  select
  or
    $else$ ;
    enterTemplateStringEX !?elseInstructionList ;
    @templateVariableMapEX templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?elseInstructionList
        !?ioUsesColumnMarker
      ;
      enterTemplateStringEX !?elseInstructionList ;
    end repeat ;
  end select ;
#---
  $end$ ;
  $if$ ;
  ioResultingInstructionList += ![@templateInstructionIf new
    !templateInstructionIfBranchList
    !elseInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@templateVariableMapEX ioTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
  ?!@bool ioUsesColumnMarker
:
  $switch$ ;
#--- Switch expression
  @typeExpression switchExpression ;
  @AC_galgasType switchExpressionType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inSemanticContext
    !inOptionsComponentsMapForUse
    !ioTemplateVariableMap
    ?switchExpression
    ?switchExpressionType
  ;
#--- Check switch expression type is an enum
  @typeGalgas_enum x := (cast switchExpressionType if >= @typeGalgas_enum else error here) ;
  const @enumConstantMap enumConstantesMap := [x mEnumConstantesMap] ;
#--- Loop on "when' clauses
  @stringset namedConstantSet [emptySet] ;
  @templateInstructionSwitchBranchList templateInstructionSwitchBranchList [emptyList] ;
  repeat
  while
    $when$ ;
    @lstringlist constantList [emptyList] ;
    repeat
      $identifier$ ?@lstring constantName ;
      [enumConstantesMap searchKey !constantName ?*] ;
      if [namedConstantSet hasKey ![constantName string]] then
        error constantName : "this constant is already named in the switch instruction" ;
      end if ;
      namedConstantSet += ![constantName string] ;
      constantList += !constantName ;
    while
      $,$ ;
    end repeat ;
    $:$ ;
    @templateInstructionList instructionList [emptyList] ;
    enterTemplateStringEX !? instructionList ;
    @templateVariableMapEX templateVariableMap := ioTemplateVariableMap ;
    repeat
    while
      <template_instruction>
        !?templateVariableMap
        !inSemanticContext
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?instructionList
        !?ioUsesColumnMarker
      ;
      enterTemplateStringEX !? instructionList ;
    end repeat ;
    templateInstructionSwitchBranchList += !constantList !instructionList ;
  end repeat ;
#--- Check every constant is named once
  @stringset missingConstants := [enumConstantesMap allKeys] - namedConstantSet ;
  if [missingConstants count] > 0 then
    @string m := "the following constants are missing:" ;
    foreach missingConstants do
      m .= "\n  - '" . key . "'" ;
    end foreach ;
    error here : m ;
  end if ;
#---
  $end$ ;
  $switch$ ;
  ioResultingInstructionList += ![@templateInstructionSwitch new
    ![[x mEnumTypeName] string]
    !switchExpression
    !templateInstructionSwitchBranchList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexique_component_start_symbol>
  ??@templateVariableMapEX inTemplateVariableMap
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
  !@bool outUsesColumnMarker
:
  outResultingInstructionList := [@templateInstructionList emptyList] ;
  @templateVariableMapEX templateVariableMap := inTemplateVariableMap ;
  enterTemplateStringEX !?outResultingInstructionList ;
  outUsesColumnMarker := false ;
  repeat
  while
    <template_instruction>
      !?templateVariableMap
      !inSemanticContext
      !inComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?outResultingInstructionList
      !?outUsesColumnMarker
    ;
    enterTemplateStringEX !?outResultingInstructionList ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
