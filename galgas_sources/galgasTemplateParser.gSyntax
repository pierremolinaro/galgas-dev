#---------------------------------------------------------------------------*
#                                                                           *
#  Template parser                                                          *
#                                                                           *
#  Copyright (C) 2008, ..., 2008 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax galgasTemplateParser :
import lexique galgasTemplateScanner in "galgasTemplateScanner.gLexique" ;
import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

nonterminal <lexique_component_start_symbol>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
;

nonterminal <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse inEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioTemplateVariableMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

#---------------------------------------------------------------------------*

routine enterTemplateString
  ?!@templateInstructionList outResultingInstructionList
:
  @lstring s := [@lstring retrieveAndResetTemplateString]  ;
  if [s length] > 0 then
    outResultingInstructionList += ![@templateInstructionString new ![s string]] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  @typeExpression expression ;
  @AC_galgasType resultType ;
  $($ ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioTemplateVariableMap
    ?expression
    ?resultType
  ;
  @typeGalgas_string x := (cast resultType if >= @typeGalgas_string else error here) ;
  ioResultingInstructionList += ![@templateInstructionExpression new !expression] ;
  $)$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse unused inComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  @lstring parameterName ;
  $identifier$ ? parameterName ;
  @AC_galgasType type ;
  @typeCplusPlusName cppName ;
  [!?ioTemplateVariableMap searchForReadOnlyAccess !parameterName ?type ?cppName] ;
  @typeGalgas_string x := (cast type if >= @typeGalgas_string else error parameterName) ;
  ioResultingInstructionList += ![@templateInstructionConstant new !cppName] ;
end rule ;

#---------------------------------------------------------------------------*

rule <template_instruction>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@templateInstructionList ioResultingInstructionList
:
  $foreach$ ;
  @bool ascending ;
  select
    ascending := true ;
  or
    $<$ ;
    ascending := true ;
  or
    $>$ ;
    ascending := false ;
  end select ;
  @typeExpression expression ;
  @AC_galgasType expressionType ;
  <expression>
    !inComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioTemplateVariableMap
    ?expression
    ?expressionType
  ;
#---
  @string cppExpressionTypeName ;
  [expressionType getTypeName ?cppExpressionTypeName] ;
#--- Check this variable can be enumerated
  @location instructionLocation := here ;
  @typeListeAttributsSemantiques formalEnumerationList ;
  @localConstantBuildStyleEnum localConstantBuildStyleEnum ;
  @bool iteratorNewStyle ;
  [expressionType acceptForeachInstruction
    !inComponentSemanticsEntitiesMap
    !instructionLocation
    ?formalEnumerationList
    ?localConstantBuildStyleEnum
    ?iteratorNewStyle
  ] ;
  block ioTemplateVariableMap.repeatBlock () :
    block ioTemplateVariableMap.repeatPart () :
    #--- Build enumeration variables
      @bool mapStyle := localConstantBuildStyleEnum != [@localConstantBuildStyleEnum listStyle] ;
      @bool firstOne := true ;
      foreach formalEnumerationList (@AC_galgasType type @lstring attributeName) do
        @typeCplusPlusName cppName ;
        if (localConstantBuildStyleEnum == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & firstOne then
          cppName := [@typeKeyName new !instructionLocation !iteratorNewStyle] ;
        else
          cppName := [@typeOperandName new !instructionLocation ![attributeName string] !mapStyle !iteratorNewStyle] ;
        end if ;
        [!? ioTemplateVariableMap insertUsedConstInArgument !attributeName !type !cppName] ;
        firstOne := false ;
      end foreach ;
      $do$ ;
      @templateInstructionList doInstructionList [emptyList] ;
      enterTemplateString !?doInstructionList ;
      repeat
      while
        <template_instruction>
          !?ioTemplateVariableMap
          !inComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?doInstructionList
        ;
        enterTemplateString !?doInstructionList ;
      end repeat ;
    end block (!here) ;
  end block () ;
#--- between block
  @templateInstructionList betweenInstructionList [emptyList] ;
  select
  or
    $between$ ;
    enterTemplateString !? betweenInstructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?betweenInstructionList
      ;
      enterTemplateString !?betweenInstructionList ;
    end repeat ;
  end select ;
  $end$ ;
  $foreach$ ;
  ioResultingInstructionList += ![@templateInstructionForeach new
   !ascending
   !cppExpressionTypeName
   !iteratorNewStyle
   !expression
   !instructionLocation
   !doInstructionList
   !betweenInstructionList
  ] ;
end rule ;

#---------------------------------------------------------------------------*

rule <lexique_component_start_symbol>
  ?!@typeVariablesMap ioTemplateVariableMap
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  !@templateInstructionList outResultingInstructionList
:
  outResultingInstructionList := [@templateInstructionList emptyList] ;
  block ioTemplateVariableMap.verifyVariableUsing () :
    enterTemplateString !?outResultingInstructionList ;
    repeat
    while
      <template_instruction>
        !?ioTemplateVariableMap
        !inComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?outResultingInstructionList
      ;
      enterTemplateString !?outResultingInstructionList ;
    end repeat ;
  end block (!here) ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
