#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS metamodel component parser definition                             *
#                                                                           *
#  Copyright (C) 2006, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_parser :

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

#-------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  !@entityToImplementMap outAllMetamodelClassMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label parse
;

nonterminal <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ??@bool inGenerateMetamodelCode
label parse
;

nonterminal <entity_declaration_list>
  ??@string inCurrentMetamodelName
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@entityToImplementMap ioEntityMap
  ?!@entityToImplementMap ioAllEntityMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
label parse
;

nonterminal <entity_declaration>
  ??@string inCurrentMetamodelName
  ??@stringset inMetamodelClassSet
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@entityToImplementMap ioEntityMap
  ?!@entityToImplementMap ioAllEntityMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@uint ioEntityID
label parseForEnumeratingClasses
  ?!@stringset ioMetamodelClassSet
label parse
;

#-------------------------------------------------------------------*
#                   Metamodel component                             *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  <parse_metamodel> !?ioMetamodelComponentMap !true ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_metamodel> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  <parse_metamodel> !?ioMetamodelComponentMap !false ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
  ?!@EXsemanticContext unused ioSemanticContext
  ?!@stringset unused ioImportedSemanticsComponentNameSet
:
  <parse_metamodel> !?ioMetamodelComponentMap !false ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  <parse_metamodel> !?ioMetamodelComponentMap !false ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_metamodel> parse ;
end rule ;

#-------------------------------------------------------------------*

rule <parse_metamodel>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ??@bool inGenerateMetamodelCode
:
  @lstring metamodelName ;
  @lstringlist superMetamodelList ;
  @lstring rootEntityName ;
  select
    $abstract$ ;
    $metamodel$ ;
    $identifier$ ? metamodelName ;
  #--- Super metamodels
    select
      superMetamodelList := [@lstringlist emptyList] ;
    or
      superMetamodelList := [@lstringlist emptyList] ;
      $extends$ ;
      repeat
       @lstring superMetamodel ;
        $identifier$ ? superMetamodel ;
        superMetamodelList += !superMetamodel ;
      while
        $,$ ;
      end repeat ;
    end select ;
    rootEntityName := [@lstring new !"" !here] ;
  or
    $metamodel$ ;
    $identifier$ ? metamodelName ;
  #--- Super metamodels
    select
      superMetamodelList := [@lstringlist emptyList] ;
    or
      superMetamodelList := [@lstringlist emptyList] ;
      $extends$ ;
      repeat
       @lstring superMetamodel ;
        $identifier$ ? superMetamodel ;
        superMetamodelList += !superMetamodel ;
      while
        $,$ ;
      end repeat ;
    end select ;
  #--- Root entity
    $root$ ;
    $type_name$ ? rootEntityName ;
  end select ;
  $:$ ;
#--- Import statements
  @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
  @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
  @M_treewalkingComponents treewalkingComponentMap [emptyMap] ;
  @M_grammarComponents grammarComponentsMap [emptyMap] ;
  @M_optionComponents optionsComponentsMap [emptyMap] ;
  @ModelMap modelMap [emptyMap] ;
  @ActionMap actionMap [emptyMap] ;
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  @M_semanticsEntitiesForUse semanticsEntitiesMap ;
  @stringset classNamesSet [emptySet] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedGrammarComponents ;
  @entityToImplementMap allMetamodelClassMap ;
  @EXsemanticContext semanticContext [new
    ![@M_filewrappers emptyMap]
    ![@stringset emptySet]
  ] ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedMetamodelComponents
    ?includedOptionComponents
    ?includedGrammarComponents
    !?lexiqueMapForUse
    !?semanticsComponentsMap
    !?ioMetamodelComponentMap
    !?treewalkingComponentMap
    !?grammarComponentsMap
    !?optionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?optionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?semanticsEntitiesMap
    ?tableEnAvant
    ?allMetamodelClassMap
    !?semanticContext
  ;
#--- Header inclusion list
  @stringlist headerInclusionList [emptyList] ;
  foreach semanticsComponentsMap (@lstring kSemanticComponentName 7*) do
    headerInclusionList += ![kSemanticComponentName string] ;
  end foreach ;
#--- Check super metamodels are defined, build all entity map
  @stringset superMetamodels [emptySet] ;
  @entityToImplementMap allEntityMap [emptyMap] ;
  foreach superMetamodelList (@lstring kSuperMetamodelName) do
    headerInclusionList += ![kSuperMetamodelName string] ;
    performMetamodelInclusion
      !ioMetamodelComponentMap
      !kSuperMetamodelName
      !?superMetamodels
      !?allEntityMap
    ;
  end foreach ;
#--- Entity declarations
  @entityToImplementMap entityMap [emptyMap] ;
  @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
  <entity_declaration_list>
    ![metamodelName string]
    !semanticsEntitiesMap
    !?entityMap
    !?allEntityMap
    !?listeEntitesAengendrer
  ;
#--- Check properties
  foreach entityMap (@lstring kEntityName
                     @entityPropertyMap kAllPropertiesMap
                     *
                     @entityPropertyMap kEntityPropertiesMap
                     5*) do
    foreach kEntityPropertiesMap (@lstring kAttributeName
                                  @AC_galgasType kPropertyType) do
      cast kPropertyType :
      when >= @typeGalgas_singleReferenceEntity e do
        [allEntityMap searchKey ![e mEntityTypeName] ?8*] ;
      when >= @typeGalgas_multipleReferenceEntity e do
        [allEntityMap searchKey ![e mEntityTypeName] ?8*] ;
      else
      end cast ;
    end foreach ;
  end foreach ;
#--- Generate C++ code
  if inGenerateMetamodelCode then
    generate_metamodel
      !entityMap
      !metamodelName
      !listeEntitesAengendrer
      !rootEntityName
      !headerInclusionList
    ;
  end if ;
#--- Add metamodel to metamodel map
  if not [ioMetamodelComponentMap hasKey ![metamodelName string]] then
    [!?ioMetamodelComponentMap insertKey
      !metamodelName
      !rootEntityName
      !entityMap
      !superMetamodels
    ] ;
  end if ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration_list>
  ??@string inCurrentMetamodelName
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@entityToImplementMap ioEntityMap
  ?!@entityToImplementMap ioAllEntityMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
:
  @stringset metamodelClassSet [emptySet] ;
  parse
  do
    repeat
    while
      <entity_declaration> parseForEnumeratingClasses
        !?metamodelClassSet
      ;
    end repeat ;
  rewind
    @uint entityID := 0 ;
    repeat
    while
      <entity_declaration>
        !inCurrentMetamodelName
        !metamodelClassSet
        !inSemanticsEntitiesMap
        !?ioEntityMap
        !?ioAllEntityMap
        !?listeEntitesAengendrer
        !?entityID
      ;
    end repeat ;
  end parse ;
end rule ;

#-------------------------------------------------------------------*

rule <entity_declaration>
  ??@string inCurrentMetamodelName
  ??@stringset inMetamodelClassSet
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@entityToImplementMap ioEntityMap
  ?!@entityToImplementMap ioAllEntityMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@uint ioEntityID
:
#--- Abstract ?
  @bool isAbstract ;
  select
    isAbstract := false ;
  or
    $abstract$ ;
    isAbstract := true ;
  end select ;
#--- Entity Names
  $entity$ ;
  @lstringlist entityNameList [emptyList] ;
  repeat
    @lstring entityName ;
    $type_name$ ? entityName ;
    entityNameList += !entityName ;
  while
    $,$ ;
  end repeat ;
#--- Context properties, or super entity (or nothing)
  @entityPropertyMap allMetamodelPropertyMap ;
  @lstring superEntity ;
  @typeSuperClassesMap superEntityMap ;
  @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
  select
    superEntity := [@lstring new !"" !here] ;
    allMetamodelPropertyMap := [@entityPropertyMap emptyMap] ;
    superEntityMap := [@typeSuperClassesMap emptyMap] ;
    listeTousAttributsSemantiques := [@typeListeAttributsSemantiques emptyList] ;
  or
    $extends$ ;
    $type_name$ ? superEntity ;
    [ioAllEntityMap searchKey
      !superEntity
      ?allMetamodelPropertyMap
      ?3*
      ?superEntityMap
      ?listeTousAttributsSemantiques
      ?2*
    ] ;
    [!?superEntityMap insertKey !superEntity] ;
  end select ;
#--- Property declarations
  @entityPropertyMap currentEntityPropertyMap [emptyMap] ;
  @typeListeAttributsSemantiques listeAttributsSemantiquesCourants [emptyList] ;
  ${$ ;
  repeat
  while
    @lstring propertyOrEntityTypeName ;
    $type_name$ ? propertyOrEntityTypeName ;
    select
      @lstring attributeName ;
      $identifier$ ? attributeName ;
      @AC_galgasType propertyType ;
      if [inMetamodelClassSet hasKey ![propertyOrEntityTypeName string]] then
        propertyType := [@typeGalgas_singleReferenceEntity new
           !propertyOrEntityTypeName
           ![@typeListeAttributsSemantiques emptyList]
           ![@stringset emptySet]
        ] ;
        [!?currentEntityPropertyMap insertKey !attributeName !propertyType] ; 
        [!?allMetamodelPropertyMap insertKey !attributeName !propertyType] ;
      else #--- Attribute
        @AC_semanticsEntity theEntity ;
        [inSemanticsEntitiesMap searchKey !propertyOrEntityTypeName ?theEntity] ;
        propertyType := [(cast theEntity if >= @typeEntiteType else error propertyOrEntityTypeName) aDefType] ;
        [!?currentEntityPropertyMap insertKey !attributeName !propertyType] ; 
        [!?allMetamodelPropertyMap insertKey !attributeName !propertyType] ;
      end if ;
      listeTousAttributsSemantiques += !propertyType !attributeName ;
      listeAttributsSemantiquesCourants += !propertyType !attributeName ;
    or
      @luint lowerBound ;
      @luint higherBound ;
      $[$ ;
      select
        $unsigned_literal_integer$ ? lowerBound ;
        select
          $,$ ;
          select
            $unsigned_literal_integer$ ? higherBound ;
            if ([lowerBound uint] == 0) & ([higherBound uint] == 0) then
              error lowerBound: "if lower bound is zero, higher bound should be greater than zero" ;
            elsif ([lowerBound uint] > 0) & ([higherBound uint] < [lowerBound uint]) then
              error lowerBound: "higher bound should be greater or equal than lower bound" ;
            end if ;
          or
            $*$ ;
            higherBound := [@luint new !0 !here] ;            
          end select ;
        or
          higherBound := lowerBound ;
          if [lowerBound uint] == 0 then
            error lowerBound: "if higher bound is implicit, lower bound should be greater than zero" ;
          end if ;
        end select ;
      or
        lowerBound := [@luint new !0 !here] ;
        higherBound := [@luint new !0 !here] ;
      end select ;
      $]$ ;
      @lstring attributeName ;
      $identifier$ ? attributeName ;
      @AC_galgasType propertyType := [@typeGalgas_multipleReferenceEntity new
        !propertyOrEntityTypeName
        !lowerBound
        !higherBound
      ] ;
      [!?currentEntityPropertyMap insertKey !attributeName !propertyType] ; 
      [!?allMetamodelPropertyMap insertKey !attributeName !propertyType] ; 
      listeTousAttributsSemantiques += !propertyType !attributeName ;
      listeAttributsSemantiquesCourants += !propertyType !attributeName ;
    end select ;
    $;$ ;
  end repeat ;
  $}$ ;
  foreach entityNameList (@lstring kEntityName) do
    [!?ioEntityMap insertKey
      !kEntityName
      !allMetamodelPropertyMap
      !isAbstract
      !currentEntityPropertyMap
      !superEntity
      !superEntityMap
      !listeTousAttributsSemantiques
      !inCurrentMetamodelName
      !ioEntityID
    ] ;
    [!?ioAllEntityMap insertKey
      !kEntityName
      !allMetamodelPropertyMap
      !isAbstract
      !currentEntityPropertyMap
      !superEntity
      !superEntityMap
      !listeTousAttributsSemantiques
      !inCurrentMetamodelName
      !ioEntityID
    ] ;
  #--- Define entity type generation
    @typeEntityToGenerate def := [@C_metamodelEntityToImplement new 
      !kEntityName
      !isAbstract
      !listeTousAttributsSemantiques
      !listeAttributsSemantiquesCourants
      ![superEntity string]
      !ioEntityID
    ] ;
    listeEntitesAengendrer += !def ;
    ioEntityID ++ ;
  end foreach ;
label parseForEnumeratingClasses
  ?!@stringset ioMetamodelClassSet
:
#--- Abstract ?
  select
  or
    $abstract$ ;
  end select ;
#--- Entity Name
  $entity$ ;
  repeat
    @lstring entityName ;
    $type_name$ ? entityName ;
    ioMetamodelClassSet += ![entityName string] ;
  while
    $,$ ;
  end repeat ;
#--- Super entity (or nothing)
  select
  or
    $extends$ ;
    $type_name$ ? * ;
  end select ;
#--- Property declarations
  ${$ ;
  repeat
  while
    $type_name$ ? * ;
    select
      $identifier$ ? * ;
    or
      $[$ ;
      select
        $unsigned_literal_integer$ ? * ;
        select
          $,$ ;
          select
            $unsigned_literal_integer$ ? * ;
          or
            $*$ ;
          end select ;
        or
        end select ;
      or
      end select ;
      $]$ ;
      $identifier$ ? * ;
    end select ;
    $;$ ;
  end repeat ;
  $}$ ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
