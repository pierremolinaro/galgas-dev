#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS main program definition                                           *
#                                                                           *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

program galgas_prgm_v1 "version GALGAS_BETA_VERSION" :
  import semantics lexiqueSemantics in "lexiqueSemantics.gSemantics" ;
  import semantics projectGlobalCheckings in "projectGlobalCheckings.gSemantics" ;
  import semantics projectCreation in "projectCreation.gSemantics" ;
  import semantics lexiqueCompilation in "lexiqueCompilation.gSemantics" ;
  import semantics guiCompilation in "guiCompilation.gSemantics" ;
  import semantics XcodeProjectGeneration in "XcodeProjectGeneration.gSemantics" ;
  import semantics syntaxCompilation in "syntaxCompilation.gSemantics" ;
  import semantics predefinedTypes in "predefinedTypes.gSemantics" ;
  import semantics programComponentCompilation in "programComponentCompilation.gSemantics" ;
  import grammar galgas_LL1_grammar in "galgas_LL1_grammar.gGrammar" ;
  import grammar projectLL1grammar in "projectLL1grammar.gGrammar" ;
  import semantics targetGeneration in "targetGeneration.gSemantics" ;

#---------------------------------------------------------------------------*

before {
#--- Check definition of 'LIBPM_PATH' environnement variable
  const @string libpmVarName := "LIBPM_PATH" ;
  if not [libpmVarName doesEnvironmentVariableExist] then
    error here : "the '" . libpmVarName
    . "' environnement variable is not set; GALGAS requires it to be defined with the absolute path to the 'libpm' directory" ;
  else
    const @string libpmPosixPath := [[@string stringWithEnvironmentVariable !libpmVarName] unixPathWithNativePath] ;
    if not [libpmPosixPath directoryExists] then
      error here : "the '" . libpmVarName
      . "' environnement variable is set to '" . [@string stringWithEnvironmentVariable !libpmVarName]
      . "', but this value does not designate any directory (it should designate the 'libpm' directory" ;
    else
      const @string libpmVersionFilePath := libpmPosixPath . "/version_libpm.h" ;
      if not [libpmVersionFilePath fileExists] then
        error here : "the '" . libpmVarName
        . "' environnement variable is set to '" . [@string stringWithEnvironmentVariable !libpmVarName]
        . "', but this value does not designate a valid 'libpm' directory (it does not contain the 'version_libpm.h' file)" ;
      end if ;
    end if ;
  end if ;
#--- Generate project
  const @string creationProjectName := [option galgas_cli_options.create_project value] ;
  projectCreation !creationProjectName ;
  if [option galgas_cli_options.printPredefinedLexicalActions value] then
    printPredefinedLexicalActions ;
  end if ;
  generatePredefinedTypeFiles
    ![option galgas_cli_options.generatePredefinedTypes value]
  ;
}

#---------------------------------------------------------------------------*

when . "gOption"
message "a GALGAS option source file"
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
  ] ;
  compileOptionComponent !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct ;
}

#---------------------------------------------------------------------------*

when . "gLexique"
message "a GALGAS lexique source file"
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
  ] ;
  compileLexiqueComponent !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct ;
}

#---------------------------------------------------------------------------*

when . "gSemantics"
message "a GALGAS semantics source file"
??@lstring inSourceFile {
  if not [option galgas_cli_options.legacyCodeGeneration value] then
    @parsedComponentStruct parsedComponentStruct [new
      ![@parsedSemanticsComponentMap emptyMap]
      ![@parsedLexiqueComponentMap emptyMap]
      ![@parsedSyntaxComponentMap emptyMap]
      ![@parsedOptionComponentMap emptyMap]
      ![@parsedGrammarComponentMap emptyMap]
      ![@parsedProgramComponentMap emptyMap]
    ] ;
    compileSemanticsComponent !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct;
  else
    @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
    @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
    @M_syntaxComponents syntaxComponentsMap [emptyMap] ;
    @M_grammarComponents grammarComponentsMap [emptyMap] ;
    @M_optionComponents optionComponentsMap [emptyMap] ;
    @EXsemanticContext semanticContext [new
      ![@M_filewrappersEX emptyMap]
      ![@stringset emptySet]
      ![@EXcategoryMethodMap emptyMap]
      ![@EXcategoryReaderMap emptyMap]
      ![@EXcategoryTemplateMap emptyMap]
    ] ;
    grammar galgas_LL1_grammar in inSourceFile dependency "galgas-dep" in "DEPENDENCIES"
      !?lexiqueMapForUse
      !?semanticsComponentsMap
      !?syntaxComponentsMap
      !?grammarComponentsMap
      !?optionComponentsMap
      !?semanticContext
    ;
  end if ;
}

#---------------------------------------------------------------------------*

when . "gSyntax"
message "a GALGAS syntax source file"
??@lstring inSourceFile {
  if not [option galgas_cli_options.legacyCodeGeneration value] then
    @parsedComponentStruct parsedComponentStruct [new
      ![@parsedSemanticsComponentMap emptyMap]
      ![@parsedLexiqueComponentMap emptyMap]
      ![@parsedSyntaxComponentMap emptyMap]
      ![@parsedOptionComponentMap emptyMap]
      ![@parsedGrammarComponentMap emptyMap]
      ![@parsedProgramComponentMap emptyMap]
    ] ;
    compileSyntaxComponent !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct;
  else
    @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
    @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
    @M_syntaxComponents syntaxComponentsMap [emptyMap] ;
    @M_grammarComponents grammarComponentsMap [emptyMap] ;
    @M_optionComponents optionComponentsMap [emptyMap] ;
    @EXsemanticContext semanticContext [new
      ![@M_filewrappersEX emptyMap]
      ![@stringset emptySet]
      ![@EXcategoryMethodMap emptyMap]
      ![@EXcategoryReaderMap emptyMap]
      ![@EXcategoryTemplateMap emptyMap]
    ] ;
    grammar galgas_LL1_grammar in inSourceFile dependency "galgas-dep" in "DEPENDENCIES"
      !?lexiqueMapForUse
      !?semanticsComponentsMap
      !?syntaxComponentsMap
      !?grammarComponentsMap
      !?optionComponentsMap
      !?semanticContext
    ;
  end if ;
}

#---------------------------------------------------------------------------*

when . "gGrammar"
message "a GALGAS grammar source file"
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
  ] ;
  compileGrammarComponent
    !inSourceFile
    !outputDirectory [!inSourceFile]
    ![inSourceFile stringByDeletingLastPathComponent]
    !?parsedComponentStruct;
}

#---------------------------------------------------------------------------*

when . "gGui"
message "a GALGAS GUI source file"
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
  ] ;
  compileGuiComponent !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct ;
}

#---------------------------------------------------------------------------*

when . "gProgram"
message "a GALGAS program source file"
??@lstring inSourceFile {
  if not [option galgas_cli_options.legacyCodeGeneration value] then
    @parsedComponentStruct parsedComponentStruct [new
      ![@parsedSemanticsComponentMap emptyMap]
      ![@parsedLexiqueComponentMap emptyMap]
      ![@parsedSyntaxComponentMap emptyMap]
      ![@parsedOptionComponentMap emptyMap]
      ![@parsedGrammarComponentMap emptyMap]
      ![@parsedProgramComponentMap emptyMap]
    ] ;
    compileProgramComponent !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct;
  else
    @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
    @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
    @M_syntaxComponents syntaxComponentsMap [emptyMap] ;
    @M_grammarComponents grammarComponentsMap [emptyMap] ;
    @M_optionComponents optionComponentsMap [emptyMap] ;
    @EXsemanticContext semanticContext [new
      ![@M_filewrappersEX emptyMap]
      ![@stringset emptySet]
      ![@EXcategoryMethodMap emptyMap]
      ![@EXcategoryReaderMap emptyMap]
      ![@EXcategoryTemplateMap emptyMap]
    ] ;
    grammar galgas_LL1_grammar in inSourceFile dependency "galgas-dep" in "DEPENDENCIES"
      !?lexiqueMapForUse
      !?semanticsComponentsMap
      !?syntaxComponentsMap
      !?grammarComponentsMap
      !?optionComponentsMap
      !?semanticContext
    ;
  end if ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#          Project                                                           *
#                                                                            *
#----------------------------------------------------------------------------*

when . "gProject"
message "a GALGAS project source file"
??@lstring inSourceFile {
  const @string outputDirectory := outputDirectory [!inSourceFile] ;
#--- Parse metamodel component
  @projectComponentAST projectComponent ;
  grammar projectLL1grammar in inSourceFile ?projectComponent ;
#--- Check project name
  if [[projectComponent mProjectName] string] != [[inSourceFile lastPathComponent] stringByDeletingPathExtension] then
    error [projectComponent mProjectName] 
    :"the project name ('" . [projectComponent mProjectName] . "') should be the same as the source file base name ('"
    . [[inSourceFile lastPathComponent] stringByDeletingPathExtension] . "')" ;
  end if ;
#--- Check target name
  const @string targetName := [[projectComponent mTargetName] string] ;
  if targetName == "" then
    error [projectComponent mTargetName]: "the target name should not be empty" ;
  end if ;
#--- Parse features
  @stringset availableGenerationFeatures [emptySet] ;
  availableGenerationFeatures += !"makefile-macosx-intel" ;
  availableGenerationFeatures += !"makefile-macosx-ppc" ;
  availableGenerationFeatures += !"makefile-macosx-universal" ;
  availableGenerationFeatures += !"makefile-macosx" ;
  availableGenerationFeatures += !"makefile-unix" ;
  availableGenerationFeatures += !"makefile-i386-linux-on-macosx" ;
  availableGenerationFeatures += !"makefile-mingw-on-macosx" ;
  availableGenerationFeatures += !"makefile-msys-on-win32" ;
  availableGenerationFeatures += !"xcode-project" ;
  @stringset generationFeatures [emptySet] ;
  foreach [projectComponent mGenerationFeatureList] do
    if [availableGenerationFeatures hasKey ![mValue string]] then
      if [generationFeatures hasKey ![mValue string]] then
        error mValue: "duplicate '" . mValue . "' feature" ;
      end if ;
      generationFeatures += ![mValue string] ;
    else
      @string s := "" ;
      foreach availableGenerationFeatures do
        s .= "\n  - '" . key . "'" ;
      end foreach ;
      error mValue: "unknown '" . mValue . "' feature; avalaible features are:" . s ;
    end if ;
  end foreach ;
#--- 
  if [generationFeatures hasKey !"makefile-macosx-universal"] & not [generationFeatures hasKey !"makefile-macosx-ppc"] then
    warning [projectComponent mProjectName] : "'feature makefile-macosx-ppc' implicitly added, due to 'feature makefile-macosx-universal'" ;
    generationFeatures += !"makefile-macosx-ppc" ;
  end if ;
  if [generationFeatures hasKey !"makefile-macosx-universal"] & not [generationFeatures hasKey !"makefile-macosx-intel"] then
    warning [projectComponent mProjectName] : "'feature makefile-macosx-intel' implicitly added, due to 'feature makefile-macosx-universal'" ;
    generationFeatures += !"makefile-macosx-intel" ;
  end if ;
#--- Generate projects
  const @string projectDirectory := [[inSourceFile stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] ;
  if [generationFeatures hasKey !"makefile-macosx-ppc"] then
    generateMakefilePPCMacOSXTarget !projectDirectory !targetName ;
  end if ;
  if [generationFeatures hasKey !"makefile-macosx-intel"] then
    generateMakefileIntelMacOSXTarget !projectDirectory !targetName ;
  end if ;
  if [generationFeatures hasKey !"makefile-macosx-universal"] then
    generateMakefileUniversalMacOSXTarget !projectDirectory !targetName ;
  end if ;
  if [generationFeatures hasKey !"makefile-macosx"] then
    generateMakefileMacOSXTarget !projectDirectory !targetName ;
  end if ;
  if [generationFeatures hasKey !"makefile-unix"] then
    generateMakefileUnixTarget !projectDirectory !targetName ;
  end if ;
  if [generationFeatures hasKey !"makefile-i386-linux-on-macosx"] then
    generateI386LinuxOnMacOSXTarget !projectDirectory !targetName ;
  end if ;
  if [generationFeatures hasKey !"makefile-mingw-on-macosx"] then
    generateMinGWOnMacOSXTarget !projectDirectory !targetName ;
  end if ;
  if [generationFeatures hasKey !"makefile-msys-on-win32"] then
    generateMsysOnWin32Target !projectDirectory !targetName ;
  end if ;
  if [generationFeatures hasKey !"xcode-project"] then
    generateXcodeProjectTarget !projectDirectory !targetName ;
  end if ;
#--- Check target names, file base name uniqueness, and build target file list
  @sourceFileMap sourceFileMap [emptyMap] ;
  @targetFileListMap targetFileListMap [emptyMap] ;
  foreach [projectComponent mProjectSourceList] do
    @string baseName := [[[mFilePath string] lastPathComponent] stringByDeletingPathExtension] ;
    [!?sourceFileMap insertKey ![@lstring new !baseName ![mFilePath location]] ![mFilePath string] !mSourceKind] ;
    foreach mTargetList do
      if ([mValue string] != "makefile") & ([mValue string] != "xcode_tool") & ([mValue string] != "xcode_app") then
        error mValue: "the target name should be \"makefile\", \"xcode_tool\" or \"xcode_app\"" ;
      else
        targetFileListMap += ![mValue string] !baseName ;
      end if ;
    end foreach ;
  end foreach ;
#--- Parset Component struct
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
  ] ;
#--- Parse galgas sources
  foreach [projectComponent mProjectSourceList] do
    @string extension := [mFilePath pathExtension] ;
    @lstring fullFilePath [new
      ![inSourceFile stringByDeletingLastPathComponent] . "/" . [mFilePath string]
      ![mFilePath location]
    ] ;
    if mSourceKind != [@sourceFileKind externSourceFile] then
      message "*** Compiling '" . mFilePath . "'\n" ;
    end if ;
    switch mSourceKind
    when externSourceFile :
    when guiSourceFile :
      if extension == "gGui" then
        compileGuiComponent !fullFilePath ! outputDirectory !?parsedComponentStruct ;
      else
        error mFilePath:"extension of a gui component should be '.gGui'." ;
      end if ;
    when lexiqueSourceFile :
      if extension == "gLexique" then
        compileLexiqueComponent !fullFilePath ! outputDirectory !?parsedComponentStruct ;
      else
        error mFilePath:"extension of a lexique component should be '.gLexique'." ;
      end if ;
    when optionSourceFile :
      if extension == "gOption" then
        compileOptionComponent !fullFilePath ! outputDirectory !?parsedComponentStruct ;
      else
        error mFilePath:"extension of an option component should be '.gOption'." ;
      end if ;
    when semanticsSourceFile :
      if extension == "gSemantics" then
        if not [option galgas_cli_options.legacyCodeGeneration value] then
          compileSemanticsComponent !fullFilePath ! outputDirectory !?parsedComponentStruct ;
        else
          @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
          @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
          @M_syntaxComponents syntaxComponentsMap [emptyMap] ;
          @M_grammarComponents grammarComponentsMap [emptyMap] ;
          @M_optionComponents optionComponentsMap [emptyMap] ;
          @EXsemanticContext semanticContext [new
            ![@M_filewrappersEX emptyMap]
            ![@stringset emptySet]
            ![@EXcategoryMethodMap emptyMap]
            ![@EXcategoryReaderMap emptyMap]
            ![@EXcategoryTemplateMap emptyMap]
          ] ;
          grammar galgas_LL1_grammar in fullFilePath dependency "galgas-dep" in "DEPENDENCIES"
            !?lexiqueMapForUse
            !?semanticsComponentsMap
            !?syntaxComponentsMap
            !?grammarComponentsMap
            !?optionComponentsMap
            !?semanticContext
          ;
        end if ;
      else
        error mFilePath:"extension of a semantics component should be '.gSemantics'." ;
      end if ;
    when syntaxSourceFile :
      if extension == "gSyntax" then
        if not [option galgas_cli_options.legacyCodeGeneration value] then
          compileSyntaxComponent !fullFilePath !outputDirectory [!inSourceFile] !?parsedComponentStruct;
        else
          @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
          @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
          @M_syntaxComponents syntaxComponentsMap [emptyMap] ;
          @M_grammarComponents grammarComponentsMap [emptyMap] ;
          @M_optionComponents optionComponentsMap [emptyMap] ;
          @EXsemanticContext semanticContext [new
            ![@M_filewrappersEX emptyMap]
            ![@stringset emptySet]
            ![@EXcategoryMethodMap emptyMap]
            ![@EXcategoryReaderMap emptyMap]
            ![@EXcategoryTemplateMap emptyMap]
          ] ;
          grammar galgas_LL1_grammar in fullFilePath dependency "galgas-dep" in "DEPENDENCIES"
            !?lexiqueMapForUse
            !?semanticsComponentsMap
            !?syntaxComponentsMap
            !?grammarComponentsMap
            !?optionComponentsMap
            !?semanticContext
          ;
        end if ;
      else
        error mFilePath:"extension of a syntax component should be '.gSyntax'." ;
      end if ;
    when grammarSourceFile :
      if extension == "gGrammar" then
        compileGrammarComponent
          !fullFilePath
          !outputDirectory [!inSourceFile]
          ![inSourceFile stringByDeletingLastPathComponent]
          !?parsedComponentStruct
        ;
      else
        error mFilePath:"extension of a grammar component should be '.gGrammar'." ;
      end if ;
    when programSourceFile :
      if extension == "gProgram" then
        if not [option galgas_cli_options.legacyCodeGeneration value] then
          compileProgramComponent !fullFilePath !outputDirectory !?parsedComponentStruct ;
        else
          @M_lexiqueComponents lexiqueMapForUse [emptyMap] ;
          @M_semanticsComponents semanticsComponentsMap [emptyMap] ;
          @M_syntaxComponents syntaxComponentsMap [emptyMap] ;
          @M_grammarComponents grammarComponentsMap [emptyMap] ;
          @M_optionComponents optionComponentsMap [emptyMap] ;
          @EXsemanticContext semanticContext [new
            ![@M_filewrappersEX emptyMap]
            ![@stringset emptySet]
            ![@EXcategoryMethodMap emptyMap]
            ![@EXcategoryReaderMap emptyMap]
            ![@EXcategoryTemplateMap emptyMap]
          ] ;
          grammar galgas_LL1_grammar in fullFilePath dependency "galgas-dep" in "DEPENDENCIES"
            !?lexiqueMapForUse
            !?semanticsComponentsMap
            !?syntaxComponentsMap
            !?grammarComponentsMap
            !?optionComponentsMap
            !?semanticContext
          ;
        end if ;
      else
        error mFilePath:"extension of a program component should be '.gProgram'." ;
      end if ;
    end switch ;
  end foreach ;
#--- Perform global checkings
  if [@uint errorCount] == 0 then
    message "*** Perform global checkings\n" ;
    performProjectGlobalCheckings !parsedComponentStruct ![projectComponent mEndOfSourceFile] ;
  end if ;
#--- Update file list for makefile
  if [@uint errorCount] == 0 then
    @stringlist makefileFiles := [targetFileListMap listForKey !"makefile"] ;
    if [makefileFiles length] > 0 then
      @string externSourceFileList := "" ;
      @string galgasSourceList := "" ;
      @stringset pathSet [emptySet] ;
      pathSet += !"SOURCES_DIR += ../hand_coded_sources\n" ;
      foreach makefileFiles do
        @string fullPath ;
        @sourceFileKind sourceKind ;
        [sourceFileMap searchKey ![@lstring new !mValue !here] ?fullPath ?sourceKind] ;
        @string filePath := [fullPath stringByDeletingLastPathComponent] ;
        if sourceKind == [@sourceFileKind externSourceFile] then
          if [filePath firstCharacterOrNul] == '/' then
            pathSet += !"SOURCES_DIR += " . filePath . "\n" ;
          elsif filePath != "" then
            pathSet += !"SOURCES_DIR += ../hand_coded_sources/" . filePath . "\n" ;
          end if ;
          externSourceFileList .= "SOURCES += " . [fullPath lastPathComponent] . "\n" ;
        else
          galgasSourceList .= "SOURCES += " . [[fullPath lastPathComponent] stringByDeletingPathExtension] . ".cpp\n" ;
        end if ;
      end foreach ;
      @string pathesString := "" ;
      foreach pathSet do
        pathesString .= key ;
      end foreach ;
      @string newFileListContents := [filewrapper fileListTemplateFileWrapper.fileListTemplate
        !pathesString
        !galgasSourceList
        !externSourceFileList
        ![option galgas_cli_options.legacyCodeGeneration value]
      ] ;
      @string fileListPath := outputDirectory . "/file_list.mke" ;
      [newFileListContents writeToFileWhenDifferentContents !fileListPath ?*] ;
    end if ;
  end if ;
#--- Update Xcode project
  @stringlist xcode_tool_files := [targetFileListMap listForKey !"xcode_tool"] ;
  @stringlist xcode_app_files := [targetFileListMap listForKey !"xcode_app"] ;
  if [@uint errorCount] == 0 then
    @string XcodeProjectDir := [[inSourceFile stringByDeletingLastPathComponent] stringByDeletingLastPathComponent] . "/project_xcode" ;
#    log XcodeProjectDir ;
    @stringlist iconFiles := [XcodeProjectDir regularFilesWithExtensions !false ![@stringlist listWithValue !"icns"]] ;
    @stringlist xcodeProjects := [XcodeProjectDir directoriesWithExtensions !false ![@stringlist listWithValue !"xcodeproj"]] ;
    #log xcodeProjects ;
    if [xcodeProjects length] == 0 then
      message "****** Cannot update Xcode project, no project found in '" . XcodeProjectDir . "' directory. ********\n" ;
    elsif [xcodeProjects length] > 1 then
      message "****** Cannot update Xcode project, more than one project exist in '" . XcodeProjectDir . "' directory. ********\n" ;
    elsif [xcodeProjects length] == 1 then
      @string name ; [xcodeProjects first ?name] ;
      const @string fullXcodePath := XcodeProjectDir . "/" . name . "/project.pbxproj" ;
    #--- Update intermediate file
      const @string intermediateFilePath := outputDirectory . "/file_list_for_xcode_project.txt" ;
    #--- Update Xcode project
      @stringset externSourceSet_tool [emptySet] ;
      @stringset guiSourceSet_tool [emptySet] ;
      @stringset scannerSourceSet_tool [emptySet] ;
      @stringset optionSourceSet_tool [emptySet] ;
      @stringset semanticsSourceSet_tool [emptySet] ;
      @stringset syntaxSourceSet_tool [emptySet] ;
      @stringset grammarSourceSet_tool [emptySet] ;
      @stringset programSourceSet_tool [emptySet] ;
      foreach xcode_tool_files do
        @string fullPath ;
        @sourceFileKind sourceKind ;
        [sourceFileMap searchKey ![@lstring new !mValue !here] ?fullPath ?sourceKind] ;
        switch sourceKind 
        when externSourceFile :
          externSourceSet_tool += !fullPath ;
        when lexiqueSourceFile :
          scannerSourceSet_tool += !mValue ;
        when guiSourceFile :
          guiSourceSet_tool += !mValue ;
        when optionSourceFile :
          optionSourceSet_tool += !mValue ;
        when syntaxSourceFile :
          syntaxSourceSet_tool += !mValue ;
        when semanticsSourceFile :
          semanticsSourceSet_tool += !mValue ;
        when grammarSourceFile :
          grammarSourceSet_tool += !mValue ;
        when programSourceFile :
          programSourceSet_tool += !mValue ;
        end switch ;
      end foreach ;
      @stringset externSourceSet_app [emptySet] ;
      @stringset guiSourceSet_app [emptySet] ;
      @stringset scannerSourceSet_app [emptySet] ;
      @stringset optionSourceSet_app [emptySet] ;
      @stringset semanticsSourceSet_app [emptySet] ;
      @stringset syntaxSourceSet_app [emptySet] ;
      @stringset grammarSourceSet_app [emptySet] ;
      @stringset programSourceSet_app [emptySet] ;
      foreach xcode_app_files do
        @string fullPath ;
        @sourceFileKind sourceKind ;
        [sourceFileMap searchKey ![@lstring new !mValue !here] ?fullPath ?sourceKind] ;
        switch sourceKind 
        when externSourceFile :
          externSourceSet_app += !fullPath ;
        when lexiqueSourceFile :
          scannerSourceSet_app += !mValue ;
        when guiSourceFile :
          guiSourceSet_app += !mValue ;
        when optionSourceFile :
          optionSourceSet_app += !mValue ;
        when syntaxSourceFile :
          syntaxSourceSet_app += !mValue ;
        when semanticsSourceFile :
          semanticsSourceSet_app += !mValue ;
        when grammarSourceFile :
          grammarSourceSet_app += !mValue ;
        when programSourceFile :
          programSourceSet_app += !mValue ;
        end switch ;
      end foreach ;
    #--- Build intermediate
      generateXcodeProject
        !externSourceSet_tool
        !guiSourceSet_tool
        !scannerSourceSet_tool
        !optionSourceSet_tool
        !semanticsSourceSet_tool
        !syntaxSourceSet_tool
        !grammarSourceSet_tool
        !programSourceSet_tool
        !externSourceSet_app
        !guiSourceSet_app
        !scannerSourceSet_app
        !optionSourceSet_app
        !semanticsSourceSet_app
        !syntaxSourceSet_app
        !grammarSourceSet_app
        !programSourceSet_app
        ![name stringByDeletingPathExtension] # XCode project base name
        ![fullXcodePath stringByDeletingLastPathComponent] # Full Path of xxx.xcodeproj file
        !iconFiles
        !intermediateFilePath
        ![option galgas_cli_options.legacyCodeGeneration value]
      ;
    end if ;
  end if ;
}

#---------------------------------------------------------------------------*

after {
}

#---------------------------------------------------------------------------*

end program ;

#---------------------------------------------------------------------------*
