#---------------------------------------------------------------------------*
#                                                                           *
#  'metamodel' component parser, as model builder                           *
#                                                                           *
#  Copyright (C) 2007, ..., 2007 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax metamodel_model_builder :
import lexique galgas_scanner in "galgas_scanner.ggs" ;
import metamodel metamodel_metamodel in "metamodel_metamodel.gMetamodel" ;

nonterminal <metamodel_component_start_symbol> -> @metamodelComponentRoot ;

nonterminal <entity_declaration> -> @metamodelEntity ;

nonterminal <component_importation> ?!@lstringlist ioImportedComponentList ;

nonterminal <attribute_or_single_reference_declaration> ??@lstring inPropertyTypeName -> @metamodelAttribute ;

nonterminal <multiple_reference_declaration> ??@lstring inPropertyTypeName -> @metamodelMultipleReference ;

#---------------------------------------------------------------------------*

rule <metamodel_component_start_symbol> -> @metamodelComponentRoot :
  $metamodel$ ;
#--- Metamodel Component Name
  $identifier$ ? mMetamodelComponentName ;
#--- Super metamodels
  mSuperMetamodels := [@lstringlist emptyList] ;
  select
  or
    $extends$ ;
    repeat
      @lstring superMetamodelName ;
      $identifier$ ? superMetamodelName ;
      mSuperMetamodels += !superMetamodelName ;
    while
      $,$ ;
    end repeat ;
  end select ;
#--- Root Entity
  $root$ ;
  $type_name$ ? mMetamodelRootEntityName ;
  $:$ ;
#--- Parse entities and import
  mMetamodelImportedComponents := [@lstringlist emptyList] ;
  repeat
  while 
    <entity_declaration> +> mMetamodelEntities ;
  while 
    <component_importation> !?mMetamodelImportedComponents ;
  end repeat ;
  $end$ ;
  $metamodel$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <component_importation> ?!@lstringlist ioImportedComponentList :
  $import$ ;
  repeat
    @lstring importedComponentFileName ;
    $literal_string$ ? importedComponentFileName ;
    ioImportedComponentList += !importedComponentFileName ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <entity_declaration> -> @metamodelEntity :
#--- Entity header
  select
    mIsAbstract := false ;
  or
   $abstract$ ;
    mIsAbstract := true ;
  end select ;
#---
  $entity$ ;
  $type_name$ ? mEntityName  ;
#--- Super entity
  select
    mSuperEntityName := [@lstring new !"" !here] ;
  or
    $extends$ ;
    $type_name$ ? mSuperEntityName  ;
  end select ;
#--- Properties
  ${$ ;
  repeat
  while
    @lstring propertyTypeName ;
    $type_name$ ? propertyTypeName ;
    select
      <attribute_or_single_reference_declaration> !propertyTypeName +> mAttributes ;
    or
      $[$ ;
      <multiple_reference_declaration> !propertyTypeName +> mMultipleReferences ;
    end select ;
    $;$ ;
  end repeat ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <attribute_or_single_reference_declaration> ??@lstring inPropertyTypeName -> @metamodelAttribute :
  mAttributeTypeName := inPropertyTypeName ;
  $identifier$ ? mAttributeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <multiple_reference_declaration> ??@lstring inPropertyTypeName -> @metamodelMultipleReference :
  select # [] equivalent to [0, 0]
    mLowerBound := [@luint new !0 !here] ;
    mUpperBound := [@luint new !0 !here] ;
  or
    $unsigned_literal_integer$ ? mLowerBound ;
    select # [n] equivalent to [n, n], with n > 0
      mUpperBound := mLowerBound ;
      if [mLowerBound uint] == 0 then
        error mLowerBound: "multiplicity should be greater than zero" -> mLowerBound, mUpperBound ;
      end if ;
    or # [n, p], and p >= n
      $,$ ;
      $unsigned_literal_integer$ ? mUpperBound ;
      if [mUpperBound uint] < [mLowerBound uint] then
        error mUpperBound: "upper bound should be greater or equal to lower bound" -> mLowerBound, mUpperBound ;
      end if ;
    end select ;
  end select ;
  $]$ ;
  mAttributeTypeName := inPropertyTypeName ;
  $identifier$ ? mAttributeName ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
