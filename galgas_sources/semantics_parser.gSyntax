#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component parser definition                             *
#                                                                           *
#  Copyright (C) 1997, ..., 2009 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax semantics_parser :
with "galgas_scanner.gLexique" ;

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

import grammar galgas_LL1_grammar in "galgas_LL1_grammar.gGrammar" ;

import grammar galgasTemplateGrammar in "galgasTemplateGrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#          Nonterminal symbols declaration                                  *
#                                                                           *
#---------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <parse_grammar_component_for_importing>
  ??@lstring inFileName
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <parse_option_component_for_importing>
  ??@lstring inFileName
  ?!@M_optionComponents ioOptionsComponentsMap
label parse
;

nonterminal <class_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
  ??@bool inIsAbstract
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
  ??@bool inIsAbstract
label parse
;

nonterminal <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <semantics_declaration_beginning_by_abstract>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
label parse
;

nonterminal <semantics_declaration_begining_by_extern>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
label parse
;

nonterminal <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  ?!@EXsemanticContext ioSemanticContext
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
label parse
;

nonterminal <parent_class>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
  !@string outSuperClassMessage
  !@bool outHasGeneratedInSeparateFileSetting
label importSemantics
  ?!@ModelMap ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@bool outHasGeneratedInSeparateFileSetting
label parse
;

nonterminal <attributes_definition_list>
  ??@typeTableEnAvant inTableEnAvant
  ?!@typeListModel outAttributeListModel
  ?!@typeSemanticAttributesMap tableAttributs
  ?!@typeListeAttributsSemantiques listeTousAttributsSemantiques # herites et definis dans la classe courante
  !@typeListeAttributsSemantiques listeAttributsSemantiquesCourants # definis dans la classe courante
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

nonterminal <type_parsing>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType definitionType
  !@lstring outTypeName
label parse
;

nonterminal <parse_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outMethodName
  !@typeInstructionList outInstructionsList
  !@L_EXsignature outMethodSignature
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@string inClassMessage
  ??@EXsemanticContext inSemanticContext
  ??@L_lazyAttributeList inLazyAttributeListToImplement
label parse
;

nonterminal <overrided_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool estAbstraite
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@string inClassMessage
  ??@EXsemanticContext inSemanticContext
  ??@L_lazyAttributeList inLazyAttributeListToImplement
label parse
;

nonterminal <non_abstract_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@string inClassMessage
  ??@EXsemanticContext inSemanticContext
  ??@L_lazyAttributeList inLazyAttributeListToImplement
label parse
;

nonterminal <abstract_method>
  ??@bool inIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodes tableDesMethodes
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
label parse
;

nonterminal <semantic_instructions_list>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
label parse
;

nonterminal <semantic_instructions_list_no_verif>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
label parse
;

nonterminal <constant_while_before_in_foreach_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ??@EXsemanticContext inSemanticContext
  !@typeCplusPlusName outIndexVariable
  !@typeInstructionList out_before_instructionList
label secondPhase
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ??@EXsemanticContext inSemanticContext
  !@foreachEnumerationList outForeachEnumerationList
  !@typeExpression outWhileExpression
  !@typeInstructionList out_do_instructionList
label parse
;

nonterminal <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
label parse
;

nonterminal <error_instruction>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <warning_instruction>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <extract_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap tableMessagesAbstraits
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
label parse
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <input_parameters_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ??@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <parse_parameters_list>
  !@L_actualParametersSignature listeTypesParametresEffectifs
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@bool outHasInputParameter
label parse
;

nonterminal <read_access>
  !@lstring nomAttribut
  !@typeCplusPlusName nomCppEntite
  !@AC_galgasType typeEntite
  ?!@typeVariablesMap ioVariablesMap
label parse
;

nonterminal <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
label parse
;

nonterminal <instruction_beginning_with_identifier_and_structure_access>
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
  ??@typeCplusPlusName inNomCppVariableSource
  ??@AC_galgasType inTargetType
  ??@lstringlist inStructAttributeList
label parse
;

nonterminal <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring nomVarDest
  ??@typeCplusPlusName inVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

nonterminal <ex_map_method>
  !@lstring nomMethode
  !@lstring outMessage
label parse
;

nonterminal <map_method>
  !@lstring methodName
  !@lstring getIndexMethodName
  !@lstring outMessage
label parse
;

nonterminal <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@signatureForGrammarAnalysis outSignature
label importGrammarForSemantics
  !@signatureForGrammarAnalysis outSignature
label parse
;

nonterminal <formal_input_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@signatureForGrammarAnalysis outSignature
label importGrammarForSemantics
  !@signatureForGrammarAnalysis outSignature
label parse
;

nonterminal <output_expression_list>
  !@typeExpressionList outExpressionList 
  ??@typeListeAttributsSemantiques inAttributesList
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ?!@typeVariablesMap ioVariablesMap
label parse
;

nonterminal <formal_argument_type>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ??@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
label parse
;

nonterminal <parse_match_operand>
  ?!@typeVariablesMap ioVariablesMap
  !@typeCplusPlusName outCppName
  !@lstring outBaseTypeName
  !@location outVarLocation
  !@bool outIsEnumeration
  !@enumConstantMap outEnumMessageMap
label parse
;

nonterminal <parse_match_case>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outTypeName
label parse
;

nonterminal <parse_effective_input_parameters_list>
  ?!@typeVariablesMap ioVariablesMap
  ?@typeListeAttributsSemantiques inFormalArgumentsList
  ?@location inVarLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
  ?@bool inEnumeratorNewStyle
  !@bool outNoUsedParameter
label parse
;

extern routine buildFileNameWithPath
  !@lstring outFileNameWithPath
  ?@lstring inPath
  ??@lstring inCppClassName
  ??@lstring inExtension
;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E M A N T I C S    C O M P O N E N T                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
:
  $semantics$ ;
#--- Obtenir le nom du component semantique
  @lstring componentName ;
  $identifier$ ? componentName ;
  $:$ ;
  if [[@string stringWithSourceFilePath] pathExtension] != "gSemantics" then
    warning componentName: "In GALGAS 1.9.11 and later, use '.gSemantics' for extension of a semantics file name" ;
  end if ;
  const @string basename := [[[@string stringWithSourceFilePath] lastPathComponent] stringByDeletingPathExtension] ;
  if [componentName string] != basename then
    error componentName: "the component name ('" . [componentName string]
    . "') should be the same as the source file base name ('" . basename . "')"
    ;
  end if ; 
#--- No lexique
  @string defLexique := "" ;
#--- Import semantics
  @ModelMap modelMap [emptyMap] ;
  @ActionMap actionMap [emptyMap] ;
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  @M_semanticsEntitiesForUse componentEntitiesMap ;
  @stringset classNamesSet [emptySet] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedGrammarComponents ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedMetamodelComponents
    ?includedOptionComponents
    ?includedGrammarComponents
    !?ioLexiqueMapForUse
    !?ioSemanticsComponentsMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?optionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?componentEntitiesMap
    ?tableEnAvant
    !?ioSemanticContext
  ;
#-------------- Semantic Declarations
  parse
  #--- First pass on semantic declarations
  do
    @typeTableRoutinesAimplementer UNUSED_tableRoutinesAimplementer [emptyMap] ;
    @typeTableNomRoutinesDeclarees UNUSED_tableNomRoutinesDeclarees [emptyMap] ;
    @typeTableEnAvant UNUSED_tableEnAvant := tableEnAvant ;
    @M_semanticsEntitiesForUse UNUSED_componentSemanticsEntitiesMap := componentEntitiesMap ;
    @EXsemanticContext UNUSED_semanticContext [new
      ![@M_filewrappers emptyMap]
      ![@stringset emptySet]
      ![@EXcategoryMethodMap emptyMap]
      ![@EXcategoryReaderMap emptyMap]
      ![@EXcategoryTemplateMap emptyMap]
    ] ;
    repeat
    while
    <semantics_declaration> importSemantics
      !?modelMap
      !?actionMap
      !?UNUSED_componentSemanticsEntitiesMap
      !?UNUSED_tableNomRoutinesDeclarees
      !?UNUSED_tableEnAvant
      !?UNUSED_tableRoutinesAimplementer
      !?UNUSED_semanticContext
    ;
    end repeat ;
  #--- Second pass on semantic declarations
  rewind
    @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
    @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    repeat
    while
      <semantics_declaration>
        !?componentEntitiesMap
        !?listeEntitesAengendrer
        !optionsComponentsMapForUse
        !?tableNomRoutinesDeclarees
        !?tableEnAvant
        !?tableRoutinesAimplementer
        !?ioSemanticContext
      ; 
    end repeat ;
  end parse ;
#--- Enter component entities in map
  if not [ioSemanticsComponentsMap hasKey ![componentName string]] then
    @M_optionComponents optionsComponentsMap [emptyMap] ;
    [!?ioSemanticsComponentsMap insertKey
      !componentName
      !modelMap
      !actionMap
      !includedSemanticsComponents
      !includedMetamodelComponents
      !includedOptionComponents
      !optionsComponentsMap
      !componentEntitiesMap
    ] ;
  end if ;
#--- End of file
  $end$ ;
  $semantics$ ;
  $;$ ;
#--- Check that all routines have been implemented
  foreach tableNomRoutinesDeclarees do
    if not [tableRoutinesAimplementer hasKey ![key string]] then
      error key : "the routine '" . [key string] .
                         "' is not implemented in the component" ;
    end if ;
  end foreach ;
#--- Check that all forward types have been implemented
  foreach tableEnAvant do
    if not [componentEntitiesMap hasKey ![key string]] then
      error key : "the '@" . [key string] .
                         "' forward type is not implemented in the component" ;
    end if ;
  end foreach ;
#--- Generate component
  generateSemanticsComponent
    !?componentName
    !?inclusionsForHeaderFile
    !?defLexique
    !?listeEntitesAengendrer
    !?inclusionsForImplementationFile
   ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
:
  $semantics$ ;
  @lstring componentName ;
  $identifier$ ? componentName ;
  $:$ ;
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap ;
  enterBuiltinTypes ?componentSemanticsEntitiesMap ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents [emptySet] ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;

  <import_headers_semantics_and_grammars> importSemantics
    !?ioSemanticsComponentsMap
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?modelMap
    ?actionMap
    !?componentSemanticsEntitiesMap
    !?ioSemanticContext
    !?ioImportedSemanticsComponentNameSet
  ;
  @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
  @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  repeat
  while
    <semantics_declaration> importSemantics
      !?modelMap
      !?actionMap
      !?componentSemanticsEntitiesMap
      !?tableNomRoutinesDeclarees
      !?tableEnAvant
      !?tableRoutinesAimplementer
      !?ioSemanticContext
    ;
  end repeat ;
#--- Enter component entities in map
  if not [ioSemanticsComponentsMap hasKey ![componentName string]] then
    @M_optionComponents optionsComponentsMap [emptyMap] ;
    [!?ioSemanticsComponentsMap insertKey
      !componentName
      !modelMap
      !actionMap
      !includedSemanticsComponents
      !includedMetamodelComponents
      !includedOptionComponents
      !optionsComponentsMap
      !componentSemanticsEntitiesMap
    ] ;
  end if ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@EXsemanticContext unused ioSemanticContext
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $semantics$ ;
  $identifier$ ? * ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
end rule ;

#------------------------------------------------------------------------------*
#                                                                              *
#          Parse semantics component for importing                             *
#                                                                              *
#------------------------------------------------------------------------------*

routine parse_semantics_component_for_importing
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
:
  grammar galgas_LL1_grammar label importSemantics in inFileName
    !?ioSemanticsMapForUse
    !?ioSemanticContext
    !?ioImportedSemanticsComponentNameSet
  ;
end routine ;

#---------------------------------------------------------------------------*
#                                                                           *
# I M P O R T  H E A D E R S,  S E M A N T I C S  A N D  G R A M M A R S    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <import_headers_semantics_and_grammars>
  !@stringset outImportedSemanticsComponentNameSet
  !@stringset outIncludedMetamodelComponents
  !@stringset outImportedOptionComponents
  !@stringset outImportedGrammarComponents
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  ?!@EXsemanticContext ioSemanticContext
:
  outActionMap := [@ActionMap emptyMap] ;
  outInclusionsForHeaderFile := [@stringset emptySet] ;
  outInclusionsForImplementationFile := [@stringset emptySet] ;
  outImportedSemanticsComponentNameSet := [@stringset emptySet] ;
  outIncludedMetamodelComponents := [@stringset emptySet] ;
  outImportedOptionComponents := [@stringset emptySet] ;
  outImportedGrammarComponents := [@stringset emptySet] ;
  tableEnAvant := [@typeTableEnAvant emptyMap] ;
  ioOptionsComponentsMapForUse := [@M_optionComponents emptyMap] ;
#--- Create model map, and enter builtin types
  outModelMap := [@ModelMap emptyMap] ;

  [!?outModelMap insertKey ![@lstring new !"char" ! here] ![@CharModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"string" ! here] ![@StringModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"uint" ! here] ![@UIntModel new]] ;
 
  [!?outModelMap insertKey ![@lstring new !"sint" ! here] ![@SIntModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"uint64" ! here] ![@UInt64Model new]] ;
 
  [!?outModelMap insertKey ![@lstring new !"sint64" ! here] ![@SInt64Model new]] ;

  [!?outModelMap insertKey ![@lstring new !"bool" ! here] ![@BoolModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"double" ! here] ![@DoubleModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"lchar" ! here] ![@LCharModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"lstring" ! here] ![@LStringModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"luint" ! here] ![@LUIntModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"lsint" ! here] ![@LSIntModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"luint64" ! here] ![@LUInt64Model new] ] ;

  [!?outModelMap insertKey ![@lstring new !"lsint64" ! here] ![@LSInt64Model new]] ;

  [!?outModelMap insertKey ![@lstring new !"lbool" ! here] ![@LBoolModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"ldouble" ! here] ![@LDoubleModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"location" ! here] ![@LocationModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"stringset" ! here] ![@StringsetModel new]] ;
#--- enter in semantics entities map the galgas types corresponding to keywords
  enterBuiltinTypes ?ioComponentSemanticsEntitiesMap ;
  @stringset alreadyImportedSemanticsComponents [emptySet] ;
  @stringset alreadyImportedMetamodelComponents [emptySet] ;
#--- Loop on import instructions
  repeat
  while
    $import$ ;
    select
      $literal_string$ ? * ;
    or
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      outInclusionsForHeaderFile += ![optionComponentName string] ;
      outImportedOptionComponents += ![optionComponentName string] ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      $in$ ;
      @lstring fileName ;
      $literal_string$ ? fileName ;
      @M_optionComponents importedOptionComponentsMap [emptyMap] ;
      <parse_option_component_for_importing>
        !fileName
        !?importedOptionComponentsMap
      ;
      [importedOptionComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      [!?ioOptionsComponentsMapForUse insertKey !optionComponentName !boolOptionsMap !uintOptionsMap !stringOptionsMap] ;
    or
      $grammar$ ;
      @lstring grammarComponentName ;
      $identifier$ ? grammarComponentName ;
      outInclusionsForImplementationFile += ![grammarComponentName string] . ".h" ;
      outImportedGrammarComponents += ![grammarComponentName string] ;
      @M_grammarComponents grammarComponentsMap ;
      $in$ ;
      @lstring sourceFile ;
      $literal_string$ ? sourceFile ;
      grammarComponentsMap := [@M_grammarComponents emptyMap] ;
      <parse_grammar_component_for_importing> 
        !sourceFile
        !?grammarComponentsMap
        !?ioOptionsComponentsMapForUse
        !?ioSemanticContext
      ;
      @nonterminalSymbolLabelMapForGrammarAnalysis nonterminalSymbolParametersMap ;
      @lstring lexiqueClassName ;
      [grammarComponentsMap searchKey !grammarComponentName ?nonterminalSymbolParametersMap ?lexiqueClassName ?*] ;
      @M_nonterminalSymbolAlts grammarAltMap [emptyMap] ;
      foreach nonterminalSymbolParametersMap do
        @L_EXsignature formalParametersList [emptyList] ;
        foreach mFormalParametersList do
          @AC_semanticsEntity e ;
          [ioComponentSemanticsEntitiesMap searchKey !mGalgasTypeNameForGrammarAnalysis ?e] ;
          @AC_galgasType type := [(cast e if >= @typeEntiteType else error mGalgasTypeNameForGrammarAnalysis) aDefType] ;
          formalParametersList += !type !mFormalArgumentPassingModeForGrammarAnalysis ;
        end foreach ;
        [!?grammarAltMap insertKey !key !formalParametersList] ;
      end foreach ;
      @AC_semanticsEntity e := [@C_grammarForSemantics new !grammarAltMap !lexiqueClassName] ;
      [!?ioComponentSemanticsEntitiesMap insertKey !grammarComponentName !e] ;
      @lstring path := [@lstring new !"" !here] ;
      @lstring extension := [@lstring new !"h" !here] ;
      @lstring fileNameWithPath ;
      buildFileNameWithPath ?fileNameWithPath !path !grammarComponentName !extension ;
      outInclusionsForImplementationFile += ![fileNameWithPath string] ;
      foreach grammarComponentsMap do
        if not [ioGrammarComponentsMap hasKey ![key string]] then
          [!?ioGrammarComponentsMap insertKey
            !key
            !mNonterminalSymbolParametersMap
            !mLexiqueName
            !mOptionsMap
          ] ;
        end if ;
      end foreach ;
    or
      $semantics$ ;
      @lstring componentName ;
      $identifier$ ?componentName ;
      outInclusionsForHeaderFile += ![componentName string] ;
      $in$ ;
      @lstring sourceFile ;
      $literal_string$ ?sourceFile ;
      if not [outImportedSemanticsComponentNameSet hasKey ![componentName string]] then
        outImportedSemanticsComponentNameSet += ![componentName string] ;
#        message "'IMPORTING '" . sourceFile . "'\n" ;
        parse_semantics_component_for_importing
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioSemanticContext
          !?outImportedSemanticsComponentNameSet
        ;
        @M_semanticsEntitiesForUse importedEntities ;
        @M_optionComponents importedOptionsComponentsMap ;
        [ioSemanticsComponentsMap searchKey !componentName ?5* ?importedOptionsComponentsMap ?importedEntities] ;
        foreach importedEntities do
          if not [ioComponentSemanticsEntitiesMap hasKey ![key string]] then
            [!?ioComponentSemanticsEntitiesMap insertKey !key !aDefEntite] ;
          end if ;
        end foreach ;
#        message "'IMPORTING '" . sourceFile . "' DONE\n" ;
      #--- Check that every used option component is already declared
        foreach importedOptionsComponentsMap do
          if not [ioOptionsComponentsMapForUse hasKey ![key string]] then
            error here: "the '" . [key string] . "' option component must have been imported" ;
          end if ;
        end foreach ;
      end if ;
    #--- Import semantics component
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?outModelMap
        !?outActionMap
        !?alreadyImportedSemanticsComponents
        !?alreadyImportedMetamodelComponents
        !componentName
      ;
    end select ;
    $;$ ;
  end repeat ;
#--- Check that every option component used by an imported component is declared here

label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@EXsemanticContext ioSemanticContext
  ?!@stringset ioImportedSemanticsComponentNameSet
:
  outActionMap := [@ActionMap emptyMap] ;
  outModelMap := [@ModelMap emptyMap] ;
  outIncludedSemanticsComponents := [@stringset emptySet] ;
  outIncludedOptionComponents := [@stringset emptySet] ;
  @stringset alreadyImportedSemanticsComponents [emptySet] ;
  @stringset alreadyImportedMetamodelComponents [emptySet] ;
  repeat
  while
    $import$ ;
    select
      $literal_string$ ? * ;
    or
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      outIncludedOptionComponents += ![optionComponentName string] ;
      $in$ ;
      $literal_string$ ? * ;
      <parse_option_component_for_importing> parse ;
    or
      $grammar$ ;
      $identifier$ ? * ;
      $in$ ;
      $literal_string$ ? * ;
      <parse_grammar_component_for_importing> parse ;
    or
      $semantics$ ;
      @lstring componentName ;
      $identifier$ ?componentName ;
      outIncludedSemanticsComponents += ![componentName string] ;
      $in$ ;
      @lstring sourceFile ;
      $literal_string$ ? sourceFile ;
      parse_semantics_component_for_importing
        !sourceFile
        !?ioSemanticsComponentsMap
        !?ioSemanticContext
        !?ioImportedSemanticsComponentNameSet
      ;
      @M_semanticsEntitiesForUse importedEntities ;
      [ioSemanticsComponentsMap searchKey !componentName ?5* ?* ?importedEntities] ;
      foreach importedEntities do
        if not [ioComponentSemanticsEntitiesMap hasKey ![key string]] then
          [!?ioComponentSemanticsEntitiesMap insertKey !key !aDefEntite] ;
        end if ;
      end foreach ;
    #--- Import semantics component
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?outModelMap
        !?outActionMap
        !?alreadyImportedSemanticsComponents
        !?alreadyImportedMetamodelComponents
        !componentName
      ;
    end select ;
    $;$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  R O U T I N E    D E C L A R A T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  $routine$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap localVariableMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?localVariableMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?*
  ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !routineName ?entite] ;
    @typeEntiteRoutine precedenteDeclaration := (cast entite if == @typeEntiteRoutine else error routineName) ;
    verifierCompatibiliteSignatures
      ![precedenteDeclaration aListeArgumentsFormels]
      !listeDeTypes
      !here
     ;
  else
    [!?tableNomRoutinesDeclarees insertKey !routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteRoutine new !listeDeTypes] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    @typeInstructionList ioInstructionList [emptyList] ;
    <semantic_instructions_list>
      !tableEnAvant
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?localVariableMap
      !?ioInstructionList
      !ioSemanticContext
    ;
    $end$ ;
    $routine$ ;
    $;$ ;
  #--- Inserer la routine dans la map des routines a implementer
    @typeEntityToGenerate ea := [@typeRoutineAengendrer new
      !routineName
      !listeTypeEtNomsArguments
      !ioInstructionList
    ] ;
    listeEntitesAengendrer += !ea ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
  end select ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $routine$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Arguments formels de la routine -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap localVariableMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signature ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?localVariableMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signature
  ;
#--- Inserer dans la map des routines utilisables, -------------------------
  if not [ioExternActionMap hasKey ![routineName string]] then
    [!?ioExternActionMap insertKey !routineName !signature !false] ;
  end if ;
  if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    @typeEntiteRoutine precedenteDeclaration := (cast entite if == @typeEntiteRoutine else error routineName) ;
    verifierCompatibiliteSignatures
      ![precedenteDeclaration aListeArgumentsFormels]
      !listeDeTypes
      !here
     ;
  else
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteRoutine new !listeDeTypes] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    <semantic_instructions_list> parse ;
    $end$ ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
    $routine$ ;
    $;$ ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  F U N C T I O N    D E C L A R A T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  $function$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap localVariableMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?localVariableMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?*
  ;
#---- Function return value -----------------------------------------
  @L_EXsignature returnedTypes [emptyList] ;
  $->$ ;
#--- Parse result
  @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentOut] ;
  @AC_galgasType returnedType ;
  @lstring galgasTypeName ;
  <formal_argument_type>
    !ioComponentSemanticsEntitiesMap
    ?returnedType
    !tableEnAvant
    ?galgasTypeName
  ;
  @lstring nomArgument ;
  $identifier$ ? nomArgument ;
  @typeCplusPlusName returnedVar := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
  @bool modeIn := false ;
  [!?localVariableMap insertOutArgument !nomArgument !returnedType !returnedVar] ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !routineName ?entite] ;
    @typeEntiteFonction precedenteDeclaration := (cast entite if == @typeEntiteFonction else error routineName) ;
    verifierCompatibiliteSignatures
      ![precedenteDeclaration aListeArgumentsFormels]
      !listeDeTypes
      !here
     ;
    checkAssignmentTypesCompatibility
      ![precedenteDeclaration mReturnedType]
      !returnedType
      !here
      !false
     ;
  else
    [!?tableNomRoutinesDeclarees insertKey !routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteFonction new !listeDeTypes !returnedType] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    @typeInstructionList ioInstructionList [emptyList] ;
    <semantic_instructions_list>
      !tableEnAvant
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?localVariableMap
      !?ioInstructionList
      !ioSemanticContext
    ;
    $end$ ;
    $function$ ;
    $;$ ;
  #--- Inserer la routine dans la map des routines a implementer
    @typeEntityToGenerate ea := [@typeFonctionAengendrer new
      !routineName
      !listeTypeEtNomsArguments
      !returnedType
      !returnedVar
      !ioInstructionList
    ] ;
    listeEntitesAengendrer += !ea ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
  end select ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $function$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Arguments formels de la routine -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap localVariableMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signature ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?localVariableMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signature
  ;
#---- Function return value -----------------------------------------
  @L_EXsignature returnedTypes [emptyList] ;
  $->$ ;
  @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentOut] ;
  @AC_galgasType returnedType ;
  @lstring galgasTypeName ;
  <formal_argument_type>
    !ioComponentSemanticsEntitiesMap
    ?returnedType
    !tableEnAvant
    ?galgasTypeName
  ;
  @lstring nomArgument ;
  $identifier$ ? nomArgument ;
  @typeCplusPlusName returnedVar := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
  [!?localVariableMap insertOutArgument !nomArgument !returnedType !returnedVar] ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    @typeEntiteFonction precedenteDeclaration := (cast entite if == @typeEntiteFonction else error routineName) ;
    verifierCompatibiliteSignatures
      ![precedenteDeclaration aListeArgumentsFormels]
      !listeDeTypes
      !here
     ;
    checkAssignmentTypesCompatibility
      ![precedenteDeclaration mReturnedType]
      !returnedType
      !here
      !false
     ;
  else
    [!?ioExternActionMap insertKey !routineName !signature !false] ;
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteFonction new !listeDeTypes !returnedType] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    <semantic_instructions_list> parse ;
    $end$ ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
    $function$ ;
    $;$ ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  O N C E    F U N C T I O N    D E C L A R A T I O N                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  $once$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Formal arguments -----------------------------------------
  const @L_EXsignature listeDeTypes [emptyList] ;
  @typeVariablesMap localVariableMap [emptyMap] ;
#---- Function return value -----------------------------------------
  @L_EXsignature returnedTypes [emptyList] ;
  $->$ ;
#--- Parse result
  @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentOut] ;
  @AC_galgasType returnedType ;
  @lstring galgasTypeName ;
  <formal_argument_type>
    !ioComponentSemanticsEntitiesMap
    ?returnedType
    !tableEnAvant
    ?galgasTypeName
  ;
  @lstring nomArgument ;
  $identifier$ ? nomArgument ;
  @typeCplusPlusName returnedVar := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
  @bool modeIn := false ;
  [!?localVariableMap insertOutArgument !nomArgument !returnedType !returnedVar] ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !routineName ?entite] ;
    @typeEntiteFonction precedenteDeclaration := (cast entite if == @typeEntiteFonction else error routineName) ;
    verifierCompatibiliteSignatures
      ![precedenteDeclaration aListeArgumentsFormels]
      !listeDeTypes
      !here
     ;
    checkAssignmentTypesCompatibility
      ![precedenteDeclaration mReturnedType]
      !returnedType
      !here
      !false
     ;
  else
    [!?tableNomRoutinesDeclarees insertKey !routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteFonction new !listeDeTypes !returnedType] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    @typeInstructionList instructionList [emptyList] ;
    <semantic_instructions_list>
      !tableEnAvant
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?localVariableMap
      !?instructionList
      !ioSemanticContext
    ;
    $end$ ;
    $once$ ;
    $;$ ;
  #--- Inserer la routine dans la map des routines a implementer
    @typeEntityToGenerate ea := [@typeOnceFunctionToGenerate new
      !routineName
      !returnedType
      !returnedVar
      !instructionList
    ] ;
    listeEntitesAengendrer += !ea ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
  end select ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $once$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Arguments formels de la routine -----------------------------------------
  const @L_EXsignature listeDeTypes [emptyList] ;
  @typeVariablesMap localVariableMap [emptyMap] ;
  const @signatureForGrammarAnalysis signature [emptyList] ;
#---- Function return value -----------------------------------------
  @L_EXsignature returnedTypes [emptyList] ;
  $->$ ;
  @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentOut] ;
  @AC_galgasType returnedType ;
  @lstring galgasTypeName ;
  <formal_argument_type>
    !ioComponentSemanticsEntitiesMap
    ?returnedType
    !tableEnAvant
    ?galgasTypeName
  ;
  @lstring nomArgument ;
  $identifier$ ? nomArgument ;
  @typeCplusPlusName returnedVar := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
  [!?localVariableMap insertOutArgument !nomArgument !returnedType !returnedVar] ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    ou verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    @typeEntiteFonction precedenteDeclaration := (cast entite if == @typeEntiteFonction else error routineName) ;
    verifierCompatibiliteSignatures
      ![precedenteDeclaration aListeArgumentsFormels]
      !listeDeTypes
      !here
     ;
    checkAssignmentTypesCompatibility
      ![precedenteDeclaration mReturnedType]
      !returnedType
      !here
      !false
     ;
  else
    [!?ioExternActionMap insertKey !routineName !signature !false] ;
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteFonction new !listeDeTypes !returnedType] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    <semantic_instructions_list> parse ;
    $end$ ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
    $once$ ;
    $;$ ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                        ANALYSE D'UNE CLASSE MERE                          *
#---------------------------------------------------------------------------*

rule <parent_class>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
  !@string outSuperClassMessage
  !@bool outHasGeneratedInSeparateFileSetting
:
  listeTousAttributsSemantiques := [@typeListeAttributsSemantiques emptyList] ;
  tableDesClassesAncetres := [@typeSuperClassesMap emptyMap] ;
  tableDesMethodes := [@typeTableMethodes emptyMap] ;
  tableMessagesAbstraits := [@typeClassInheritedMessagesMap emptyMap] ;
  tableAttributs := [@typeSemanticAttributesMap emptyMap] ;
  outSuperClassName := [@lstring new !"" !here] ;
  outSuperClassMessage := "" ;
  outHasGeneratedInSeparateFileSetting := false ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@bool outHasGeneratedInSeparateFileSetting
:
  listeTousAttributsSemantiques := [@typeListeAttributsSemantiques emptyList] ;
  tableDesClassesAncetres := [@typeSuperClassesMap emptyMap] ;
  tableDesMethodes := [@typeTableMethodes emptyMap] ;
  tableMessagesAbstraits := [@typeClassInheritedMessagesMap emptyMap] ;
  tableAttributs := [@typeSemanticAttributesMap emptyMap] ;
#---
  outMessageMap := [@classMessageMap emptyMap] ;
  outSuperClasses := [@stringset emptySet] ;
  outAttributeList := [@typeListModel emptyList] ;
  outHasGeneratedInSeparateFileSetting := false ;
end rule ;

#---------------------------------------------------------------------------*

rule <parent_class>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
  !@string outSuperClassMessage
  !@bool outHasGeneratedInSeparateFileSetting
:
#--- Parse super class name
  $extends$ ;
  $type_name$ ? outSuperClassName ;
#--- Verifications semantiques sur le Parse super class name
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey ! outSuperClassName ?entite] ;
  @AC_galgasType typeUtilisateur :=
      [(cast entite if >= @typeEntiteType else error outSuperClassName) aDefType] ;
  @typeGalgasClassType classType := (cast typeUtilisateur if >= @typeGalgasClassType else error outSuperClassName) ;
  tableDesMethodes := [classType mMethodMap] ;
  listeTousAttributsSemantiques := [classType mAttributeList] ;
  tableDesClassesAncetres := [classType mAncestorClassesMap] ;
  tableMessagesAbstraits := [classType mMessagesMap] ;
  tableAttributs := [classType mNonExternAttributesMap] ;
  outSuperClassMessage := [classType mClassMessage] ;
  outHasGeneratedInSeparateFileSetting := [classType mHasGeneratedInSeparateFileSetting] ;
#--- Le Parse super class name est la derniere inseree en fin de la liste des ancetres 
  [!?tableDesClassesAncetres insertKey ! outSuperClassName] ;
label importSemantics
  ?!@ModelMap ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@bool outHasGeneratedInSeparateFileSetting
:
#--- Parse super class name
  @lstring superClassName ;
  $extends$ ;
  $type_name$ ? superClassName ;
#--- Verifications semantiques sur le Parse super class name
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey ! superClassName ?entite] ;
  @AC_galgasType typeUtilisateur :=
      [(cast entite if >= @typeEntiteType else error superClassName) aDefType] ;
  @typeGalgasClassType classType := (cast typeUtilisateur if >= @typeGalgasClassType else error superClassName) ;
  tableDesMethodes := [classType mMethodMap] ;
  listeTousAttributsSemantiques := [classType mAttributeList] ;
  tableDesClassesAncetres := [classType mAncestorClassesMap] ;
  tableMessagesAbstraits := [classType mMessagesMap] ;
  tableAttributs := [classType mNonExternAttributesMap] ;
  outHasGeneratedInSeparateFileSetting := [classType mHasGeneratedInSeparateFileSetting] ;
#--- Le Parse super class name est la derniere inseree en fin de la liste des ancetres 
#--- The direct super class is last inserted one 
  [!?tableDesClassesAncetres insertKey ! superClassName] ;
#---
  @TypeModel type ;
  [ioModelMap searchKey !superClassName ?type] ;
  cast type :
  when >= @ClassModel model do #(* @stringset superClasses @typeListModel attributeList @classMessageMap messageMap) ->
    outSuperClasses := [model mSuperClasses] ;
    outAttributeList := [model mAttributeList] ;
    outMessageMap := [model mMessageMap] ;
  else
    error superClassName: "the '@" . [superClassName string] . "' type is not a class"
     : outSuperClasses, outAttributeList, outMessageMap ;
  end cast ;
  outSuperClasses += ![superClassName string] ;

  outMessageMap := [@classMessageMap emptyMap] ;
  outSuperClasses := [@stringset emptySet] ;
  outAttributeList := [@typeListModel emptyList] ;

end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     D E C L A R A T I O N   B E G I N N I N G    B Y    A B S T R A C T   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  $abstract$ ;
  <semantics_declaration_beginning_by_abstract>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
    !?ioSemanticContext
  ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  $abstract$ ;
  <semantics_declaration_beginning_by_abstract> importSemantics
    !?ioModelMap
    !?ioExternActionMap
    !?ioComponentSemanticsEntitiesMap
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
    !?ioSemanticContext
  ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     A B S T R A C T    O R    C O N C R E T E    C L A S S                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_beginning_by_abstract>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  <class_declaration>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
    !?ioSemanticContext
    !true # Is abstract
  ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  <class_declaration> importSemantics
    !?ioModelMap
    !?ioExternActionMap
    !?ioComponentSemanticsEntitiesMap
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
    !?ioSemanticContext
    !true # Is abstract
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  <class_declaration>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
    !?ioSemanticContext
    !false # Is not abstract
  ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  <class_declaration> importSemantics
    !?ioModelMap
    !?ioExternActionMap
    !?ioComponentSemanticsEntitiesMap
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
    !?ioSemanticContext
    !false # Is not abstract
  ;
end rule ;

#---------------------------------------------------------------------------*

nonterminal  <once_reader>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributsHerites
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@string inClassMessage
  ??@EXsemanticContext inSemanticContext
  ?!@L_lazyAttributeList ioLazyAttributeList
label parse
;

rule <once_reader>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributsHerites
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@string inClassMessage
  ??@EXsemanticContext inSemanticContext
  ?!@L_lazyAttributeList ioLazyAttributeList
:
#--- Create local variable map
  @typeVariablesMap methodLocalVariablesMap [emptyMap]  ;
  foreach tableAttributsHerites do
    @typeCplusPlusName nomCpp := [@typeDirectName new ![key location] ![key string]] ;
    [!?methodLocalVariablesMap insertUsedConstInArgument !key !mAttributType !nomCpp] ;
  end foreach ;
#--- Header
  $once$ ;
  @typeListeAttributsSemantiques computedAttributeTypeAndNameList [emptyList] ;
  repeat
    $type_name$ ?@lstring  attributeTypeName ;
    $identifier$ ? @lstring attributeName ;
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !attributeTypeName ?entite] ;
    @AC_galgasType t := [(cast entite if >= @typeEntiteType else error attributeTypeName) aDefType] ;
    @typeCplusPlusName nomCpp := [@typeDirectName new ![attributeName location] ![attributeName string]] ;
    [!?methodLocalVariablesMap insertOutArgument !attributeName !t !nomCpp] ;
    computedAttributeTypeAndNameList += !t !attributeName ;
  while
  end repeat ;
#--- Insert the predefined "self" variable
  @L_lazyAttributeList lazyAttributeListForSelfAndSuper := ioLazyAttributeList ;
  lazyAttributeListForSelfAndSuper +=
    !here
    !computedAttributeTypeAndNameList
    ![@typeInstructionList emptyList]
  ;
  @AC_galgasType typeDefinition := [@typeGalgasClassType new 
    !inCurrentClassName
    !tableDesMethodes
    !listeTousAttributsSemantiques
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributsHerites
    !inClassIsAbstract
    !inClassMessage
    !false
    !lazyAttributeListForSelfAndSuper
  ] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument ![@lstring new !"self" !here] !typeDefinition ![@typeCppStarThisName new !here ![inCurrentClassName string]]] ;
#--- Insert the predefined "super" variable
  typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !inAncestorClassMethodsMap
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributsHerites
           !inClassIsAbstract
           !inClassMessage
           !false
     !lazyAttributeListForSelfAndSuper
  ] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument ![@lstring new !"super" !here] !typeDefinition ![@typeCppInheritedName new !here]] ;
#--- Add current class definition
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap := ioComponentSemanticsEntitiesMap ;
  @AC_semanticsEntity entite := [@typeEntiteType new ! typeDefinition] ;
  [!?componentSemanticsEntitiesMap insertKey !inCurrentClassName !entite] ;
#--- Parse reader instruction list
  $:$ ;
  @typeInstructionList instructionsList [emptyList] ;
  <semantic_instructions_list>
    !tableEnAvant
    !componentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?methodLocalVariablesMap
    !?instructionsList
    !inSemanticContext
  ;
#--- End
  $end$ ;
  $once$ ;
  $;$ ;
#--- Enter in implement list
  ioLazyAttributeList +=
    !here
    !computedAttributeTypeAndNameList
    !instructionsList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <class_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
  ??@bool inIsAbstract
:
  $class$ ;
 #--- Abstract class name
  $type_name$ ?@lstring  abstractClassName ;
  select
    if not ([tableEnAvant hasKey ![abstractClassName string]] |
          [ioComponentSemanticsEntitiesMap hasKey ![abstractClassName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedClassType new !abstractClassName] ;
      [!?tableEnAvant insertKey !abstractClassName !t] ;
    end if ;
    $;$ ;
  or
  #--- Analyse de la classe mere (if existe)
    @typeTableMethodes ancestorClassMethodsMap ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
    @typeSuperClassesMap tableDesClassesAncetres ;
    @typeClassInheritedMessagesMap inheritedMessageMap ;
    @typeSemanticAttributesMap tableAttributs ;
    @string superClassMessage ;
    @bool hasGeneratedInSeparateFileSetting ;
    <parent_class>
      !?ioComponentSemanticsEntitiesMap
      ?tableAttributs
      ?listeTousAttributsSemantiques
      ?ancestorClassMethodsMap
      ?tableDesClassesAncetres
      ?inheritedMessageMap
      ?*
      ?superClassMessage
      ?hasGeneratedInSeparateFileSetting
    ;
    select
    or
      $feature$ ;
      $identifier$ ? @lstring optionString ;
      if [optionString string] != "generatedInSeparateFile" then
        error optionString:"only the \"generatedInSeparateFile\" pragma is allowed here" ;
      end if ;
      hasGeneratedInSeparateFileSetting := true ;
      if [tableDesClassesAncetres count] > 0 then
        error optionString:"the \"generatedInSeparateFile\" pragma is allowed only for a base class" ;
      end if ;
    end select ;
    ${$ ;
  #--- Attributs de la classe
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes
    @typeTableMethodesAimplementer tableMethodesAimplementer [emptyMap] ;
    @typeClassMessagesMap tableMessagesClasseConcrete [emptyMap] ;
    @typeClassInheritedMessagesMap messageMapForHeirs [emptyMap] ;
    @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
    @L_lazyAttributeList onceReaderListToImplement [emptyList] ;
    @string classMessage := "" ;
    repeat
    while
      $message$ ;
      select
        @lstring messageText ;
        $literal_string$ ? messageText ;
        if [classMessage length] > 0 then
          error messageText : "the class message is already defined" ;
        elsif [messageText length] == 0 then
          error messageText : "the class message string should not be empty" ;
        else
          classMessage := [messageText string] ;
        end if ;
      or
        @lstring messageName ;
        $identifier$ ? messageName ;
      #--- Chaine definissant le message d'erreur
        @lstring messageText ;
        $literal_string$ ? messageText ;
      #--- Entrer le message dans la map
        if not [inheritedMessageMap hasKey ![messageName string]] then
          [!?messageMapForHeirs insertKey !messageName] ;
        end if ; 
        [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ;
      end select ;
      $;$ ;
    while
      <abstract_method>
        !inIsAbstract
        !?ioComponentSemanticsEntitiesMap
        !?tableDesMethodes
        !?tableMethodesAimplementer
        !?tableEnAvant
      ;
    while
      <non_abstract_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !inIsAbstract
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !inOptionsComponentsMapForUse
        !classMessage
        !ioSemanticContext
        !onceReaderListToImplement
      ;
     while
      <overrided_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !inIsAbstract
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !inOptionsComponentsMapForUse
        !classMessage
        !ioSemanticContext
        !onceReaderListToImplement
     ;
    while
      <once_reader>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !inIsAbstract
        !?ioComponentSemanticsEntitiesMap
        !?tableEnAvant
        !inOptionsComponentsMapForUse
        !classMessage
        !ioSemanticContext
        !?onceReaderListToImplement
     ;
    end repeat ;
  #--- Check class message is defined if needed
    if ([superClassMessage length] > 0) & ([classMessage length] == 0) then
      error here: "this class should defined a class message, as it inherits from a class that does" ;
    end if ;
  #--- Verify that all inherited messages are defined
    foreach inheritedMessageMap do
      if not [tableMessagesClasseConcrete hasKey ![key string]] then
        error here : "the message '" . [key string] . "' is not defined" ;
      end if ;
  end foreach ;
  #--- Inserer dans la map des classes utilisables
    @AC_galgasType c := [@typeGalgasClassType new 
      !abstractClassName
      !tableDesMethodes
      !listeTousAttributsSemantiques
      !tableDesClassesAncetres
      !messageMapForHeirs
      !tableAttributs
      !inIsAbstract
      !classMessage
      !hasGeneratedInSeparateFileSetting
      !onceReaderListToImplement
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !abstractClassName !entite] ;
  #--- Modifiers
    @typeListeAttributsSemantiques setterAttributeModifierToImplementList [emptyList] ;
    foreach listeAttributsSemantiquesCourants do
      @bool hasSetter ;
      [tableAttributs searchKey !mAttributeName ?* ?hasSetter ?*] ;
      if hasSetter then
        setterAttributeModifierToImplementList +=
          !mAttributType
          !mAttributeName
        ;
      end if ;
    end foreach ;
  #--- Readers
    @typeListeAttributsSemantiques getterAttributeReaderToImplementList [emptyList] ;
    foreach listeAttributsSemantiquesCourants do
      @bool hasGetter ;
      [tableAttributs searchKey !mAttributeName ?* ?* ?hasGetter] ;
      if hasGetter then
        getterAttributeReaderToImplementList +=
          !mAttributType
          !mAttributeName
        ;
      end if ;
    end foreach ;
  #--- Inserer dans la map des classes definies dans ce fichier (a implementer)
    @typeEntityToGenerate def := [@C_classToImplement new 
      !abstractClassName
      !inIsAbstract
      !listeTousAttributsSemantiques
      !tableDesMethodes
      !tableMethodesAimplementer
      !listeAttributsSemantiquesCourants
      !tableDesClassesAncetres
      !tableMessagesClasseConcrete
      !classMessage
      !hasGeneratedInSeparateFileSetting
      !onceReaderListToImplement
      !setterAttributeModifierToImplementList
      !getterAttributeReaderToImplementList
    ] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
  ??@bool inIsAbstract
:
  $class$ ;
 #--- Abstract class name
  @lstring abstractClassName ;
  $type_name$ ? abstractClassName ;
  select
    if not ([tableEnAvant hasKey ![abstractClassName string]] |
            [ioComponentSemanticsEntitiesMap hasKey ![abstractClassName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedClassType new !abstractClassName] ;
      [!?tableEnAvant insertKey !abstractClassName !t] ;
    end if ;
    $;$ ;
  or
  #--- Analyse de la classe mere (if existe)
    @typeTableMethodes ancestorClassMethodsMap ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
    @typeSuperClassesMap tableDesClassesAncetres ;
    @typeClassInheritedMessagesMap inheritedMessageMap ;
    @typeSemanticAttributesMap tableAttributs ;
    @stringset superClasses ;
    @typeListModel attributeList ;
    @classMessageMap messageMap ;
    @bool hasGeneratedInSeparateFileSetting := false ;
    <parent_class> importSemantics
      !?ioModelMap
      ?superClasses
      ?attributeList
      ?messageMap
      !?ioComponentSemanticsEntitiesMap
      ?tableAttributs
      ?listeTousAttributsSemantiques
      ?ancestorClassMethodsMap
      ?tableDesClassesAncetres
      ?inheritedMessageMap
      ?hasGeneratedInSeparateFileSetting
    ;
    select
    or
      $feature$ ;
      $identifier$ ? @lstring optionString ;
      if [optionString string] != "generatedInSeparateFile" then
        error optionString:"only the \"generatedInSeparateFile\" pragma is allowed here" ;
      end if ;
      hasGeneratedInSeparateFileSetting := true ;
      if [tableDesClassesAncetres count] > 0 then
        error optionString:"the \"generatedInSeparateFile\" pragma is allowed only for a base class" ;
      end if ;
    end select ;
    ${$ ;
  #--- Attributs de la classe
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeList
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes
    @typeTableMethodesAimplementer tableMethodesAimplementer [emptyMap] ;
    @typeClassMessagesMap tableMessagesClasseConcrete [emptyMap] ;
    @typeClassInheritedMessagesMap messageMapForHeirs [emptyMap] ;
    @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
    @L_lazyAttributeList onceReaderListToImplement [emptyList] ;
    @string classMessage := "" ;
    repeat
    while
      $message$ ;
      select
        @lstring messageText ;
        $literal_string$ ? messageText ;
        if [classMessage length] > 0 then
          error messageText : "the class message is already defined" ;
        elsif [messageText length] == 0 then
          error messageText : "the class message string should not be empty" ;
        else
          classMessage := [messageText string] ;
        end if ;
      or
        @lstring messageName ;
        $identifier$ ? messageName ;
      #--- Chaine definissant le message d'erreur
        @lstring messageText ;
        $literal_string$ ? messageText ;
      #--- Entrer le message dans la map
        if not [inheritedMessageMap hasKey ![messageName string]] then
          [!?messageMapForHeirs insertKey !messageName] ;
        end if ; 
        [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ;
      end select ;
      $;$ ;
    while
      <abstract_method>
        !inIsAbstract
        !?ioComponentSemanticsEntitiesMap
        !?tableDesMethodes
        !?tableMethodesAimplementer
        !?tableEnAvant ;
    while
      <non_abstract_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !inIsAbstract
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !optionsComponentsMapForUse
        !classMessage
        !ioSemanticContext
        ! onceReaderListToImplement
      ;
     while
      <overrided_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !inIsAbstract
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !optionsComponentsMapForUse
        !classMessage
        !ioSemanticContext
        ! onceReaderListToImplement
     ;
    while
      <once_reader>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !inIsAbstract
        !?ioComponentSemanticsEntitiesMap
        !?tableEnAvant
        !optionsComponentsMapForUse
        !classMessage
        !ioSemanticContext
        !?onceReaderListToImplement
     ;
    end repeat ;
  #--- Verify that all inherited messages are defined
    foreach inheritedMessageMap do
      if not [tableMessagesClasseConcrete hasKey ![key string]] then
        error here : "the message '" .  [key string] . "' is not defined" ;
      end if ;
  end foreach ;
  #--- Inserer dans la map des classes utilisables
    @AC_galgasType c := [@typeGalgasClassType new 
      !abstractClassName
      !tableDesMethodes
      !listeTousAttributsSemantiques
      !tableDesClassesAncetres
      !messageMapForHeirs
      !tableAttributs
      !inIsAbstract
      !classMessage
      !hasGeneratedInSeparateFileSetting
      !onceReaderListToImplement
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !abstractClassName !entite] ;
    $}$ ;
    @TypeModel t := [@ClassModel new !true !superClasses !attributeList !messageMap] ;
    [!?ioModelMap insertKey !abstractClassName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                 Methode abstract                          *
#---------------------------------------------------------------------------*

rule <abstract_method>
  ??@bool inIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodes tableDesMethodes
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
:
  $abstract$ ;
  $method$ ;
  if not inIsAbstract then
    error here: "a concrete class should not declare an abstract method" ;
  end if ;
  @lstring nomMethode ;
  $identifier$ ? nomMethode ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  [!?tableDesMethodes insertKey !nomMethode !listeDeTypes] ;
  @typeInstructionList listeInstructions [emptyList] ;
  [!?tableMethodesAimplementer insertAbstract !nomMethode !listeDeTypes !listeTypeEtNomsArguments !listeInstructions] ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <parse_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributsHerites
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outMethodName
  !@typeInstructionList outInstructionsList
  !@L_EXsignature outMethodSignature
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@string inClassMessage
  ??@EXsemanticContext inSemanticContext
  ??@L_lazyAttributeList inLazyAttributeListToImplement
:
#--- Get reader name
  $identifier$ ? outMethodName ;
#--- Create local variable map
  @typeVariablesMap methodLocalVariablesMap [emptyMap]  ;
  foreach tableAttributsHerites do
    @typeCplusPlusName nomCpp := [@typeDirectName new ![key location] ![key string]] ;
    [!?methodLocalVariablesMap insertUsedConstInArgument !key !mAttributType !nomCpp] ;
  end foreach ;
#--- Insert the predefined "self" variable
  @AC_galgasType typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !tableDesMethodes
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributsHerites
           !inClassIsAbstract
           !inClassMessage
           !false
        !inLazyAttributeListToImplement
  ] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument ![@lstring new !"self" !here] !typeDefinition ![@typeCppStarThisName new !here ![inCurrentClassName string]]] ;
#--- Insert the predefined "super" variable
  typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !inAncestorClassMethodsMap
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributsHerites
           !inClassIsAbstract
           !inClassMessage
           !false
        !inLazyAttributeListToImplement
  ] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument ![@lstring new !"super" !here] !typeDefinition ![@typeCppInheritedName new !here]] ;
#--- Parse formal arguments
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?outMethodSignature
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  $:$ ;
#--- Add current class definition
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap := ioComponentSemanticsEntitiesMap ;
  @AC_semanticsEntity entite := [@typeEntiteType new ! typeDefinition] ;
  [!?componentSemanticsEntitiesMap insertKey !inCurrentClassName !entite] ;
#--- Parse reader instruction list
  outInstructionsList := [@typeInstructionList emptyList] ;
  <semantic_instructions_list>
    !tableEnAvant
    !componentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?methodLocalVariablesMap
    !?outInstructionsList
    !inSemanticContext
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <non_abstract_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@string inClassMessage
  ??@EXsemanticContext inSemanticContext
  ??@L_lazyAttributeList inLazyAttributeListToImplement
:
  $method$ ;
  @lstring methodName ;
  @typeInstructionList instructionsList ;
  @L_EXsignature methodSignature ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <parse_method>
    !inCurrentClassName
    !inAncestorClassMethodsMap
    !listeTousAttributsSemantiques
    !tableDesMethodes
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributs
    !inClassIsAbstract
    !?ioComponentSemanticsEntitiesMap
    !?tableEnAvant
    ?methodName
    ?instructionsList
    ?methodSignature
    ?listeTypeEtNomsArguments
    !inOptionsComponentsMapForUse
    !inClassMessage
    !inSemanticContext
    !inLazyAttributeListToImplement
  ;
  [!?tableDesMethodes insertKey !methodName !methodSignature] ;
  [!?tableMethodesAimplementer insertNotAbstract !methodName !methodSignature !listeTypeEtNomsArguments !instructionsList] ;
  $end$ ;
  $method$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <overrided_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@string inClassMessage
  ??@EXsemanticContext inSemanticContext
  ??@L_lazyAttributeList inLazyAttributeListToImplement
:
  $override$ ;
  $method$ ;
  @lstring methodName ;
  @typeInstructionList instructionsList ;
  @L_EXsignature methodSignature ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <parse_method>
    !inCurrentClassName
    !inAncestorClassMethodsMap
    !listeTousAttributsSemantiques
    !tableDesMethodes
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributs
    !inClassIsAbstract
    !?ioComponentSemanticsEntitiesMap
    !?tableEnAvant
    ?methodName
    ?instructionsList
    ?methodSignature
    ?listeTypeEtNomsArguments
    !inOptionsComponentsMapForUse
    !inClassMessage
    !inSemanticContext
    !inLazyAttributeListToImplement
  ;
#--- Verify reader signature is compatible with overriden reader signature
  @L_EXsignature listeDeTypesMethodeOriginale ;
  [tableDesMethodes searchKey !methodName ?listeDeTypesMethodeOriginale] ;
  verifierCompatibiliteSignatures
    !listeDeTypesMethodeOriginale 
    !methodSignature
    !here
  ;
#--- Insert reader into reader table
  [!?tableMethodesAimplementer insertNotAbstract !methodName !methodSignature !listeTypeEtNomsArguments !instructionsList] ;
  $end$ ;
  $method$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#               Analyse des arguments formels d'une methode                 *
#                     (entree, sortie, or entree/sortie)                    *
#---------------------------------------------------------------------------*

rule <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@signatureForGrammarAnalysis outSignatureForGrammar
:
  listeDeTypes := [@L_EXsignature emptyList] ;
  listeTypeEtNomsArguments := [@typeListeTypesEtNomsArgMethode emptyList] ;
  outSignatureForGrammar := [@signatureForGrammarAnalysis emptyList] ;
  repeat
  while
    $??$ ; # '??'  : constant input formal parameter
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentConstantIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    @bool modeIn := true ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn !nomArgument ;
      [!?tableArgumentsMethode insertUnusedConstInArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn !nomArgument ;
      [!?tableArgumentsMethode insertConstInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $?$ ; # '?'  : input formal parameter
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !true !nomArgument ;
      [!?tableArgumentsMethode insertUnusedInArgument !nomArgument !type_semantique !natureNom] ;
    or
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !true !nomArgument ;
      [!?tableArgumentsMethode insertInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $?!$ ; # '?!' : input/output formal parameter
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentInOut] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !false !nomArgument ;
      [!?tableArgumentsMethode insertUnusedInOutArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !false !nomArgument ;
      [!?tableArgumentsMethode insertInOutArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $!$ ; # '!' : output formal parameter
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentOut] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
    @bool modeIn := false ;
    listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn !nomArgument ;
    [!?tableArgumentsMethode insertOutArgument !nomArgument !type_semantique !natureNom] ;
  end repeat ;
label importGrammarForSemantics
  !@signatureForGrammarAnalysis outSignature
:
  outSignature := [@signatureForGrammarAnalysis emptyList] ;
  repeat
  while
    $??$ ;
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentConstantIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $?$ ;
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $?!$ ;
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentInOut] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $!$ ;
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentOut] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    $identifier$ ? * ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#           Analyse des arguments formels d'entree d'une fonction           *
#---------------------------------------------------------------------------*

rule <formal_input_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@signatureForGrammarAnalysis outSignatureForGrammar
:
  listeDeTypes := [@L_EXsignature emptyList] ;
  listeTypeEtNomsArguments := [@typeListeTypesEtNomsArgMethode emptyList] ;
  outSignatureForGrammar := [@signatureForGrammarAnalysis emptyList] ;
  repeat
  while
    $??$ ; # '??'  : constant input formal parameter
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentConstantIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    @bool modeIn := true ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn !nomArgument ;
      [!?tableArgumentsMethode insertUnusedConstInArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn !nomArgument ;
      [!?tableArgumentsMethode insertConstInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $?$ ; # '?'  : input formal parameter
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !true !nomArgument ;
      [!?tableArgumentsMethode insertUnusedInArgument !nomArgument !type_semantique !natureNom] ;
    or
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !true !nomArgument ;
      [!?tableArgumentsMethode insertInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  end repeat ;
label importGrammarForSemantics
  !@signatureForGrammarAnalysis outSignature
:
  outSignature := [@signatureForGrammarAnalysis emptyList] ;
  repeat
  while
    $??$ ;
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentConstantIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $?$ ;
    @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#            Parse type name and check it is defined                        *
#---------------------------------------------------------------------------*

rule <type_parsing>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType outTypeDefinition
  !@lstring outTypeName
:
  $type_name$ ? outTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outTypeName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !outTypeName ?entite] ;
    outTypeDefinition := [(cast entite if >= @typeEntiteType else error outTypeName) aDefType] ;
  elsif [inTableEnAvant hasKey ![outTypeName string]] then
    [inTableEnAvant searchKey !outTypeName ? outTypeDefinition] ;
  else
    error outTypeName: "the '@" . [outTypeName string] . "' type is not defined" : outTypeDefinition ;
  end if ;
end rule ;


#---------------------------------------------------------------------------*
#                                                                           *
#  A S S I G N M E N T     I N S T R U C T I O N     idf := ... ;           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring inTargetVarName
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
:
  $:=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Get target entity infos
  @AC_galgasType targetVarType ;
  @typeCplusPlusName targetVarCppName ;
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?targetVarType ?targetVarCppName] ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !targetVarType !sourceType !here !true ;
#--- Generate instruction
  @typeInstruction instruction := [@C_assignmentInstruction new !targetVarCppName ![@lstringlist emptyList] !sourceExpression] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                 A S S I G N M E N T    I N S T R U C T I O N              *
#                                                                           *
#                            idf->field1->field2... := ... ;                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
:
#--- Perform an io access for target variable
  @AC_galgasType targetType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetType ?nomCppVariableSource] ;
#--- Struct attributes
  @lstringlist structAttributeList [emptyList] ;
  repeat
    $->$ ;
    @lstring structAttributeName ;
    $identifier$ ? structAttributeName ;
    structAttributeList += !structAttributeName ;
    @typeGalgasStructType structType := (cast targetType if >= @typeGalgasStructType else error structAttributeName) ;
    @bool found := false ;
    foreach [structType mAttributeList] while not found do
      found := [mAttributeName string] == [structAttributeName string] ;
      targetType := mAttributType ;
    end foreach ;
    if not found then
      error structAttributeName: "the '@" . [structType mStructTypeName] . "' does not define a '" . structAttributeName . "' attribute" ;
    end if ;
  while
  end repeat ;
#--- Assignment
  $:=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !targetType !sourceType !here !true ;
#--- Generate instruction
  @typeInstruction instruction := [@C_assignmentInstruction new !nomCppVariableSource !structAttributeList !sourceExpression] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  .=     I N S T R U C T I O N     idf.field1.field2 .= ... ;              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier_and_structure_access>
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
  ??@typeCplusPlusName inTargetVarCppName
  ??@AC_galgasType inTargetType
  ??@lstringlist inStructAttributeList
:
  $.=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Match target and source types
  @string sourceExpressionConverter ;
  match inTargetType :: sourceType :
  when @typeGalgasListmapType (@lstring mTypeName1 ...) :: @typeGalgasListmapType (@lstring mTypeName2 ...) :
    if [mTypeName1 string] != [mTypeName2 string] then
      error here: "for '.=' operator, listmap type @" . mTypeName1
      . " of target object is not compatible with listmap type @" . mTypeName2
      . " of source expression" : sourceExpressionConverter ;
    else
      sourceExpressionConverter := "" ;
    end if ;
  when @typeGalgasListType (@lstring mTypeName1 ...) :: @typeGalgasListType (@lstring mTypeName2 ...) :
    if [mTypeName1 string] != [mTypeName2 string] then
      error here: "for '.=' operator, list type @" . mTypeName1
      . " of target object is not compatible with list type @" . mTypeName2
      . " of source expression" : sourceExpressionConverter ;
    else
      sourceExpressionConverter := "" ;
    end if ;
  when @typeGalgasSortedListType (@lstring mTypeName1 ...) :: @typeGalgasSortedListType (@lstring mTypeName2 ...) :
    if [mTypeName1 string] != [mTypeName2 string] then
      error here: "for '.=' operator, sortedlist type @" . mTypeName1
      . " of target object is not compatible with sortedlist type @" . mTypeName2
      . " of source expression" : sourceExpressionConverter ;
    else
      sourceExpressionConverter := "" ;
    end if ;
  when @typeGalgas_string () :: @typeGalgas_string () :
    sourceExpressionConverter := "" ;
  when @typeGalgas_string () :: @typeGalgas_lstring () :
    sourceExpressionConverter := "ggs_string" ;
  else
    error here: "for '.=' operator, " . [inTargetType messageGalgasType]
    . " target object type is not compatible with " . [sourceType messageGalgasType]
    . " source expression type" : sourceExpressionConverter ;
  end match ;
#--- Generate instruction
  @typeInstruction instruction := [@C_dotEqualInstruction new
    !inTargetVarCppName
    !inStructAttributeList
    !sourceExpression
    !sourceExpressionConverter
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#        Liste d'arguments effectifs en entree : ( ?<entite dest> ? * ...)  *
#---------------------------------------------------------------------------*

rule <input_parameters_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ??@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
:
  @typeListeCibles listeCibles [emptyList] ;
  repeat
  while
    $?$ ;
    select
      @lstring nomVariableDest ;
      select
        @AC_galgasType definitionType ;
        @lstring typeName ;
        <type_parsing>
          ![@typeTableEnAvant emptyMap]
          !ioComponentSemanticsEntitiesMap
          ?definitionType
          ?typeName
        ;
        $identifier$ ? nomVariableDest ;
        @typeCplusPlusName nomCppVariable := [@typeAutomaticName new ![nomVariableDest location] ![nomVariableDest string]] ;
        [!?ioVariablesMap insertLocalVariable !nomVariableDest !definitionType !nomCppVariable] ;
        ioInstructionList += ![@typeInstructionDeclarationVarLocale new ! nomCppVariable !definitionType] ;
      or
        $identifier$ ? nomVariableDest ;
      end select ;
      @AC_galgasType typeVarDest ;
      @typeCplusPlusName nomCppDest ;
      [!?ioVariablesMap searchForWriteAccess !nomVariableDest ?typeVarDest ?nomCppDest] ;
      listeCibles += ![@typeEntiteDest new !typeVarDest !nomCppDest !here] ;
    or
      $*$ ;
      listeCibles += ![@typeJoker new] ;
    or
      @luint jokerCountWithLocation ;
      $unsigned_literal_integer$ ? jokerCountWithLocation ;
      $*$ ;
      @uint jokerCount := [jokerCountWithLocation uint] ;
      loop jokerCount + 1 :
      while jokerCount > 0 do
        listeCibles += ![@typeJoker new] ;
        jokerCount -- ;
      end loop ;
    end select ;
  end repeat ;
  @bool ellipsis ;
  select
    $...$ ;
    ellipsis := true ;
  or
    ellipsis := false ;
  end select ;
#--- Verifier la compatibilite des list et construire la list des affectations
  if [listeAttributsSemantiques length] < [listeCibles length] then
    error here : "too much arguments: " . [[listeAttributsSemantiques length] string]
      . " expected, " . [[listeCibles length] string] . " found" 
      : outAllVariablesList, listeAffectationParametresEffectifs ;
  elsif ([listeAttributsSemantiques length] > [listeCibles length]) & not ellipsis then
    error here : "argument(s) missing: " . [[listeAttributsSemantiques length] string]
      . " expected, " . [[listeCibles length] string] . " found"
      : outAllVariablesList, listeAffectationParametresEffectifs ;
  else
    listeAffectationParametresEffectifs := [@L_assignedVariables emptyList] ;
    outAllVariablesList := [@typeCplusPlusNameList emptyList] ;
    foreach listeAttributsSemantiques, listeCibles do
      @lstring nomAttributSource := mAttributeName ;
      [aCible verifierType !mAttributType !?nomAttributSource !?listeAffectationParametresEffectifs !?outAllVariablesList] ;
    end foreach ;
  end if ;
#--- Append Joker if needed
  @typeCplusPlusName nullName := [@typeNullName new !here] ;
  appendJokersIfNeeded
   !?outAllVariablesList
   ![listeCibles length]
   ![listeAttributsSemantiques length]
   !nullName
  ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#               I N S T R U C T I O N     B E G I N N I N G                 *
#                                                                           *
#                  W I T H    A N    I D E N T I F I E R                    *
#                                                                           *
#  A N D    A C C E S S    T O    S T R U C T U R E    F I E L D            *
#                                                                           *
#  variable.field. ...                                                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
:
#--- Perform an io access for target variable
  @AC_galgasType targetType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetType ?nomCppVariableSource] ;
#--- Struct attributes
  @lstringlist structAttributeList [emptyList] ;
  repeat
  while
    $->$ ;
    @lstring structAttributeName ;
    $identifier$ ? structAttributeName ;
    structAttributeList += !structAttributeName ;
    @typeGalgasStructType structType := (cast targetType if >= @typeGalgasStructType else error structAttributeName) ;
    @bool found := false ;
    foreach [structType mAttributeList] while not found do
      found := [mAttributeName string] == [structAttributeName string] ;
      targetType := mAttributType ;
    end foreach ;
    if not found then
      error structAttributeName: "the '@" . [structType mStructTypeName] . "' does not define a '" . structAttributeName . "' attribute" ;
    end if ;
  end repeat ;
#--- Instruction
  <instruction_beginning_with_identifier_and_structure_access>
    !?ioVariablesMap
    !?ioInstructionList
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
    !inSemanticContext
    !nomCppVariableSource
    !targetType
    !structAttributeList
  ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   + =    I N S T R U C T I O N                                            *
#                                                                           *
#  variable += !source_exp !... !source_exp ;                               *
#  variable.field. ... += !source_exp !... !source_exp ;                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier_and_structure_access>
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
  ??@typeCplusPlusName inNomCppVariableSource
  ??@AC_galgasType inTargetType
  ??@lstringlist inStructAttributeList
:
#---- Operator
  $+=$ ;
#--- Does the variable class accept the += operator ?
  @typeListeAttributsSemantiques formalParametersList ;
  [inTargetType handleAddAssignOperatorCall !here ?formalParametersList] ;
#--- Parse argument list
  @typeTypesList typeList := [@typeTypesList emptyList] ;
  @typeExpressionList expressionList [emptyList] ;
  repeat
    $!$ ;
    @typeExpression expression ;
    @AC_galgasType resultType ;
    <expression> 
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?expression
      ?resultType
    ;
    typeList += !resultType !here ;
    expressionList += !expression ;
  while
  end repeat ;
#--- Check expression types list against formal parameter list
  if [formalParametersList length] != [typeList length] then
    error here : [[typeList length] string] . " argument(s), while " . [[formalParametersList length] string] . " are needed" ;
  else
    foreach formalParametersList, typeList do
      checkAssignmentTypesCompatibility
        !mAttributType
        !mType
        !mEndOfExpressionLocation
        !true
      ;
    end foreach ;
  end if ;
  @typeInstruction instruction := [@typeAppendInstruction new !inNomCppVariableSource !inStructAttributeList !expressionList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   - =    I N S T R U C T I O N                                            *
#                                                                           *
#  variable -= !source_exp !... !source_exp ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier_and_structure_access>
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
  ??@typeCplusPlusName inNomCppVariableSource
  ??@AC_galgasType inTargetType
  ??@lstringlist inStructAttributeList
:
  $-=$ ;
#--- Does the variable class accept the += operator ?
  @typeListeAttributsSemantiques formalParametersList ;
  [inTargetType handleMinusAssignOperatorCall !here ?formalParametersList] ;
#--- Parse argument list
  @typeTypesList typeList := [@typeTypesList emptyList] ;
  @typeExpressionList expressionList [emptyList] ;
  repeat
    $!$ ;
    @typeExpression expression ;
    @AC_galgasType resultType ;
    <expression> 
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?expression
      ?resultType
    ;
    typeList += !resultType !here ;
    expressionList += !expression ;
  while
  end repeat ;
#--- Check expression types list against formal parameter list
  if [formalParametersList length] != [typeList length] then
    error here : [[typeList length] string] . " argument(s), while " . [[formalParametersList length] string] . " are needed" ;
  else
    foreach formalParametersList, typeList do
      checkAssignmentTypesCompatibility
        !mAttributType
        !mType
        !mEndOfExpressionLocation
        !true
      ;
    end foreach ;
  end if ;
  @typeInstruction instruction := [@typeRemoveInstruction new !inNomCppVariableSource !inStructAttributeList !expressionList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   I N C R E M E N T    I N S T R U C T I O N                              *
#                                                                           *
#  variable ++ ;                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier_and_structure_access>
  ?!@typeVariablesMap unused ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext unused inSemanticContext
  ??@typeCplusPlusName inNomCppVariableSource
  ??@AC_galgasType inTargetType
  ??@lstringlist inStructAttributeList
:
  $++$ ;
#--- Does the variable class accept the ++ operator ?
  [inTargetType handleIncrementOperatorCall !here] ;
#--- Generate instruction
  @typeInstruction instruction := [@typeIncrementInstruction new !inNomCppVariableSource !inStructAttributeList !here] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   D E C R E M E N T    I N S T R U C T I O N                              *
#                                                                           *
#  variable -- ;                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier_and_structure_access>
  ?!@typeVariablesMap unused ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext unused inSemanticContext
  ??@typeCplusPlusName inNomCppVariableSource
  ??@AC_galgasType inTargetType
  ??@lstringlist inStructAttributeList
:
  $--$ ;
#--- Does the variable class accept the ++ operator ?
  [inTargetType handleDecrementOperatorCall !here] ;
#--- Generate instruction
  @typeInstruction instruction := [@typeDecrementInstruction new !inNomCppVariableSource !inStructAttributeList !here] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#            Liste d'arguments effectifs !? entite ! entite ? entite ...    *
#---------------------------------------------------------------------------*

rule <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList
:
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?outExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioComponentSemanticsEntitiesMap
    ?*
  ;
#--- Verifier la correction des arguments effectifs
  verifierCompatibiliteArgEffectifsSignature
    !listeTypesParametresFormels
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionList
    !?outExpressionList
  ;
end rule ;

#---------------------------------------------------------------------------*
#            Liste d'arguments effectifs !? entite ! entite ? entite ...    *
#                          sans verification de type                        *
#---------------------------------------------------------------------------*

rule <parse_parameters_list>
  !@L_actualParametersSignature listeTypesParametresEffectifs
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@bool outHasInputParameter
:
  outExpressionList := [@typeExpressionList emptyList] ;
  listeTypesParametresEffectifs := [@L_actualParametersSignature emptyList] ;
  @stringset exclusiveVariables [emptySet] ;
  outHasInputParameter := false ;
  repeat
  while
    $!$ ;
    @AC_galgasType expressionType ;
    @typeExpression expressionValue ;
    <expression>
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?expressionValue
      ?expressionType ;
    @EXactualParametersPassingMode parameterPassingMode := [@EXactualParametersPassingMode parameterOut] ;
    listeTypesParametresEffectifs += !expressionType !parameterPassingMode ;
    outExpressionList += !expressionValue ;
  while
    $?$ ;
    @EXactualParametersPassingMode parameterPassingMode := [@EXactualParametersPassingMode parameterIn] ;
    select
      $*$ ;
      listeTypesParametresEffectifs += ![@typeGalgas_jokerInParameterList new] !parameterPassingMode ;
      outExpressionList += ![@typeJokerInExpression new] ;
    or
      @luint jokerCountWithLocation ;
      $unsigned_literal_integer$ ? jokerCountWithLocation ;
      $*$ ;
      @uint jokerCount := [jokerCountWithLocation uint] ;
      loop jokerCount + 1 :
      while jokerCount > 0 do
        listeTypesParametresEffectifs += ![@typeGalgas_jokerInParameterList new] !parameterPassingMode ;
        outExpressionList += ![@typeJokerInExpression new] ;
        jokerCount -- ;
      end loop ;
    or
      @AC_galgasType typeArgument ;
      @typeCplusPlusName nomCppArgument ;
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      [!?ioVariablesMap searchForWriteAccess !nomArgument ?typeArgument ?nomCppArgument] ;
      listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
      @typeExpression e := [@typeVarInExpression new !nomCppArgument ![@lstringlist emptyList]] ;
      outExpressionList += !e ;
      if [exclusiveVariables hasKey ![nomArgument string]] then
        error nomArgument: "this object is already named as input or output/input effectif argument of current instruction" ;
      else
         exclusiveVariables += ![nomArgument string] ;
      end if ;
      outHasInputParameter := true ;
    end select ;
  while
    $!?$ ;
    @AC_galgasType typeArgument ;
    @typeCplusPlusName nomCppArgument ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    [!?ioVariablesMap searchForReadWriteAccess !nomArgument ?typeArgument ?nomCppArgument] ;
    @lstringlist structAttributeList [emptyList] ;
    repeat
    while
      $->$ ;
      $identifier$ ? @lstring structAttributeName ;
      @typeGalgasStructType structType := (cast typeArgument if >= @typeGalgasStructType else error structAttributeName) ;
      @bool found := false ;
      foreach [structType mAttributeList] while not found do
        found := [mAttributeName string] == [structAttributeName string] ;
        typeArgument := mAttributType ;
      end foreach ;
      if not found then
        error structAttributeName: "the '@" . [structType mStructTypeName] . "' does not define a '" . structAttributeName . "' attribute" ;
      end if ;
      structAttributeList += !structAttributeName ;
    end repeat ;
    @EXactualParametersPassingMode parameterPassingMode := [@EXactualParametersPassingMode parameterOutIn] ;
    listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
    @typeExpression e := [@typeVarInExpression new !nomCppArgument !structAttributeList] ;
    outExpressionList += !e ;
    if [exclusiveVariables hasKey ![nomArgument string]] then
      error nomArgument: "this object is already named as input or output/input effectif argument of current instruction" ;
    else
      exclusiveVariables += ![nomArgument string] ;
    end if ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#              LISTE DES INSTRUCTIONS SEMANTIQUES D'UNE METHODE             *
#---------------------------------------------------------------------------*

rule <semantic_instructions_list>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  block ioVariablesMap.verifyVariableUsing () :
    <semantic_instructions_list_no_verif>
      !inTableEnAvant
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !inSemanticContext
    ;
  end block (!here) ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#      extract instruction                                                  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $extract$ ;
#--- Source variable
  @AC_galgasType typeVarSource ;
  @typeCplusPlusName sourceVarCppName ;
  @lstring nomVarSource ;
  <read_access> ?nomVarSource ?sourceVarCppName ?typeVarSource !?ioVariablesMap ;
#--- Check variable has class type
  @typeGalgasClassType classType := (cast typeVarSource if >= @typeGalgasClassType else error nomVarSource) ;
  @lstring nomTypeSource := [classType mClassTypeName] ;
  @typeClassInheritedMessagesMap tableMessagesAbstraits := [classType mMessagesMap] ;
#--- Parse simple or structured extract instruction
  <extract_instruction>
    !inTableEnAvant
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    !sourceVarCppName
    !nomTypeSource
    !tableMessagesAbstraits
    !?ioInstructionList
    !inSemanticContext
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#       Structured extract instruction                                      *
#---------------------------------------------------------------------------*

rule <extract_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap unused tableMessagesAbstraits
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  @typeStructuredExtractCasesList casesList [emptyList] ;
  $:$ ;
  warning here:"structured extract instruction is obsolete: use cast instruction instead" ;
  $when$ ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @location indicatif1 := here ;
      #--- Nom du type 1
        @lstring nomType1 ;
        $type_name$ ? nomType1 ;
      #--- Verifier que la classe 'nomType1' est declaree
        @AC_semanticsEntity entite ;
        [ioComponentSemanticsEntitiesMap searchKey !nomType1 ?entite] ;
        @AC_galgasType definitionClasse1 := [(cast entite if >= @typeEntiteType else error nomType1) aDefType] ;
      #--- Verifier que la classe 'nomType1' herite de la classe 'nomTypeBase1'
        @typeGalgasClassType classType1 := (cast definitionClasse1 if >= @typeGalgasClassType else error nomType1) ;
        @typeListeAttributsSemantiques listeAttributs1 := [classType1 mAttributeList] ;
        @typeSuperClassesMap tableDesClassesAncetresType1 := [classType1 mAncestorClassesMap] ;
      #--- Verify class is an heir of variable type
        if not [tableDesClassesAncetresType1 hasKey ![nomTypeSource string]] then
          error nomType1 : "This class does not inherit from '@" . [nomTypeSource string] . "'" ;
        end if ;
      #--- Arguments du type 1
       @bool noUsedParameter ;
        <parse_effective_input_parameters_list>
          !?ioVariablesMap
          !listeAttributs1
          !indicatif1
          ![@localConstantBuildStyleEnum listStyle]
          !false # No new style of enumerator
          ?noUsedParameter
        ;
      #--- Liste des instructions
        $->$ ;
        @typeInstructionList instructionsList [emptyList] ;
        <semantic_instructions_list>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
          !inSemanticContext
        ;
        casesList += !nomType1 !indicatif1 !instructionsList !noUsedParameter ;
      end block (!here) ;
    while
      $when$ ;
    end repeat ;
  #---------------------  Default error -----------------------
    block ioVariablesMap.testPart () :
      $else$ ;
      @typeInstructionList elseInstructionList [emptyList] ;
      <semantic_instructions_list>
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?elseInstructionList
        !inSemanticContext
      ;
      ioInstructionList += ![@typeStructuredExtractInstructionWithElse new
        !inSourceVarCppName !casesList !elseInstructionList
      ] ;
    end block (!here) ;
  end block () ;
  $end$ ;
  $extract$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#      cast instruction                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $cast$ ;
#--- Source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?sourceExpression
    ?sourceExpressionType
  ;
#--- Check variable has class type
  @typeGalgasClassType sourceClassType := (cast sourceExpressionType if >= @typeGalgasClassType else error here) ;
  @lstring sourceExpressionTypeName := [sourceClassType mClassTypeName] ;
  @string sourceClassMessage := [sourceClassType mClassMessage] ;
#--- When branches
  @typeStructuredCastBranchList branchList [emptyList] ;
  $:$ ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        $when$ ;
        @bool checkForKindOfClass ;
        select
          $>=$ ;
          checkForKindOfClass := true ;
        or
          $==$ ;
          checkForKindOfClass := false ;
        end select ;
        @lstring castedTypeName ;
        $type_name$ ?castedTypeName ;
      #--- Check the name 'castedTypeName' refers to a type
        @AC_semanticsEntity entite ;
        [ioComponentSemanticsEntitiesMap searchKey !castedTypeName ?entite] ;
        @AC_galgasType typeDefinition := [(cast entite if >= @typeEntiteType else error castedTypeName) aDefType] ;
      #--- Check the type is a class
        @typeSuperClassesMap superClassMap :=
           [(cast typeDefinition if >= @typeGalgasClassType else error castedTypeName) mAncestorClassesMap] ;
      #--- Verify class is an heir of variable type
        @string sourceExpressionTypeNameString := [sourceExpressionTypeName string] ;
        if not checkForKindOfClass then
          if ([castedTypeName string] != sourceExpressionTypeNameString) & not [superClassMap hasKey ! sourceExpressionTypeNameString] then
            error castedTypeName : "This class is not '@" . sourceExpressionTypeNameString . "' and does inherit from it" ;
          end if ;
        elsif not [superClassMap hasKey !sourceExpressionTypeNameString] then
          error castedTypeName : "This class does not inherit from '@" . sourceExpressionTypeNameString . "'" ;
        end if ;
      #--- Parse local constant name
        @typeCplusPlusNameList localConstantCppNameList [emptyList] ;
        select
        or
          @lstring localConstantName ;
          $identifier$ ? localConstantName ;
          @typeCplusPlusName localConstantCppName := [@typeAutomaticName new ![localConstantName location] ![localConstantName string]] ;
          localConstantCppNameList += !localConstantCppName ;
          [!?ioVariablesMap insertConstInArgument !localConstantName !typeDefinition ! localConstantCppName] ;
        or
          $unused$ ;
          @lstring localConstantName ;
          $identifier$ ? localConstantName ;
          @typeCplusPlusName localConstantCppName := [@typeAutomaticName new ![localConstantName location] ![localConstantName string]] ;
          localConstantCppNameList += !localConstantCppName ;
          [!?ioVariablesMap insertUnusedConstInArgument !localConstantName !typeDefinition !localConstantCppName] ;
        end select ;
        $do$ ;
        @typeInstructionList instructionsList [emptyList] ;
        <semantic_instructions_list>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
          !inSemanticContext
        ;
        branchList += !castedTypeName !checkForKindOfClass !localConstantCppNameList !instructionsList ;
      end block (!here) ;
    while
    end repeat ;
  #--- else part
    @AC_elseOrDefaultForCastInstruction elseOrDefault ;
    block ioVariablesMap.testPart () :
      select
        $default$ ;
        if [sourceClassMessage length] == 0 then
          error here : "for using the 'default' construct, the static class of source expression (@"
                     . sourceExpressionTypeName . ") should define a class message" ;
        end if ;
        $error$ ;
        @typeExpression errorLocationExpression ;
        @AC_galgasType errorLocationExpressionType ;
        <expression>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !inSemanticContext
          !?ioVariablesMap
          ?errorLocationExpression
          ?errorLocationExpressionType
        ;
      #--- Check expression has location info
        [errorLocationExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
        elseOrDefault := [@C_defaultForCastInstruction new !errorLocationExpression !here] ;
      or
        $else$ ;
        @typeInstructionList elseBranchInstructionsList [emptyList] ;
        <semantic_instructions_list_no_verif>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?elseBranchInstructionsList
          !inSemanticContext
        ;
        elseOrDefault := [@C_elseForCastInstruction new !elseBranchInstructionsList] ;
     end select ; 
    end block (!here) ;
  end block () ;
#--- Enter instruction in instruction list
  @typeInstruction instruction := [@typeStructuredCastInstruction new
    !here
    !sourceExpression
    !sourceExpressionTypeName
    !branchList
    !elseOrDefault
  ] ;
  ioInstructionList += !instruction ;
#--- End of cast instruction
  $end$ ;
  $cast$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# Local variable declaration                                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
#--- Type name
  @AC_galgasType definitionType ;
  @lstring typeName ;
  <type_parsing>
    !inTableEnAvant
    !ioComponentSemanticsEntitiesMap
    ?definitionType
    ?typeName
  ;
#--- Variable name
  @lstring targetVarName ;
  $identifier$ ? targetVarName ;
  @typeCplusPlusName nomCppVariable := [@typeAutomaticName new ![targetVarName location] ![targetVarName string]] ;
  [!?ioVariablesMap insertLocalVariable !targetVarName !definitionType !nomCppVariable] ;
#--- Assignment ?
  <optional_assignment>
    !typeName
    !targetVarName
    !nomCppVariable
    !definitionType
    !?ioVariablesMap
    !?ioInstructionList
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioComponentSemanticsEntitiesMap
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction log variableName, ... ;                    *
#                    Instruction log "message" : expression ;               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $log$ ;
  repeat
    select
      $identifier$ ? @lstring galgasVariableName ;
      @typeCplusPlusName nomCppVar ;
      [!?ioVariablesMap searchForReadOnlyAccess !galgasVariableName ?* ?nomCppVar] ;
      ioInstructionList += ![@typeLogInstruction new
        !galgasVariableName
        ![@typeVarInExpression new !nomCppVar ![@lstringlist emptyList]]
      ] ;
    or
      $literal_string$ ? @lstring logMessage ;
      $:$ ;
      @typeExpression logExpression ;
      <expression>
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !inSemanticContext
        !?ioVariablesMap
        ?logExpression
        ?*
      ;
      ioInstructionList += ![@typeLogInstruction new
        !logMessage
        !logExpression
      ] ;
    end select ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction drop nomVariable, ... ;                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext unused inSemanticContext
:
  $drop$ ;
  repeat
    @lstring nom ;
    $identifier$ ? nom ;
    @typeCplusPlusName nomCppVar ;
    [!?ioVariablesMap searchForDestructiveReadAccess !nom ?* ?nomCppVar] ;
    @typeInstruction instruction := [@typeDropInstruction new !nomCppVar] ;
    ioInstructionList += !instruction ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#            R O U T I N E    C A L L    I N S T R U C T I O N              *
#                                                                           *
#                          routine_name ... ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@EXsemanticContext inSemanticContext
:
#--- Verifier que le nom est bien un nom de routine
  @L_EXsignature signatureRoutine ;
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !nomVarDest ?entite] ;
  @bool isExternActionCall ;
  cast entite:
  when >= @typeEntiteRoutine r do
    signatureRoutine := [r aListeArgumentsFormels] ;
    isExternActionCall := false ;
  when >= @typeEntiteRoutineExterne ae do
    signatureRoutine := [ae aSignature] ;
    isExternActionCall := true ;
  else
    error nomVarDest :
     "'" . [nomVarDest string] . "' should name a routine or an extern routine"
     : signatureRoutine, isExternActionCall
    ;
  end cast ;
#--- Arguments effectifs
  @typeExpressionList expressionsList ;
  <actual_parameters_list>
    !signatureRoutine
    ?expressionsList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioComponentSemanticsEntitiesMap
    !?ioInstructionList
  ;
#--- Generate instruction
  @typeInstruction instruction := [@typeRoutineCallInstruction new
    !nomVarDest
    !expressionsList
    !signatureRoutine
    !isExternActionCall
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M E T H O D    C A L L   I N S T R U C T I O N                         *
#               [object method !... !?... ?...] ;                           *
#                                                                           *
#    M O D I F I E R    C A L L   I N S T R U C T I O N                     *
#               [!?object modifier !... !?... ?...] ;                       *
#                                                                           *
#    T Y P E    M E T H O D    I N S T R U C T I O N                        *
#               [@aType type_method_name !... !?... ?...] ;                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $[$ ;
#--- Get source identity characteristics
  @typeInstruction instruction ;
  select #--- METHOD CALL
    @typeExpression expression ;
    @AC_galgasType expressionType ;
    <expression>
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?expression
      ?expressionType
    ;
  #--- Method name
    @lstring methodName ;
    $identifier$ ? methodName ;
    @L_EXsignature methodSignature ;
    @string categoryMethodClassBaseName ;
    [expressionType handleMethodInstructionCall
      !methodName
      ![inSemanticContext mCategoryMethodMap]
      ?methodSignature
      ?categoryMethodClassBaseName
    ] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !methodSignature
      ?expressionsList
      !?ioVariablesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !ioComponentSemanticsEntitiesMap
      !?ioInstructionList
    ;
  #--- Generate instruction
    instruction := [@typeMethodCallInstruction new
     !expressionType
     !expression
     !methodName
     !categoryMethodClassBaseName
     !expressionsList
   ] ;
  or #---- MODIFIER CALL
    $!?$ ;
    @lstring modifiedObjectName ;
    $identifier$ ? modifiedObjectName ;
    @AC_galgasType variableType ;
    @typeCplusPlusName cppVariableName ;
    [!?ioVariablesMap searchForReadWriteAccess !modifiedObjectName ?variableType ?cppVariableName] ; 
  #--- Struct attributes
    @lstringlist structAttributeList [emptyList] ;
    repeat
    while
      $->$ ;
      @lstring structAttributeName ;
      $identifier$ ? structAttributeName ;
      structAttributeList += !structAttributeName ;
      @typeGalgasStructType structType := (cast variableType if >= @typeGalgasStructType else error structAttributeName) ;
      @bool found := false ;
      foreach [structType mAttributeList] while not found do
        found := [mAttributeName string] == [structAttributeName string] ;
        variableType := mAttributType ;
      end foreach ;
      if not found then
        error structAttributeName: "the '@" . [structType mStructTypeName] . "' does not define a '" . structAttributeName . "' attribute" ;
      end if ;
    end repeat ;
  #--- Get modifier name
    @lstring modifierName ;
    $identifier$ ? modifierName ;
    @L_EXsignature methodSignature ;
    [variableType handleModifierCall !modifierName ?methodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !methodSignature
      ?expressionsList
      !?ioVariablesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !ioComponentSemanticsEntitiesMap
      !?ioInstructionList
    ;
  #--- Generate instruction
    instruction := [@typeModifierCallInstruction new !cppVariableName !structAttributeList !modifierName !expressionsList] ;
  or #--------- TYPE METHOD
    @lstring typeName ;
    $type_name$ ? typeName ;
    @lstring typeMethodName ;
    $identifier$ ? typeMethodName ;
  #--- Retrieve type method information
    @L_EXsignature typeMethodSignature ;
    @AC_semanticsEntity theEntity  ;
    [ioComponentSemanticsEntitiesMap searchKey !typeName ? theEntity] ;
    @AC_galgasType type := [(cast theEntity if >=@typeEntiteType else error typeName) aDefType] ;
    [type handleClassMethodCall !typeMethodName ?typeMethodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !typeMethodSignature
      ?expressionsList
      !?ioVariablesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !ioComponentSemanticsEntitiesMap
      !?ioInstructionList
    ;
  #--- Generate instruction
    instruction := [@typeCallOfTypeMethodInstruction new
      !typeName
      !typeMethodName
      !expressionsList
    ] ;
  end select ;
  ioInstructionList += !instruction ;
  $]$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#             C O N S T A N T    D E C L A R A T I O N                      *
#                                                                           *
#  const idf := ... ;                                                       *
#  const idf [ ... ] ;                                                      *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $const$ ;
#--- Type name
  @AC_galgasType targetVarType ;
  @lstring targetTypeName ;
  <type_parsing>
    !inTableEnAvant
    !ioComponentSemanticsEntitiesMap
    ?targetVarType
    ?targetTypeName
  ;
#--- Variable name
  @lstring targetVarName ;
  $identifier$ ? targetVarName ;
#--- Source expression
  @typeExpression sourceExpression ;
  select
    $:=$ ;
  #--- Parse source expression
    @AC_galgasType sourceExpressionType ;
    <expression>
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?sourceExpression
      ?sourceExpressionType
    ;
  #--- Match target and source types
    checkAssignmentTypesCompatibility !targetVarType !sourceExpressionType !here !true ;
  or
  #--- Indicate variable is written
    $[$ ;
  #--- Class method name
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques listeAttributsSemantiques ;
    @bool hasLexiqueAndLocationArguments ;
    @AC_galgasType returnedType ;
    [targetVarType handleConstructorInvocation !constructorName ?listeAttributsSemantiques ?hasLexiqueAndLocationArguments ?returnedType] ;
  #--- Check returned type is the same as constant type
    if targetVarType != returnedType then
      @string typeName ; [returnedType getTypeName ?typeName] ;
      error constructorName:"this constructor returns an other type: '@" . typeName . "'" ;
    end if ;
  #--- Actual arguments
    @typeExpressionList expressionList ;
    <output_expression_list>
      ?expressionList
      !listeAttributsSemantiques
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
    ;
    $]$ ;
  #--- Build source expression
    sourceExpression := [@typeConstructorExpression new 
      !targetVarType
      !constructorName
      !hasLexiqueAndLocationArguments
      !expressionList
    ] ;
  end select ;
  $;$ ;
#--- Declare constant
  @typeCplusPlusName targetVarCppName := [@typeAutomaticName new ![targetVarName location] ![targetVarName string]] ;
  [!?ioVariablesMap insertConstInArgument !targetVarName !targetVarType !targetVarCppName] ;
#--- Generate instruction
  ioInstructionList += ![@C_constantDeclarationInstruction new
    !targetVarType
    !targetVarCppName 
    !sourceExpression
  ] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#             I N S T R U C T I O N   B E G I N N I N G                     *
#               W I T H    A N    I D E N T I F I E R                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  @lstring nomVarDest ;
  $identifier$ ? nomVarDest ;
  <instruction_beginning_with_identifier>
    !nomVarDest
    !?ioVariablesMap 
    !?ioInstructionList
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
    !inSemanticContext
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           'warning ... ;' instruction                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  <warning_instruction>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    !?ioInstructionList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <warning_instruction>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
:
  $warning$ ;
  @typeExpression errorExpression ;
  @AC_galgasType errorExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?errorExpression
    ?errorExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
#--- Warning message
  @typeExpression warningMessageExpression ;
  @AC_galgasType warningMessageExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?warningMessageExpression
    ?warningMessageExpressionType
  ;
#--- Check that error message is a @string instance
  @typeGalgas_string gs := (cast warningMessageExpressionType if >= @typeGalgas_string else error here) ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@typeWarningInstruction new !errorExpression !warningMessageExpression !here] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           Instruction 'error ... ;'                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  <error_instruction>
   !ioComponentSemanticsEntitiesMap
   !inOptionsComponentsMapForUse
   !inSemanticContext
   !?ioVariablesMap
   !?ioInstructionList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <error_instruction>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
:
  $error$ ;
  @typeExpression errorLocationExpression ;
  @AC_galgasType errorLocationExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?errorLocationExpression
    ?errorLocationExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorLocationExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
#--- Error message
  @typeExpression errorMessageExpression ;
  @AC_galgasType errorMessageExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?errorMessageExpression
    ?errorMessageExpressionType
  ;
#--- Check that error message is a @string instance
  @typeGalgas_string gs := (cast errorMessageExpressionType if >= @typeGalgas_string else error here) ;
#--- Valuations fictives
  @varToDropList variablesToDrop [emptyList] ;
  select
  or
    $:$ ;
    repeat
      @lstring nomVariable ;
      $identifier$ ? nomVariable ;
      @typeCplusPlusName varCppName ;
      [!?ioVariablesMap searchForWriteAccess !nomVariable ?* ?varCppName] ;
      variablesToDrop += !varCppName ;
    while
      $,$ ;
   end repeat ;
  end select ;
  $;$ ;
#--- Build instruction and append it to instructions list
  @typeInstruction instruction := [@typeErrorInstruction new
    !errorLocationExpression
    !errorMessageExpression
    !here
    !variablesToDrop
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           'message ... ;' instruction                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $message$ ;
  @location instructionLocation := here ;
#--- Message
  @typeExpression messageExpression ;
  @AC_galgasType messageExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?messageExpression
    ?messageExpressionType
  ;
#--- Check that error message is a @string instance
  @typeGalgas_string gs := (cast messageExpressionType if >= @typeGalgas_string else error here) ;
#--- Construire l'instruction
  @typeInstruction instruction := [@typeMessageInstruction new !messageExpression !instructionLocation] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction 'if ... then ... elsif ... else ... end if ;'               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $if$ ;
  @L_expression_instructionsList_list listeBranchesTest [emptyList] ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @typeExpression testBranche ;
        @AC_galgasType resultType ;
        <expression>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !inSemanticContext
          !?ioVariablesMap
          ?testBranche
          ?resultType
        ;
        @typeGalgas_bool b := (cast resultType if >= @typeGalgas_bool else error here) ;
        $then$ ;
        @typeInstructionList listeInstructionsBrancheTest [emptyList] ;
        <semantic_instructions_list_no_verif>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheTest
          !inSemanticContext
        ;
        listeBranchesTest += !testBranche !listeInstructionsBrancheTest !here ;
      end block (!here) ;
    while
      $elsif$ ;
    end repeat ;
    @typeInstructionList listeInstructionsBrancheAutre [emptyList] ;
    block ioVariablesMap.testPart () :
      select
      or
        $else$ ;
        <semantic_instructions_list_no_verif>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheAutre
          !inSemanticContext
        ;
      end select ; 
    end block (!here) ;
    $end$ ;
    $if$ ;
  end block () ;
#--- Engendrer l'instruction
  @typeInstruction instruction ;
  instruction := [@C_if_instruction new !listeBranchesTest !listeInstructionsBrancheAutre] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction                                                             *
#     'switch exp when cst, cst: ...instructions... when ... end switch ;'  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $switch$ ;
#--- Expression
  @typeExpression switchExpression ;
  @AC_galgasType resultType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?switchExpression
    ?resultType
  ;
#--- Check expression type in an enum type
  @typeGalgas_enum e := (cast resultType if >= @typeGalgas_enum else error here) ;
  @lstring enumTypeName := [e mEnumTypeName] ;
  @enumConstantMap enumConstantesMap := [e mEnumConstantesMap] ;
#---- When branches
  @stringset allBranchConstantSet [emptySet] ;
  @L_switchBranchlist switchBranchlist [emptyList] ;
  block ioVariablesMap.testBloc () :
    $when$ ;
    repeat
    #--- Parse constant list
      @stringset branchConstantSet [emptySet] ;
      repeat
        @lstring enumConstantName ;
        $identifier$ ? enumConstantName ;
        branchConstantSet += ![enumConstantName string] ;
        [enumConstantesMap searchKey !enumConstantName ?*] ;
        if [allBranchConstantSet hasKey ![enumConstantName string]] then
          error enumConstantName: "this constant is already used in current switch instruction" ;
        end if ;
      while
        $,$ ;
      end repeat ;
      $:$ ;
      allBranchConstantSet := allBranchConstantSet | branchConstantSet ;
      block ioVariablesMap.testPart () :
        @typeInstructionList branchInstructionList [emptyList] ;
        <semantic_instructions_list_no_verif>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?branchInstructionList
          !inSemanticContext
        ;
        switchBranchlist += !branchConstantSet !branchInstructionList ;
      end block (!here) ;
    while
      $when$ ;
    end repeat ;
  end block () ;
  $end$ ;
#--- Check all constant are named
  @stringset missingConstants := [enumConstantesMap allKeys] - allBranchConstantSet ;
  foreach missingConstants do
    error here: "the '" . key . "' is not used in switch instruction" ;
  end foreach ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@C_switch_instruction new !switchExpression !enumTypeName !switchBranchlist] ;
  ioInstructionList += !instruction ;
  $switch$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  Instruction                                                              *
#  loop variant : instructions while condition do instructions end loop ;   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $loop$ ;
#--- Variant expression
  @typeExpression variantExpression ;
  @AC_galgasType variantResultType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?variantExpression
    ?variantResultType
  ;
  @typeGalgas_uint ui := (cast variantResultType if >= @typeGalgas_uint else error here) ;
  $:$ ;
#--- Repeated instruction list
  @typeInstructionList instructionList1 [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
      <semantic_instructions_list_no_verif>
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList1
        !inSemanticContext
      ;
    end block (!here) ;
  end block () ;
  $while$ ;
#--- Conditionnal expression
  @typeExpression conditionalExpression ;
  @AC_galgasType resultType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?conditionalExpression
    ?resultType
  ;
  @typeGalgas_bool b := (cast resultType if >= @typeGalgas_bool else error here) ;
  $do$ ;
#--- Repeated instruction list
  @typeInstructionList instructionList2 [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
    #--- Liste d'instructions
      <semantic_instructions_list_no_verif>
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList2
        !inSemanticContext
      ;
    end block (!here) ;
  end block () ;
  @typeInstruction  instruction := [@C_while_instruction new
    !variantExpression
    !instructionList1
    !conditionalExpression
    !instructionList2
    !here
  ] ;
  $end$ ;
  $loop$ ;
  $;$ ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    G R A M M A R    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused  inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $grammar$ ;
#--- Grammar Name
  @lstring grammarName ;
  $identifier$ ? grammarName ;
#--- Alt option ?
  @lstring altName ;
  select
    altName := [@lstring new !"" !here] ;
  or
    $label$ ;
    $identifier$ ? altName ;
  end select ;
#--- Parse file name
  @bool sourceIsFile ;
  @typeExpression sourceExpression ;
  @typeExpression depFileExpression ;
  @typeExpression depFilePath ;
  @bool hasDependancyFile := false ;
  @location dependancyFileDefinitionLocation := here ;
  select
    $in$ ;
    sourceIsFile := true ;
    @AC_galgasType sourceExpressionType ;
    <expression>
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?sourceExpression
      ?sourceExpressionType
    ;
    @typeGalgas_lstring gs := (cast sourceExpressionType if >= @typeGalgas_lstring else error here) ;
    select
      depFileExpression := [@typeLiteralStringExpression new ![@stringlist listWithValue !""]] ;
      depFilePath := [@typeLiteralStringExpression new ![@stringlist listWithValue !""]] ;
    or
      $dependency$ ;
      @AC_galgasType depFileExpressionType ;
      <expression>
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !inSemanticContext
        !?ioVariablesMap
        ?depFileExpression
        ?depFileExpressionType
      ;
      dependancyFileDefinitionLocation := here ;
      @typeGalgas_string gss := (cast depFileExpressionType if >= @typeGalgas_string else error here) ;
      $in$ ;
      <expression>
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !inSemanticContext
        !?ioVariablesMap
        ?depFilePath
        ?depFileExpressionType
      ;
      gss := (cast depFileExpressionType if >= @typeGalgas_string else error here) ;
      hasDependancyFile := true ;
    end select ;
  or
    $on$ ;
    sourceIsFile := false ;
    @AC_galgasType sourceExpressionType ;
    <expression>
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !inSemanticContext
      !?ioVariablesMap
      ?sourceExpression
      ?sourceExpressionType
    ;
    @typeGalgas_string gs := (cast sourceExpressionType if >= @typeGalgas_string else error here) ;
    depFileExpression := [@typeLiteralStringExpression new ![@stringlist listWithValue !""]] ;
    depFilePath := [@typeLiteralStringExpression new ![@stringlist listWithValue !""]] ;
  end select ;
#--- Analyse des arguments effectifs
  @typeExpressionList expressionsList ;
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  @bool hasInputParameter ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?expressionsList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !ioComponentSemanticsEntitiesMap
    ?hasInputParameter
  ;
#--- Check if there is dependancy file, there is no input parameter
  if (hasDependancyFile & hasInputParameter) then
    error dependancyFileDefinitionLocation:"a dependancy file reference requires there is no input parameter" ;
  end if ;
#--- Look for grammar
  @AC_semanticsEntity e  ;
  [ioComponentSemanticsEntitiesMap searchKey !grammarName ?e] ;
  @C_grammarForSemantics gfs := (cast e if >= @C_grammarForSemantics else error grammarName) ;
  @M_nonterminalSymbolAlts startSymbolAltMap := [gfs mGrammarAltMap] ;
  @lstring lexiqueClassName := [gfs mLexiqueClassName] ;
  @L_EXsignature startSymbolSignature ;
  [startSymbolAltMap searchKey !altName ?startSymbolSignature] ;
#--- Verifier la coherence avec la declaration
  verifierCompatibiliteArgEffectifsSignature 
    !startSymbolSignature
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionList
    !?expressionsList
  ;
#--- Sent string
  @typeCplusPlusName sentStringName ;
  select
    sentStringName := [@typeNullName new !here] ; # No sent string
  or
    $send$ ;
    warning here: "using 'send'" ;
    $in$ ;
    @lstring sentVariableName ;
    $identifier$ ? sentVariableName ;
    @AC_galgasType targetType ;
    [!?ioVariablesMap searchForReadWriteAccess !sentVariableName ?targetType ?sentStringName] ;
    @typeGalgas_string gs := (cast targetType if >= @typeGalgas_string else error sentVariableName) ;
  end select ;
#--- Engendrer l'instruction
  @typeInstruction instruction ;
  instruction := [@C_grammarInstruction new
    !sourceIsFile
    !sourceExpression
    !grammarName
    !expressionsList
    !altName
    !lexiqueClassName
    !sentStringName
    !depFileExpression
    !depFilePath
  ] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     Instruction 'send string_expression ;'                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $send$ ;
    warning here: "using 'send'" ;
#--- Source expression
  @typeExpression expression ;
  @AC_galgasType expressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?expression
    ?expressionType
  ;
#--- Check expression type
  @typeGalgas_string classType := (cast expressionType if >= @typeGalgas_string else error here) ;
  $;$ ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@typeSendInstruction new
    !expression
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# Instruction 'with p : !?map searchMethod !key do ... else ... end with ;' *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $with$ ;
#--- Local Prefix
  @string prefixString ;
  select
    prefixString := "" ;
  or
    $identifier$ ? @lstring thePrefix ;
    prefixString := [thePrefix string] ;
    $:$ ;
  end select ;
#--- Map object reference
  $!?$ ;
  $identifier$ ? @lstring nomVarDest ;
  @location instructionLocation := [nomVarDest location] ;
#--- Perform an io access for target variable
  @AC_galgasType targetType ;
  @typeCplusPlusName accessedVariableCppName ;
  @string errorMessageName ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetType ?accessedVariableCppName] ;
#--- Struct attributes
  @lstringlist structAttributeList [emptyList] ;
  repeat
  while
    $->$ ;
    @lstring structAttributeName ;
    $identifier$ ? structAttributeName ;
    structAttributeList += !structAttributeName ;
    instructionLocation := [structAttributeName location] ;
    @typeGalgasStructType structType := (cast targetType if >= @typeGalgasStructType else error structAttributeName) ;
    @bool found := false ;
    foreach [structType mAttributeList] while not found do
      found := [mAttributeName string] == [structAttributeName string] ;
      targetType := mAttributType ;
    end foreach ;
    if not found then
      error structAttributeName: "the '@" . [structType mStructTypeName] . "' does not define a '" . structAttributeName . "' attribute" ;
    end if ;
  end repeat ;
#--- Search Method name
  $identifier$ ? @lstring searchMethodName ;
#--- key expression
  $!$ ;
  @typeExpression keyExpression ;
  @AC_galgasType keyExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?keyExpression
    ?keyExpressionType
  ;
#--- Check map access
  @typeListeAttributsSemantiques attributeList ;
  @string mapTypeName ;
  [targetType check_with_InstructionAccess
    !instructionLocation
    !searchMethodName
    !keyExpressionType
    ?mapTypeName
    ?errorMessageName
    ?attributeList
  ] ;
#--- First branch
  @typeInstructionList doBranchInstructionList [emptyList] ;
  @typeInstructionList elseBranchInstructionList [emptyList] ;
  block ioVariablesMap.testBloc () :
    block ioVariablesMap.testPart () :
    #--- Add map entry key as constant
      [!?ioVariablesMap insertUsedConstInArgument

        ![@lstring new !prefixString . "key" !instructionLocation]
        ![@typeGalgas_lstring new]
        ![@typeKeyName new !instructionLocation !false]
      ] ;
    #--- Add map entry attributes as local variables
      foreach attributeList do
        [!?ioVariablesMap insertWithInstructionLocalVariable
          ![@lstring new !prefixString . [mAttributeName string] !instructionLocation]
          !mAttributType
          ![@typeOperandName new !instructionLocation ![mAttributeName string] !true !false]
        ] ;
      end foreach ;
    #---
      $do$ ;
      <semantic_instructions_list_no_verif>
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?doBranchInstructionList
        !inSemanticContext
      ;
    end block (!here) ;
    block ioVariablesMap.testPart () :
      select
      or
        $else$ ;
        <semantic_instructions_list_no_verif>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?elseBranchInstructionList
          !inSemanticContext
        ;
      end select ; 
    end block (!here) ;
  end block () ;
  $end$ ;
  $with$ ;
  $;$ ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@typeWithInstruction new
    !mapTypeName
    !accessedVariableCppName
    !structAttributeList
    !errorMessageName
    !keyExpression
    !doBranchInstructionList
    !elseBranchInstructionList
    !instructionLocation
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     Instruction 'foreach ... ;'                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <constant_while_before_in_foreach_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ??@EXsemanticContext inSemanticContext
  !@typeCplusPlusName outIndexVariable
  !@typeInstructionList out_before_instructionList
:
#--- First phase: handle while expression and before instructions
  block ioVariablesMap.repeatPart () :
#--- Parse enumerated variables
  repeat
    select
    or
      $<$ ;
    or
      $>$ ;
    end select ;
  #--- Source expression
    <expression> parse ;
  #--- Parse effective input attribute list
    select
      <parse_effective_input_parameters_list> parse ;
    or
      $prefixedby$ ;
      $identifier$ ? * ;
    or
    end select ;
  while
    $,$ ;
  end repeat ;
#--- Optional index
  select
    outIndexVariable := [@typeNullName new !here] ;
  or
    $index$ ;
    @lstring indexVariableName ;
    $identifier$ ? indexVariableName ;
    outIndexVariable := [@typeAutomaticName new ![indexVariableName location] ![indexVariableName string]] ;
    [!?ioVariablesMap insertUsedConstInArgument
       !indexVariableName
       ![@typeGalgas_uint new]
       !outIndexVariable
    ] ;
  end select ;
#--- While expression
  select
  or
    $while$ ;
    <expression> parse ;
  end select ;
#--- Before instruction list
  out_before_instructionList := [@typeInstructionList emptyList] ;
    select
    or
      $before$ ;
      <semantic_instructions_list_no_verif>
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?out_before_instructionList
        !inSemanticContext
      ;
    end select ;
  end block (!here) ;
#--- Repeated instruction list
  $do$ ;
  <semantic_instructions_list_no_verif> parse ;
label secondPhase
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ??@EXsemanticContext inSemanticContext
  !@foreachEnumerationList outForeachEnumerationList
  !@typeExpression outWhileExpression
  !@typeInstructionList out_do_instructionList
:
  block ioVariablesMap.repeatPart () :
  #--- Parse enumerated variables
    outForeachEnumerationList := [@foreachEnumerationList emptyList] ;
    repeat
      const @location magicNumber := here ;
    #--- Ascending or descending ?
      @bool ascending ;
      select
        ascending := true ;
      or
        $<$ ;
        ascending := true ;
      or
        $>$ ;
        ascending := false ;
      end select ;
    #--- Source expression
      @typeExpression sourceExpression ;
      @AC_galgasType sourceExpressionType ;
      <expression>
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !inSemanticContext
        !?ioVariablesMap
        ?sourceExpression
        ?sourceExpressionType
      ;
    #--- Check this variable can be enumerated
      @typeListeAttributsSemantiques formalEnumerationList ;
      @localConstantBuildStyleEnum localConstantBuildStyleEnum ;
      @bool iteratorNewStyle ;
      [sourceExpressionType acceptForeachInstruction
        !ioComponentSemanticsEntitiesMap
        !magicNumber
        ?formalEnumerationList
        ?localConstantBuildStyleEnum
        ?iteratorNewStyle
      ] ;
    #--- Extract type name
      @string typeName ;
      [sourceExpressionType getTypeName ?typeName] ;
    #--- Parse effective input attribute list
      select
        <parse_effective_input_parameters_list>
          !?ioVariablesMap
          !formalEnumerationList
          !magicNumber
          !localConstantBuildStyleEnum
          !iteratorNewStyle
          ?*
        ;
      or
        $prefixedby$ ;
        $identifier$ ? @lstring prefix ;
        @bool mapStyle := localConstantBuildStyleEnum != [@localConstantBuildStyleEnum listStyle] ;
        @bool firstOne := true ;
        foreach formalEnumerationList do
          @typeCplusPlusName cppName ;
          if (localConstantBuildStyleEnum == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & firstOne then
            cppName := [@typeKeyName new !magicNumber !iteratorNewStyle] ;
          else
            cppName := [@typeOperandName new !magicNumber ![mAttributeName string] !mapStyle !iteratorNewStyle] ;
          end if ;
          [!?ioVariablesMap insertUsedConstInArgument ![@lstring new ![prefix string] . [mAttributeName string] !here] !mAttributType !cppName] ;
          firstOne := false ;
        end foreach ;
      or
        @bool mapStyle := localConstantBuildStyleEnum != [@localConstantBuildStyleEnum listStyle] ;
        @bool firstOne := true ;
        foreach formalEnumerationList do
          @typeCplusPlusName cppName ;
          if (localConstantBuildStyleEnum == [@localConstantBuildStyleEnum firstIsKeyOtherMapStyle]) & firstOne then
            cppName := [@typeKeyName new !magicNumber !iteratorNewStyle] ;
          else
            cppName := [@typeOperandName new !magicNumber ![mAttributeName string] !mapStyle !iteratorNewStyle] ;
          end if ;
          [!?ioVariablesMap insertUsedConstInArgument ![@lstring new ![mAttributeName string] !here] !mAttributType !cppName] ;
          firstOne := false ;
        end foreach ;
      end select ;
      outForeachEnumerationList += !iteratorNewStyle !sourceExpression !magicNumber !typeName !ascending ;
    while
      $,$ ;
    end repeat ;
  #--- Optional index
    select
    or
      $index$ ;
      @lstring indexVariableName ;
      $identifier$ ? indexVariableName ;
      @typeCplusPlusName indexVariable := [@typeAutomaticName new ![indexVariableName location] ![indexVariableName string]] ;
      [!?ioVariablesMap insertUsedConstInArgument
         !indexVariableName
         ![@typeGalgas_uint new]
         !indexVariable
      ] ;
    end select ;
    select
      outWhileExpression := [@typeTrueBool new] ;
    or
      $while$ ;
      @AC_galgasType resultType ;
      <expression>
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !inSemanticContext
        !?ioVariablesMap
        ?outWhileExpression
        ?resultType
       ;
    @typeGalgas_bool b := (cast resultType if >= @typeGalgas_bool else error here) ;
    end select ;
  #--- Before instruction list
    select
    or
      $before$ ;
      <semantic_instructions_list_no_verif> parse ;
    end select ;
    #--- Repeated instruction list
      $do$ ;
    #--- Liste d'instructions
      out_do_instructionList := [@typeInstructionList emptyList] ;
      <semantic_instructions_list_no_verif>
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?out_do_instructionList
        !inSemanticContext
      ;
  end block (!here) ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $foreach$ ;
  @typeInstruction instruction ;
  block ioVariablesMap.repeatBlock () :
    @typeInstructionList before_instructionList ;
    @typeExpression whileExpression ;
    @foreachEnumerationList foreachEnumerationList ;
    @typeInstructionList do_instructionList ;
    @typeCplusPlusName indexVariable ;
    parse do
      <constant_while_before_in_foreach_instruction>
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !inSemanticContext
        ?indexVariable
        ?before_instructionList
      ;
    rewind
      <constant_while_before_in_foreach_instruction> secondPhase
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !inSemanticContext
        ?foreachEnumerationList
        ?whileExpression
        ?do_instructionList
      ;
    end parse ;
  #--- Between instruction list
    @typeInstructionList between_instructionList [emptyList] ;
    block ioVariablesMap.repeatPart () :
      select
      or
        cast indexVariable :
        when == @typeAutomaticName a do
          [!?ioVariablesMap insertUsedConstInArgument
            ![@lstring new ![a mName] ![a mVariableLocation]]
            ![@typeGalgas_uint new]
            !indexVariable
          ] ;
        else
        end cast ;
        $between$ ;
        <semantic_instructions_list_no_verif>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?between_instructionList
          !inSemanticContext
        ;
      end select ;
    end block (!here) ;
  #--- After instruction list
   @typeInstructionList after_instructionList [emptyList] ;
    block ioVariablesMap.repeatPart () :
      select
      or
        cast indexVariable :
        when == @typeAutomaticName a do
          [!?ioVariablesMap insertUsedConstInArgument
            ![@lstring new ![a mName] ![a mVariableLocation]]
            ![@typeGalgas_uint new]
            !indexVariable
          ] ;
        else
        end cast ;
        $after$ ;
        <semantic_instructions_list_no_verif>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?after_instructionList
          !inSemanticContext
        ;
      end select ;
    end block (!here) ;
  end block () ;
  instruction := [@typeForeachInstruction new
    !foreachEnumerationList
    !indexVariable
    !whileExpression
    !before_instructionList
    !do_instructionList
    !between_instructionList
    !after_instructionList
  ] ;
  $end$ ;
  $foreach$ ;
  $;$ ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     ' M A T C H '    I N S T R U C T I O N                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <parse_match_operand>
  ?!@typeVariablesMap ioVariablesMap
  !@typeCplusPlusName outCppName
  !@lstring outBaseTypeName
  !@location outVarLocation
  !@bool outIsEnumeration
  !@enumConstantMap outEnumMessageMap
:
  @lstring variableName ;
  @AC_galgasType type ;
  <read_access>
    ?variableName
    ?outCppName
    ?type
    !?ioVariablesMap
  ;
  outVarLocation := here ;
  cast type :
  when >= @typeGalgasClassType t do
    outBaseTypeName := [t mClassTypeName] ;
    outIsEnumeration := false ;
    outEnumMessageMap := [@enumConstantMap emptyMap] ;
  when >= @typeGalgas_enum e do
    outBaseTypeName := [e mEnumTypeName] ;
    outIsEnumeration := true ;
    outEnumMessageMap := [e mEnumConstantesMap] ;
  else
    @string actualTypeName ;
    [type getTypeName ?actualTypeName] ; 
    error variableName : "the type of this variable is '@" . actualTypeName
      . "' ; I was expected an enumeration type or an abstract type" 
      : outBaseTypeName, outIsEnumeration, outEnumMessageMap ;
  end cast ;
end rule ;


#---------------------------------------------------------------------------*

rule <parse_match_case>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap unused inEnumMessageMap
  !@lstring outTypeName
:
#--- Nom du type 1
  $type_name$ ? outTypeName ;
#--- Verifier que la classe 'outTypeName' est declaree
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !outTypeName ?entite] ;
  @AC_galgasType definitionClasse1 := [(cast entite if >= @typeEntiteType else error outTypeName) aDefType] ;
#--- Verifier que la classe 'outTypeName' herite de la classe 'baseTypeName1'
  @typeGalgasClassType classType := (cast definitionClasse1 if >= @typeGalgasClassType else error outTypeName) ;
  @typeSuperClassesMap tableDesClassesAncetresType1 := [classType mAncestorClassesMap] ;
  @typeListeAttributsSemantiques listeAttributs1 := [classType mAttributeList] ;
  @bool isAbstract := [classType mClassIsAbstract] ;
#--- Check class is not abstract
  if isAbstract then
    error outTypeName : "an abstract class is not allowed here" ;
  end if ;
#--- Verify class is an heir of variable type
  if inIsEnumeration then
    error outTypeName : "a constant of '@" . [inTypeName string] . "' enumeration type is expected here" ;
  elsif not [tableDesClassesAncetresType1 hasKey ![inTypeName string]] then
    error outTypeName : "This type does not inherit from '" . [inTypeName string] . "'" ;
  end if ;
#--- Arguments
  <parse_effective_input_parameters_list>
    !?ioVariablesMap
    !listeAttributs1
    !inVarLocation
    ![@localConstantBuildStyleEnum listStyle]
    !false # No new style of enumerator
    ?*
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <parse_match_case>
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap unused ioVariablesMap
  ?@lstring inTypeName
  ?@location unused inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outEnumConstantName
:
#--- Enumeration constant
  $identifier$ ? outEnumConstantName ;
#--- Verify constant belongs to constants map
  if inIsEnumeration then
    [inEnumMessageMap searchKey !outEnumConstantName ?*] ;
  else
    error outEnumConstantName : "a class that inherit from '@" . [inTypeName string] . "' abstract class is expected here" ;
  end if ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  $match$ ;
#--- Get first operand
  @typeCplusPlusName operand1_cppName ;
  @lstring operand1_typeName ;
  @location operand1_location ;
  @bool operand1_isEnumeration ;
  @enumConstantMap operand1_enumMessageMap ;
  <parse_match_operand>
    !?ioVariablesMap
    ?operand1_cppName
    ?operand1_typeName
    ?operand1_location
    ?operand1_isEnumeration
    ?operand1_enumMessageMap
  ;
#--- Get second operand
  $::$ ;
  @typeCplusPlusName operand2_cppName ;
  @lstring operand2_typeName ;
  @location operand2_location ;
  @bool operand2_isEnumeration ;
  @enumConstantMap operand2_enumMessageMap ;
  <parse_match_operand>
    !?ioVariablesMap
    ?operand2_cppName
    ?operand2_typeName
    ?operand2_location
    ?operand2_isEnumeration
    ?operand2_enumMessageMap
  ;
#---  Cases list
  $:$ ;
  @L_matchInstructionCasesList casesList [emptyList] ;
  block ioVariablesMap.testBloc () :
    repeat
    while
      $when$ ;
      block ioVariablesMap.testPart () :
        @lstring case1_name ;
      #--- First case 
       <parse_match_case>
          !ioComponentSemanticsEntitiesMap
          !?ioVariablesMap
          !operand1_typeName
          !operand1_location
          !operand1_isEnumeration
          !operand1_enumMessageMap
          ?case1_name
        ;
      #--- Separator
        $::$ ;
      #--- Second case
        @lstring case2_name ;
        <parse_match_case>
          !ioComponentSemanticsEntitiesMap
          !?ioVariablesMap
          !operand2_typeName
          !operand2_location
          !operand2_isEnumeration
          !operand2_enumMessageMap
          ?case2_name
        ;
      #--- Instructions list
        $:$ ;
        @typeInstructionList instructionsList [emptyList] ;
        <semantic_instructions_list>
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
          !inSemanticContext
        ;
        casesList += !case1_name !case2_name !instructionsList ;
      end block (!here) ;
    end repeat ;
  #---------------------  E L S E    P A R T -----------------------
    block ioVariablesMap.testPart () :
      $else$ ;
      @typeInstructionList elsePartInstructionsList [emptyList] ;
      <semantic_instructions_list>
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?elsePartInstructionsList
        !inSemanticContext
      ;
    end block (!here) ;
  end block () ;
  $end$ ;
  $match$ ;
  $;$ ;
#--- Insert instruction
  @typeInstruction instruction := [@typeMatchInstruction new !operand1_location
                                                             !operand2_location
                                                             !operand1_cppName
                                                             !operand2_cppName
                                                             !operand1_typeName
                                                             !operand2_typeName
                                                             !operand1_isEnumeration
                                                             !operand2_isEnumeration
                                                             !casesList
                                                             !elsePartInstructionsList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instructions_list_no_verif>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@EXsemanticContext inSemanticContext
:
  repeat
  while
    <semantic_instruction>
      !inTableEnAvant
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !inSemanticContext
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                 Affection optionnelle dans une declaration                *
#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring unused inTargetVarName
  ??@typeCplusPlusName inVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap unused ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ??@EXsemanticContext unused inSemanticContext
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
:
  ioInstructionList += ![@typeInstructionDeclarationVarLocale new !inVariableCppName !inVariableType] ;
end rule ;

#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring inTargetVarName
  ??@typeCplusPlusName inTargetVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $:=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !inVariableType !sourceType !here !true ;
#--- Generate instruction
  @typeInstruction instruction := [@C_declarationInstructionWithAssignment new !inVariableType !inTargetVariableCppName !sourceExpression] ;
  ioInstructionList += !instruction ;
#--- Indicate variable is written
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?* ?*] ;
end rule ;

#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring inTargetVarName
  ??@typeCplusPlusName inTargetVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@EXsemanticContext inSemanticContext
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
#--- Indicate variable is written
  $[$ ;
#--- Class method name
  @lstring constructorName ;
  $identifier$ ? constructorName ;
  @typeListeAttributsSemantiques listeAttributsSemantiques ;
  @bool hasLexiqueAndLocationArguments ;
  @AC_galgasType returnedType ;
  [inVariableType handleConstructorInvocation !constructorName ?listeAttributsSemantiques ?hasLexiqueAndLocationArguments ?returnedType] ;
#--- Check returned type is the same as constant type
  if inVariableType != returnedType then
    @string typeName ; [returnedType getTypeName ?typeName] ;
    error constructorName:"this constructor returns an other type: '@" . typeName . "'" ;
  end if ;
#--- Actual arguments
  @typeExpressionList expressionList ;
  <output_expression_list>
    ?expressionList
    !listeAttributsSemantiques
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !inSemanticContext
    !?ioVariablesMap
  ;
  $]$ ;
#--- Generate instruction
  @typeExpression  e := [@typeConstructorExpression new 
    !inVariableType
    !constructorName
    !hasLexiqueAndLocationArguments
    !expressionList
  ] ;
  ioInstructionList += ![@C_declarationInstructionWithAssignment new !inVariableType !inTargetVariableCppName !e] ;
#--- Indicate variable is written
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?* ?*] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P I N D E X    D E C L A R A T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $mapproxy$ ;
  @lstring mapindexTypeName ;
  $type_name$ ? mapindexTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![mapindexTypeName string]]
         | [ioComponentSemanticsEntitiesMap hasKey ![mapindexTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapindexType new !mapindexTypeName] ;
      [!?tableEnAvant insertKey !mapindexTypeName !t] ;
    end if ;
  or
    $($ ;
    @lstring mapTypeName ;
    $type_name$ ? mapTypeName ;
    @AC_semanticsEntity theEntity ;
    [ioComponentSemanticsEntitiesMap searchKey !mapTypeName ? theEntity] ;
    @AC_galgasType aType := [(cast theEntity if >= @typeEntiteType else error mapTypeName) aDefType] ;
    @typeGalgasMapType mapType := (cast aType if >= @typeGalgasMapType else error mapTypeName) ;
    @typeListeAttributsSemantiques mapAttributesList := [mapType mAttributeList] ;
    @typeTableBlocsDeTable tableMethodesSurcharger := [mapType aTableMethodesSurcharger] ;
    @mapModifierMap modifierMethodMap := [mapType mModifierMethodMap] ;
    @EXmapMethodMap readerMethodMap := [mapType mReaderMethodMap] ;
    $)$ ;
    $;$ ;
    @AC_galgasType t := [@typeGalgasMapindexType new 
      !mapindexTypeName
      !mapTypeName
      !mapType
      !mapAttributesList
      !tableMethodesSurcharger
      !modifierMethodMap
      !readerMethodMap
    ] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapindexTypeName ![@typeEntiteType new !t]] ;
    @typeEntityToGenerate e := [@C_mapindexToImplement new
      !mapindexTypeName
      !mapTypeName
      !mapAttributesList
      !readerMethodMap
    ] ;
    listeEntitesAengendrer += !e ;
  end select ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $mapproxy$ ;
  @lstring mapindexTypeName ;
  $type_name$ ? mapindexTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![mapindexTypeName string]]
         | [ioComponentSemanticsEntitiesMap hasKey ![mapindexTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapindexType new !mapindexTypeName] ;
      [!?tableEnAvant insertKey !mapindexTypeName !t] ;
    end if ;
  or
    $($ ;
    @lstring mapTypeName ;
    $type_name$ ? mapTypeName ;
    @AC_semanticsEntity theEntity ;
    [ioComponentSemanticsEntitiesMap searchKey !mapTypeName ? theEntity] ;
    @AC_galgasType aType := [(cast theEntity if >= @typeEntiteType else error mapTypeName) aDefType] ;
    @typeGalgasMapType mapType := (cast aType if >= @typeGalgasMapType else error mapTypeName) ;
    @typeListeAttributsSemantiques mapAttributesList := [mapType mAttributeList] ;
    @typeTableBlocsDeTable tableMethodesSurcharger := [mapType aTableMethodesSurcharger] ;
    @mapModifierMap modifierMethodMap := [mapType mModifierMethodMap] ;
    @EXmapMethodMap readerMethodMap := [mapType mReaderMethodMap] ;
    $)$ ;
    $;$ ;
    @AC_galgasType t := [@typeGalgasMapindexType new 
      !mapindexTypeName
      !mapTypeName
      !mapType
      !mapAttributesList
      !tableMethodesSurcharger
      !modifierMethodMap
      !readerMethodMap
    ] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapindexTypeName ![@typeEntiteType new !t]] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P    D E C L A R A T I O N                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $map$ ;
  @lstring mapTypeName ;
  $type_name$ ? mapTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![mapTypeName string]]
         | [ioComponentSemanticsEntitiesMap hasKey ![mapTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapType new !mapTypeName] ;
      [!?tableEnAvant insertKey !mapTypeName !t] ;
    end if ;
  or
  #--- map generique C++ utilisee
    $class$ ;
    @lstring cppClassName ;
    $identifier$ ?cppClassName ;
    warning cppClassName: "old style map definition" ;
    $;$ ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
    repeat
    while
      $insert$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      insertMethodList += !nomMethode ![errorMessage string] !true !"" ; # Bool parameter has any value
    while 
      $search$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      searchMethodList += !nomMethode ![errorMessage string] !true !"" ; # Bool parameter has any value
    while
      $block$ ;
      @lstring nomMethode ;
      $identifier$ ? nomMethode ;
      $:$ ;
      @L_EXsignature signatureDebut ;
      @typeVariablesMap tableDebut [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeDebut ; 
      $($ ;
      @signatureForGrammarAnalysis signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?signatureDebut
        !?tableDebut
        ?listeTypesEtNomsArgMethodeDebut
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $:$ ;
      @L_EXsignature signatureFin ;
      @typeVariablesMap tableFin [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeFin ; 
      $($ ;
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?signatureFin
        !?tableFin
        ?listeTypesEtNomsArgMethodeFin
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $;$ ;
      [!?tableMethodesBloc insertKey !nomMethode !signatureDebut !signatureFin] ;
    end repeat ;
  #--- Attributs de la map
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Build insert and search method map
    @mapModifierMap mapModifierMethodMap [emptyMap] ;
    @formalArgumentPassingModeAST inPassingMode [argumentIn] ;
    @formalArgumentPassingModeAST outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    foreach insertMethodList do
    #--- Insert Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !mMethodName !methodSignature] ;
    #--- Insert Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !inPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![mMethodName string] . "GetIndex" ![mMethodName location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
    foreach searchMethodList do
   #--- insert method
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !mMethodName !methodSignature] ;
   #--- insert method GetIndex
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !outPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![mMethodName string] . "GetIndex" ![mMethodName location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      ![@EXmapMethodMap emptyMap]
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
  #--- Insertion dans la map des classes definies dans le fichier source courant
    @typeEntityToGenerate def := [@typeDefinitionTableAimplementer new !mapTypeName
                                                                       !listeTousAttributsSemantiques
                                                                       !cppClassName
                                                                       !insertMethodList
                                                                       !searchMethodList
                                                                       !tableMethodesBloc] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  or #------------------ New Map
    @lstring enumTypeName ;
    @lstring checkFinalStateMethod ;
    select
      enumTypeName := [@lstring new !"" !here] ;
      checkFinalStateMethod := [@lstring new !"" !here] ;
    or
      $($ ;
      $type_name$ ? enumTypeName ;
      $:$ ;
      $identifier$ ? checkFinalStateMethod ;
      $)$ ;
    end select ;
    ${$ ;
  #--- Parse Map attributes
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @insertOrSearchMethodList removeMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
  #--- Build insert and search method map
    @formalArgumentPassingModeAST inPassingMode [argumentIn] ;
    @formalArgumentPassingModeAST outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    @mapModifierMap mapModifierMethodMap [emptyMap] ;
    @EXmapMethodMap mapReaderMethodMap [emptyMap] ;
    @bool hasInsertOrReplaceMethod := false ;
    repeat
    while
      $insert$ ;
      $or$ ;
      $replace$ ;
      $;$ ;
      hasInsertOrReplaceMethod := true ;
      #--- Enter insert method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey ![@lstring new !"insertOrReplace" !here] !methodSignature] ;
    while
      $remove$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      check_KL_escapeCharacters !errorMessage ;
      $;$ ;
    #--- Insert method
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
      removeMethodList += !methodName ![errorMessage string] !false !"" ;
   #-- Insert And Get Index Method
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques do
          getIndexMethodSignature += !mAttributType !outPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        removeMethodList += !getIndexMethodName ![errorMessage string] !true !"" ;
      end if ;
    while
      $insert$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      check_KL_escapeCharacters !errorMessage ;
      @string shadowErrorMessage ;
      select
        shadowErrorMessage := "" ;
      or
        $,$ ;
        @lstring shadowErrorMessageString ;
        $literal_string$ ? shadowErrorMessageString ;
#        warning shadowErrorMessageString : "shadow message" ;
        check_KL_escapeCharacters !shadowErrorMessageString ;
        shadowErrorMessage := [shadowErrorMessageString string] ;
      end select ;
      $;$ ;
    #--- Insert method
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
      insertMethodList += !methodName ![errorMessage string] !false !shadowErrorMessage ;
   #-- Insert And Get Index Method
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques do
          getIndexMethodSignature += !mAttributType !inPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        insertMethodList += !getIndexMethodName ![errorMessage string] !true !shadowErrorMessage ;
      end if ;
    while
      $search$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      check_K_escapeCharacters !errorMessage ;
      $;$ ;
    #--- Insert search method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !outPassingMode ;      
      end foreach ;
      [!?mapReaderMethodMap insertKey !methodName !methodSignature] ;
      searchMethodList += !methodName ![errorMessage string] !false !"" ;
    #--- Insert 'Get Index' search method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques do
         getIndexMethodSignature += !mAttributType !outPassingMode ;      
        end foreach ;
        [!?mapReaderMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        searchMethodList += !getIndexMethodName ![errorMessage string] !true !"" ;
      end if ;
    end repeat ;
  #--- Modifiers "Set'Value'ForKey"
    foreach tableAttributs do
      if mHasSetter then
        @string modifierName := "set" . [[key string] stringByCapitalizingFirstCharacter] . "ForKey" ;
        @L_EXsignature modifierSignature [emptyList] ;
        modifierSignature += !mAttributType !inPassingMode ; 
        modifierSignature += ![@typeGalgas_string new] !inPassingMode ; 
        [!?mapModifierMethodMap insertKey ![@lstring new !modifierName !here] !modifierSignature] ;
      end if ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      !mapReaderMethodMap
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
  #--- Insertion dans la map des classes definies dans le fichier source courant
    @typeEntityToGenerate def := [@C_mapToImplement new
      !mapTypeName
      !enumTypeName
      !checkFinalStateMethod
      !listeTousAttributsSemantiques
      !tableAttributs
      !insertMethodList
      !searchMethodList
      !removeMethodList
      !hasInsertOrReplaceMethod
    ] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $map$ ;
  @lstring mapTypeName ;
  $type_name$ ? mapTypeName ;
  select
    $;$ ;
    if not([tableEnAvant hasKey ![mapTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![mapTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapType new !mapTypeName] ;
      [!?tableEnAvant insertKey !mapTypeName !t] ;
    end if ;
  or
  #--- map generique C++ utilisee
    $class$ ;
    @lstring cppClassName ;
    $identifier$ ?cppClassName ;
    $;$ ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
    repeat
    while
      $insert$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      insertMethodList += !nomMethode ![errorMessage string] !true !"" ; #bool parameter can have any value
    while 
      $search$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      searchMethodList += !nomMethode ![errorMessage string] !true !"" ; #bool parameter can have any value
    while
      $block$ ;
      @lstring nomMethode ;
      $identifier$ ? nomMethode ;
      $:$ ;
      @L_EXsignature signatureDebut ;
      @typeVariablesMap tableDebut [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeDebut ; 
      $($ ;
      @signatureForGrammarAnalysis signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?signatureDebut
        !?tableDebut
        ?listeTypesEtNomsArgMethodeDebut
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $:$ ;
      @L_EXsignature signatureFin ;
      @typeVariablesMap tableFin [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeFin ; 
      $($ ;
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?signatureFin
        !?tableFin
        ?listeTypesEtNomsArgMethodeFin
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $;$ ;
      [!?tableMethodesBloc insertKey !nomMethode !signatureDebut !signatureFin] ;
    end repeat ;
  #--- Attributs de la map
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Build insert and search method map
    @mapModifierMap mapModifierMethodMap [emptyMap] ;
    @formalArgumentPassingModeAST inPassingMode [argumentIn] ;
    @formalArgumentPassingModeAST outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    foreach insertMethodList do
    #--- Insert Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !mMethodName !methodSignature] ;
    #--- Insert Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !inPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![mMethodName string] . "GetIndex" ![mMethodName location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
    foreach searchMethodList do
    #--- Search Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !mMethodName !methodSignature] ;
    #--- Search Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !outPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![mMethodName string] . "GetIndex" ![mMethodName location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      ![@EXmapMethodMap emptyMap]
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
    @TypeModel type := [@MapModel new ! attributeListModel] ;
    [!?ioModelMap insertKey !mapTypeName !type] ;
    $}$ ;
  or
    select
    or
      $($ ;
      $type_name$ ? * ;
      $:$ ;
      $identifier$ ? * ;
      $)$ ;
    end select ;
    ${$ ;
  #--- Map attributes
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
  #--- Build insert and search method map
    const @formalArgumentPassingModeAST inPassingMode [argumentIn] ;
    const @formalArgumentPassingModeAST outPassingMode [argumentOut] ;
    const @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    const @AC_galgasType luintType := [@typeGalgas_luint new] ;
    @mapModifierMap mapModifierMethodMap [emptyMap] ;
    @EXmapMethodMap mapReaderMethodMap [emptyMap] ;
    @bool hasInsertOrReplaceMethod := false ;
    repeat
    while
      $insert$ ;
      $or$ ;
      $replace$ ;
      $;$ ;
      hasInsertOrReplaceMethod := true ;
      #--- Enter insert method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey ![@lstring new !"insertOrReplace" !here] !methodSignature] ;
    while
      $remove$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      $;$ ;
    #--- Enter insert method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'GetIndex' insert method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques do
          getIndexMethodSignature += !mAttributType !outPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
      end if ;
    while
      $insert$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      select
      or
        $,$ ;
        $literal_string$ ? * ;
      end select ;
      $;$ ;
    #--- Enter insert method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'GetIndex' insert method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques do
          getIndexMethodSignature += !mAttributType !inPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName ! getIndexMethodSignature] ;
      end if ;
    while
      $search$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      $;$ ;
    #--- Enter search method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ; # Key
      foreach listeTousAttributsSemantiques do
        methodSignature += !mAttributType !outPassingMode ;      
      end foreach ;
      [!?mapReaderMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'Get Index' search method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature := [@L_EXsignature emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ; # Key
        getIndexMethodSignature += !luintType !outPassingMode ; # Returned Index
        foreach listeTousAttributsSemantiques do
          getIndexMethodSignature += !mAttributType !outPassingMode ;      
        end foreach ;
        [!?mapReaderMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
      end if ;
    end repeat ;
  #--- Modifiers "Set'Value'ForKey"
    foreach tableAttributs do
      if mHasSetter then
        @string modifierName := "set" . [[key string] stringByCapitalizingFirstCharacter] . "ForKey" ;
        @L_EXsignature modifierSignature [emptyList] ;
        modifierSignature += !mAttributType !inPassingMode ; 
        modifierSignature += ![@typeGalgas_string new] !inPassingMode ; 
        [!?mapModifierMethodMap insertKey ![@lstring new !modifierName !here] !modifierSignature] ;
      end if ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
     !mapTypeName
     !listeTousAttributsSemantiques
     !tableMethodesBloc
     !mapModifierMethodMap
     !mapReaderMethodMap
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
    @TypeModel type := [@MapModel new ! attributeListModel] ;
    [!?ioModelMap insertKey !mapTypeName !type] ;
    $}$ ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*

rule <ex_map_method>
  !@lstring nomMethode
  !@lstring outMessage
:
  $identifier$ ? nomMethode ;
  $error$ ;
  $message$ ;
  $literal_string$ ? outMessage ;
end rule ;

#---------------------------------------------------------------------------*

rule <map_method>
  !@lstring methodName
  !@lstring getIndexMethodName
  !@lstring outMessage
:
  $identifier$ ?methodName ;
  select
    getIndexMethodName := [@lstring new !"" !here] ;
  or
    $,$ ;
    $identifier$ ?getIndexMethodName ;
    warning getIndexMethodName : "use an alternate method is obsolete in GALGAS 1.9.12 and later" ;
  end select ;
  $error$ ;
  $message$ ;
  $literal_string$ ? outMessage ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# A B S T R A C T    C A T E G O R Y    M E T H O D   D E C L A R A T I O N *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_beginning_by_abstract>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind [abstractMethod] ;
  $method$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring methodName ;
#---- Formal arguments -----------------------------------------
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @L_EXsignature listeDeTypes ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  const @lstring kKey [new ![className string] . ":" . [methodName string] ![methodName location]] ;
  [!?ioSemanticContext->mCategoryMethodMap insertKey !kKey !categoryMethodKind !listeDeTypes] ;
#---- Get class attribute list ---------------------------------
  @AC_semanticsEntity theEntity ;
  [ioComponentSemanticsEntitiesMap searchKey !className ?theEntity] ;
  @AC_galgasType type := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
  @typeGalgasClassType classType := (cast type if >= @typeGalgasClassType else error className) ;
#---- Check method definition in super class -------------------
  @string baseClassName ;
  @typeSuperClassesMap ancestorClassesMap := [classType mAncestorClassesMap] ;  
#--- Check no super class defines this method
  foreach ancestorClassesMap do
    @string keyClassMethod := [key string]  . ":" . [methodName string] ;
    if [[ioSemanticContext mCategoryMethodMap] hasKey !keyClassMethod] then
      error methodName: "this method is already defined for super class @" . key
      . ": you should use the 'override' key word" ;
    end if ;
  end foreach ;
  baseClassName := [className string] ;
  $;$ ;
#--- Generate 
  @typeInstructionList instructionList [emptyList] ;
  listeEntitesAengendrer += ![@categoryMethodToImplement new
    !categoryMethodKind
    !baseClassName
    !className
    !methodName
    !listeTypeEtNomsArguments
    !instructionList
    ![methodName location] # Magic Number
  ] ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind [abstractMethod] ;
  $method$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring methodName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  @lstring key [new ![className string] . ":" . [methodName string] ![methodName location]] ;
  if not [[ioSemanticContext mCategoryMethodMap] hasKey ![key string]] then
    [!?ioSemanticContext->mCategoryMethodMap insertKey !key !categoryMethodKind !listeDeTypes] ;
  end if ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     C A T E G O R Y    M E T H O D   D E C L A R A T I O N                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind ;
  select
    categoryMethodKind := [@categoryMethodKind baseMethod] ;
  or
    $override$ ;
    categoryMethodKind := [@categoryMethodKind overridingMethod] ;
  end select ;
  $method$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring methodName ;
#---- Formal arguments -----------------------------------------
  @typeVariablesMap methodLocalVariablesMap [emptyMap] ;
  @L_EXsignature listeDeTypes ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  const @lstring kKey [new ![className string] . ":" . [methodName string] ![methodName location]] ;
  [!?ioSemanticContext->mCategoryMethodMap insertKey !kKey !categoryMethodKind !listeDeTypes] ;
#---- Get class attribute list ---------------------------------
  @AC_semanticsEntity theEntity ;
  [ioComponentSemanticsEntitiesMap searchKey !className ?theEntity] ;
  @AC_galgasType type := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
  @typeGalgasClassType classType := (cast type if >= @typeGalgasClassType else error className) ;
#---- Check method definition in super class -------------------
  @string baseClassName ;
  @typeSuperClassesMap ancestorClassesMap := [classType mAncestorClassesMap] ;  
  if categoryMethodKind == [@categoryMethodKind overridingMethod] then #--- Check a super class defines this method
    baseClassName := "" ;
    @bool found := false ;
    foreach ancestorClassesMap while not found do
      @string keyClassMethod := [key string]  . ":" . [methodName string] ;
      baseClassName := [key string] ;
      found := [[ioSemanticContext mCategoryMethodMap] hasKey !keyClassMethod] ;
      if found then
        @categoryMethodKind localCategoryMethodKind ;
        @L_EXsignature listeDeTypesPrecedenteDeclaration ;
        [[ioSemanticContext mCategoryMethodMap] searchKey ![@lstring new !keyClassMethod !here] ?localCategoryMethodKind ?listeDeTypesPrecedenteDeclaration] ;
        verifierCompatibiliteSignatures
          !listeDeTypesPrecedenteDeclaration
          !listeDeTypes
          !here
        ;
        found := localCategoryMethodKind != [@categoryMethodKind overridingMethod] ;
      end if ;
    end foreach ;
    if not found then
      error methodName: "this overriden method is not defined in any super class of @" . className
      . ": you should remove the 'override' key word" ;
    end if ;
  else #--- Check no super class defines this method
    foreach ancestorClassesMap do
      @string keyClassMethod := [key string]  . ":" . [methodName string] ;
      if [[ioSemanticContext mCategoryMethodMap] hasKey !keyClassMethod] then
        error methodName: "this method is already defined for super class @" . key
        . ": you should use the 'override' key word" ;
     end if ;
    end foreach ;
    baseClassName := [className string] ;
  end if ;
#---- Add attributes as used local constants -------------------
  foreach [classType mAttributeList] do
    @typeCplusPlusName cppName := [@typeOperandName new
      ![methodName location] # Magic Number
      ![mAttributeName string]
      !false # not mapStyle
      !false # not iterator new style
    ] ;
    [!? methodLocalVariablesMap insertUsedConstInArgument !mAttributeName !mAttributType !cppName] ;
  end foreach ;
#--- Insert the predefined "self" variable
  [!?methodLocalVariablesMap insertUsedConstInArgument ![@lstring new !"self" !here] !classType ![@typeCppThisInCategoryName new ![methodName location]]] ;
#--- Instructions
  $:$ ;
  @typeInstructionList instructionList [emptyList] ;
  <semantic_instructions_list>
    !tableEnAvant
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !? methodLocalVariablesMap
    !?instructionList
    !ioSemanticContext
  ;
  $end$ ;
  $method$ ;
  $;$ ;
  listeEntitesAengendrer += ![@categoryMethodToImplement new
    !categoryMethodKind
    !baseClassName
    !className
    !methodName
    !listeTypeEtNomsArguments
    !instructionList
    ![methodName location] # Magic Number
  ] ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind ;
  select
    categoryMethodKind := [@categoryMethodKind baseMethod] ;
  or
    $override$ ;
    categoryMethodKind := [@categoryMethodKind overridingMethod] ;
  end select ;
  $method$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring methodName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap methodLocalVariablesMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  @lstring key [new ![className string] . ":" . [methodName string] ![methodName location]] ;
  if not [[ioSemanticContext mCategoryMethodMap] hasKey ![key string]] then
    [!?ioSemanticContext->mCategoryMethodMap insertKey !key !categoryMethodKind !listeDeTypes] ;
  end if ;
#--- Instructions
  $:$ ;
  <semantic_instructions_list> parse ;
  $end$ ;
  $method$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# A B S T R A C T    C A T E G O R Y    R E A D E R   D E C L A R A T I O N *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_beginning_by_abstract>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind [abstractMethod] ;
  $reader$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring readerName ;
#---- Formal arguments -----------------------------------------
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @L_EXsignature listeDeTypes ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#---- Returned type --------------------------------------------
  $->$ ;
  $type_name$ ? @lstring returnedTypeName ;
  $identifier$ ?@lstring returnedVariableName ;
  @typeCplusPlusName returnedCppVarName := [@typeAutomaticName new ![returnedVariableName location] ![returnedVariableName string]] ;
  @AC_semanticsEntity theEntity ;
  [ioComponentSemanticsEntitiesMap searchKey !returnedTypeName ?theEntity] ;
  @AC_galgasType returnedType := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
#---- Insert in category reader map ----------------------------
  const @lstring kKey [new ![className string] . ":" . [readerName string] ![readerName location]] ;
  [!?ioSemanticContext-> mCategoryReaderMap insertKey !kKey !categoryMethodKind !listeDeTypes !returnedType] ;
#---- Get class attribute list ---------------------------------
  [ioComponentSemanticsEntitiesMap searchKey !className ?theEntity] ;
  @AC_galgasType type := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
  @typeGalgasClassType classType := (cast type if >= @typeGalgasClassType else error className) ;
#---- Check method definition in super class -------------------
  @string baseClassName ;
  @typeSuperClassesMap ancestorClassesMap := [classType mAncestorClassesMap] ;  
#--- Check no super class defines this method
  foreach ancestorClassesMap do
    @string keyClassMethod := [key string]  . ":" . [readerName string] ;
    if [[ioSemanticContext mCategoryReaderMap] hasKey !keyClassMethod] then
      error readerName: "this reader is already defined for super class @" . key
      . ": you should use the 'override' key word" ;
    end if ;
  end foreach ;
  baseClassName := [className string] ;
  $;$ ;
#--- Generate 
  @typeInstructionList instructionList [emptyList] ;
  listeEntitesAengendrer += ![@categoryReaderToImplement new
    !categoryMethodKind
    !baseClassName
    !className
    !readerName
    !listeTypeEtNomsArguments
    !instructionList
    ![readerName location] # Magic Number
    !returnedType
    !returnedCppVarName
  ] ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind [abstractMethod] ;
  $reader$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring readerName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#---- Returned type --------------------------------------------
  $->$ ;
  $type_name$ ? @lstring returnedTypeName ;
  $identifier$ ?* ;
  @AC_semanticsEntity theEntity ;
  [ioComponentSemanticsEntitiesMap searchKey !returnedTypeName ?theEntity] ;
  @AC_galgasType returnedType := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
#---- Insert in category reader map ----------------------------
  @lstring key [new ![className string] . ":" . [readerName string] ![readerName location]] ;
  if not [[ioSemanticContext mCategoryReaderMap] hasKey ![key string]] then
    [!?ioSemanticContext-> mCategoryReaderMap insertKey !key !categoryMethodKind !listeDeTypes !returnedType] ;
  end if ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     C A T E G O R Y    R E A D E R   D E C L A R A T I O N                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind ;
  select
    categoryMethodKind := [@categoryMethodKind baseMethod] ;
  or
    $override$ ;
    categoryMethodKind := [@categoryMethodKind overridingMethod] ;
  end select ;
  $reader$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring readerName ;
#---- Formal arguments -----------------------------------------
  @typeVariablesMap methodLocalVariablesMap [emptyMap] ;
  @L_EXsignature listeDeTypes ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#---- Returned type --------------------------------------------
  $->$ ;
  $type_name$ ? @lstring returnedTypeName ;
  @AC_semanticsEntity theEntity ;
  [ioComponentSemanticsEntitiesMap searchKey !returnedTypeName ?theEntity] ;
  @AC_galgasType returnedType := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
#---- Returned value identifier --------------------------------
  $identifier$ ?@lstring returnedVariableName ;
  @typeCplusPlusName returnedCppVarName := [@typeAutomaticName new ![returnedVariableName location] ![returnedVariableName string]] ;
  [!?methodLocalVariablesMap insertOutArgument !returnedVariableName !returnedType !returnedCppVarName] ;
#---- Insert in category reader map ----------------------------
  const @lstring kKey [new ![className string] . ":" . [readerName string] ![readerName location]] ;
  [!?ioSemanticContext-> mCategoryReaderMap insertKey !kKey !categoryMethodKind !listeDeTypes !returnedType] ;
#---- Get class attribute list ---------------------------------
  [ioComponentSemanticsEntitiesMap searchKey !className ?theEntity] ;
  @AC_galgasType type := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
  @typeGalgasClassType classType := (cast type if >= @typeGalgasClassType else error className) ;
#---- Check method definition in super class -------------------
  @string baseClassName ;
  @typeSuperClassesMap ancestorClassesMap := [classType mAncestorClassesMap] ;  
  if categoryMethodKind == [@categoryMethodKind overridingMethod] then #--- Check a super class defines this method
    baseClassName := "" ;
    @bool found := false ;
    foreach ancestorClassesMap while not found do
      @string keyClassMethod := [key string]  . ":" . [readerName string] ;
      baseClassName := [key string] ;
      found := [[ioSemanticContext mCategoryReaderMap] hasKey !keyClassMethod] ;
      if found then
        @categoryMethodKind localCategoryMethodKind ;
        @L_EXsignature listeDeTypesPrecedenteDeclaration ;
        @AC_galgasType returnedTypePreviousDeclaration ;
        [[ioSemanticContext mCategoryReaderMap] searchKey
           ![@lstring new !keyClassMethod !here]
           ?localCategoryMethodKind
           ?listeDeTypesPrecedenteDeclaration
           ?returnedTypePreviousDeclaration
        ] ;
        verifierCompatibiliteSignatures
          !listeDeTypesPrecedenteDeclaration
          !listeDeTypes
          ![readerName location]
        ;
        checkAssignmentTypesCompatibility
           !returnedType
           !returnedTypePreviousDeclaration
           ![returnedVariableName location]
           !false
        ;
        found := localCategoryMethodKind != [@categoryMethodKind overridingMethod] ;
      end if ;
    end foreach ;
    if not found then
      error readerName: "this overriden reader is not defined in any super class of @" . className
      . ": you should remove the 'override' key word" ;
    end if ;
  else #--- Check no super class defines this method
    foreach ancestorClassesMap do
      @string keyClassMethod := [key string]  . ":" . [readerName string] ;
      if [[ioSemanticContext mCategoryReaderMap] hasKey !keyClassMethod] then
        error readerName: "this reader is already defined for super class @" . key
        . ": you should use the 'override' key word" ;
     end if ;
    end foreach ;
    baseClassName := [className string] ;
  end if ;
#---- Add attributes as used local constants -------------------
  foreach [classType mAttributeList] do
    @typeCplusPlusName cppName := [@typeOperandName new
      ![readerName location] # Magic Number
      ![mAttributeName string]
      !false # not mapStyle
      !false # not iterator new style
    ] ;
    [!?methodLocalVariablesMap insertUsedConstInArgument !mAttributeName !mAttributType !cppName] ;
  end foreach ;
#--- Insert the predefined "self" variable
  [!?methodLocalVariablesMap insertUsedConstInArgument ![@lstring new !"self" !here] !classType ![@typeCppThisInCategoryName new ![readerName location]]] ;
#--- Instructions
  $:$ ;
  @typeInstructionList instructionList [emptyList] ;
  <semantic_instructions_list>
    !tableEnAvant
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !? methodLocalVariablesMap
    !?instructionList
    !ioSemanticContext
  ;
  $end$ ;
  $reader$ ;
  $;$ ;
  listeEntitesAengendrer += ![@categoryReaderToImplement new
    !categoryMethodKind
    !baseClassName
    !className
    !readerName
    !listeTypeEtNomsArguments
    !instructionList
    ![readerName location] # Magic Number
    !returnedType
    !returnedCppVarName
  ] ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind ;
  select
    categoryMethodKind := [@categoryMethodKind baseMethod] ;
  or
    $override$ ;
    categoryMethodKind := [@categoryMethodKind overridingMethod] ;
  end select ;
  $reader$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring readerName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap methodLocalVariablesMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#---- Returned type --------------------------------------------
  $->$ ;
  $type_name$ ? @lstring returnedTypeName ;
  $identifier$ ?* ;
  @AC_semanticsEntity theEntity ;
  [ioComponentSemanticsEntitiesMap searchKey !returnedTypeName ?theEntity] ;
  @AC_galgasType returnedType := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
#---- Insert in category reader map ----------------------------
  @lstring key [new ![className string] . ":" . [readerName string] ![readerName location]] ;
  if not [[ioSemanticContext mCategoryReaderMap] hasKey ![key string]] then
    [!?ioSemanticContext-> mCategoryReaderMap insertKey !key !categoryMethodKind !listeDeTypes !returnedType] ;
  end if ;
#--- Instructions
  $:$ ;
  <semantic_instructions_list> parse ;
  $end$ ;
  $reader$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# A B S T R A C T    C A T E G O R Y    T E M P L A T E   D E C L A R A T I O N *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_beginning_by_abstract>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind [abstractMethod] ;
  $template$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring templateName ;
#---- Formal arguments -----------------------------------------
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @L_EXsignature listeDeTypes ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#---- Insert in category reader map ----------------------------
  @lstring kKey [new ![className string] . ":" . [templateName string] ![templateName location]] ;
  [!?ioSemanticContext->mCategoryTemplateMap insertKey !kKey !categoryMethodKind !listeDeTypes] ;
#---- Get class attribute list ---------------------------------
  @AC_semanticsEntity theEntity ;
  [ioComponentSemanticsEntitiesMap searchKey !className ?theEntity] ;
  @AC_galgasType type := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
  @typeGalgasClassType classType := (cast type if >= @typeGalgasClassType else error className) ;
#---- Check method definition in super class -------------------
  @string baseClassName ;
  @typeSuperClassesMap ancestorClassesMap := [classType mAncestorClassesMap] ;  
#--- Check no super class defines this method
  foreach ancestorClassesMap do
    @string keyClassMethod := [key string]  . ":" . [templateName string] ;
    if [[ioSemanticContext mCategoryTemplateMap] hasKey !keyClassMethod] then
      error templateName: "this template is already defined for super class @" . key
      . ": you should use the 'override' key word" ;
    end if ;
  end foreach ;
  baseClassName := [className string] ;
  $;$ ;
#--- Generate 
  listeEntitesAengendrer += ![@categoryTemplateToImplement new
    !categoryMethodKind
    !baseClassName
    !className
    !templateName
    !listeTypeEtNomsArguments
    ![@templateInstructionList emptyList]
    ![templateName location] # Magic Number
    !false
  ] ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind [abstractMethod] ;
  $template$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring templateName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#---- Insert in category template map ----------------------------
  @lstring key [new ![className string] . ":" . [templateName string] ![templateName location]] ;
  if not [[ioSemanticContext mCategoryTemplateMap] hasKey ![key string]] then
    [!?ioSemanticContext->mCategoryTemplateMap insertKey !key !categoryMethodKind !listeDeTypes] ;
  end if ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     C A T E G O R Y    T E M P L A T E   D E C L A R A T I O N            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind ;
  select
    categoryMethodKind := [@categoryMethodKind baseMethod] ;
  or
    $override$ ;
    categoryMethodKind := [@categoryMethodKind overridingMethod] ;
  end select ;
  $template$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring templateName ;
  warning templateName:"obsolete construct" ;
#---- Formal arguments -----------------------------------------
  @typeVariablesMap variableMap [emptyMap] ;
  @L_EXsignature listeDeTypes ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?variableMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  @templateVariableMap categoryTemplateVariableMap [emptyMap] ;
#---- Insert in template reader map ----------------------------
  const @lstring kKey [new ![className string] . ":" . [templateName string] ![templateName location]] ;
  [!?ioSemanticContext->mCategoryTemplateMap insertKey !kKey !categoryMethodKind !listeDeTypes] ;
#---- Get class attribute list ---------------------------------
  @AC_semanticsEntity theEntity ;
  [ioComponentSemanticsEntitiesMap searchKey !className ?theEntity] ;
  @AC_galgasType type := [(cast theEntity  if >= @typeEntiteType else error className) aDefType] ;
  @typeGalgasClassType classType := (cast type if >= @typeGalgasClassType else error className) ;
#---- Check method definition in super class -------------------
  @string baseClassName ;
  @typeSuperClassesMap ancestorClassesMap := [classType mAncestorClassesMap] ;  
  if categoryMethodKind == [@categoryMethodKind overridingMethod] then #--- Check a super class defines this method
    baseClassName := "" ;
    @bool found := false ;
    foreach ancestorClassesMap while not found do
      @string keyClassMethod := [key string]  . ":" . [templateName string] ;
      baseClassName := [key string] ;
      found := [[ioSemanticContext mCategoryTemplateMap] hasKey !keyClassMethod] ;
      if found then
        @categoryMethodKind localCategoryMethodKind ;
        @L_EXsignature listeDeTypesPrecedenteDeclaration ;
        [[ioSemanticContext mCategoryTemplateMap] searchKey
           ![@lstring new !keyClassMethod !here]
           ?localCategoryMethodKind
           ?listeDeTypesPrecedenteDeclaration
        ] ;
        verifierCompatibiliteSignatures
          !listeDeTypesPrecedenteDeclaration
          !listeDeTypes
          ![templateName location]
        ;
        found := localCategoryMethodKind != [@categoryMethodKind overridingMethod] ;
      end if ;
    end foreach ;
    if not found then
      error templateName: "this overriden template is not defined in any super class of @" . className
      . ": you should remove the 'override' key word" ;
    end if ;
  else #--- Check no super class defines this method
    foreach ancestorClassesMap do
      @string keyClassMethod := [key string]  . ":" . [templateName string] ;
      if [[ioSemanticContext mCategoryTemplateMap] hasKey !keyClassMethod] then
        error templateName: "this template is already defined for super class @" . key
        . ": you should use the 'override' key word" ;
     end if ;
    end foreach ;
    baseClassName := [className string] ;
  end if ;
#---- Add attributes as used local constants -------------------
  foreach [classType mAttributeList] do
    @typeCplusPlusName cppName := [@typeOperandName new
      ![templateName location] # Magic Number
      ![mAttributeName string]
      !false # not mapStyle
      !false # not iterator new style
    ] ;
    [!?categoryTemplateVariableMap insertKey !mAttributeName !mAttributType !cppName] ;
  end foreach ;
#--- Insert the predefined "self" variable
  [!?categoryTemplateVariableMap insertKey ![@lstring new !"self" !here] !classType ![@typeCppThisInCategoryName new ![templateName location]]] ;
#--- Instructions
  $:$ ;
  @string templateString := "" ;
  repeat
    $literal_string$ ?@lstring s ;
    templateString .= [s string] ;
  while
  end repeat ;
  @templateInstructionList templateInstructionList ;
  @bool usesColumnMarker ;
  grammar galgasTemplateGrammar on templateString
    !categoryTemplateVariableMap
    !ioSemanticContext
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    ?templateInstructionList
    ?usesColumnMarker
  ;
  $end$ ;
  $template$ ;
  $;$ ;
  listeEntitesAengendrer += ![@categoryTemplateToImplement new
    !categoryMethodKind
    !baseClassName
    !className
    !templateName
    !listeTypeEtNomsArguments
    !templateInstructionList
    ![templateName location] # Magic Number
    !usesColumnMarker
  ] ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  @categoryMethodKind categoryMethodKind ;
  select
    categoryMethodKind := [@categoryMethodKind baseMethod] ;
  or
    $override$ ;
    categoryMethodKind := [@categoryMethodKind overridingMethod] ;
  end select ;
  $template$ ;
  $type_name$ ? @lstring className ;
  $identifier$ ? @lstring templateName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap methodLocalVariablesMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signatureForGrammarComponent ;
  <formal_input_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#---- Insert in category template map ----------------------------
  @lstring key [new ![className string] . ":" . [templateName string] ![templateName location]] ;
  if not [[ioSemanticContext mCategoryTemplateMap] hasKey ![key string]] then
    [!?ioSemanticContext->mCategoryTemplateMap insertKey !key !categoryMethodKind !listeDeTypes] ;
  end if ;
#--- Instructions
  $:$ ;
  repeat
    $literal_string$ ?* ;
  while
  end repeat ;
  $end$ ;
  $template$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     L I S T   T Y P E   D E C L A R A T I O N                             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $list$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    @L_EXsignature inputSignature [emptyList] ;
    foreach listeTousAttributsSemantiques do
      extractSignature += !mAttributType ![@formalArgumentPassingModeAST argumentOut] ;
      inputSignature += !mAttributType ![@formalArgumentPassingModeAST argumentIn] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
      !inputSignature
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @typeEntityToGenerate def := [@C_listTypeToImplement new
      !listTypeName
      !listeTousAttributsSemantiques
    ] ;
    listeEntitesAengendrer += !def ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $list$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey !listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListModel attributeListModel [emptyList] ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    @L_EXsignature inputSignature [emptyList] ;
    foreach listeTousAttributsSemantiques do
      extractSignature += !mAttributType ![@formalArgumentPassingModeAST argumentOut] ;
      inputSignature += !mAttributType ![@formalArgumentPassingModeAST argumentIn] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
      !inputSignature
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @TypeModel t := [@ListModel new !attributeListModel] ;
    [!?ioModelMap insertKey !listTypeName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     S O R T E D    L I S T   T Y P E   D E C L A R A T I O N              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $sortedlist$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedSortedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    foreach listeTousAttributsSemantiques do
      extractSignature += !mAttributType ![@formalArgumentPassingModeAST argumentOut] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasSortedListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
    ] ;
  #--- Parse sort attributes
    ${$ ;
    @EXsortDescriptorList sortDescriptorList [emptyList] ;
    @stringset usedSortedAttributes [emptySet] ;
    repeat
      @lstring sortAttribute ;
      $identifier$ ? sortAttribute ;
      if [usedSortedAttributes hasKey ![sortAttribute string]] then 
        error sortAttribute: "this attribute is already used in sort list" ;
      else
        @AC_galgasType definitionType ;
        [tableAttributs searchKey !sortAttribute ?definitionType ?* ?*] ;
        [definitionType acceptToBeSortKeyInSortedListDefinition !sortAttribute] ;
        usedSortedAttributes += ![sortAttribute string] ;
      end if ;
      @bool ascendingOrder ;
      select
        $<$ ;
        ascendingOrder := true ;
      or
        $>$ ;
        ascendingOrder := false ;
      end select ;
      sortDescriptorList += !sortAttribute !ascendingOrder ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @typeEntityToGenerate def := [@C_sortedListTypeToImplement new
      !listTypeName
      !listeTousAttributsSemantiques
      !sortDescriptorList
    ] ;
    listeEntitesAengendrer += !def ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $sortedlist$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedSortedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListModel attributeListModel [emptyList] ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    foreach listeTousAttributsSemantiques do
      extractSignature += !mAttributType ![@formalArgumentPassingModeAST argumentOut] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasSortedListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
    ] ;
  #--- Parse sort attributes
    ${$ ;
    repeat
      $identifier$ ? * ;
      select
        $<$ ;
      or
        $>$ ;
      end select ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @TypeModel t := [@ListModel new !attributeListModel] ;
    [!?ioModelMap insertKey !listTypeName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                 LISTE DE DEFINITION DES ATTRIBUTS SEMANTIQUES             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <attributes_definition_list>
  ??@typeTableEnAvant inTableEnAvant
  ?!@typeListModel outAttributeListModel
  ?!@typeSemanticAttributesMap tableAttributs
  ?!@typeListeAttributsSemantiques listeTousAttributsSemantiques # herites et definis dans la classe courante
  !@typeListeAttributsSemantiques listeAttributsSemantiquesCourants # definis dans la classe courante
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  listeAttributsSemantiquesCourants := [@typeListeAttributsSemantiques emptyList] ;
  outAttributeListModel := [@typeListModel emptyList] ;
  repeat
  while
  #--- Type name
    @AC_galgasType definitionType ;
    @lstring typeName ;
    <type_parsing>
      !inTableEnAvant
      !ioComponentSemanticsEntitiesMap
      ?definitionType
      ?typeName
     ;
  #--- Formal argument
    @lstring attributeName ;
    $identifier$ ? attributeName ;
  #--- Options
    @bool hasSetter := false ;
    @bool hasGetter := true ;
    select
    or
      $feature$ ;
      repeat
        $identifier$ ? @lstring directiveName ;
        if [directiveName string] == "nogetter" then
          if not hasGetter then
            error directiveName:"the 'nogetter' feature is already set" ;
          end if ;
          hasGetter := false ;
        elsif [directiveName string] == "setter" then
          if hasSetter then
            error directiveName:"the 'setter' feature is already set" ;
          end if ;
          hasSetter := true ;
        else
          error directiveName:"only 'setter' or 'nogetter' feature names are allowed here" ;
        end if ;
      while
        $,$ ;
      end repeat ;
    end select ;
    [!?tableAttributs insertKey !attributeName !definitionType !hasSetter !hasGetter] ;
    listeTousAttributsSemantiques += !definitionType !attributeName ;
    listeAttributsSemantiquesCourants += !definitionType !attributeName ;
    outAttributeListModel += !typeName ;
    $;$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     L I S T M A P   T Y P E   D E C L A R A T I O N                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $listmap$ ;
  $type_name$ ?@lstring listmapTypeName ;
  $($ ;
  $type_name$ ? @lstring listTypeName ;
  $)$ ;
  $;$ ;
#--- Search for list type
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !listTypeName ?entite] ;
  @AC_galgasType type := [(cast entite if >= @typeEntiteType else error listTypeName) aDefType] ;
  @typeGalgasListType listType := (cast type if >= @typeGalgasListType else error listTypeName) ;
#--- Construction de l'attribut semantique
  @AC_galgasType c := [@typeGalgasListmapType new
    !listmapTypeName
    !listTypeName
    !listType
    ![listType mAttributeList]
  ] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !listmapTypeName ![@typeEntiteType new !c]] ;
  @typeEntityToGenerate def := [@typeGalgasListmapToImplement new
    !listmapTypeName
    !listTypeName
    ![listType mAttributeList]
  ] ;
  listeEntitesAengendrer += !def ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $listmap$ ;
  $type_name$ ?@lstring listmapTypeName ;
  $($ ;
  $type_name$ ? @lstring listTypeName ;
  $)$ ;
  $;$ ;
#--- Search for list type
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !listTypeName ?entite] ;
  @AC_galgasType type := [(cast entite if >= @typeEntiteType else error listTypeName) aDefType] ;
  @typeGalgasListType listType := (cast type if >= @typeGalgasListType else error listTypeName) ;
#--- Construction de l'attribut semantique
  @AC_galgasType c := [@typeGalgasListmapType new
    !listmapTypeName
    !listTypeName
    !listType
    ![listType mAttributeList]
  ] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !listmapTypeName ![@typeEntiteType new !c]] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     S T R U C T   T Y P E   D E C L A R A T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $struct$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  ${$ ;
#-- Declaration des attributs de la list
  @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
  @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
  @typeSemanticAttributesMap tableAttributs [emptyMap] ;
  @typeListModel attributeListModel [emptyList] ;
  <attributes_definition_list>
    !tableEnAvant
    !?attributeListModel
    !?tableAttributs
    !?listeTousAttributsSemantiques
    ?listeAttributsSemantiquesCourants
    !?ioComponentSemanticsEntitiesMap
  ;
#--- Construction de l'attribut semantique
  $}$ ;
  @AC_galgasType c := [@typeGalgasStructType new
    !listTypeName
    !listeTousAttributsSemantiques
  ] ;
  @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
  @typeEntityToGenerate def := [@C_structToImplement new
    !listTypeName
    !listeTousAttributsSemantiques
  ] ;
  listeEntitesAengendrer += !def ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $struct$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  ${$ ;
#-- Declaration des attributs de la list
  @typeListModel attributeListModel [emptyList] ;
  @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
  @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
  @typeSemanticAttributesMap tableAttributs [emptyMap] ;
  <attributes_definition_list>
    !tableEnAvant
    !?attributeListModel
    !?tableAttributs
    !?listeTousAttributsSemantiques
    ?listeAttributsSemantiquesCourants
    !?ioComponentSemanticsEntitiesMap
  ;
#--- Construction de l'attribut semantique
  $}$ ;
  @AC_galgasType c := [@typeGalgasStructType new
    !listTypeName
    !listeTousAttributsSemantiques
  ] ;
  @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
  @TypeModel t := [@ListModel new !attributeListModel] ;
  [!?ioModelMap insertKey !listTypeName !t] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     W R A P P E R    D E C L A R A T I O N                                *
#                                                                           *
#---------------------------------------------------------------------------*

routine recursivelyEnumerateDirectories
  ??@string inAbsoluteSourcePath
  ??@string inPathInWrapper
  ??@wrapperExtensionMap inExtensionMap
  !@wrapperFileSortedList outWrapperFileSortedList
  !@wrapperDirectorySortedList outWrapperDirectorySortedList
  ?!@uint ioWrapperFileIndex
  ?!@uint ioWrapperDirectoryIndex
  ?!@M_regularFiles ioRegularFileMap
:
  @uint currentDirectoryIndex := ioWrapperDirectoryIndex ;
  ioWrapperDirectoryIndex ++ ;
#--- Enumerates regular files
  @stringlist files := [inAbsoluteSourcePath regularFiles !false] ;
  outWrapperFileSortedList := [@wrapperFileSortedList emptySortedList] ;
  foreach files do
    if [inExtensionMap hasKey ![mValue pathExtension]] then
      @string absoluteFilePath := inAbsoluteSourcePath . "/" . mValue ;
      #log absoluteFilePath ;
      outWrapperFileSortedList +=
        !mValue
        !absoluteFilePath
        !currentDirectoryIndex
        !ioWrapperFileIndex
      ;
      [!?ioRegularFileMap insertKey
        ![@lstring new !inPathInWrapper . mValue !here]
        !currentDirectoryIndex
        !ioWrapperFileIndex
      ] ;
      ioWrapperFileIndex ++ ;
    end if ;
  end foreach ;
#--- Enumerates regular directories
  @stringlist directories := [inAbsoluteSourcePath directories !false] ;
  outWrapperDirectorySortedList := [@wrapperDirectorySortedList emptySortedList] ;
  foreach directories do
    @wrapperFileSortedList internalWrapperFileSortedList ;
    @wrapperDirectorySortedList internalWrapperDirectorySortedList ;
    @uint theDirectoryIndex := ioWrapperDirectoryIndex ;
    recursivelyEnumerateDirectories
      !inAbsoluteSourcePath . "/" . mValue
      !inPathInWrapper . mValue . "/"
      !inExtensionMap
      ?internalWrapperFileSortedList
      ?internalWrapperDirectorySortedList
      !?ioWrapperFileIndex
      !?ioWrapperDirectoryIndex
      !?ioRegularFileMap
    ;
    outWrapperDirectorySortedList +=
      !mValue
      !internalWrapperFileSortedList
      !internalWrapperDirectorySortedList
      !theDirectoryIndex
    ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  $filewrapper$ ;
  @lstring wrapperName ;
  $identifier$ ? wrapperName ;
  $in$ ;
  @lstring sourcePath ;
  $literal_string$ ? sourcePath ;
  ${$ ;
  @wrapperExtensionMap extensionMap [emptyMap] ;
  select
  or
    repeat
      @lstring extension ;
      $literal_string$ ? extension ;
      [!?extensionMap insertKey !extension] ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $}$ ;
#--- Build absolute path
  @M_regularFiles regularFileMap [emptyMap] ;
  @string absoluteSourcePath ;
  if [sourcePath firstCharacterOrNul] == '/' then
    absoluteSourcePath := [sourcePath string] ;
  else
    absoluteSourcePath := [[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] . "/" . [sourcePath string] ;
  end if ;
  if not [absoluteSourcePath directoryExists] then
    error sourcePath: "The '" . absoluteSourcePath . "' directory does not exist" ;
  else
  #--- Enumerate pathes
    @wrapperFileSortedList wrapperFileSortedList ;
    @wrapperDirectorySortedList wrapperDirectorySortedList ;
    @uint wrapperFileIndex := 0 ;
    @uint wrapperDirectoryIndex := 0 ;
    recursivelyEnumerateDirectories
     !absoluteSourcePath
     !"/"
     !extensionMap
     ?wrapperFileSortedList
     ?wrapperDirectorySortedList
     !?wrapperFileIndex
     !?wrapperDirectoryIndex
     !?regularFileMap
   ;
  #---- Enter wrapper in generated list
    @typeEntityToGenerate w := [@C_wrapperToImplement new
      !wrapperName
      ![sourcePath string]
      !extensionMap
      !wrapperFileSortedList
      !wrapperDirectorySortedList
    ] ;
    listeEntitesAengendrer += !w ;
  end if ;
#--- Parse templates
  @filewrapperTemplateMapEX templateMap [emptyMap] ;
  ${$ ;
  repeat
  while
    $template$ ;
  #--- Template name
    @lstring templateName ;
    $identifier$ ? templateName ;
  #--- Template path
    @lstring templatePath ;
    $literal_string$ ? templatePath ;
    @lstring templateAbsolutePath [new
      !absoluteSourcePath . "/" . [templatePath string]
      ![templatePath location]
    ] ;
  #--- Template formal arguments
    @typeListeTypesEtNomsArgMethode templateArgumentTypesList [emptyList] ;
    @typeListeAttributsSemantiques formalAttributeList [emptyList] ;
    @templateVariableMap templateVariableMap [emptyMap] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !ioComponentSemanticsEntitiesMap
        ?type_semantique
        !tableEnAvant
        ?galgasTypeName
      ;
      formalAttributeList += !type_semantique ![@lstring new !"" !here] ;
      @bool parameterIsUsed ;
      select
        parameterIsUsed := true ;
      or
        $unused$ ;
        parameterIsUsed := false ;
      end select ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      @typeCplusPlusName cppName := [@typeAutomaticName new ![parameterName location] ![parameterName string]] ;
      templateArgumentTypesList += !type_semantique ![@formalArgumentPassingModeAST argumentConstantIn] !cppName !true !parameterName ;
      if parameterIsUsed then
        [!?templateVariableMap insertKey !parameterName !type_semantique !cppName] ;
      else
        [!?templateVariableMap insertKey !parameterName !type_semantique !cppName] ;
      end if ;
    end repeat ;
    [!?templateMap insertKey !templateName !formalAttributeList] ;
    @templateInstructionList templateInstructionList ;
    @bool usesColumnMarker ;
    grammar galgasTemplateGrammar in templateAbsolutePath
      !templateVariableMap
      !ioSemanticContext
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      ?templateInstructionList
      ?usesColumnMarker
    ;
    listeEntitesAengendrer += ![@C_filewrapperTemplateToImplement new
      !wrapperName
      !templateName
      !templateArgumentTypesList
      !templateInstructionList
      !usesColumnMarker
    ] ;
    $;$ ;
  end repeat ;
#--- Enter in wrapper map
  [!?ioSemanticContext->mFilewrappers insertKey !wrapperName !regularFileMap !templateMap] ;
  $}$ ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext ioSemanticContext
:
  $filewrapper$ ;
  @lstring wrapperName ;
  $identifier$ ? wrapperName ;
  $in$ ;
  @lstring sourcePath ;
  $literal_string$ ? sourcePath ;
  ${$ ;
  @wrapperExtensionMap extensionMap [emptyMap] ;
  select
  or
    repeat
      @lstring extension ;
      $literal_string$ ? extension ;
      [!?extensionMap insertKey !extension] ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $}$ ;
  @M_regularFiles regularFileMap [emptyMap] ;
  if not [[ioSemanticContext mFilewrappers] hasKey ![wrapperName string]] then
  #--- Build absolute path
    @string absoluteSourcePath ;
    if [sourcePath firstCharacterOrNul] == '/' then
      absoluteSourcePath := [sourcePath string] ;
    else
      absoluteSourcePath := [[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] . "/" . [sourcePath string] ;
    end if ;
    if not [absoluteSourcePath directoryExists] then
      error sourcePath: "The '" . absoluteSourcePath . "' directory does not exist" ;
    else
    #--- Enumerate pathes
      @wrapperFileSortedList wrapperFileSortedList ;
      @wrapperDirectorySortedList wrapperDirectorySortedList ;
      @uint wrapperFileIndex := 0 ;
      @uint wrapperDirectoryIndex := 0 ;
      recursivelyEnumerateDirectories
        !absoluteSourcePath
        !"/"
        !extensionMap
        ?wrapperFileSortedList
        ?wrapperDirectorySortedList
        !?wrapperFileIndex
        !?wrapperDirectoryIndex
        !?regularFileMap
      ;
    end if ;
  end if ;
#--- Parse templates
  @filewrapperTemplateMapEX templateMap [emptyMap] ;
  ${$ ;
  repeat
  while
    $template$ ;
    @lstring templateName ;
    $identifier$ ?templateName ;
    @lstring templatePath ;
    $literal_string$ ?templatePath ;
    @typeListeAttributsSemantiques formalAttributeList [emptyList] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !ioComponentSemanticsEntitiesMap
        ?type_semantique
        !tableEnAvant
        ?galgasTypeName
      ;
      formalAttributeList += !type_semantique ![@lstring new !"" !here] ;
      select
      or
        $unused$ ;
      end select ;
      $identifier$ ? * ;
    end repeat ;
    [!?templateMap insertKey !templateName !formalAttributeList] ;
    $;$ ;
  end repeat ;
#--- Enter in wrapper map
  if not [[ioSemanticContext mFilewrappers] hasKey ![wrapperName string]] then
    [!?ioSemanticContext->mFilewrappers insertKey !wrapperName !regularFileMap !templateMap] ;
  end if ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     E X T E R N   T Y P E   D E C L A R A T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $extern$ ;
  <semantics_declaration_begining_by_extern>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
  ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $extern$ ;
  <semantics_declaration_begining_by_extern> importSemantics
    !?ioModelMap
    !?ioExternActionMap
    !?ioComponentSemanticsEntitiesMap
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
  ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     E X T E R N   T Y P E   D E C L A R A T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_begining_by_extern>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
#--- Parse extern type name
  @lstring externTypeName ;
  $type_name$ ? externTypeName ;
  ${$ ;
#--- Default behaviour : no operator, no method available
  @typeTableMethodes modifiersMap [emptyMap] ;
  @typeTableMethodes readersInInstructionMap [emptyMap] ;
  @bool acceptAddAssignOperatorCall := false ;
  @typeListeAttributsSemantiques addAssignOperatorCallTypeList [emptyList] ;
  @M_externTypeConstructorMap constructorsMap [emptyMap] ;
#--- Parse class operators and methods
  repeat
  while
    $constructor$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques constructorArgumentTypesList [emptyList] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !ioComponentSemanticsEntitiesMap
        ?type_semantique
        !tableEnAvant
        ?galgasTypeName
      ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      constructorArgumentTypesList += !type_semantique !parameterName ;
    end repeat ;
    $;$ ;
    [!?constructorsMap insertKey !constructorName !constructorArgumentTypesList] ;
  while
    $method$ ;
  #--- Method name
    @lstring methodName ;
    $identifier$ ? methodName ;
  #--- Formal parameters
    @L_EXsignature listeDeTypes ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @signatureForGrammarAnalysis signatureForGrammarComponent ; # Not used here
    <formal_arguments_list>
      !ioComponentSemanticsEntitiesMap
      ?listeDeTypes
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammarComponent
    ;
    $;$ ;
    [!?readersInInstructionMap insertKey !methodName !listeDeTypes] ;
  while
    $modifier$ ;
    select
    #--- Method name
      @lstring methodName ;
      $identifier$ ? methodName ;
    #--- Formal parameters
      @L_EXsignature listeDeTypes ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @typeVariablesMap tableArgumentsMethode [emptyMap] ;
      @signatureForGrammarAnalysis signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?listeDeTypes
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      [!?modifiersMap insertKey !methodName !listeDeTypes] ;
    or
      $+=$ ;
      @location errorLocation := here ;
      repeat
      while
        $?$ ;
        @AC_galgasType type_semantique ;
        @lstring galgasTypeName ; # Not used here
        <formal_argument_type>
          !ioComponentSemanticsEntitiesMap
          ?type_semantique
          !tableEnAvant
          ?galgasTypeName
        ;
        @lstring parameterName ;
        $identifier$ ? parameterName ;
        addAssignOperatorCallTypeList += !type_semantique !parameterName ;
      end repeat ;
      if acceptAddAssignOperatorCall then
        error errorLocation : "'+=' operator is already defined" ;
      else
        acceptAddAssignOperatorCall := true ;
      end if ;
    end select ;
    $;$ ;
  end repeat ;
#--- enter the new type into the list of entities to be generated
  @typeEntityToGenerate t := [@typeExternTypeToGenerate new
    !externTypeName
    !constructorsMap
    !modifiersMap
    !readersInInstructionMap
    !acceptAddAssignOperatorCall
    !addAssignOperatorCallTypeList
  ] ;
  listeEntitesAengendrer += !t ;
#--- Enter the new type in entities map
  @AC_galgasType c := [@typeGalgasExternType new
    !externTypeName
    !constructorsMap
    !modifiersMap
    !readersInInstructionMap
    !acceptAddAssignOperatorCall
    !addAssignOperatorCallTypeList
  ] ;
  @AC_semanticsEntity e := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !externTypeName !e] ;
  $}$ ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
#--- Parse extern type name
  @lstring externTypeName ;
  $type_name$ ? externTypeName ;
  ${$ ;
#--- Default behaviour : no operator, no method available
  @typeTableMethodes EXmodifiersMap [emptyMap] ;
  @typeTableMethodes readersInInstructionMap [emptyMap] ;
  @bool acceptAddAssignOperatorCall := false ;
  @typeListeAttributsSemantiques addAssignOperatorCallTypeList [emptyList] ;
  @M_externTypeConstructorMap EXconstructorsMap [emptyMap] ;
  @externTypeConstructorMap constructorMap [emptyMap] ;
  @externTypeReaderMap readerMap [emptyMap] ;
  @externTypeModifierMap modifierMap [emptyMap] ;
  @typeListModel addAssignFormalInputArgumentList [emptyList] ; # List is empty if += operator is not defined
#--- Parse class operators and methods
  repeat
  while
    $constructor$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques constructorArgumentTypesList [emptyList] ;
    @typeListModel formalInputArgumentList [emptyList] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !ioComponentSemanticsEntitiesMap
        ?type_semantique
        !tableEnAvant
        ?galgasTypeName
      ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      constructorArgumentTypesList += !type_semantique !parameterName ;
      formalInputArgumentList += !galgasTypeName ;
    end repeat ;
    $;$ ;
    [!?EXconstructorsMap insertKey !constructorName !constructorArgumentTypesList] ;
    [!?constructorMap insertKey !constructorName ! formalInputArgumentList] ;
  while
    $method$ ;
  #--- Reader name
    @lstring readerName ;
    $identifier$ ? readerName ;
  #--- Formal parameters
    @L_EXsignature listeDeTypes ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @signatureForGrammarAnalysis signature ;
    <formal_arguments_list>
      !ioComponentSemanticsEntitiesMap
      ?listeDeTypes
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signature
    ;
    $;$ ;
    [!?readersInInstructionMap insertKey !readerName !listeDeTypes] ;
    [!?readerMap insertKey !readerName !signature] ;
  while
    $modifier$ ;
    select
    #--- Method name
      @lstring modifierName ;
      $identifier$ ? modifierName ;
    #--- Formal parameters
      @L_EXsignature listeDeTypes ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @typeVariablesMap tableArgumentsMethode [emptyMap] ;
      @signatureForGrammarAnalysis signature ;
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?listeDeTypes
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signature
      ;
      [!?EXmodifiersMap insertKey ! modifierName !listeDeTypes] ;
      [!?modifierMap insertKey !modifierName !signature] ;
    or
      $+=$ ;
      if [addAssignFormalInputArgumentList length] > 0 then
        error here : "'+=' operator is already defined" ;
      else
        acceptAddAssignOperatorCall := true ;
      end if ;
      repeat
      while
        $?$ ;
        @AC_galgasType type_semantique ;
        @lstring galgasTypeName ;
        <formal_argument_type>
          !ioComponentSemanticsEntitiesMap
          ?type_semantique
          !tableEnAvant
          ?galgasTypeName
        ;
        @lstring parameterName ;
        $identifier$ ? parameterName ;
        addAssignOperatorCallTypeList += !type_semantique !parameterName ;
        addAssignFormalInputArgumentList += !galgasTypeName ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
#--- Enter the new type in entities map
  @AC_galgasType c := [@typeGalgasExternType new
    !externTypeName
    !EXconstructorsMap
    !EXmodifiersMap
    !readersInInstructionMap
    !acceptAddAssignOperatorCall
     !addAssignOperatorCallTypeList
  ] ;
  @AC_semanticsEntity e := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !externTypeName !e] ;
  @TypeModel t := [@ExternTypeModel new !constructorMap !readerMap !modifierMap !addAssignFormalInputArgumentList] ;
  [!? ioModelMap insertKey !externTypeName !t] ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*
#                            Type d'un argument                             *
#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ??@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $type_name$ ? outGalgasTypeName ;
  if [inComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [inComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    type_semantique := [(cast entite if >= @typeEntiteType else error outGalgasTypeName) aDefType] ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ??@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $list$ ;
  $type_name$ ? outGalgasTypeName ;
  if [inComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [inComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    type_semantique := [(cast entite if >= @typeEntiteType else error outGalgasTypeName) aDefType] ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    @typeGalgasUndefinedListType x := (cast type_semantique if >= @typeGalgasUndefinedListType else error outGalgasTypeName) ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $list$ ;
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ??@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $map$ ;
  $type_name$ ? outGalgasTypeName ;
  if [inComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [inComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    type_semantique := [(cast entite if >= @typeEntiteType else error outGalgasTypeName) aDefType] ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    @typeGalgasUndefinedMapType x := (cast type_semantique if >= @typeGalgasUndefinedMapType else error outGalgasTypeName) ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $map$ ;
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ??@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $abstract$ ;
  $class$ ;
  $identifier$ ? outGalgasTypeName ;
  if [inComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [inComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    type_semantique := [(cast entite if >= @typeEntiteType else error outGalgasTypeName) aDefType] ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    @typeGalgasUndefinedClassType x := (cast type_semantique if >= @typeGalgasUndefinedClassType else error outGalgasTypeName) ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $abstract$ ;
  $class$ ;
  $identifier$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                   DECLARATION D'UNE ROUTINE EXTERNE                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_begining_by_extern>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $routine$ ;
  @lstring nomAction ;
  $identifier$ ?nomAction ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?*
  ;

  @AC_semanticsEntity entite := [@typeEntiteRoutineExterne new !listeDeTypes] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !nomAction !entite] ;
  @typeEntityToGenerate ea := [@typeRoutineExterneAengendrer new !nomAction !listeDeTypes] ;
  listeEntitesAengendrer += !ea ;
  $;$ ;    
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $routine$ ;
  @lstring actionName ;
  $identifier$ ? actionName ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signature ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signature
  ;

  @AC_semanticsEntity entite := [@typeEntiteRoutineExterne new !listeDeTypes] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ! actionName !entite] ;
  [!?ioExternActionMap insertKey !actionName !signature !true] ;
  $;$ ;    
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                   DECLARATION D'UNE FONCTION EXTERNE                      *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_begining_by_extern>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $function$ ;
  @lstring nomAction ;
  $identifier$ ?nomAction ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?*
  ;
#---- Function return value -----------------------------------------
  @L_EXsignature returnedTypes [emptyList] ;
  $->$ ;
#--- Check all arguments are input or const input
  foreach listeTypeEtNomsArguments do
    if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
      error mParameterName:"for a function only input parameters (?) and constant input parameters (??) can be used." ;
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
      error mParameterName:"for a function only input parameters (?) and constant input parameters (??) can be used." ;
    end if ;
  end foreach ;
#--- Parse result
  @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentOut] ;
  @AC_galgasType returnedType ;
  @lstring galgasTypeName ;
  <formal_argument_type>
    !ioComponentSemanticsEntitiesMap
    ?returnedType
    !tableEnAvant
    ?galgasTypeName
  ;
  @lstring nomArgument ;
  $identifier$ ? nomArgument ;
  @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
  [!?tableArgumentsMethode insertOutArgument !nomArgument !returnedType !natureNom] ;

  @AC_semanticsEntity entite := [@typeEntiteFonctionExterne new !listeDeTypes !returnedType] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !nomAction !entite] ;
  @typeEntityToGenerate ea := [@typeFonctionExterneAengendrer new !nomAction !listeDeTypes !returnedType] ;
  listeEntitesAengendrer += !ea ;
  $;$ ;    
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
:
  $function$ ;
  @lstring actionName ;
  $identifier$ ? actionName ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @signatureForGrammarAnalysis signature ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signature
  ;
#---- Function return value -----------------------------------------
  @L_EXsignature returnedTypes [emptyList] ;
  $->$ ;
#--- Check all arguments are input or const input
  foreach listeTypeEtNomsArguments do
    if mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentOut] then
      error mParameterName:"for a function only input parameters (?) and constant input parameters (??) can be used." ;
    elsif mFormalArgumentPassingMode == [@formalArgumentPassingModeAST argumentInOut] then
      error mParameterName:"for a function only input parameters (?) and constant input parameters (??) can be used." ;
    end if ;
  end foreach ;
#--- Parse result
  @formalArgumentPassingModeAST passingMode := [@formalArgumentPassingModeAST argumentOut] ;
  @AC_galgasType returnedType ;
  @lstring galgasTypeName ;
  <formal_argument_type>
    !ioComponentSemanticsEntitiesMap
    ?returnedType
    !tableEnAvant
    ?galgasTypeName
  ;
  @lstring nomArgument ;
  $identifier$ ? nomArgument ;
  @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
  [!?tableArgumentsMethode insertOutArgument !nomArgument !returnedType !natureNom] ;

  @AC_semanticsEntity entite := [@typeEntiteFonctionExterne new !listeDeTypes !returnedType] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !actionName !entite] ;
  [!?ioExternActionMap insertKey !actionName !signature !true] ;
  $;$ ;    
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E N U M     T Y P E                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $enum$ ;
#--- Enum type name
  @lstring enumTypeName ;
  $type_name$ ? enumTypeName ;
  ${$ ;
#--- Enum constants
  @enumConstantMap constantMap [emptyMap] ;
  select
    repeat
      @lstring constantName ;
      $identifier$ ? constantName ;
      [!?constantMap insertKey !constantName ![constantMap count]] ;
    while
      $,$ ;
    end repeat ;
  or
    repeat
    while
      $constructor$ ;
      repeat
        $identifier$ ?@lstring constantName ;
        [!?constantMap insertKey !constantName ![constantMap count]] ;
      while
        $,$ ;
      end repeat ;
      $;$ ;
    end repeat ;
    @string s := "" ;
    foreach constantMap
    do s .= [key string] ;
    between s .= ", " ;
    end foreach ;
    warning here : "Old style declaration: now write '... {" . s . "} ..." ;
  end select ;
  $}$ ;
  ${$ ;
#--- Enum messages, action messages
  @typeEnumMessageMap enumMessageMap [emptyMap] ;
  repeat
  while
    $reader$ ;
    @lstring messageName ;
    $identifier$ ? messageName ;
    $:$ ;
    @typeEnumCstMessageStringMap cstMessageStringMap [emptyMap] ;
    repeat
      @lstring cstName ;
      $identifier$ ? cstName ;
      $->$ ;
      @lstring cstString ;
      $literal_string$ ? cstString ;
      [!?cstMessageStringMap insertKey !cstName !cstString] ;
      $;$ ;
    while
    end repeat ;
    $end$ ;
    $reader$ ;
    $;$ ;
  #--- Build message string list
    @lstringlist messageStringList [emptyList] ;
    foreach constantMap do
      @lstring name := [@lstring new ![key string] !here] ;
      @lstring cstString ;
      [cstMessageStringMap searchKey !name ?cstString] ;
      messageStringList += !cstString ;
    end foreach ;
  #--- Enter message definition into message map
    [!?enumMessageMap insertKey !messageName !messageStringList] ;
  end repeat ;
#--- End type definition end
  $}$ ;
#---- Enter enum datas into the list of entities to generate
  @typeEntityToGenerate e := [@enumGalgasType new
    !enumTypeName
    !constantMap
    !enumMessageMap
  ] ;
  listeEntitesAengendrer += !e ;
#--- Enter enum type into semantic entities map
  @AC_galgasType t := [@typeGalgas_enum new
    !enumTypeName
    !constantMap
    !enumMessageMap
  ] ;
  @AC_semanticsEntity ee := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !enumTypeName !ee] ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ?!@EXsemanticContext unused ioSemanticContext
:
  $enum$ ;
#--- Enum type name
  @lstring enumTypeName ;
  $type_name$ ? enumTypeName ;
  ${$ ;
#--- Enum constants
  @enumConstantMap constantMap [emptyMap] ;
  select
    repeat
      @lstring constantName ;
      $identifier$ ? constantName ;
      [!?constantMap insertKey !constantName ![constantMap count]] ;
    while
      $,$ ;
    end repeat ;
  or
    repeat
    while
      $constructor$ ;
      repeat
        $identifier$ ?@lstring constantName ;
        [!?constantMap insertKey !constantName ![constantMap count]] ;
      while
      $,$ ;
      end repeat ;
      $;$ ;
    end repeat ;
  end select ;
  $}$ ;
  ${$ ;
#--- readers, modifiers map
  @typeEnumMessageMap exEnumMessageMap [emptyMap] ;
  @EXenumMessageMap enumMessageMap [emptyMap] ;
  repeat
  while
    $reader$ ;
    @lstring messageName ;
    $identifier$ ? messageName ;
  #--- Enter message definition into message map
    [!?enumMessageMap insertKey !messageName] ;
    @lstringlist messageStringList [emptyList] ;
    [!? exEnumMessageMap insertKey !messageName !messageStringList] ;
    $:$ ;
    repeat
      $identifier$ ? * ;
      $->$ ;
      $literal_string$ ? * ;
      $;$ ;
    while
    end repeat ;
    $end$ ;
    $reader$ ;
    $;$ ;
  end repeat ;
  $}$ ;
#--- Enter enum type into semantic entities map
  @AC_galgasType t := [@typeGalgas_enum new
    !enumTypeName
    !constantMap
    !exEnumMessageMap
  ] ;
  @AC_semanticsEntity e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !enumTypeName !e] ;
  @TypeModel type := [@EnumModel new !constantMap !enumMessageMap] ;
  [!?ioModelMap insertKey !enumTypeName !type] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
