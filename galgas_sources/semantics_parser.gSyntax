#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS semantics component parser definition                             *
#                                                                           *
#  Copyright (C) 1997, ..., 2007 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax semantics_parser :

import lexique galgas_scanner in "galgas_scanner.gLexique" ;

import semantics semantics_semantics in "semantics_semantics.gSemantics" ;

#---------------------------------------------------------------------------*
#                                                                           *
#          Nonterminal symbols declaration                                  *
#                                                                           *
#---------------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label parse
;

nonterminal <parse_grammar_component_for_importing>
  ??@lstring inFileName
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_optionComponents ioOptionsComponentsMapForUse
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label parse
;

nonterminal <parse_option_component_for_importing>
  ??@lstring inFileName
  ?!@M_optionComponents ioOptionsComponentsMap
label parse
;

nonterminal <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label parse
;
nonterminal <semantics_declaration_begining_by_extern>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents ioOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
label parse
;

nonterminal <import_headers_semantics_and_grammars>
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outIncludedOptionComponents
  !@stringset outIncludedGrammarComponents
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  !@entityToImplementMap outAllMetamodelClassMap
  ?!@M_filewrappers ioFileWrappers
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIcludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
label parse
;

nonterminal <parent_class>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
  !@string outSuperClassMessage
label importSemantics
  ?!@ModelMap ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
label parse
;

nonterminal <attributes_definition_list>
  ??@typeTableEnAvant inTableEnAvant
  ?!@typeListModel outAttributeListModel
  ?!@typeSemanticAttributesMap tableAttributs
  ?!@typeListeAttributsSemantiques listeTousAttributsSemantiques # herites et definis dans la classe courante
  !@typeListeAttributsSemantiques listeAttributsSemantiquesCourants # definis dans la classe courante
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

nonterminal <type_parsing>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType definitionType
  !@lstring outTypeName
label parse
;

nonterminal <parse_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outMethodName
  !@typeInstructionList outInstructionsList
  !@L_EXsignature outMethodSignature
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ??@string inClassMessage
label parse
;

nonterminal <overrided_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool estAbstraite
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ??@string inClassMessage
label parse
;

nonterminal <non_abstract_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ??@string inClassMessage
label parse
;

nonterminal <abstract_method>
  ??@bool inIsAbstract
  ?!@typeListeAttributsSemantiques listeAttributsSemantiquesCourants
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodes tableDesMethodes
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
label parse
;

nonterminal <semantic_instructions_list>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label parse
;

nonterminal <semantic_instructions_list_no_verif>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label parse
;

nonterminal <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label parse
;

nonterminal <error_instruction>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <warning_instruction>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <extract_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@typeInstruction outInstruction
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
label parse
;

nonterminal <expression>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  !@typeExpression outExpression
  !@AC_galgasType outResultType
label parse
;

nonterminal <input_parameters_list>
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ?@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
label parse
;

nonterminal <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList
label parse
;

nonterminal <parse_parameters_list>
  !@L_actualParametersSignature listeTypesParametresEffectifs
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

nonterminal <read_access>
  !@lstring nomAttribut
  !@typeCplusPlusName nomCppEntite
  !@AC_galgasType typeEntite
  ?!@typeVariablesMap ioVariablesMap
label parse
;

nonterminal <instruction_beginning_with_identifier>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@entityToImplementMap inMetamodelEntityMap
label parse
;

nonterminal <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring nomVarDest
  ??@typeCplusPlusName inVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
label parse
;

nonterminal <ex_map_method>
  !@lstring nomMethode
  !@lstring outMessage
label parse
;

nonterminal <map_method>
  !@lstring methodName
  !@lstring getIndexMethodName
  !@lstring outMessage
label parse
;

nonterminal <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignature
label importGrammarForSemantics
  !@L_signature outSignature
label parse
;

nonterminal <output_expression_list>
  !@typeExpressionList outExpressionList 
  ??@typeListeAttributsSemantiques inAttributesList
  ??@M_semanticsEntitiesForUse ioEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
label parse
;

nonterminal <formal_argument_type>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
label parse
;

nonterminal <parse_match_operand>
  ?!@typeVariablesMap ioVariablesMap
  !@typeCplusPlusName outCppName
  !@lstring outBaseTypeName
  !@location outVarLocation
  !@bool outIsEnumeration
  !@enumConstantMap outEnumMessageMap
label parse
;

nonterminal <parse_match_case>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outTypeName
label parse
;

nonterminal <parse_effective_input_parameters_list>
  ?!@typeVariablesMap ioVariablesMap
  ?@typeListeAttributsSemantiques inFormalArgumentsList
  ?@location inVarLocation
  ?@localConstantBuildStyleEnum inLocalConstantStyle
  !@bool outNoUsedParameter
label parse
;

extern routine buildFileNameWithPath
  !@lstring outFileNameWithPath
  ?@lstring inPath
  ??@lstring inCppClassName
  ??@lstring inExtension
;

#---------------------------------------------------------------------------*
#                                                                           *
#    S E M A N T I C S    C O M P O N E N T                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
:
  $semantics$ ;
#--- Obtenir le nom du component semantique
  @lstring componentName ;
  $identifier$ ? componentName ;
  select
  or
    $extends$ ;
    repeat
      $identifier$ ? * ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $:$ ;
#--- No lexique
  @string defLexique := "" ;
#--- Import semantics
  @ModelMap modelMap [emptyMap] ;
  @ActionMap actionMap [emptyMap] ;
  @stringset inclusionsForHeaderFile ;
  @stringset inclusionsForImplementationFile ;
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  @M_semanticsEntitiesForUse componentEntitiesMap ;
  @stringset classNamesSet [emptySet] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents ;
  @stringset includedGrammarComponents ;
  @entityToImplementMap allMetamodelClassMap ;
  <import_headers_semantics_and_grammars>
    ?includedSemanticsComponents
    ?includedMetamodelComponents
    ?includedOptionComponents
    ?includedGrammarComponents
    !?ioLexiqueMapForUse
    !?ioSemanticsComponentsMap
    !?ioMetamodelComponentMap
    !?ioTreewalkingComponentMap
    !?ioGrammarComponentsMap
    !?ioOptionsComponentsMap
    ?inclusionsForImplementationFile
    ?inclusionsForHeaderFile
    ?optionsComponentsMapForUse
    ?modelMap
    ?actionMap
    ?componentEntitiesMap
    ?tableEnAvant
    ?allMetamodelClassMap
    !?ioFileWrappers
  ;
#-------------- Semantic Declarations
  parse
  #--- First pass on semantic declarations
  do
    @typeTableRoutinesAimplementer UNUSED_tableRoutinesAimplementer [emptyMap] ;
    @typeTableNomRoutinesDeclarees UNUSED_tableNomRoutinesDeclarees [emptyMap] ;
    @typeTableEnAvant UNUSED_tableEnAvant := tableEnAvant ;
    @M_semanticsEntitiesForUse UNUSED_componentSemanticsEntitiesMap := componentEntitiesMap ;
    @M_filewrappers UNUSED_FileWrappers [emptyMap] ;
    repeat
    while
    <semantics_declaration> importSemantics
      !?modelMap
      !?actionMap
      !?UNUSED_componentSemanticsEntitiesMap
      !?UNUSED_tableNomRoutinesDeclarees
      !?UNUSED_tableEnAvant
      !?UNUSED_tableRoutinesAimplementer
      !ioTreewalkingComponentMap
      !?UNUSED_FileWrappers
    ;
    end repeat ;
  #--- Second pass on semantic declarations
  rewind
    @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
    @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    @treewalkingRoutineHeaderMap treewalkingRoutineHeaderMap [emptyMap] ;
    repeat
    while
      <semantics_declaration>
        !?componentEntitiesMap
        !?listeEntitesAengendrer
        !optionsComponentsMapForUse
        !?tableNomRoutinesDeclarees
        !?tableEnAvant
        !?tableRoutinesAimplementer
        !ioTreewalkingComponentMap
        !?ioFileWrappers
      ; 
    end repeat ;
  end parse ;
#--- Enter component entities in map
  if not [ioSemanticsComponentsMap hasKey ![componentName string]] then
    @M_optionComponents optionsComponentsMap [emptyMap] ;
    [!?ioSemanticsComponentsMap insertKey
      !componentName
      !modelMap
      !actionMap
      !includedSemanticsComponents
      !includedMetamodelComponents
      !includedOptionComponents
      !optionsComponentsMap
      !componentEntitiesMap
    ] ;
  end if ;
#--- End of file
  $end$ ;
  $semantics$ ;
  $;$ ;
#--- Check that all routines have been implemented
  foreach tableNomRoutinesDeclarees (@lstring nomRoutine) :
    if not [tableRoutinesAimplementer hasKey ![nomRoutine string]] then
      error nomRoutine : "the routine '" . [nomRoutine string] .
                         "' is not implemented within the component" ;
    end if ;
  end foreach ;
#--- Generate component
  generateSemanticsComponent
    !?componentName
    !?inclusionsForHeaderFile
    !?defLexique
    !?listeEntitesAengendrer
    !?inclusionsForImplementationFile
   ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $semantics$ ;
  $identifier$ ? * ;
  select
  or
    $extends$ ;
    repeat
      $identifier$ ? * ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
:
  $semantics$ ;
  @lstring componentName ;
  $identifier$ ? componentName ;
  select
  or
    $extends$ ;
    repeat
      $identifier$ ? * ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $:$ ;
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap ;
  enterBuiltinTypes ?componentSemanticsEntitiesMap ;
  @stringset includedSemanticsComponents ;
  @stringset includedOptionComponents ;
  @stringset includedMetamodelComponents [emptySet] ;
  @ModelMap modelMap ;
  @ActionMap actionMap ;

  <import_headers_semantics_and_grammars> importSemantics
    !?ioSemanticsComponentsMap
    ?includedSemanticsComponents
    ?includedOptionComponents
    ?modelMap
    ?actionMap
    !?componentSemanticsEntitiesMap
    !?ioMetamodelComponentMap
    !?ioTreewalkingComponentMap
    !?ioFileWrappers
  ;
  @typeTableRoutinesAimplementer tableRoutinesAimplementer [emptyMap] ;
  @typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees [emptyMap] ;
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  repeat
  while
    <semantics_declaration> importSemantics
      !?modelMap
      !?actionMap
      !?componentSemanticsEntitiesMap
      !?tableNomRoutinesDeclarees
      !?tableEnAvant
      !?tableRoutinesAimplementer
      !ioTreewalkingComponentMap
      !?ioFileWrappers
    ;
  end repeat ;
#--- Enter component entities in map
  if not [ioSemanticsComponentsMap hasKey ![componentName string]] then
    @M_optionComponents optionsComponentsMap [emptyMap] ;
    [!?ioSemanticsComponentsMap insertKey
      !componentName
      !modelMap
      !actionMap
      !includedSemanticsComponents
      !includedMetamodelComponents
      !includedOptionComponents
      !optionsComponentsMap
      !componentSemanticsEntitiesMap
    ] ;
  end if ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  $semantics$ ;
  $identifier$ ? * ;
  select
  or
    $extends$ ;
    repeat
      $identifier$ ? * ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_treewalkingComponents unused ioTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $semantics$ ;
  $identifier$ ? * ;
  select
  or
    $extends$ ;
    repeat
      $identifier$ ? * ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  $semantics$ ;
  $identifier$ ? * ;
  select
  or
    $extends$ ;
    repeat
      $identifier$ ? * ;
    while
      $,$ ;
    end repeat ;
  end select ;
  $:$ ;
  <import_headers_semantics_and_grammars> parse ;
  repeat
  while
    <semantics_declaration> parse ;
  end repeat ;
  $end$ ;
  $semantics$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# I M P O R T  H E A D E R S,  S E M A N T I C S  A N D  G R A M M A R S    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <import_headers_semantics_and_grammars>
  !@stringset outImportedSemanticsComponents
  !@stringset outIncludedMetamodelComponents
  !@stringset outImportedOptionComponents
  !@stringset outImportedGrammarComponents
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  !@stringset outInclusionsForImplementationFile
  !@stringset outInclusionsForHeaderFile
  !@M_optionComponents ioOptionsComponentsMapForUse
  !@ModelMap outModelMap
  !@ActionMap outActionMap

  !@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeTableEnAvant tableEnAvant
  !@entityToImplementMap outAllMetamodelClassMap
  ?!@M_filewrappers ioFileWrappers
:
  outAllMetamodelClassMap := [@entityToImplementMap emptyMap] ;
  outActionMap := [@ActionMap emptyMap] ;
  outInclusionsForHeaderFile := [@stringset emptySet] ;
  outInclusionsForImplementationFile := [@stringset emptySet] ;
  outImportedSemanticsComponents := [@stringset emptySet] ;
  outIncludedMetamodelComponents := [@stringset emptySet] ;
  outImportedOptionComponents := [@stringset emptySet] ;
  outImportedGrammarComponents := [@stringset emptySet] ;
  tableEnAvant := [@typeTableEnAvant emptyMap] ;
  ioOptionsComponentsMapForUse := [@M_optionComponents emptyMap] ;
#--- Create model map, and enter builtin types
  outModelMap := [@ModelMap emptyMap] ;

  [!?outModelMap insertKey ![@lstring new !"char" ! here] ![@CharModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"string" ! here] ![@StringModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"uint" ! here] ![@UIntModel new]] ;
 
  [!?outModelMap insertKey ![@lstring new !"sint" ! here] ![@SIntModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"uint64" ! here] ![@UInt64Model new]] ;
 
  [!?outModelMap insertKey ![@lstring new !"sint64" ! here] ![@SInt64Model new]] ;

  [!?outModelMap insertKey ![@lstring new !"bool" ! here] ![@BoolModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"double" ! here] ![@DoubleModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"lchar" ! here] ![@LCharModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"lstring" ! here] ![@LStringModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"luint" ! here] ![@LUIntModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"lsint" ! here] ![@LSIntModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"luint64" ! here] ![@LUInt64Model new] ] ;

  [!?outModelMap insertKey ![@lstring new !"lsint64" ! here] ![@LSInt64Model new]] ;

  [!?outModelMap insertKey ![@lstring new !"lbool" ! here] ![@LBoolModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"ldouble" ! here] ![@LDoubleModel new] ] ;

  [!?outModelMap insertKey ![@lstring new !"location" ! here] ![@LocationModel new]] ;

  [!?outModelMap insertKey ![@lstring new !"stringset" ! here] ![@StringsetModel new]] ;
#--- enter in semantics entities map the galgas types corresponding to keywords
  enterBuiltinTypes ?ioComponentSemanticsEntitiesMap ;
  @stringset alreadyImportedSemanticsComponents [emptySet] ;
  @stringset alreadyImportedMetamodelComponents [emptySet] ;
#--- Loop on import instructions
  repeat
  while
    $import$ ;
    select
      $literal_string$ ? * ;
    or
      $treewalking$ ;
      @lstring treewalkingComponentName ;
      $identifier$ ? treewalkingComponentName ;
      outInclusionsForHeaderFile += ![treewalkingComponentName string] ;
      outInclusionsForImplementationFile += ![treewalkingComponentName string] . ".h" ;
      select
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        <parse_semantics_component_for_importing> 
          !fileName
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioTreewalkingComponentMap
          !?ioFileWrappers
        ;
      end select ;
    or
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      outInclusionsForHeaderFile += ![optionComponentName string] ;
      outImportedOptionComponents += ![optionComponentName string] ;
      @M_cli_options boolOptionsMap ;
      @M_cli_options uintOptionsMap ;
      @M_cli_options stringOptionsMap ;
      select
        [ioOptionsComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      or
        $in$ ;
        @lstring fileName ;
        $literal_string$ ? fileName ;
        @M_optionComponents importedOptionComponentsMap [emptyMap] ;
        <parse_option_component_for_importing>
          !fileName
          !?importedOptionComponentsMap
        ;
        [importedOptionComponentsMap searchKey !optionComponentName ?boolOptionsMap ?uintOptionsMap ?stringOptionsMap] ;
      end select ;
      [!?ioOptionsComponentsMapForUse insertKey !optionComponentName !boolOptionsMap !uintOptionsMap !stringOptionsMap] ;
    or
      $grammar$ ;
      @lstring grammarComponentName ;
      $identifier$ ? grammarComponentName ;
      outInclusionsForImplementationFile += ![grammarComponentName string] . ".h" ;
      outImportedGrammarComponents += ![grammarComponentName string] ;
      @M_grammarComponents grammarComponentsMap ;
      select
        grammarComponentsMap := ioGrammarComponentsMap ;
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ? sourceFile ;
        grammarComponentsMap := [@M_grammarComponents emptyMap] ;
        <parse_grammar_component_for_importing> 
          !sourceFile
          !?grammarComponentsMap
          !?ioMetamodelComponentMap
          !?ioOptionsComponentsMapForUse
          !?ioTreewalkingComponentMap
          !?ioFileWrappers
        ;
      end select ;
      @M_nonterminalSymbolAltsForGrammar nonterminalSymbolParametersMap ;
      @lstring lexiqueClassName ;
      [grammarComponentsMap searchKey !grammarComponentName ?nonterminalSymbolParametersMap ?lexiqueClassName ?*] ;
      @M_nonterminalSymbolAlts grammarAltMap [emptyMap] ;
      foreach nonterminalSymbolParametersMap (@lstring altName @L_signature signature @lstring kReturnedEntity) :
        @L_EXsignature formalParametersList [emptyList] ;
        foreach signature (@formalArgumentPassingMode passingMode @lstring typeName) :
          @AC_semanticsEntity e ;
          [ioComponentSemanticsEntitiesMap searchKey !typeName ?e] ;
          @AC_galgasType type := [(cast e if >= @typeEntiteType else error typeName) aDefType] ;
          formalParametersList += !type !passingMode ;
        end foreach ;
        [!?grammarAltMap insertKey !altName !formalParametersList !kReturnedEntity] ;
      end foreach ;
      @AC_semanticsEntity e := [@C_grammarForSemantics new !grammarAltMap !lexiqueClassName] ;
      [!?ioComponentSemanticsEntitiesMap insertKey !grammarComponentName !e] ;
      @lstring path := [@lstring new !"" !here] ;
      @lstring extension := [@lstring new !"h" !here] ;
      @lstring fileNameWithPath ;
      buildFileNameWithPath ?fileNameWithPath !path !grammarComponentName !extension ;
      outInclusionsForImplementationFile += ![fileNameWithPath string] ;
      foreach grammarComponentsMap (@lstring kKey
                                    @M_nonterminalSymbolAltsForGrammar kNonterminalSymbolParametersMap
                                    @lstring kLexiqueName
                                    @M_optionComponents kOptionsMap) :
        if not [ioGrammarComponentsMap hasKey ![kKey string]] then
          [!?ioGrammarComponentsMap insertKey
            !kKey
            !kNonterminalSymbolParametersMap
            !kLexiqueName
            !kOptionsMap
          ] ;
        end if ;
      end foreach ;
    or
      $semantics$ ;
      @lstring componentName ;
      $identifier$ ?componentName ;
      outInclusionsForHeaderFile += ![componentName string] ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioTreewalkingComponentMap
          !?ioFileWrappers
        ;
      end select ;
      if not [outImportedSemanticsComponents hasKey ![componentName string]] then
        @M_semanticsEntitiesForUse importedEntities ;
        @M_optionComponents importedOptionsComponentsMap ;
        [ioSemanticsComponentsMap searchKey !componentName ?5* ?importedOptionsComponentsMap ?importedEntities] ;
        foreach importedEntities (@lstring entityName @AC_semanticsEntity entityType) :
          if not [ioComponentSemanticsEntitiesMap hasKey ![entityName string]] then
            [!?ioComponentSemanticsEntitiesMap insertKey !entityName !entityType] ;
          end if ;
        end foreach ;
        outInclusionsForHeaderFile += ![componentName string] ;
      #--- Check that every used option component is already declared
        foreach importedOptionsComponentsMap (@lstring optionComponentMap ...) :
          if not [ioOptionsComponentsMapForUse hasKey ![optionComponentMap string]] then
            error here: "the '" . [optionComponentMap string] . "' option component must have been imported" ;
          end if ;
        end foreach ;
      end if ;
    #--- Import semantics component
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?ioMetamodelComponentMap
        !?outModelMap
        !?outActionMap
        !?alreadyImportedSemanticsComponents
        !?alreadyImportedMetamodelComponents
        !componentName
      ;
    #---
      outInclusionsForHeaderFile += ![componentName string] ;
      outImportedSemanticsComponents += ![componentName string] ;
    or
      $metamodel$ ;
      @lstring metamodelComponentName ;
      $identifier$ ? metamodelComponentName ;
      outInclusionsForHeaderFile += ![metamodelComponentName string] ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioTreewalkingComponentMap
          !?ioFileWrappers
        ;
      end select ;
      if not [outIncludedMetamodelComponents hasKey ![metamodelComponentName string]] then
        @entityToImplementMap metamodelClassMap ;
        [ioMetamodelComponentMap searchKey !metamodelComponentName ?* ?metamodelClassMap ?*] ;
        foreach metamodelClassMap (@lstring kMetamodelClassName
                                   @entityPropertyMap kAllMetamodelPropertyMap
                                   @bool kIsAbstract
                                   @entityPropertyMap kCurrentMetamodelPropertyMap
                                   @lstring kSuperEntityName
                                   @typeSuperClassesMap kSuperEntityMap
                                   @typeListeAttributsSemantiques kListeAttributsSemantiquesCourants
                                   @string kMetamodelName
                                   @uint kID) :
          [!?outAllMetamodelClassMap insertKey
            !kMetamodelClassName
            !kAllMetamodelPropertyMap
            !kIsAbstract
            !kCurrentMetamodelPropertyMap
            !kSuperEntityName
            !kSuperEntityMap
            !kListeAttributsSemantiquesCourants
            !kMetamodelName
            !kID
          ] ;
          @AC_galgasType t := [@typeGalgas_singleReferenceEntity new
            !kMetamodelClassName
            !kListeAttributsSemantiquesCourants
            ![kSuperEntityMap allKeys]
          ] ;
          [!?ioComponentSemanticsEntitiesMap insertKey
            !kMetamodelClassName
            ![@typeEntiteType new !t]
          ] ;
        end foreach ;
      end if ;
    #---
      outInclusionsForHeaderFile += ![metamodelComponentName string] ;
      outIncludedMetamodelComponents += ![metamodelComponentName string] ;
    end select ;
    $;$ ;
  end repeat ;
#--- Check that every option component used by an imported component is declared here

label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  !@stringset outIncludedSemanticsComponents
  !@stringset outIncludedOptionComponents
  !@ModelMap outModelMap
  !@ActionMap outActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_treewalkingComponents ioTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
:
  outActionMap := [@ActionMap emptyMap] ;
  outModelMap := [@ModelMap emptyMap] ;
  outIncludedSemanticsComponents := [@stringset emptySet] ;
  outIncludedOptionComponents := [@stringset emptySet] ;
  @stringset alreadyImportedSemanticsComponents [emptySet] ;
  @stringset alreadyImportedMetamodelComponents [emptySet] ;
  repeat
  while
    $import$ ;
    select
      $literal_string$ ? * ;
    or
      $treewalking$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_semantics_component_for_importing> parse ;
     end select ;
    or
      $option$ ;
      @lstring optionComponentName ;
      $identifier$ ? optionComponentName ;
      outIncludedOptionComponents += ![optionComponentName string] ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_option_component_for_importing> parse ;
     end select ;
    or
      $grammar$ ;
      $identifier$ ? * ;
      select
      or
        $in$ ;
        $literal_string$ ? * ;
        <parse_grammar_component_for_importing> parse ;
      end select ;
    or
      $semantics$ ;
      @lstring componentName ;
      $identifier$ ?componentName ;
      outIncludedSemanticsComponents += ![componentName string] ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ? sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioTreewalkingComponentMap
          !?ioFileWrappers
        ;
      end select ;
      @M_semanticsEntitiesForUse importedEntities ;
      [ioSemanticsComponentsMap searchKey !componentName ?5* ?* ?importedEntities] ;
      foreach importedEntities (@lstring entityName @AC_semanticsEntity entityType) :
        if not [ioComponentSemanticsEntitiesMap hasKey ![entityName string]] then
          [!?ioComponentSemanticsEntitiesMap insertKey !entityName !entityType] ;
        end if ;
      end foreach ;
    #--- Import semantics component
      importSemanticsComponent
        !?ioSemanticsComponentsMap
        !?ioMetamodelComponentMap
        !?outModelMap
        !?outActionMap
        !?alreadyImportedSemanticsComponents
        !?alreadyImportedMetamodelComponents
        !componentName
      ;
    or
      $metamodel$ ;
      @lstring metamodelComponentName ;
      $identifier$ ?metamodelComponentName ;
      select
      or
        $in$ ;
        @lstring sourceFile ;
        $literal_string$ ?sourceFile ;
        <parse_semantics_component_for_importing> 
          !sourceFile
          !?ioSemanticsComponentsMap
          !?ioMetamodelComponentMap
          !?ioTreewalkingComponentMap
          !?ioFileWrappers
        ;
      end select ;
      [ioMetamodelComponentMap searchKey !metamodelComponentName ?3*] ;
    end select ;
    $;$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  R O U T I N E    D E C L A R A T I O N                                   *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $routine$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Formal arguments -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    @L_EXsignature listeDeTypesPrecedenteDeclaration :=
      [(cast entite if == @typeEntiteRoutine else error routineName) aListeArgumentsFormels] ;
    verifierCompatibiliteSignatures
      !listeDeTypesPrecedenteDeclaration
      !listeDeTypes
      !here
     ;
  else
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteRoutine new !listeDeTypes] ;
    [!?ioComponentSemanticsEntitiesMap insertKey ! routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    @typeInstructionList ioInstructionList [emptyList] ;
    @entityPropertyMap propertyMap [emptyMap] ;
    @treewalkingRoutineHeaderMap treewalkingRoutineHeaderMap [emptyMap] ;
    @entityToImplementMap metamodelEntityMap [emptyMap] ;
    <semantic_instructions_list>
      !treewalkingRoutineHeaderMap
      !tableEnAvant
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?tableArgumentsMethode
      !?ioInstructionList
      !propertyMap
      !metamodelEntityMap
      !inTreewalkingComponentMap
    ;
    $end$ ;
    $routine$ ;
    $;$ ;
  #--- Inserer la routine dans la map des routines a implementer
    @typeEntityToGenerate ea := [@typeRoutineAengendrer new ! routineName
                                                              !listeTypeEtNomsArguments
                                                              !ioInstructionList] ;
    listeEntitesAengendrer += !ea ;
    [!?tableRoutinesAimplementer insertKey ! routineName] ;
  end select ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $routine$ ;
#---- Nom de la routine -------------------------------------------------------
  @lstring routineName ;
  $identifier$ ? routineName ;
#---- Arguments formels de la routine -----------------------------------------
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signature ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ? signature
  ;
  [!?ioExternActionMap insertKey !routineName !signature !false] ;
#--- Inserer dans la map des routines utilisables, -------------------------
#    or verifier la coherence de la signature
 if [ioComponentSemanticsEntitiesMap hasKey ![routineName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey ! routineName ?entite] ;
    @L_EXsignature listeDeTypesPrecedenteDeclaration :=
      [(cast entite if == @typeEntiteRoutine else error routineName) aListeArgumentsFormels] ;
    verifierCompatibiliteSignatures
      !listeDeTypesPrecedenteDeclaration
      !listeDeTypes
      !here
    ;
  else
    [!?tableNomRoutinesDeclarees insertKey ! routineName] ;
    @AC_semanticsEntity entite := [@typeEntiteRoutine new !listeDeTypes] ;
    [!?ioComponentSemanticsEntitiesMap insertKey ! routineName !entite] ;
  end if ;
  select
#---- Declaration anticipee de la routine (prototype) -------------------------
    $;$ ;
#---- Implementation de la routine --------------------------------------------
  or
   $:$ ;
  #--- Instructions
    <semantic_instructions_list> parse ;
    $end$ ;
    [!?tableRoutinesAimplementer insertKey !routineName] ;
    $routine$ ;
    $;$ ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                        ANALYSE D'UNE CLASSE MERE                          *
#---------------------------------------------------------------------------*

rule <parent_class>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
  !@string outSuperClassMessage
:
  listeTousAttributsSemantiques := [@typeListeAttributsSemantiques emptyList] ;
  tableDesClassesAncetres := [@typeSuperClassesMap emptyMap] ;
  tableDesMethodes := [@typeTableMethodes emptyMap] ;
  tableMessagesAbstraits := [@typeClassInheritedMessagesMap emptyMap] ;
  tableAttributs := [@typeSemanticAttributesMap emptyMap] ;
  outSuperClassName := [@lstring new !"" !here] ;
  outSuperClassMessage := "" ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
:
  listeTousAttributsSemantiques := [@typeListeAttributsSemantiques emptyList] ;
  tableDesClassesAncetres := [@typeSuperClassesMap emptyMap] ;
  tableDesMethodes := [@typeTableMethodes emptyMap] ;
  tableMessagesAbstraits := [@typeClassInheritedMessagesMap emptyMap] ;
  tableAttributs := [@typeSemanticAttributesMap emptyMap] ;
#---
  outMessageMap := [@classMessageMap emptyMap] ;
  outSuperClasses := [@stringset emptySet] ;
  outAttributeList := [@typeListModel emptyList] ;
end rule ;

#---------------------------------------------------------------------------*

rule <parent_class>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@lstring outSuperClassName
  !@string outSuperClassMessage
:
#--- Parse super class name
  $extends$ ;
  $type_name$ ? outSuperClassName ;
#--- Verifications semantiques sur le Parse super class name
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey ! outSuperClassName ?entite] ;
  @AC_galgasType typeUtilisateur :=
      [(cast entite if >= @typeEntiteType else error outSuperClassName) aDefType] ;
  @typeGalgasClassType classType := (cast typeUtilisateur if >= @typeGalgasClassType else error outSuperClassName) ;
  tableDesMethodes := [classType mReaderMap] ;
  listeTousAttributsSemantiques := [classType mNonExternAttributesList] ;
  tableDesClassesAncetres := [classType mAncestorClassesMap] ;
  tableMessagesAbstraits := [classType mMessagesMap] ;
  tableAttributs := [classType mNonExternAttributesMap] ;
  outSuperClassMessage := [classType mClassMessage] ;
#--- Le Parse super class name est la derniere inseree en fin de la liste des ancetres 
  [!?tableDesClassesAncetres insertKey ! outSuperClassName] ;
label importSemantics
  ?!@ModelMap ioModelMap
  !@stringset outSuperClasses
  !@typeListModel outAttributeList
  !@classMessageMap outMessageMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@typeSemanticAttributesMap tableAttributs
  !@typeListeAttributsSemantiques listeTousAttributsSemantiques
  !@typeTableMethodes tableDesMethodes
  !@typeSuperClassesMap tableDesClassesAncetres
  !@typeClassInheritedMessagesMap tableMessagesAbstraits
:
#--- Parse super class name
  @lstring superClassName ;
  $extends$ ;
  $type_name$ ? superClassName ;
#--- Verifications semantiques sur le Parse super class name
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey ! superClassName ?entite] ;
  @AC_galgasType typeUtilisateur :=
      [(cast entite if >= @typeEntiteType else error superClassName) aDefType] ;
  @typeGalgasClassType classType := (cast typeUtilisateur if >= @typeGalgasClassType else error superClassName) ;
  tableDesMethodes := [classType mReaderMap] ;
  listeTousAttributsSemantiques := [classType mNonExternAttributesList] ;
  tableDesClassesAncetres := [classType mAncestorClassesMap] ;
  tableMessagesAbstraits := [classType mMessagesMap] ;
  tableAttributs := [classType mNonExternAttributesMap] ;
#--- Le Parse super class name est la derniere inseree en fin de la liste des ancetres 
#--- The direct super class is last inserted one 
  [!?tableDesClassesAncetres insertKey ! superClassName] ;
#---
  @TypeModel type ;
  [ioModelMap searchKey !superClassName ?type] ;
  cast type :
  when >= @ClassModel model do #(* @stringset superClasses @typeListModel attributeList @classMessageMap messageMap) ->
    outSuperClasses := [model mSuperClasses] ;
    outAttributeList := [model mAttributeList] ;
    outMessageMap := [model mMessageMap] ;
  else
    error superClassName: "the '@" . [superClassName string] . "' type is not a class"
     -> outSuperClasses, outAttributeList, outMessageMap ;
  end cast ;
  outSuperClasses += ![superClassName string] ;

  outMessageMap := [@classMessageMap emptyMap] ;
  outSuperClasses := [@stringset emptySet] ;
  outAttributeList := [@typeListModel emptyList] ;

end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     A B S T R A C T    O R    C O N C R E T E    C L A S S                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  @bool estAbstraite ;
  select
    $abstract$ ;
    estAbstraite := true ;
  or
    estAbstraite := false ;
  end select ;
  $class$ ;
 #--- Abstract class name
  @lstring abstractClassName ;
  $type_name$ ? abstractClassName ;
  select
    if not ([tableEnAvant hasKey ![abstractClassName string]] |
          [ioComponentSemanticsEntitiesMap hasKey ![abstractClassName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedClassType new !abstractClassName] ;
      [!?tableEnAvant insertKey !abstractClassName !t] ;
    end if ;
    $;$ ;
  or
  #--- Analyse de la classe mere (if existe)
    @typeTableMethodes ancestorClassMethodsMap ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
    @typeSuperClassesMap tableDesClassesAncetres ;
    @typeClassInheritedMessagesMap inheritedMessageMap ;
    @typeSemanticAttributesMap tableAttributs ;
    @string superClassMessage ;
    <parent_class>
      !?ioComponentSemanticsEntitiesMap
      ?tableAttributs
      ?listeTousAttributsSemantiques
      ?ancestorClassMethodsMap
      ?tableDesClassesAncetres
      ?inheritedMessageMap
      ?*
      ?superClassMessage
    ;
    ${$ ;
  #--- Attributs de la classe
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes
    @typeTableMethodesAimplementer tableMethodesAimplementer [emptyMap] ;
    @typeClassMessagesMap tableMessagesClasseConcrete [emptyMap] ;
    @typeClassInheritedMessagesMap messageMapForHeirs [emptyMap] ;
    @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
    @string classMessage := "" ;
    repeat
    while
      $message$ ;
      select
        @lstring messageText ;
        $literal_string$ ? messageText ;
        if [classMessage length] > 0 then
          error messageText : "the class message is already defined" ;
        elsif [messageText length] == 0 then
          error messageText : "the class message string should not be empty" ;
        else
          classMessage := [messageText string] ;
        end if ;
      or
        @lstring messageName ;
        $identifier$ ? messageName ;
      #--- Chaine definissant le message d'erreur
        @lstring messageText ;
        $literal_string$ ? messageText ;
      #--- Entrer le message dans la map
        if not [inheritedMessageMap hasKey ![messageName string]] then
          [!?messageMapForHeirs insertKey !messageName] ;
        end if ; 
        [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ;
      end select ;
      $;$ ;
    while
      <abstract_method>
        !estAbstraite
        !?listeAttributsSemantiquesCourants
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableDesMethodes
        !?tableMethodesAimplementer
        !?tableEnAvant
      ;
    while
      <non_abstract_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !inOptionsComponentsMapForUse
        !inTreewalkingComponentMap
        !classMessage
      ;
     while
      <overrided_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !inOptionsComponentsMapForUse
        !inTreewalkingComponentMap
        !classMessage
     ;
    end repeat ;
  #--- Check class message is defined if needed
    if ([superClassMessage length] > 0) & ([classMessage length] == 0) then
      error here: "this class should defined a class message, as it inherits from a class that does" ;
    end if ;
  #--- Verify that all inherited messages are defined
    foreach inheritedMessageMap (@lstring nomMessageAbstrait) :
      if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait string]] then
        error here : "the message '" . [nomMessageAbstrait string] . "' is not defined" ;
      end if ;
  end foreach ;
  #--- Inserer dans la map des classes utilisables
    @AC_galgasType c := [@typeGalgasClassType new 
      !abstractClassName
      !tableDesMethodes
      !listeTousAttributsSemantiques
      !tableDesClassesAncetres
      !messageMapForHeirs
      !tableAttributs
      !estAbstraite
      !classMessage] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !abstractClassName !entite] ;
  #--- Inserer dans la map des classes definies dans ce fichier (a implementer)
    @typeEntityToGenerate def := [@C_classToImplement new 
       !abstractClassName
       !estAbstraite
       !listeTousAttributsSemantiques
       !tableDesMethodes
       !tableMethodesAimplementer
       !listeAttributsSemantiquesCourants
       !tableDesClassesAncetres
       !tableMessagesClasseConcrete
       !classMessage
    ] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  @bool estAbstraite ;
  select
    $abstract$ ;
    estAbstraite := true ;
  or
    estAbstraite := false ;
  end select ;
  $class$ ;
 #--- Abstract class name
  @lstring abstractClassName ;
  $type_name$ ? abstractClassName ;
  select
    if not ([tableEnAvant hasKey ![abstractClassName string]] |
            [ioComponentSemanticsEntitiesMap hasKey ![abstractClassName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedClassType new !abstractClassName] ;
      [!?tableEnAvant insertKey !abstractClassName !t] ;
    end if ;
    $;$ ;
  or
  #--- Analyse de la classe mere (if existe)
    @typeTableMethodes ancestorClassMethodsMap ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques ;
    @typeSuperClassesMap tableDesClassesAncetres ;
    @typeClassInheritedMessagesMap inheritedMessageMap ;
    @typeSemanticAttributesMap tableAttributs ;
    @stringset superClasses ;
    @typeListModel attributeList ;
    @classMessageMap messageMap ;
    <parent_class> importSemantics
      !?ioModelMap
      ?superClasses
      ?attributeList
      ?messageMap
      !?ioComponentSemanticsEntitiesMap
      ?tableAttributs
      ?listeTousAttributsSemantiques
      ?ancestorClassMethodsMap
      ?tableDesClassesAncetres
      ?inheritedMessageMap
    ;
    ${$ ;
  #--- Attributs de la classe
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeList
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes
    @typeTableMethodesAimplementer tableMethodesAimplementer [emptyMap] ;
    @typeClassMessagesMap tableMessagesClasseConcrete [emptyMap] ;
    @typeClassInheritedMessagesMap messageMapForHeirs [emptyMap] ;
    @typeTableMethodes tableDesMethodes := ancestorClassMethodsMap ;
    @typeEntitiesToGenerateList listeEntitesAengendrer [emptyList] ;
    @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
    @string classMessage := "" ;
    repeat
    while
      $message$ ;
      select
        @lstring messageText ;
        $literal_string$ ? messageText ;
        if [classMessage length] > 0 then
          error messageText : "the class message is already defined" ;
        elsif [messageText length] == 0 then
          error messageText : "the class message string should not be empty" ;
        else
          classMessage := [messageText string] ;
        end if ;
      or
        @lstring messageName ;
        $identifier$ ? messageName ;
        # warning messageName:"old class feature" ;
      #--- Chaine definissant le message d'erreur
        @lstring messageText ;
        $literal_string$ ? messageText ;
      #--- Entrer le message dans la map
        if not [inheritedMessageMap hasKey ![messageName string]] then
          [!?messageMapForHeirs insertKey !messageName] ;
        end if ; 
        [!?tableMessagesClasseConcrete insertKey !messageName !messageText] ;
      end select ;
      $;$ ;
    while
      <abstract_method>
        !estAbstraite
        !?listeAttributsSemantiquesCourants
        !?listeEntitesAengendrer
        !?ioComponentSemanticsEntitiesMap
        !?tableDesMethodes
        !?tableMethodesAimplementer
        !?tableEnAvant ;
    while
      <non_abstract_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !optionsComponentsMapForUse
        !inTreewalkingComponentMap
        !classMessage
      ;
     while
      <overrided_method>
        !abstractClassName
        !ancestorClassMethodsMap
        !listeTousAttributsSemantiques
        !?tableDesMethodes
        !tableDesClassesAncetres
        !messageMapForHeirs
        !tableAttributs
        !estAbstraite
        !?ioComponentSemanticsEntitiesMap
        !?tableMethodesAimplementer
        !?tableEnAvant
        !optionsComponentsMapForUse
        !inTreewalkingComponentMap
        !classMessage
     ;
    end repeat ;
  #--- Verify that all inherited messages are defined
    foreach inheritedMessageMap (@lstring nomMessageAbstrait) :
      if not [tableMessagesClasseConcrete hasKey ![nomMessageAbstrait string]] then
        error here : "the message '" .  [nomMessageAbstrait string] . "' is not defined" ;
      end if ;
  end foreach ;
  #--- Inserer dans la map des classes utilisables
    @AC_galgasType c := [@typeGalgasClassType new 
                                             !abstractClassName
                                             !tableDesMethodes
                                             !listeTousAttributsSemantiques
                                             !tableDesClassesAncetres
                                             !messageMapForHeirs
                                             !tableAttributs
                                             !estAbstraite
                                             !classMessage] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !abstractClassName !entite] ;
    $}$ ;
    @TypeModel t := [@ClassModel new !true !superClasses !attributeList !messageMap] ;
    [!?ioModelMap insertKey !abstractClassName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                 Methode abstract                          *
#---------------------------------------------------------------------------*

rule <abstract_method>
  ??@bool inIsAbstract
  ?!@typeListeAttributsSemantiques unused listeAttributsSemantiquesCourants
  ?!@typeEntitiesToGenerateList unused listeEntitesAengendrer
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodes tableDesMethodes
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
:
  $abstract$ ;
  $method$ ;
  if not inIsAbstract then
    error here: "a concrete class should not declare an abstract method" ;
  end if ;
  @lstring nomMethode ;
  $identifier$ ? nomMethode ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  [!?tableDesMethodes insertKey !nomMethode !listeDeTypes] ;
  @typeInstructionList listeInstructions [emptyList] ;
  [!?tableMethodesAimplementer insertAbstract !nomMethode !listeDeTypes !listeTypeEtNomsArguments !listeInstructions] ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <parse_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ??@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributsHerites
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outMethodName
  !@typeInstructionList outInstructionsList
  !@L_EXsignature outMethodSignature
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ??@string inClassMessage
:
#--- Get reader name
  $identifier$ ? outMethodName ;
#--- Create local variable map
  @typeVariablesMap methodLocalVariablesMap [emptyMap]  ;
  foreach tableAttributsHerites (@lstring kKey @AC_galgasType kType) :
    @typeCplusPlusName nomCpp := [@typeDirectName new ![kKey location] ![kKey string]] ;
    [!?methodLocalVariablesMap insertUsedConstInArgument !kKey !kType !nomCpp] ;
  end foreach ;
#--- Insert the predefined "self" variable
  @lstring me_Constant := [@lstring new !"self" !here] ;
  @typeCplusPlusName me_constantCppName := [@typeCppThisName new !here] ;
  @AC_galgasType typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !tableDesMethodes
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributsHerites
           !inClassIsAbstract
           !inClassMessage] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument !me_Constant !typeDefinition !me_constantCppName] ;
#--- Insert the predefined "super" variable
  @lstring super_Constant := [@lstring new !"super" !here] ;
  @typeCplusPlusName super_constantCppName := [@typeCppInheritedName new !here] ;
  typeDefinition := [@typeGalgasClassType new 
           !inCurrentClassName
           !inAncestorClassMethodsMap
           !listeTousAttributsSemantiques
           !tableDesClassesAncetres
           !messageMapForHeirs
           !tableAttributsHerites
           !inClassIsAbstract
        !inClassMessage
  ] ;
  [!?methodLocalVariablesMap insertUsedConstInArgument !super_Constant !typeDefinition !super_constantCppName] ;
#--- Parse formal arguments
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?outMethodSignature
    !?methodLocalVariablesMap
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  $:$ ;
#--- Add current class definition
  @M_semanticsEntitiesForUse componentSemanticsEntitiesMap := ioComponentSemanticsEntitiesMap ;
  @AC_semanticsEntity entite := [@typeEntiteType new ! typeDefinition] ;
  [!?componentSemanticsEntitiesMap insertKey !inCurrentClassName !entite] ;
#--- Parse reader instruction list
  outInstructionsList := [@typeInstructionList emptyList] ;
  @entityPropertyMap propertyMap [emptyMap] ;
  @treewalkingRoutineHeaderMap treewalkingRoutineHeaderMap [emptyMap] ;
  @entityToImplementMap metamodelEntityMap [emptyMap] ;
  <semantic_instructions_list>
    !treewalkingRoutineHeaderMap
    !tableEnAvant
    !componentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?methodLocalVariablesMap
    !?outInstructionsList
    !propertyMap
    !metamodelEntityMap
    !inTreewalkingComponentMap
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <non_abstract_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ??@string inClassMessage
:
  select
    $method$ ;
  or
    $reader$ ;
    warning here: "old syntax: from GALGAS 1.5.1, use 'method' instead of 'reader'" ;
  end select ;
  @lstring methodName ;
  @typeInstructionList instructionsList ;
  @L_EXsignature methodSignature ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <parse_method>
    !inCurrentClassName
    !inAncestorClassMethodsMap
    !listeTousAttributsSemantiques
    !tableDesMethodes
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributs
    !inClassIsAbstract
    !?ioComponentSemanticsEntitiesMap
    !?tableEnAvant
    ?methodName
    ?instructionsList
    ?methodSignature
    ?listeTypeEtNomsArguments
    !inOptionsComponentsMapForUse
    !inTreewalkingComponentMap
    !inClassMessage
  ;
  [!?tableDesMethodes insertKey !methodName !methodSignature] ;
  [!?tableMethodesAimplementer insertNotAbstract !methodName !methodSignature !listeTypeEtNomsArguments !instructionsList] ;
  $end$ ;
  select
    $method$ ;
  or
    $reader$ ;
    warning here: "old syntax: from GALGAS 1.5.1, use 'method' instead of 'reader'" ;
  end select ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*

rule <overrided_method>
  ??@lstring inCurrentClassName
  ??@typeTableMethodes inAncestorClassMethodsMap
  ??@typeListeAttributsSemantiques listeTousAttributsSemantiques
  ?!@typeTableMethodes tableDesMethodes
  ??@typeSuperClassesMap tableDesClassesAncetres
  ??@typeClassInheritedMessagesMap messageMapForHeirs
  ??@typeSemanticAttributesMap tableAttributs
  ??@bool inClassIsAbstract
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableMethodesAimplementer tableMethodesAimplementer
  ?!@typeTableEnAvant tableEnAvant
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ??@string inClassMessage
:
  $override$ ;
  select
    $method$ ;
  or
    $reader$ ;
    warning here: "old syntax: from GALGAS 1.5.1, use 'method' instead of 'reader'" ;
  end select ;
  @lstring methodName ;
  @typeInstructionList instructionsList ;
  @L_EXsignature methodSignature ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  <parse_method>
    !inCurrentClassName
    !inAncestorClassMethodsMap
    !listeTousAttributsSemantiques
    !tableDesMethodes
    !tableDesClassesAncetres
    !messageMapForHeirs
    !tableAttributs
    !inClassIsAbstract
    !?ioComponentSemanticsEntitiesMap
    !?tableEnAvant
    ?methodName
    ?instructionsList
    ?methodSignature
    ?listeTypeEtNomsArguments
    !inOptionsComponentsMapForUse
    !inTreewalkingComponentMap
    !inClassMessage
  ;
#--- Verify reader signature is compatible with overriden reader signature
  @L_EXsignature listeDeTypesMethodeOriginale ;
  [tableDesMethodes searchKey !methodName ?listeDeTypesMethodeOriginale] ;
  verifierCompatibiliteSignatures
    !listeDeTypesMethodeOriginale 
    !methodSignature
    !here
  ;
#--- Insert reader into reader table
  [!?tableMethodesAimplementer insertNotAbstract !methodName !methodSignature !listeTypeEtNomsArguments !instructionsList] ;
  $end$ ;
  select
    $method$ ;
  or
    $reader$ ;
    warning here: "old syntax: from GALGAS 1.5.1, use 'method' instead of 'reader'" ;
  end select ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#               Analyse des arguments formels d'une methode                 *
#                     (entree, sortie, or entree/sortie)                    *
#---------------------------------------------------------------------------*

rule <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap tableArgumentsMethode
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignatureForGrammar
:
  listeDeTypes := [@L_EXsignature emptyList] ;
  listeTypeEtNomsArguments := [@typeListeTypesEtNomsArgMethode emptyList] ;
  outSignatureForGrammar := [@L_signature emptyList] ;
  repeat
  while
    $??$ ; # '??'  : constant input formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentConstantIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    @bool modeIn := true ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
      [!?tableArgumentsMethode insertUnusedConstInArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
      [!?tableArgumentsMethode insertConstInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $?$ ; # '?'  : input formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentIn] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !true ;
      [!?tableArgumentsMethode insertUnusedInArgument !nomArgument !type_semantique !natureNom] ;
    or
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !true ;
      [!?tableArgumentsMethode insertInArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $?!$ ; # '?!' : input/output formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentInOut] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    select
      $unused$ ;
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !false ;
      [!?tableArgumentsMethode insertUnusedInOutArgument !nomArgument !type_semantique !natureNom] ;
    or
      $identifier$ ? nomArgument ;
      @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
      listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !false ;
      [!?tableArgumentsMethode insertInOutArgument !nomArgument !type_semantique !natureNom] ;
    end select ;
  while
    $!$ ; # '!' : output formal parameter
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentOut] ;
    @AC_galgasType type_semantique ;
    @lstring galgasTypeName ;
    <formal_argument_type>
      !ioComponentSemanticsEntitiesMap
      ?type_semantique
      !?tableEnAvant
      ?galgasTypeName
    ;
    listeDeTypes += !type_semantique !passingMode ;
    outSignatureForGrammar += !passingMode !galgasTypeName ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
    @bool modeIn := false ;
    listeTypeEtNomsArguments += !type_semantique !passingMode !natureNom !modeIn ;
    [!?tableArgumentsMethode insertOutArgument !nomArgument !type_semantique !natureNom] ;
  end repeat ;
label importGrammarForSemantics
  !@L_signature outSignature
:
  outSignature := [@L_signature emptyList] ;
  repeat
  while
    $??$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentConstantIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $?$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentIn] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $?!$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentInOut] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    select
      $unused$ ;
      $identifier$ ? * ;
    or
      $identifier$ ? * ;
    end select ;
  while
    $!$ ;
    @formalArgumentPassingMode passingMode := [@formalArgumentPassingMode argumentOut] ;
    @lstring galgasTypeName ; 
    <formal_argument_type> importGrammarForSemantics ?galgasTypeName ;
    outSignature += !passingMode !galgasTypeName ;
    $identifier$ ? * ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#            Parse type name and check it is defined                        *
#---------------------------------------------------------------------------*

rule <type_parsing>
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@AC_galgasType outTypeDefinition
  !@lstring outTypeName
:
  $type_name$ ? outTypeName ;
  if [ioComponentSemanticsEntitiesMap hasKey ![outTypeName string]] then
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey !outTypeName ?entite] ;
    outTypeDefinition := [(cast entite if >= @typeEntiteType else error outTypeName) aDefType] ;
  elsif [inTableEnAvant hasKey ![outTypeName string]] then
    [inTableEnAvant searchKey !outTypeName ? outTypeDefinition] ;
  else
    error outTypeName: "the '@" . [outTypeName string] . "' type is not defined" -> outTypeDefinition ;
  end if ;
end rule ;


#---------------------------------------------------------------------------*
#                                                                           *
#  A S S I G N M E N T     I N S T R U C T I O N     idf := ... ;           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ?@lstring inTargetVarName
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@entityToImplementMap unused inMetamodelEntityMap
:
  $:=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Get target entity infos
  @AC_galgasType targetVarType ;
  @typeCplusPlusName targetVarCppName ;
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?targetVarType ?targetVarCppName] ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !targetVarType !sourceType !here !true ;
#--- Generate instruction
  @typeInstruction instruction := [@C_assignmentInstruction new !targetVarCppName !sourceExpression] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  . =     I N S T R U C T I O N     idf .= ... ;                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ?@lstring inTargetVarName
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@entityToImplementMap unused inMetamodelEntityMap
:
  $.=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Get target entity infos
  @AC_galgasType targetVarType ;
  @typeCplusPlusName targetVarCppName ;
  [!?ioVariablesMap searchForReadWriteAccess !inTargetVarName ?targetVarType ?targetVarCppName] ;
#--- Match target and source types
  @string sourceExpressionConverter ;
  match targetVarType :: sourceType :
  when @typeGalgas_string () :: @typeGalgas_string () :
    sourceExpressionConverter := "" ;
  when @typeGalgas_string () :: @typeGalgas_lstring () :
    sourceExpressionConverter := "ggs_string" ;
  else
    error here: "for '.=' operator, " . [targetVarType messageGalgasType]
    . " target object type is not compatible with " . [sourceType messageGalgasType]
    . " source expression type" -> sourceExpressionConverter ;
  end match ;
#--- Generate instruction
  @typeInstruction instruction := [@C_dotEqualInstruction new
    !targetVarCppName
    !sourceExpression
    !sourceExpressionConverter
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#        Liste d'arguments effectifs en entree : ( ?<entite dest> ? * ...)  *
#---------------------------------------------------------------------------*

rule <input_parameters_list>
  !@L_assignedVariables listeAffectationParametresEffectifs
  !@typeCplusPlusNameList outAllVariablesList
  ?@typeListeAttributsSemantiques listeAttributsSemantiques
  ?!@typeVariablesMap ioVariablesMap
:
  @typeListeCibles listeCibles [emptyList] ;
  repeat
  while
    $?$ ;
    select
      @lstring nomVariableDest ;
      $identifier$ ? nomVariableDest ;
      @AC_galgasType typeVarDest ;
      @typeCplusPlusName nomCppDest ;
      [!?ioVariablesMap searchForWriteAccess !nomVariableDest ?typeVarDest ?nomCppDest] ;
      listeCibles += ![@typeEntiteDest new !typeVarDest !nomCppDest !here] ;
    or
      $*$ ;
      listeCibles += ![@typeJoker new] ;
    or
      @luint jokerCountWithLocation ;
      $unsigned_literal_integer$ ? jokerCountWithLocation ;
      $*$ ;
      @uint jokerCount := [jokerCountWithLocation uint] ;
      loop jokerCount + 1 :
      while jokerCount > 0 do
        listeCibles += ![@typeJoker new] ;
        jokerCount -- ;
      end loop ;
    end select ;
  end repeat ;
  @bool ellipsis ;
  select
    $...$ ;
    ellipsis := true ;
  or
    ellipsis := false ;
  end select ;
#--- Verifier la compatibilite des list et construire la list des affectations
  if [listeAttributsSemantiques length] < [listeCibles length] then
    error here : "too much arguments: " . [[listeAttributsSemantiques length] string]
      . " expected, " . [[listeCibles length] string] . " found" 
      -> outAllVariablesList, listeAffectationParametresEffectifs ;
  elsif ([listeAttributsSemantiques length] > [listeCibles length]) & not ellipsis then
    error here : "argument(s) missing: " . [[listeAttributsSemantiques length] string]
      . " expected, " . [[listeCibles length] string] . " found"
      -> outAllVariablesList, listeAffectationParametresEffectifs ;
  else
    listeAffectationParametresEffectifs := [@L_assignedVariables emptyList] ;
    outAllVariablesList := [@typeCplusPlusNameList emptyList] ;
    foreach listeAttributsSemantiques (@AC_galgasType attTypeAttribut @lstring attNomAttribut),
            listeCibles (@typeCible attCible) :
      @lstring nomAttributSource := attNomAttribut ;
      [attCible verifierType !attTypeAttribut !?nomAttributSource !?listeAffectationParametresEffectifs !?outAllVariablesList] ;
    end foreach ;
  end if ;
#--- Append Joker if needed
  @typeCplusPlusName nullName := [@typeNullName new !here] ;
  appendJokersIfNeeded
   !?outAllVariablesList
   ![listeCibles length]
   ![listeAttributsSemantiques length]
   !nullName
  ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   + =    I N S T R U C T I O N                                            *
#                                                                           *
#  variable += !source_exp !... !source_exp ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@entityToImplementMap unused inMetamodelEntityMap
:
  $+=$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the += operator ?
  @typeListeAttributsSemantiques formalParametersList ;
  cast targetVariableType :
  when == @typeGalgas_multipleReferenceEntity mre do
    formalParametersList := [@typeListeAttributsSemantiques emptyList] ;
    @AC_semanticsEntity entite ;
    [ioComponentSemanticsEntitiesMap searchKey ![mre mEntityTypeName] ? entite] ;
    @AC_galgasType elementType := [(cast entite if >= @typeEntiteType else error here) aDefType] ;
    formalParametersList += !elementType ![@lstring new !"" !here] ;
  else
    [targetVariableType handleAddAssignOperatorCall !here ?formalParametersList] ;
  end cast ;
#--- Parse argument list
  @typeTypesList typeList := [@typeTypesList emptyList] ;
  @typeExpressionList expressionList [emptyList] ;
  repeat
    $!$ ;
    @typeExpression expression ;
    @AC_galgasType resultType ;
    <expression> 
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expression
      ?resultType
    ;
    typeList += !resultType !here ;
    expressionList += !expression ;
  while
  end repeat ;
#--- Check expression types list against formal parameter list
  if [formalParametersList length] != [typeList length] then
    error here : [[typeList length] string] . " argument(s), while " . [[formalParametersList length] string] . " are needed" ;
  else
    foreach formalParametersList (@AC_galgasType formalType @lstring formalName),
            typeList (@AC_galgasType effectiveType @location kErrorLocation) :
      checkAssignmentTypesCompatibility
        !formalType
        !effectiveType
        !kErrorLocation
        !true
      ;
    end foreach ;
  end if ;
  @typeInstruction instruction := [@typeAppendInstruction new !nomCppVariableSource !expressionList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   - =    I N S T R U C T I O N                                            *
#                                                                           *
#  variable -= !source_exp !... !source_exp ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@entityToImplementMap unused inMetamodelEntityMap
:
  $-=$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the += operator ?
  @typeListeAttributsSemantiques formalParametersList ;
  [targetVariableType handleMinusAssignOperatorCall !here ?formalParametersList] ;
#--- Parse argument list
  @typeTypesList typeList := [@typeTypesList emptyList] ;
  @typeExpressionList expressionList [emptyList] ;
  repeat
    $!$ ;
    @typeExpression expression ;
    @AC_galgasType resultType ;
    <expression> 
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expression
      ?resultType
    ;
    typeList += !resultType !here ;
    expressionList += !expression ;
  while
  end repeat ;
#--- Check expression types list against formal parameter list
  if [formalParametersList length] != [typeList length] then
    error here : [[typeList length] string] . " argument(s), while " . [[formalParametersList length] string] . " are needed" ;
  else
    foreach formalParametersList (@AC_galgasType formalType @lstring formalName),
            typeList (@AC_galgasType effectiveType @location kErrorLocation) :
      checkAssignmentTypesCompatibility
        !formalType
        !effectiveType
        !kErrorLocation
        !true
      ;
    end foreach ;
  end if ;
  @typeInstruction instruction := [@typeRemoveInstruction new !nomCppVariableSource !expressionList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   I N C R E M E N T    I N S T R U C T I O N                              *
#                                                                           *
#  variable ++ ;                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ??@entityToImplementMap unused inMetamodelEntityMap
:
  $++$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the ++ operator ?
  [targetVariableType handleIncrementOperatorCall !here] ;
#--- Generate instruction
  @typeInstruction instruction := [@typeIncrementInstruction new !nomCppVariableSource !here] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   D E C R E M E N T    I N S T R U C T I O N                              *
#                                                                           *
#  variable -- ;                                                            *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ??@entityToImplementMap unused inMetamodelEntityMap
:
  $--$ ;
#--- Perform an io access for target variable
  @AC_galgasType targetVariableType ;
  @typeCplusPlusName nomCppVariableSource ;
  [!?ioVariablesMap searchForReadWriteAccess !nomVarDest ?targetVariableType ?nomCppVariableSource] ;
#--- Does the variable class accept the ++ operator ?
  [targetVariableType handleDecrementOperatorCall !here] ;
#--- Generate instruction
  @typeInstruction instruction := [@typeDecrementInstruction new !nomCppVariableSource !here] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#            Liste d'arguments effectifs !? entite ! entite ? entite ...    *
#---------------------------------------------------------------------------*

rule <actual_parameters_list>
  ??@L_EXsignature listeTypesParametresFormels
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeInstructionList ioInstructionList
:
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?outExpressionList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
  ;
#--- Verifier la correction des arguments effectifs
  verifierCompatibiliteArgEffectifsSignature
    !listeTypesParametresFormels
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionList
    !?outExpressionList
  ;
end rule ;

#---------------------------------------------------------------------------*
#            Liste d'arguments effectifs !? entite ! entite ? entite ...    *
#                          sans verification de type                        *
#---------------------------------------------------------------------------*

rule <parse_parameters_list>
  !@L_actualParametersSignature listeTypesParametresEffectifs
  !@typeExpressionList outExpressionList
  ?!@typeVariablesMap ioVariablesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  outExpressionList := [@typeExpressionList emptyList] ;
  listeTypesParametresEffectifs := [@L_actualParametersSignature emptyList] ;
  @stringset exclusiveVariables [emptySet] ;
  repeat
  while
    $!$ ;
    @AC_galgasType expressionType ;
    @typeExpression expressionValue ;
    <expression>
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      ?expressionValue
      ?expressionType ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterOut] ;
    listeTypesParametresEffectifs += !expressionType !parameterPassingMode ;
    outExpressionList += !expressionValue ;
  while
    $?$ ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterIn] ;
    select
      $*$ ;
      listeTypesParametresEffectifs += ![@typeGalgas_jokerInParameterList new] !parameterPassingMode ;
      outExpressionList += ![@typeJokerInExpression new] ;
    or
      @luint jokerCountWithLocation ;
      $unsigned_literal_integer$ ? jokerCountWithLocation ;
      $*$ ;
      @uint jokerCount := [jokerCountWithLocation uint] ;
      loop jokerCount + 1 :
      while jokerCount > 0 do
        listeTypesParametresEffectifs += ![@typeGalgas_jokerInParameterList new] !parameterPassingMode ;
        outExpressionList += ![@typeJokerInExpression new] ;
        jokerCount -- ;
      end loop ;
    or
      @AC_galgasType typeArgument ;
      @typeCplusPlusName nomCppArgument ;
      @lstring nomArgument ;
      $identifier$ ? nomArgument ;
      [!?ioVariablesMap searchForWriteAccess !nomArgument ?typeArgument ?nomCppArgument] ;
      listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
      @typeExpression e := [@typeVarInExpression new !nomCppArgument] ;
      outExpressionList += !e ;
      if [exclusiveVariables hasKey ![nomArgument string]] then
        error nomArgument: "this object is already named as input or output/input effectif argument of current instruction" ;
      else
         exclusiveVariables += ![nomArgument string] ;
      end if ;
    end select ;
  while
    $!?$ ;
    @AC_galgasType typeArgument ;
    @typeCplusPlusName nomCppArgument ;
    @lstring nomArgument ;
    $identifier$ ? nomArgument ;
    [!?ioVariablesMap searchForReadWriteAccess !nomArgument ?typeArgument ?nomCppArgument] ;
    @actualParametersPassingMode parameterPassingMode := [@actualParametersPassingMode parameterOutIn] ;
    listeTypesParametresEffectifs += !typeArgument !parameterPassingMode ;
    @typeExpression e := [@typeVarInExpression new !nomCppArgument] ;
    outExpressionList += !e ;
      if [exclusiveVariables hasKey ![nomArgument string]] then
        error nomArgument: "this object is already named as input or output/input effectif argument of current instruction" ;
      else
         exclusiveVariables += ![nomArgument string] ;
      end if ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#              LISTE DES INSTRUCTIONS SEMANTIQUES D'UNE METHODE             *
#---------------------------------------------------------------------------*

rule <semantic_instructions_list>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  block ioVariablesMap.verifyVariableUsing () :
    <semantic_instructions_list_no_verif>
      !inTreewalkingRoutineHeaderMap
      !inTableEnAvant
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !inCurrentTreewalkingRoutinePropertyMap
      !inMetamodelEntityMap
      !inTreewalkingComponentMap
    ;
  end block (!here) ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#      call instruction                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $call$ ;
#--- Called property
  @lstring calledPropertyName ;
  $identifier$ ?calledPropertyName ;
  @AC_galgasType propertyType ;
  [inCurrentTreewalkingRoutinePropertyMap searchKey !calledPropertyName ?propertyType] ;
  @lstring entityName ;
  cast propertyType :
  when >= @typeGalgas_singleReferenceEntity ref do
    entityName := [ref mEntityTypeName] ;
  when >= @typeGalgas_multipleReferenceEntity ref do
    entityName := [ref mEntityTypeName] ;
  else
    error calledPropertyName: "this property should be a single or a multiple reference" -> entityName ;
  end cast ;
#--- Check a treewalking routine is actually defined
  @L_EXsignature routineSignature ;
  if [inTreewalkingRoutineHeaderMap hasKey ![entityName string]] then
    [inTreewalkingRoutineHeaderMap searchKey !entityName ?routineSignature ?*] ;
  else
    error calledPropertyName:
      "there is no treewalking routine for the '%" . [entityName string] . "' metamodel class"
      -> routineSignature
    ;
  end if ;
#--- Check argument list types
  @typeExpressionList expressionsList ;
  <actual_parameters_list>
    !routineSignature
    ?expressionsList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
    !?ioInstructionList
  ;
  $;$ ;
#--- Generate instruction
  @typeInstruction instruction := [@callInstruction new
    !calledPropertyName
    !entityName
    !propertyType
    !expressionsList
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#      extract instruction                                                  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $extract$ ;
#--- Source variable
  @AC_galgasType typeVarSource ;
  @typeCplusPlusName sourceVarCppName ;
  @lstring nomVarSource ;
  <read_access> ?nomVarSource ?sourceVarCppName ?typeVarSource !?ioVariablesMap ;
#--- Check variable has class type
  @typeGalgasClassType classType := (cast typeVarSource if >= @typeGalgasClassType else error nomVarSource) ;
  @lstring nomTypeSource := [classType mClassTypeName] ;
  @typeClassInheritedMessagesMap tableMessagesAbstraits := [classType mMessagesMap] ;
#--- Parse simple or structured extract instruction
  @typeInstruction instruction ;
  <extract_instruction>
    !inTreewalkingRoutineHeaderMap
    !inTableEnAvant
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    !sourceVarCppName
    !nomTypeSource
    !tableMessagesAbstraits
    ?instruction
    !inCurrentTreewalkingRoutinePropertyMap
    !inMetamodelEntityMap
    !inTreewalkingComponentMap
  ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#       Simple extract instruction                                          *
#---------------------------------------------------------------------------*

rule <extract_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap tableMessagesAbstraits
  !@typeInstruction outInstruction
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  warning here:"simple extract instruction is obsolete: use cast expression instead" ;
#--- Nom de la classe pour la conversion
  $->$ ;
  # warning here:"simple extract instruction is obsolete" ;
  @lstring nomClasse ;
  $type_name$ ? nomClasse ;
#--- Obtenir les caracteristiques de la classe nommee
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !nomClasse ?entite] ;
  @AC_galgasType leType := [(cast entite if >= @typeEntiteType else error nomClasse) aDefType] ;
  @typeGalgasClassType classType := (cast leType if >= @typeGalgasClassType else error nomClasse) ;
  @typeListeAttributsSemantiques listeAttributsSemantiques := [classType mNonExternAttributesList] ;
  @typeSuperClassesMap tableDesClassesAncetres := [classType mAncestorClassesMap] ;
#--- Verify class is an heir of variable type
  if not [tableDesClassesAncetres hasKey ![nomTypeSource string]] then
    error nomClasse : "This class does not inherit from '@" . [nomTypeSource string] . "'" ;
  end if ;
#--- Arguments
  @L_assignedVariables listeAffectationParametresEffectifs ;
  @typeCplusPlusNameList allVariablesList ;
  $($ ;
  <input_parameters_list>
    ?listeAffectationParametresEffectifs
    ?allVariablesList
    !listeAttributsSemantiques
    !?ioVariablesMap
  ;
  $)$ ;
#------------------------------------------------- Error message
  $error$ ;
  @typeExpression errorExpression ;
  @AC_galgasType errorExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorExpression
    ?errorExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
  @lstring messageName ;
  $identifier$ ? messageName ;
  [tableMessagesAbstraits searchKey !messageName] ;
#------------------------------------------------- Generate instruction
  outInstruction := [@typeSimpleExtractInstruction new !inSourceVarCppName
                                                       !nomClasse
                                                       !listeAffectationParametresEffectifs
                                                       !errorExpression
                                                       !messageName] ;
end rule ;

#---------------------------------------------------------------------------*
#       Structured extract instruction                                      *
#---------------------------------------------------------------------------*

rule <extract_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?@typeCplusPlusName inSourceVarCppName
  ?@lstring nomTypeSource
  ?@typeClassInheritedMessagesMap unused tableMessagesAbstraits
  !@typeInstruction outInstruction
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  @typeStructuredExtractCasesList casesList [emptyList] ;
  $:$ ;
  warning here:"structured extract instruction is obsolete: use cast instruction instead" ;
  $when$ ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @location indicatif1 := here ;
      #--- Nom du type 1
        @lstring nomType1 ;
        $type_name$ ? nomType1 ;
      #--- Verifier que la classe 'nomType1' est declaree
        @AC_semanticsEntity entite ;
        [ioComponentSemanticsEntitiesMap searchKey !nomType1 ?entite] ;
        @AC_galgasType definitionClasse1 := [(cast entite if >= @typeEntiteType else error nomType1) aDefType] ;
      #--- Verifier que la classe 'nomType1' herite de la classe 'nomTypeBase1'
        @typeGalgasClassType classType1 := (cast definitionClasse1 if >= @typeGalgasClassType else error nomType1) ;
        @typeListeAttributsSemantiques listeAttributs1 := [classType1 mNonExternAttributesList] ;
        @typeSuperClassesMap tableDesClassesAncetresType1 := [classType1 mAncestorClassesMap] ;
      #--- Verify class is an heir of variable type
        if not [tableDesClassesAncetresType1 hasKey ![nomTypeSource string]] then
          error nomType1 : "This class does not inherit from '@" . [nomTypeSource string] . "'" ;
        end if ;
      #--- Arguments du type 1
       @bool noUsedParameter ;
        <parse_effective_input_parameters_list>
          !?ioVariablesMap
          !listeAttributs1
          !indicatif1
          ![@localConstantBuildStyleEnum listStyle]
          ?noUsedParameter
        ;
      #--- Liste des instructions
        $->$ ;
        @typeInstructionList instructionsList [emptyList] ;
        <semantic_instructions_list>
          !inTreewalkingRoutineHeaderMap
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
          !inCurrentTreewalkingRoutinePropertyMap
          !inMetamodelEntityMap
          !inTreewalkingComponentMap
        ;
        casesList += !nomType1 !indicatif1 !instructionsList !noUsedParameter ;
      end block (!here) ;
    while
      $when$ ;
    end repeat ;
  #---------------------  Default error -----------------------
    block ioVariablesMap.testPart () :
      $else$ ;
      @typeInstructionList elseInstructionList [emptyList] ;
      <semantic_instructions_list>
        !inTreewalkingRoutineHeaderMap
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?elseInstructionList
        !inCurrentTreewalkingRoutinePropertyMap
        !inMetamodelEntityMap
        !inTreewalkingComponentMap
      ;
      outInstruction := [@typeStructuredExtractInstructionWithElse new
        !inSourceVarCppName !casesList !elseInstructionList
      ] ;
    end block (!here) ;
  end block () ;
  $end$ ;
  $extract$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#      cast instruction                                                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $cast$ ;
#--- Source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?sourceExpression
    ?sourceExpressionType
  ;
#--- Check variable has class type
  @typeGalgasClassType sourceClassType := (cast sourceExpressionType if >= @typeGalgasClassType else error here) ;
  @lstring sourceExpressionTypeName := [sourceClassType mClassTypeName] ;
  @string sourceClassMessage := [sourceClassType mClassMessage] ;
#--- When branches
  @typeInstructionList elseBranchInstructionsList [emptyList] ;
  @typeStructuredCastBranchList branchList [emptyList] ;
  $:$ ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        $when$ ;
        @bool checkForKindOfClass ;
        select
          $>=$ ;
          checkForKindOfClass := true ;
        or
          $==$ ;
          checkForKindOfClass := false ;
        end select ;
        @lstring castedTypeName ;
        $type_name$ ?castedTypeName ;
      #--- Check the name 'castedTypeName' refers to a type
        @AC_semanticsEntity entite ;
        [ioComponentSemanticsEntitiesMap searchKey !castedTypeName ?entite] ;
        @AC_galgasType typeDefinition := [(cast entite if >= @typeEntiteType else error castedTypeName) aDefType] ;
      #--- Check the type is a class
        @typeSuperClassesMap superClassMap :=
           [(cast typeDefinition if >= @typeGalgasClassType else error castedTypeName) mAncestorClassesMap] ;
      #--- Verify class is an heir of variable type
        @string sourceExpressionTypeNameString := [sourceExpressionTypeName string] ;
        if not checkForKindOfClass then
          if ([castedTypeName string] != sourceExpressionTypeNameString) & not [superClassMap hasKey ! sourceExpressionTypeNameString] then
            error castedTypeName : "This class is not '@" . sourceExpressionTypeNameString . "' and does inherit from it" ;
          end if ;
        elsif not [superClassMap hasKey !sourceExpressionTypeNameString] then
          error castedTypeName : "This class does not inherit from '@" . sourceExpressionTypeNameString . "'" ;
        end if ;
      #--- Parse local constant name
        @typeCplusPlusNameList localConstantCppNameList [emptyList] ;
        select
        or
          @lstring localConstantName ;
          $identifier$ ? localConstantName ;
          @typeCplusPlusName localConstantCppName := [@typeAutomaticName new ![localConstantName location] ![localConstantName string]] ;
          localConstantCppNameList += !localConstantCppName ;
          [!?ioVariablesMap insertConstInArgument !localConstantName !typeDefinition ! localConstantCppName] ;
        or
          $unused$ ;
          @lstring localConstantName ;
          $identifier$ ? localConstantName ;
          @typeCplusPlusName localConstantCppName := [@typeAutomaticName new ![localConstantName location] ![localConstantName string]] ;
          localConstantCppNameList += !localConstantCppName ;
          [!?ioVariablesMap insertUnusedConstInArgument !localConstantName !typeDefinition !localConstantCppName] ;
        end select ;
        $do$ ;
        @typeInstructionList instructionsList [emptyList] ;
        <semantic_instructions_list>
          !inTreewalkingRoutineHeaderMap
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
          !inCurrentTreewalkingRoutinePropertyMap
          !inMetamodelEntityMap
          !inTreewalkingComponentMap
        ;
        branchList += !castedTypeName !checkForKindOfClass !localConstantCppNameList !instructionsList ;
      end block (!here) ;
    while
    end repeat ;
  #--- else part
    @AC_elseOrDefaultForCastInstruction elseOrDefault ;
    block ioVariablesMap.testPart () :
      select
        $default$ ;
        if [sourceClassMessage length] == 0 then
          error here : "for using the 'default' construct, the static class of source expression (@"
                     . sourceExpressionTypeName . ") should define a class message" ;
        end if ;
        $error$ ;
        @typeExpression errorLocationExpression ;
        @AC_galgasType errorLocationExpressionType ;
        <expression>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          ?errorLocationExpression
          ?errorLocationExpressionType
        ;
      #--- Check expression has location info
        [errorLocationExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
        elseOrDefault := [@C_defaultForCastInstruction new !errorLocationExpression !here] ;
      or
        $else$ ;
        @typeInstructionList elseBranchInstructionsList [emptyList] ;
        <semantic_instructions_list_no_verif>
          !inTreewalkingRoutineHeaderMap
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?elseBranchInstructionsList
          !inCurrentTreewalkingRoutinePropertyMap
          !inMetamodelEntityMap
          !inTreewalkingComponentMap
        ;
        elseOrDefault := [@C_elseForCastInstruction new !elseBranchInstructionsList] ;
     end select ; 
    end block (!here) ;
  end block () ;
#--- Enter instruction in instruction list
  @typeInstruction instruction := [@typeStructuredCastInstruction new
    !here
    !sourceExpression
    !sourceExpressionTypeName
    !branchList
    !elseOrDefault
  ] ;
  ioInstructionList += !instruction ;
#--- End of cast instruction
  $end$ ;
  $cast$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
# Local variable declaration                                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
#--- Type name
  @AC_galgasType definitionType ;
  @lstring typeName ;
  <type_parsing>
    !inTableEnAvant
    !ioComponentSemanticsEntitiesMap
    ?definitionType
    ?typeName
  ;
#--- Variable name
  @lstring targetVarName ;
  $identifier$ ? targetVarName ;
  @typeCplusPlusName nomCppVariable := [@typeAutomaticName new ![targetVarName location] ![targetVarName string]] ;
  [!?ioVariablesMap insertLocalVariable !targetVarName !definitionType !nomCppVariable] ;
#--- Assignment ?
  <optional_assignment>
    !typeName
    !targetVarName
    !nomCppVariable
    !definitionType
    !?ioVariablesMap
    !?ioInstructionList
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction log variableName, ... ;                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $log$ ;
  repeat
    @lstring galgasVariableName ;
    $identifier$ ? galgasVariableName ;
    @typeCplusPlusName nomCppVar ;
    [!?ioVariablesMap searchForReadOnlyAccess !galgasVariableName ?* ?nomCppVar] ;
    @typeInstruction instruction := [@typeLogInstruction new !galgasVariableName !nomCppVar] ;
    ioInstructionList += !instruction ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                    Instruction drop nomVariable, ... ;                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $drop$ ;
  repeat
    @lstring nom ;
    $identifier$ ? nom ;
    @typeCplusPlusName nomCppVar ;
    [!?ioVariablesMap searchForDestructiveReadAccess !nom ?* ?nomCppVar] ;
    @typeInstruction instruction := [@typeDropInstruction new !nomCppVar] ;
    ioInstructionList += !instruction ;
  while
    $,$ ;
  end repeat ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#            R O U T I N E    C A L L    I N S T R U C T I O N              *
#                                                                           *
#                          routine_name ... ;                               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <instruction_beginning_with_identifier>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ?@lstring nomVarDest
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@entityToImplementMap unused inMetamodelEntityMap
:
#--- Verifier que le nom est bien un nom de routine
  @L_EXsignature signatureRoutine ;
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !nomVarDest ?entite] ;
  @bool isExternActionCall ;
  cast entite:
  when >= @typeEntiteRoutine r do
    signatureRoutine := [r aListeArgumentsFormels] ;
    isExternActionCall := false ;
  when >= @typeEntiteActionExterne ae do
    signatureRoutine := [ae aSignature] ;
    isExternActionCall := true ;
  else
    error nomVarDest :
     "'" . [nomVarDest string] . "' should name a routine or an extern extern routine"
     -> signatureRoutine, isExternActionCall
    ;
  end cast ;
#--- Arguments effectifs
  @typeExpressionList expressionsList ;
  <actual_parameters_list>
    !signatureRoutine
    ?expressionsList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
    !?ioInstructionList
  ;
#--- Generate instruction
  @typeInstruction instruction := [@typeRoutineCallInstruction new
    !nomVarDest
    !expressionsList
    !signatureRoutine
    !isExternActionCall
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    M E T H O D    C A L L   I N S T R U C T I O N                         *
#               [object method !... !?... ?...] ;                           *
#                                                                           *
#    M O D I F I E R    C A L L   I N S T R U C T I O N                     *
#               [!?object modifier !... !?... ?...] ;                       *
#                                                                           *
#    T Y P E    M E T H O D   C A L L    I N S T R U C T I O N              *
#               [@aType type_method_name !... !?... ?...] ;                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $[$ ;
#--- Get source identity characteristics
  @typeInstruction instruction ;
  select
    @lstring readObjectName ;
    @AC_galgasType variableType ;
    @typeCplusPlusName cppVariableName ;
    <read_access> ?readObjectName ?cppVariableName ?variableType !?ioVariablesMap ;
    @lstring methodName ;
    $identifier$ ? methodName ;
    @L_EXsignature methodSignature ;
    [variableType handleMethodInstructionCall !readObjectName !methodName ?methodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !methodSignature
      ?expressionsList
      !?ioVariablesMap
      !inOptionsComponentsMapForUse
      !ioComponentSemanticsEntitiesMap
      !?ioInstructionList
    ;
  #--- Generate instruction
    instruction := [@typeMethodCallInstruction new !cppVariableName !methodName !expressionsList] ;
  or
    $!?$ ;
    @lstring modifiedObjectName ;
    $identifier$ ? modifiedObjectName ;
    @AC_galgasType variableType ;
    @typeCplusPlusName cppVariableName ;
    [!?ioVariablesMap searchForReadWriteAccess !modifiedObjectName ?variableType ?cppVariableName] ; 
  #--- Get method name
    @lstring methodName ;
    $identifier$ ? methodName ;
    @L_EXsignature methodSignature ;
    [variableType handleModifierCall !modifiedObjectName !methodName ?methodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !methodSignature
      ?expressionsList
      !?ioVariablesMap
      !inOptionsComponentsMapForUse
      !ioComponentSemanticsEntitiesMap
      !?ioInstructionList
    ;
  #--- Generate instruction
    instruction := [@typeModifierCallInstruction new !cppVariableName !methodName !expressionsList] ;
  or #--------- TYPE METHOD
    @lstring typeName ;
    $type_name$ ? typeName ;
    @lstring typeMethodName ;
    $identifier$ ? typeMethodName ;
  #--- Retrieve type method information
    @L_EXsignature typeMethodSignature ;
    @AC_semanticsEntity theEntity  ;
    [ioComponentSemanticsEntitiesMap searchKey !typeName ? theEntity] ;
    @AC_galgasType type := [(cast theEntity if >=@typeEntiteType else error typeName) aDefType] ;
    # $ extract theEntity->@typeEntiteType (?type) error typeName : messageTypeEntite ;
    [type handleClassMethodCall !typeMethodName ?typeMethodSignature] ;
  #--- Actual parameters
    @typeExpressionList expressionsList ;
    <actual_parameters_list>
      !typeMethodSignature
      ?expressionsList
      !?ioVariablesMap
      !inOptionsComponentsMapForUse
      !ioComponentSemanticsEntitiesMap
      !?ioInstructionList
    ;
  #--- Generate instruction
    instruction := [@typeCallOfTypeMethodInstruction new
      !typeName
      !typeMethodName
      !expressionsList
    ] ;
  end select ;
  ioInstructionList += !instruction ;
  $]$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#             I N S T R U C T I O N   B E G I N N I N G                     *
#               W I T H    A N    I D E N T I F I E R                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inMetamodelPropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  @lstring nomVarDest ;
  $identifier$ ? nomVarDest ;
  <instruction_beginning_with_identifier>
    !inTreewalkingRoutineHeaderMap
    !nomVarDest
    !?ioVariablesMap 
    !?ioInstructionList
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
    !inMetamodelEntityMap
  ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           'warning ... ;' instruction                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  <warning_instruction>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    !?ioInstructionList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <warning_instruction>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
:
  $warning$ ;
  @typeExpression errorExpression ;
  @AC_galgasType errorExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorExpression
    ?errorExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
#--- Warning message
  @typeExpression warningMessageExpression ;
  @AC_galgasType warningMessageExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?warningMessageExpression
    ?warningMessageExpressionType
  ;
#--- Check that error message is a @string instance
  @typeGalgas_string gs := (cast warningMessageExpressionType if >= @typeGalgas_string else error here) ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@typeWarningInstruction new !errorExpression !warningMessageExpression !here] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           Instruction 'error ... ;'                       *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  <error_instruction>
   !ioComponentSemanticsEntitiesMap
   !inOptionsComponentsMapForUse
   !?ioVariablesMap
   !?ioInstructionList
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <error_instruction>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
:
  $error$ ;
  @typeExpression errorLocationExpression ;
  @AC_galgasType errorLocationExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorLocationExpression
    ?errorLocationExpressionType
  ;
#--- Verifier que la variable est d'une type contenant une location localisant l'error
  [errorLocationExpressionType checkAbilityToBeSilentlyConvertedToLocation] ;
  $:$ ;
#--- Error message
  @typeExpression errorMessageExpression ;
  @AC_galgasType errorMessageExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?errorMessageExpression
    ?errorMessageExpressionType
  ;
#--- Check that error message is a @string instance
  @typeGalgas_string gs := (cast errorMessageExpressionType if >= @typeGalgas_string else error here) ;
#--- Valuations fictives
  @varToDropList variablesToDrop [emptyList] ;
  select
  or
    $->$ ;
    repeat
      @lstring nomVariable ;
      $identifier$ ? nomVariable ;
      @typeCplusPlusName varCppName ;
      [!?ioVariablesMap searchForWriteAccess !nomVariable ?* ?varCppName] ;
      variablesToDrop += !varCppName ;
    while
      $,$ ;
   end repeat ;
  end select ;
  $;$ ;
#--- Build instruction and append it to instructions list
  @typeInstruction instruction := [@typeErrorInstruction new
    !errorLocationExpression
    !errorMessageExpression
    !here
    !variablesToDrop
  ] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                           'message ... ;' instruction                     *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $message$ ;
  @location instructionLocation := here ;
#--- Message
  @typeExpression messageExpression ;
  @AC_galgasType messageExpressionType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?messageExpression
    ?messageExpressionType
  ;
#--- Check that error message is a @string instance
  @typeGalgas_string gs := (cast messageExpressionType if >= @typeGalgas_string else error here) ;
#--- Construire l'instruction
  @typeInstruction instruction := [@typeMessageInstruction new !messageExpression !instructionLocation] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction 'if ... then ... elsif ... else ... end if ;'               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $if$ ;
  @L_expression_instructionsList_list listeBranchesTest [emptyList] ;
  block ioVariablesMap.testBloc () :
    repeat
      block ioVariablesMap.testPart () :
        @typeExpression testBranche ;
        @AC_galgasType resultType ;
        <expression>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          ?testBranche
          ?resultType
        ;
        @typeGalgas_bool b := (cast resultType if >= @typeGalgas_bool else error here) ;
        $then$ ;
        @typeInstructionList listeInstructionsBrancheTest [emptyList] ;
        <semantic_instructions_list_no_verif>
          !inTreewalkingRoutineHeaderMap
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheTest
          !inCurrentTreewalkingRoutinePropertyMap
          !inMetamodelEntityMap
          !inTreewalkingComponentMap
        ;
        listeBranchesTest += !testBranche !listeInstructionsBrancheTest ;
      end block (!here) ;
    while
      $elsif$ ;
    end repeat ;
    @typeInstructionList listeInstructionsBrancheAutre [emptyList] ;
    block ioVariablesMap.testPart () :
      select
      or
        $else$ ;
        <semantic_instructions_list_no_verif>
          !inTreewalkingRoutineHeaderMap
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?listeInstructionsBrancheAutre
          !inCurrentTreewalkingRoutinePropertyMap
          !inMetamodelEntityMap
          !inTreewalkingComponentMap
        ;
      end select ; 
    end block (!here) ;
    $end$ ;
    $if$ ;
  end block () ;
#--- Engendrer l'instruction
  @typeInstruction instruction ;
  instruction := [@C_if_instruction new !listeBranchesTest !listeInstructionsBrancheAutre] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction                                                             *
#     'switch exp when cst, cst: ...instructions... when ... end switch ;'  *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $switch$ ;
#--- Expression
  @typeExpression switchExpression ;
  @AC_galgasType resultType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?switchExpression
    ?resultType
  ;
#--- Check expression type in an enum type
  @typeGalgas_enum e := (cast resultType if >= @typeGalgas_enum else error here) ;
  @lstring enumTypeName := [e mEnumTypeName] ;
  @enumConstantMap enumConstantesMap := [e mEnumConstantesMap] ;
#---- When branches
  @stringset allBranchConstantSet [emptySet] ;
  @L_switchBranchlist switchBranchlist [emptyList] ;
  block ioVariablesMap.testBloc () :
    $when$ ;
    repeat
    #--- Parse constant list
      @stringset branchConstantSet [emptySet] ;
      repeat
        @lstring enumConstantName ;
        $identifier$ ? enumConstantName ;
        branchConstantSet += ![enumConstantName string] ;
        [enumConstantesMap searchKey !enumConstantName ?*] ;
        if [allBranchConstantSet hasKey ![enumConstantName string]] then
          error enumConstantName: "this constant is already used in current switch instruction" ;
        end if ;
      while
        $,$ ;
      end repeat ;
      $:$ ;
      allBranchConstantSet := allBranchConstantSet | branchConstantSet ;
      block ioVariablesMap.testPart () :
        @typeInstructionList branchInstructionList [emptyList] ;
        <semantic_instructions_list_no_verif>
          !inTreewalkingRoutineHeaderMap
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?branchInstructionList
          !inCurrentTreewalkingRoutinePropertyMap
          !inMetamodelEntityMap
          !inTreewalkingComponentMap
        ;
        switchBranchlist += !branchConstantSet !branchInstructionList ;
      end block (!here) ;
    while
      $when$ ;
    end repeat ;
  end block () ;
  $end$ ;
#--- Check all constant are named
  @stringset missingConstants := [enumConstantesMap allKeys] - allBranchConstantSet ;
  foreach missingConstants (@string kConstant) :
    error here: "the '" . kConstant . "' is not used in switch instruction" ;
  end foreach ;
#--- Generate instruction
  @typeInstruction instruction ;
  instruction := [@C_switch_instruction new !switchExpression !enumTypeName !switchBranchlist] ;
  ioInstructionList += !instruction ;
  $switch$ ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#   Instruction 'while ... do ... end while ;'                              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $loop$ ;
#--- Variant expression
  @typeExpression variantExpression ;
  @AC_galgasType variantResultType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?variantExpression
    ?variantResultType
  ;
  @typeGalgas_uint ui := (cast variantResultType if >= @typeGalgas_uint else error here) ;
  $:$ ;
#--- Repeated instruction list
  @typeInstructionList instructionList1 [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
      <semantic_instructions_list_no_verif>
        !inTreewalkingRoutineHeaderMap
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList1
        !inCurrentTreewalkingRoutinePropertyMap
        !inMetamodelEntityMap
        !inTreewalkingComponentMap
      ;
    end block (!here) ;
  end block () ;
  $while$ ;
#--- Conditionnal expression
  @typeExpression conditionalExpression ;
  @AC_galgasType resultType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?conditionalExpression
    ?resultType
  ;
  @typeGalgas_bool b := (cast resultType if >= @typeGalgas_bool else error here) ;
  $do$ ;
#--- Repeated instruction list
  @typeInstructionList instructionList2 [emptyList] ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
    #--- Liste d'instructions
      <semantic_instructions_list_no_verif>
        !inTreewalkingRoutineHeaderMap
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList2
        !inCurrentTreewalkingRoutinePropertyMap
        !inMetamodelEntityMap
        !inTreewalkingComponentMap
      ;
    end block (!here) ;
  end block () ;
  @typeInstruction  instruction := [@C_while_instruction new
    !variantExpression
    !instructionList1
    !conditionalExpression
    !instructionList2
    !here
  ] ;
  $end$ ;
  $loop$ ;
  $;$ ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    G R A M M A R    I N S T R U C T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused  inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $grammar$ ;
#--- Nom du fichier is
  @lstring grammarName ;
  $identifier$ ? grammarName ;
#--- Alt option ?
  @lstring altName ;
  select
    altName := [@lstring new !"" !here] ;
  or
    $label$ ;
    $identifier$ ? altName ;
  end select ;
#--- Parse file name
  $in$ ;
  @lstring nomFichierSource ;
  @typeCplusPlusName nomCppFichierSource ;
  @AC_galgasType typeNomFichierSource ;
  <read_access> ?nomFichierSource ?nomCppFichierSource ?typeNomFichierSource !?ioVariablesMap ;
  @typeGalgas_lstring gs := (cast typeNomFichierSource if >= @typeGalgas_lstring else error nomFichierSource) ;
#--- Analyse des arguments effectifs
  @typeExpressionList expressionsList ;
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?expressionsList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
  ;
#--- Look for grammar
  @AC_semanticsEntity e  ;
  [ioComponentSemanticsEntitiesMap searchKey !grammarName ?e] ;
  @C_grammarForSemantics gfs := (cast e if >= @C_grammarForSemantics else error grammarName) ;
  @M_nonterminalSymbolAlts startSymbolAltMap := [gfs mGrammarAltMap] ;
  @lstring lexiqueClassName := [gfs mLexiqueClassName] ;
  @L_EXsignature startSymbolSignature ;
  @lstring returnedEntity ;
  [startSymbolAltMap searchKey !altName ?startSymbolSignature ?returnedEntity] ;
#--- Verifier la coherence avec la declaration
  verifierCompatibiliteArgEffectifsSignature 
    !startSymbolSignature
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionList
    !?expressionsList
  ;
#--- returned model
  @lstring metamodelClassVariableName [new !"" !here] ;
  select
    if [returnedEntity string] != "" then
      error here: "this grammar returns an instance of '@" . [returnedEntity string] . "' metamodel entity" ; 
    end if ;
  or
    $->$ ;
    $identifier$ ? metamodelClassVariableName ;
    @AC_galgasType type ;
    [!?ioVariablesMap searchForWriteAccess !metamodelClassVariableName ?type ?*] ;
    @lstring variableEntityName :=
      [(cast type if >= @typeGalgas_singleReferenceEntity else error metamodelClassVariableName) mEntityTypeName] ;
    if [returnedEntity string] != [variableEntityName string] then
      error metamodelClassVariableName: "this variable has the '@" . [variableEntityName string]
        . "', but a variable of '@" . [returnedEntity string] . "' type is expected" ;
    end if ;
  end select ;
#--- Engendrer l'instruction
  @typeInstruction instruction ;
  instruction := [@C_grammarInstruction new
    !nomCppFichierSource
    !grammarName
    !expressionsList
    !altName
    !metamodelClassVariableName
    !lexiqueClassName
  ] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    T R E E W A L K I N G    I N S T R U C T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap unused inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant unused  inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap unused inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap unused inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $treewalking$ ;
#--- Treewalking component name
  @lstring treewalkingComponentName ;
  $identifier$ ? treewalkingComponentName ;
#--- Search for component name
  @string rootEntityName ;
  @L_EXsignature treewalkingRoutineSignature ;
  [inTreewalkingComponentMap searchKey
    !treewalkingComponentName
    ?rootEntityName
    ?treewalkingRoutineSignature
  ] ;
#--- Model Name
  $on$ ;
  @lstring modelVariableName ;
  @typeCplusPlusName cppNameForModelVariable ;
  @AC_galgasType modelVariableType ;
  <read_access>
    ?modelVariableName
    ?cppNameForModelVariable
    ?modelVariableType
    !?ioVariablesMap
  ;
#--- Check variable type
  @lstring variableEntity :=
      [(cast modelVariableType if >= @typeGalgas_singleReferenceEntity else error modelVariableName) mEntityTypeName] ;
  if [variableEntity string] != rootEntityName then
    error modelVariableName: "the '" . [modelVariableName string]
    . "' variable is an instance of '@" . [variableEntity string]
    . "', but the '" . [treewalkingComponentName string] . "' component requires an instance of '@"
    . rootEntityName . "' type" ;
  end if ;
#--- Analyse des arguments effectifs
  @typeExpressionList expressionsList ;
  @L_actualParametersSignature listeTypesParametresEffectifs ;
  <parse_parameters_list>
    ?listeTypesParametresEffectifs
    ?expressionsList
    !?ioVariablesMap
    !inOptionsComponentsMapForUse
    !ioComponentSemanticsEntitiesMap
  ;
#--- Verifier la coherence avec la declaration
  verifierCompatibiliteArgEffectifsSignature 
    !treewalkingRoutineSignature
    !listeTypesParametresEffectifs
    !here
    !?ioInstructionList
    !?expressionsList
  ;
#--- Engendrer l'instruction
  @typeInstruction instruction := [@C_treewalkingInstruction new
    !treewalkingComponentName
    !cppNameForModelVariable
    !expressionsList
  ] ;
  ioInstructionList += !instruction ;
  $;$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     Instruction 'foreach ... ;'                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $foreach$ ;
  @typeInstruction instruction ;
  block ioVariablesMap.repeatBlock () :
    block ioVariablesMap.repeatPart () :
    #--- Parse enumerated variables
      @foreachEnumerationList foreachEnumerationList [emptyList] ;
      repeat
        @location magicNumber := here ;
      #--- Ascending or descending ?
        @bool ascending ;
        select
          ascending := true ;
        or
          $<$ ;
          ascending := true ;
        or
          $>$ ;
          ascending := false ;
        end select ;
      #--- Source expression
        @typeExpression sourceExpression ;
        @AC_galgasType sourceExpressionType ;
        <expression>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          ?sourceExpression
          ?sourceExpressionType
        ;
      #--- Check this variable can be enumerated
        @typeListeAttributsSemantiques formalEnumerationList ;
        @localConstantBuildStyleEnum localConstantBuildStyleEnum ;
        [sourceExpressionType acceptForeachInstruction
          !magicNumber
          ?formalEnumerationList
          ?localConstantBuildStyleEnum
        ] ;
      #--- Extract type name
        @string typeName ;
        [sourceExpressionType getTypeName ?typeName] ;
      #--- Parse effective input attribute list
        <parse_effective_input_parameters_list>
          !?ioVariablesMap
          !formalEnumerationList
          !magicNumber
          !localConstantBuildStyleEnum
          ?*
        ;
        foreachEnumerationList += !sourceExpression !magicNumber !typeName !ascending ;
      while
        $,$ ;
      end repeat ;
    #--- While expression
      @typeExpression whileExpression ;
      select
        whileExpression := [@typeTrueBool new] ;
      or
        $while$ ;
        @AC_galgasType resultType ;
        <expression>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          ?whileExpression
          ?resultType
         ;
      end select ;
    #--- Repeated instruction list
      $:$ ;
    #--- Liste d'instructions
      @typeInstructionList instructionList [emptyList] ;
      <semantic_instructions_list_no_verif>
        !inTreewalkingRoutineHeaderMap
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?instructionList
        !inCurrentTreewalkingRoutinePropertyMap
        !inMetamodelEntityMap
        !inTreewalkingComponentMap
      ;
    end block (!here) ;
  end block () ;
  instruction := [@typeForeachInstruction new
    !foreachEnumerationList
    !whileExpression
    !instructionList
  ] ;
  $end$ ;
  $foreach$ ;
  $;$ ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     ' M A T C H '    I N S T R U C T I O N                                *
#                                                                           *
#---------------------------------------------------------------------------*

rule <parse_match_operand>
  ?!@typeVariablesMap ioVariablesMap
  !@typeCplusPlusName outCppName
  !@lstring outBaseTypeName
  !@location outVarLocation
  !@bool outIsEnumeration
  !@enumConstantMap outEnumMessageMap
:
  @lstring variableName ;
  @AC_galgasType type ;
  <read_access>
    ?variableName
    ?outCppName
    ?type
    !?ioVariablesMap
  ;
  outVarLocation := here ;
  cast type :
  when >= @typeGalgasClassType t do
    outBaseTypeName := [t mClassTypeName] ;
    outIsEnumeration := false ;
    outEnumMessageMap := [@enumConstantMap emptyMap] ;
  when >= @typeGalgas_enum e do
    outBaseTypeName := [e mEnumTypeName] ;
    outIsEnumeration := true ;
    outEnumMessageMap := [e mEnumConstantesMap] ;
  else
    @string actualTypeName ;
    [type getTypeName ?actualTypeName] ; 
    error variableName : "the type of this variable is '@" . actualTypeName
      . "' ; I was expected an enumeration type or an abstract type" 
      -> outBaseTypeName, outIsEnumeration, outEnumMessageMap ;
  end cast ;
end rule ;


#---------------------------------------------------------------------------*

rule <parse_match_case>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap ioVariablesMap
  ?@lstring inTypeName
  ?@location inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap unused inEnumMessageMap
  !@lstring outTypeName
:
#--- Nom du type 1
  $type_name$ ? outTypeName ;
#--- Verifier que la classe 'outTypeName' est declaree
  @AC_semanticsEntity entite ;
  [ioComponentSemanticsEntitiesMap searchKey !outTypeName ?entite] ;
  @AC_galgasType definitionClasse1 := [(cast entite if >= @typeEntiteType else error outTypeName) aDefType] ;
#--- Verifier que la classe 'outTypeName' herite de la classe 'baseTypeName1'
  @typeGalgasClassType classType := (cast definitionClasse1 if >= @typeGalgasClassType else error outTypeName) ;
  @typeSuperClassesMap tableDesClassesAncetresType1 := [classType mAncestorClassesMap] ;
  @typeListeAttributsSemantiques listeAttributs1 := [classType mNonExternAttributesList] ;
  @bool isAbstract := [classType mClassIsAbstract] ;
#--- Check class is not abstract
  if isAbstract then
    error outTypeName : "an abstract class is not allowed here" ;
  end if ;
#--- Verify class is an heir of variable type
  if inIsEnumeration then
    error outTypeName : "a constant of '@" . [inTypeName string] . "' enumeration type is expected here" ;
  elsif not [tableDesClassesAncetresType1 hasKey ![inTypeName string]] then
    error outTypeName : "This type does not inherit from '" . [inTypeName string] . "'" ;
  end if ;
#--- Arguments
  <parse_effective_input_parameters_list>
    !?ioVariablesMap
    !listeAttributs1
    !inVarLocation
    ![@localConstantBuildStyleEnum listStyle]
    ?*
  ;
end rule ;

#---------------------------------------------------------------------------*

rule <parse_match_case>
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeVariablesMap unused ioVariablesMap
  ?@lstring inTypeName
  ?@location unused inVarLocation
  ?@bool inIsEnumeration
  ?@enumConstantMap inEnumMessageMap
  !@lstring outEnumConstantName
:
#--- Enumeration constant
  $identifier$ ? outEnumConstantName ;
#--- Verify constant belongs to constants map
  if inIsEnumeration then
    [inEnumMessageMap searchKey !outEnumConstantName ?*] ;
  else
    error outEnumConstantName : "a class that inherit from '@" . [inTypeName string] . "' abstract class is expected here" ;
  end if ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instruction>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  $match$ ;
#--- Get first operand
  @typeCplusPlusName operand1_cppName ;
  @lstring operand1_typeName ;
  @location operand1_location ;
  @bool operand1_isEnumeration ;
  @enumConstantMap operand1_enumMessageMap ;
  <parse_match_operand>
    !?ioVariablesMap
    ?operand1_cppName
    ?operand1_typeName
    ?operand1_location
    ?operand1_isEnumeration
    ?operand1_enumMessageMap
  ;
#--- Get second operand
  $::$ ;
  @typeCplusPlusName operand2_cppName ;
  @lstring operand2_typeName ;
  @location operand2_location ;
  @bool operand2_isEnumeration ;
  @enumConstantMap operand2_enumMessageMap ;
  <parse_match_operand>
    !?ioVariablesMap
    ?operand2_cppName
    ?operand2_typeName
    ?operand2_location
    ?operand2_isEnumeration
    ?operand2_enumMessageMap
  ;
#---  Cases list
  $:$ ;
  @L_matchInstructionCasesList casesList [emptyList] ;
  block ioVariablesMap.testBloc () :
    repeat
    while
      $when$ ;
      block ioVariablesMap.testPart () :
        @lstring case1_name ;
      #--- First case 
       <parse_match_case>
          !ioComponentSemanticsEntitiesMap
          !?ioVariablesMap
          !operand1_typeName
          !operand1_location
          !operand1_isEnumeration
          !operand1_enumMessageMap
          ?case1_name
        ;
      #--- Separator
        $::$ ;
      #--- Second case
        @lstring case2_name ;
        <parse_match_case>
          !ioComponentSemanticsEntitiesMap
          !?ioVariablesMap
          !operand2_typeName
          !operand2_location
          !operand2_isEnumeration
          !operand2_enumMessageMap
          ?case2_name
        ;
      #--- Instructions list
        $:$ ;
        @typeInstructionList instructionsList [emptyList] ;
        <semantic_instructions_list>
          !inTreewalkingRoutineHeaderMap
          !inTableEnAvant
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?ioVariablesMap
          !?instructionsList
          !inCurrentTreewalkingRoutinePropertyMap
          !inMetamodelEntityMap
          !inTreewalkingComponentMap
        ;
        casesList += !case1_name !case2_name !instructionsList ;
      end block (!here) ;
    end repeat ;
  #---------------------  E L S E    P A R T -----------------------
    block ioVariablesMap.testPart () :
      $else$ ;
      @typeInstructionList elsePartInstructionsList [emptyList] ;
      <semantic_instructions_list>
        !inTreewalkingRoutineHeaderMap
        !inTableEnAvant
        !ioComponentSemanticsEntitiesMap
        !inOptionsComponentsMapForUse
        !?ioVariablesMap
        !?elsePartInstructionsList
        !inCurrentTreewalkingRoutinePropertyMap
        !inMetamodelEntityMap
        !inTreewalkingComponentMap
      ;
    end block (!here) ;
  end block () ;
  $end$ ;
  $match$ ;
  $;$ ;
#--- Insert instruction
  @typeInstruction instruction := [@typeMatchInstruction new !operand1_location
                                                             !operand2_location
                                                             !operand1_cppName
                                                             !operand2_cppName
                                                             !operand1_typeName
                                                             !operand2_typeName
                                                             !operand1_isEnumeration
                                                             !operand2_isEnumeration
                                                             !casesList
                                                             !elsePartInstructionsList] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <semantic_instructions_list_no_verif>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap inCurrentTreewalkingRoutinePropertyMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@M_treewalkingComponents inTreewalkingComponentMap
:
  repeat
  while
    <semantic_instruction>
      !inTreewalkingRoutineHeaderMap
      !inTableEnAvant
      !ioComponentSemanticsEntitiesMap
      !inOptionsComponentsMapForUse
      !?ioVariablesMap
      !?ioInstructionList
      !inCurrentTreewalkingRoutinePropertyMap
      !inMetamodelEntityMap
      !inTreewalkingComponentMap
    ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                 Affection optionnelle dans une declaration                *
#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring unused inTargetVarName
  ??@typeCplusPlusName inVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap unused ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
:
  @typeInstruction instruction := [@typeInstructionDeclarationVarLocale new !inVariableCppName !inVariableType] ;
  ioInstructionList += !instruction ;
end rule ;

#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring unused inTypeName
  ??@lstring inTargetVarName
  ??@typeCplusPlusName inTargetVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  $:=$ ;
#--- Parse source expression
  @typeExpression sourceExpression ;
  @AC_galgasType sourceType ;
  <expression>
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
    ?sourceExpression
    ?sourceType
  ;
#--- Match target and source types
  checkAssignmentTypesCompatibility !inVariableType !sourceType !here !true ;
#--- Generate instruction
  @typeInstruction instruction := [@C_declarationInstructionWithAssignment new !inVariableType !inTargetVariableCppName !sourceExpression] ;
  ioInstructionList += !instruction ;
#--- Indicate variable is written
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?* ?*] ;
end rule ;

#---------------------------------------------------------------------------*

rule <optional_assignment>
  ??@lstring inTypeName
  ??@lstring inTargetVarName
  ??@typeCplusPlusName inTargetVariableCppName
  ??@AC_galgasType inVariableType
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
#--- Indicate variable is written
  $[$ ;
#--- Class method name
  @lstring constructorName ;
  $identifier$ ? constructorName ;
  @typeListeAttributsSemantiques listeAttributsSemantiques ;
  [inVariableType handleConstructorCall !constructorName ?listeAttributsSemantiques] ;
#--- Actual arguments
  @typeExpressionList expressionList ;
  <output_expression_list>
    ?expressionList
    !listeAttributsSemantiques
    !ioComponentSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?ioVariablesMap
  ;
  $]$ ;
#--- Generate instruction
  @typeExpression  e := [@typeConstructorExpression new 
    ![inTypeName string]
    ![constructorName string]
    !expressionList
  ] ;
  ioInstructionList += ![@C_declarationInstructionWithAssignment new !inVariableType !inTargetVariableCppName !e] ;
#--- Indicate variable is written
  [!?ioVariablesMap searchForWriteAccess !inTargetVarName ?* ?*] ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P I N D E X    D E C L A R A T I O N                                 *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $mapindex$ ;
  @lstring mapindexTypeName ;
  $type_name$ ? mapindexTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![mapindexTypeName string]]
         | [ioComponentSemanticsEntitiesMap hasKey ![mapindexTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapindexType new !mapindexTypeName] ;
      [!?tableEnAvant insertKey !mapindexTypeName !t] ;
    end if ;
  or
    $($ ;
    @lstring mapTypeName ;
    $type_name$ ? mapTypeName ;
    @AC_semanticsEntity theEntity ;
    [ioComponentSemanticsEntitiesMap searchKey !mapTypeName ? theEntity] ;
    @AC_galgasType aType := [(cast theEntity if >= @typeEntiteType else error mapTypeName) aDefType] ;
    @typeGalgasMapType mapType := (cast aType if >= @typeGalgasMapType else error mapTypeName) ;
    @typeListeAttributsSemantiques mapAttributesList := [mapType mNonExternAttributesList] ;
    @typeTableBlocsDeTable tableMethodesSurcharger := [mapType aTableMethodesSurcharger] ;
    @mapModifierMap modifierMethodMap := [mapType mModifierMethodMap] ;
    @mapMethodMap readerMethodMap := [mapType mReaderMethodMap] ;
    $)$ ;
    ${$ ;
    @mapIndexSearchReaderMap mapIndexSearchReaderMap [emptyMap] ;
    repeat
    while
      $search$ ;
      @lstring searchReaderName ;
      $identifier$ ? searchReaderName ;
      $error$ ;
      $message$ ;
      @lstring mapindexErrorMessage ;
      $literal_string$ ? mapindexErrorMessage ;
      check_KL_escapeCharacters !mapindexErrorMessage ;
      [!?mapIndexSearchReaderMap insertKey !searchReaderName !mapindexErrorMessage] ;
      $;$ ;
    end repeat ;
    $}$ ;
    @AC_galgasType t := [@typeGalgasMapindexType new 
      !mapindexTypeName
      !mapTypeName
      !mapAttributesList
      !mapIndexSearchReaderMap
      !tableMethodesSurcharger
      !modifierMethodMap
      !readerMethodMap
    ] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapindexTypeName ![@typeEntiteType new !t]] ;
    @typeEntityToGenerate e := [@C_mapindexToImplement new
      !mapindexTypeName
      !mapTypeName
      !mapAttributesList
      !mapIndexSearchReaderMap
    ] ;
    listeEntitesAengendrer += !e ;
  end select ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $mapindex$ ;
  @lstring mapindexTypeName ;
  $type_name$ ? mapindexTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![mapindexTypeName string]]
         | [ioComponentSemanticsEntitiesMap hasKey ![mapindexTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapindexType new !mapindexTypeName] ;
      [!?tableEnAvant insertKey !mapindexTypeName !t] ;
    end if ;
  or
    $($ ;
    @lstring mapTypeName ;
    $type_name$ ? mapTypeName ;
    @AC_semanticsEntity theEntity ;
    [ioComponentSemanticsEntitiesMap searchKey !mapTypeName ? theEntity] ;
    @AC_galgasType aType := [(cast theEntity if >= @typeEntiteType else error mapTypeName) aDefType] ;
    @typeGalgasMapType mapType := (cast aType if >= @typeGalgasMapType else error mapTypeName) ;
    @typeListeAttributsSemantiques mapAttributesList := [mapType mNonExternAttributesList] ;
    @typeTableBlocsDeTable tableMethodesSurcharger := [mapType aTableMethodesSurcharger] ;
    @mapModifierMap modifierMethodMap := [mapType mModifierMethodMap] ;
    @mapMethodMap readerMethodMap := [mapType mReaderMethodMap] ;
    $)$ ;
    ${$ ;
    @mapIndexSearchReaderMap mapIndexSearchReaderMap [emptyMap] ;
    repeat
    while
      $search$ ;
      @lstring searchReaderName ;
      $identifier$ ? searchReaderName ;
      $error$ ;
      $message$ ;
      @lstring mapindexErrorMessage ;
      $literal_string$ ? mapindexErrorMessage ;
      check_KL_escapeCharacters !mapindexErrorMessage ;
      [!?mapIndexSearchReaderMap insertKey !searchReaderName !mapindexErrorMessage] ;
      $;$ ;
    end repeat ;
    $}$ ;
    @AC_galgasType t := [@typeGalgasMapindexType new 
      !mapindexTypeName
      !mapTypeName
      !mapAttributesList
      !mapIndexSearchReaderMap
      !tableMethodesSurcharger
      !modifierMethodMap
      !readerMethodMap
    ] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapindexTypeName ![@typeEntiteType new !t]] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#  M A P    D E C L A R A T I O N                                           *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $map$ ;
  @lstring mapTypeName ;
  $type_name$ ? mapTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![mapTypeName string]]
         | [ioComponentSemanticsEntitiesMap hasKey ![mapTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapType new !mapTypeName] ;
      [!?tableEnAvant insertKey !mapTypeName !t] ;
    end if ;
  or
  #--- map generique C++ utilisee
    $class$ ;
    @lstring cppClassName ;
    $identifier$ ?cppClassName ;
    warning cppClassName: "old style map definition" ;
    $;$ ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
    repeat
    while
      $insert$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      insertMethodList += !nomMethode ![errorMessage string] !true !"" ; # Bool parameter has any value
    while 
      $search$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      searchMethodList += !nomMethode ![errorMessage string] !true !"" ; # Bool parameter has any value
    while
      $block$ ;
      @lstring nomMethode ;
      $identifier$ ? nomMethode ;
      $:$ ;
      @L_EXsignature signatureDebut ;
      @typeVariablesMap tableDebut [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeDebut ; 
      $($ ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?signatureDebut
        !?tableDebut
        ?listeTypesEtNomsArgMethodeDebut
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $:$ ;
      @L_EXsignature signatureFin ;
      @typeVariablesMap tableFin [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeFin ; 
      $($ ;
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?signatureFin
        !?tableFin
        ?listeTypesEtNomsArgMethodeFin
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $;$ ;
      [!?tableMethodesBloc insertKey !nomMethode !signatureDebut !signatureFin] ;
    end repeat ;
  #--- Attributs de la map
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Build insert and search method map
    @mapModifierMap mapModifierMethodMap [emptyMap] ;
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    foreach insertMethodList (@lstring kKey ...) :
    #--- Insert Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !kKey !methodSignature] ;
    #--- Insert Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey string] . "GetIndex" ![kKey location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
    foreach searchMethodList (@lstring kKey ...) :
   #--- insert method
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !kKey !methodSignature] ;
   #--- insert method GetIndex
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey string] . "GetIndex" ![kKey location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      ![@mapMethodMap emptyMap]
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
  #--- Insertion dans la map des classes definies dans le fichier source courant
    @typeEntityToGenerate def := [@typeDefinitionTableAimplementer new !mapTypeName
                                                                       !listeTousAttributsSemantiques
                                                                       !cppClassName
                                                                       !insertMethodList
                                                                       !searchMethodList
                                                                       !tableMethodesBloc] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  or
    ${$ ;
  #--- Parse Map attributes
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @insertOrSearchMethodList removeMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
  #--- Build insert and search method map
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    @mapModifierMap mapModifierMethodMap [emptyMap] ;
    @mapMethodMap mapReaderMethodMap [emptyMap] ;
    repeat
    while
      $remove$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      check_KL_escapeCharacters !errorMessage ;
      $;$ ;
    #--- Insert method
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
      removeMethodList += !methodName ![errorMessage string] !false !"" ;
   #-- Insert And Get Index Method
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !outPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        removeMethodList += !getIndexMethodName ![errorMessage string] !true !"" ;
      end if ;
    while
      $insert$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      check_KL_escapeCharacters !errorMessage ;
      @string shadowErrorMessage ;
      select
        shadowErrorMessage := "" ;
      or
        $,$ ;
        @lstring shadowErrorMessageString ;
        $literal_string$ ? shadowErrorMessageString ;
        check_KL_escapeCharacters !shadowErrorMessageString ;
        shadowErrorMessage := [shadowErrorMessageString string] ;
      end select ;
      $;$ ;
    #--- Insert method
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
      insertMethodList += !methodName ![errorMessage string] !false !shadowErrorMessage ;
   #-- Insert And Get Index Method
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !inPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        insertMethodList += !getIndexMethodName ![errorMessage string] !true !shadowErrorMessage ;
      end if ;
    while
      $search$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      @lstring errorMessage ;
      <map_method> ?methodName ?getIndexMethodName ?errorMessage ;
      check_K_escapeCharacters !errorMessage ;
      $;$ ;
    #--- Insert search method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapReaderMethodMap insertKey !methodName !methodSignature] ;
      searchMethodList += !methodName ![errorMessage string] !false !"" ;
    #--- Insert 'Get Index' search method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
         getIndexMethodSignature += !kAttributType !outPassingMode ;      
        end foreach ;
        [!?mapReaderMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
        searchMethodList += !getIndexMethodName ![errorMessage string] !true !"" ;
      end if ;
    end repeat ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      !mapReaderMethodMap
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
  #--- Insertion dans la map des classes definies dans le fichier source courant
    @typeEntityToGenerate def := [@C_mapToImplement new
      !mapTypeName
      !listeTousAttributsSemantiques
      !insertMethodList
      !searchMethodList
      !removeMethodList
    ] ;
    listeEntitesAengendrer += !def ;
    $}$ ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $map$ ;
  @lstring mapTypeName ;
  $type_name$ ? mapTypeName ;
  select
    $;$ ;
    if not([tableEnAvant hasKey ![mapTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![mapTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedMapType new !mapTypeName] ;
      [!?tableEnAvant insertKey !mapTypeName !t] ;
    end if ;
  or
  #--- map generique C++ utilisee
    $class$ ;
    @lstring cppClassName ;
    $identifier$ ?cppClassName ;
    $;$ ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @insertOrSearchMethodList insertMethodList [emptyList] ;
    @insertOrSearchMethodList searchMethodList [emptyList] ;
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
    repeat
    while
      $insert$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      insertMethodList += !nomMethode ![errorMessage string] !true !"" ; #bool parameter can have any value
    while 
      $search$ ;
      @lstring nomMethode ;
      @lstring errorMessage ;
      <ex_map_method> ?nomMethode ?errorMessage ;
      $;$ ;
      searchMethodList += !nomMethode ![errorMessage string] !true !"" ; #bool parameter can have any value
    while
      $block$ ;
      @lstring nomMethode ;
      $identifier$ ? nomMethode ;
      $:$ ;
      @L_EXsignature signatureDebut ;
      @typeVariablesMap tableDebut [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeDebut ; 
      $($ ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?signatureDebut
        !?tableDebut
        ?listeTypesEtNomsArgMethodeDebut
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $:$ ;
      @L_EXsignature signatureFin ;
      @typeVariablesMap tableFin [emptyMap] ;
      @typeListeTypesEtNomsArgMethode listeTypesEtNomsArgMethodeFin ; 
      $($ ;
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?signatureFin
        !?tableFin
        ?listeTypesEtNomsArgMethodeFin
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      $)$ ;
      $;$ ;
      [!?tableMethodesBloc insertKey !nomMethode !signatureDebut !signatureFin] ;
    end repeat ;
  #--- Attributs de la map
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Build insert and search method map
    @mapModifierMap mapModifierMethodMap [emptyMap] ;
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    foreach insertMethodList (@lstring kKey ...) :
    #--- Insert Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !kKey !methodSignature] ;
    #--- Insert Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey string] . "GetIndex" ![kKey location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
    foreach searchMethodList (@lstring kKey ...) :
    #--- Search Methods
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !kKey !methodSignature] ;
    #--- Search Get Index Methods
      methodSignature := [@L_EXsignature emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      methodSignature += !luintType !outPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      @lstring insertKeyAndGetIndexName [new ![kKey string] . "GetIndex" ![kKey location]] ;
      [!?mapModifierMethodMap insertKey !insertKeyAndGetIndexName !methodSignature] ;
    end foreach ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
      !mapTypeName
      !listeTousAttributsSemantiques
      !tableMethodesBloc
      !mapModifierMethodMap
      ![@mapMethodMap emptyMap]
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
    @TypeModel type := [@MapModel new ! attributeListModel] ;
    [!?ioModelMap insertKey !mapTypeName !type] ;
    $}$ ;
  or
    ${$ ;
  #--- Map attributes
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
  #--- Declaration des methodes d'insertion, de recherche, et de block
    @typeTableBlocsDeTable tableMethodesBloc [emptyMap] ;
  #--- Build insert and search method map
    @formalArgumentPassingMode inPassingMode [argumentIn] ;
    @formalArgumentPassingMode outPassingMode [argumentOut] ;
    @AC_galgasType lstringType := [@typeGalgas_lstring new] ;
    @AC_galgasType luintType := [@typeGalgas_luint new] ;
    @mapModifierMap mapModifierMethodMap [emptyMap] ;
    @mapMethodMap mapReaderMethodMap [emptyMap] ;
    repeat
    while
      $remove$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      $;$ ;
    #--- Enter insert method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'GetIndex' insert method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !outPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
      end if ;
    while
      $insert$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      select
      or
        $,$ ;
        $literal_string$ ? * ;
      end select ;
      $;$ ;
    #--- Enter insert method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ;
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !inPassingMode ;      
      end foreach ;
      [!?mapModifierMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'GetIndex' insert method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature [emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ;
        getIndexMethodSignature += !luintType !outPassingMode ;
        foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !inPassingMode ;      
        end foreach ;
        [!?mapModifierMethodMap insertKey !getIndexMethodName ! getIndexMethodSignature] ;
      end if ;
    while
      $search$ ;
      @lstring methodName ;
      @lstring getIndexMethodName ;
      <map_method> ?methodName ?getIndexMethodName ?* ;
      $;$ ;
    #--- Enter search method in modifier map
      @L_EXsignature methodSignature [emptyList] ;
      methodSignature += !lstringType !inPassingMode ; # Key
      foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
        methodSignature += !kAttributType !outPassingMode ;      
      end foreach ;
      [!?mapReaderMethodMap insertKey !methodName !methodSignature] ;
    #--- Enter 'Get Index' search method in modifier map (if any)
      if [getIndexMethodName string] != "" then
        @L_EXsignature getIndexMethodSignature := [@L_EXsignature emptyList] ;
        getIndexMethodSignature += !lstringType !inPassingMode ; # Key
        getIndexMethodSignature += !luintType !outPassingMode ; # Returned Index
        foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType ...) :
          getIndexMethodSignature += !kAttributType !outPassingMode ;      
        end foreach ;
        [!?mapReaderMethodMap insertKey !getIndexMethodName !getIndexMethodSignature] ;
      end if ;
    end repeat ;
  #--- Insertion dans la map des entites utilisables
    @AC_galgasType c := [@typeGalgasMapType new
     !mapTypeName
     !listeTousAttributsSemantiques
     !tableMethodesBloc
     !mapModifierMethodMap
     !mapReaderMethodMap
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !mapTypeName !entite] ;
    @TypeModel type := [@MapModel new ! attributeListModel] ;
    [!?ioModelMap insertKey !mapTypeName !type] ;
    $}$ ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*

rule <ex_map_method>
  !@lstring nomMethode
  !@lstring outMessage
:
  $identifier$ ? nomMethode ;
  $error$ ;
  $message$ ;
  $literal_string$ ? outMessage ;
end rule ;

#---------------------------------------------------------------------------*

rule <map_method>
  !@lstring methodName
  !@lstring getIndexMethodName
  !@lstring outMessage
:
  $identifier$ ?methodName ;
  select
    getIndexMethodName := [@lstring new !"" !here] ;
  or
    $,$ ;
    $identifier$ ?getIndexMethodName ;
  end select ;
  $error$ ;
  $message$ ;
  $literal_string$ ? outMessage ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     L I S T   T Y P E   D E C L A R A T I O N                             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $list$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    @L_EXsignature inputSignature [emptyList] ;
    foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType @lstring kNomAttribut) :
      extractSignature += !kAttributType ![@formalArgumentPassingMode argumentOut] ;
      inputSignature += !kAttributType ![@formalArgumentPassingMode argumentIn] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
      !inputSignature
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @typeEntityToGenerate def := [@C_listTypeToImplement new
      !listTypeName
      !listeTousAttributsSemantiques
    ] ;
    listeEntitesAengendrer += !def ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $list$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListModel attributeListModel [emptyList] ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    @L_EXsignature inputSignature [emptyList] ;
    foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType @lstring kNomAttribut) :
      extractSignature += !kAttributType ![@formalArgumentPassingMode argumentOut] ;
      inputSignature += !kAttributType ![@formalArgumentPassingMode argumentIn] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
      !inputSignature
    ] ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @TypeModel t := [@ListModel new !attributeListModel] ;
    [!?ioModelMap insertKey !listTypeName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     S O R T E D    L I S T   T Y P E   D E C L A R A T I O N              *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $sortedlist$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedSortedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    @typeListModel attributeListModel [emptyList] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType @lstring kNomAttribut) :
      extractSignature += !kAttributType ![@formalArgumentPassingMode argumentOut] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasSortedListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
    ] ;
  #--- Parse sort attributes
    ${$ ;
    @EXsortDescriptorList sortDescriptorList [emptyList] ;
    @stringset usedSortedAttributes [emptySet] ;
    repeat
      @lstring sortAttribute ;
      $identifier$ ? sortAttribute ;
      if [usedSortedAttributes hasKey ![sortAttribute string]] then 
        error sortAttribute: "this attribute is already used in sort list" ;
      else
        @AC_galgasType definitionType ;
        [tableAttributs searchKey !sortAttribute ?definitionType] ;
        [definitionType acceptToBeSortKeyInSortedListDefinition !sortAttribute] ;
        usedSortedAttributes += ![sortAttribute string] ;
      end if ;
      @bool ascendingOrder ;
      select
        $<$ ;
        ascendingOrder := true ;
      or
        $>$ ;
        ascendingOrder := false ;
      end select ;
      sortDescriptorList += !sortAttribute !ascendingOrder ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @typeEntityToGenerate def := [@C_sortedListTypeToImplement new
      !listTypeName
      !listeTousAttributsSemantiques
      !sortDescriptorList
    ] ;
    listeEntitesAengendrer += !def ;
  end select ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $sortedlist$ ;
  @lstring listTypeName ;
  $type_name$ ? listTypeName ;
  select
    $;$ ;
    if not ([tableEnAvant hasKey ![listTypeName string]] | [ioComponentSemanticsEntitiesMap hasKey ![listTypeName string]]) then
      @AC_galgasType t := [@typeGalgasUndefinedSortedListType new ! listTypeName] ;
      [!?tableEnAvant insertKey ! listTypeName !t] ;
    end if ;
  or
    ${$ ;
  #-- Declaration des attributs de la list
    @typeListModel attributeListModel [emptyList] ;
    @typeListeAttributsSemantiques listeTousAttributsSemantiques [emptyList] ;
    @typeListeAttributsSemantiques listeAttributsSemantiquesCourants ;
    @typeSemanticAttributesMap tableAttributs [emptyMap] ;
    <attributes_definition_list>
      !tableEnAvant
      !?attributeListModel
      !?tableAttributs
      !?listeTousAttributsSemantiques
      ?listeAttributsSemantiquesCourants
      !?ioComponentSemanticsEntitiesMap
    ;
    @L_EXsignature extractSignature [emptyList] ;
    foreach listeTousAttributsSemantiques (@AC_galgasType kAttributType @lstring kNomAttribut) :
      extractSignature += !kAttributType ![@formalArgumentPassingMode argumentOut] ;
    end foreach ;
  #--- Construction de l'attribut semantique
    $}$ ;
    @AC_galgasType c := [@typeGalgasSortedListType new
      !listTypeName
      !listeTousAttributsSemantiques
      !extractSignature
    ] ;
  #--- Parse sort attributes
    ${$ ;
    repeat
      $identifier$ ? * ;
      select
        $<$ ;
      or
        $>$ ;
      end select ;
    while
      $,$ ;
    end repeat ;
    $}$ ;
    @AC_semanticsEntity entite := [@typeEntiteType new !c] ;
    [!?ioComponentSemanticsEntitiesMap insertKey !listTypeName !entite] ;
    @TypeModel t := [@ListModel new !attributeListModel] ;
    [!?ioModelMap insertKey !listTypeName !t] ;
  end select ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                 LISTE DE DEFINITION DES ATTRIBUTS SEMANTIQUES             *
#                                                                           *
#---------------------------------------------------------------------------*

rule <attributes_definition_list>
  ??@typeTableEnAvant inTableEnAvant
  ?!@typeListModel outAttributeListModel
  ?!@typeSemanticAttributesMap tableAttributs
  ?!@typeListeAttributsSemantiques listeTousAttributsSemantiques # herites et definis dans la classe courante
  !@typeListeAttributsSemantiques listeAttributsSemantiquesCourants # definis dans la classe courante
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
:
  listeAttributsSemantiquesCourants := [@typeListeAttributsSemantiques emptyList] ;
  outAttributeListModel := [@typeListModel emptyList] ;
  repeat
  while
  #--- Type name
    @AC_galgasType definitionType ;
    @lstring typeName ;
    <type_parsing>
      !inTableEnAvant
      !ioComponentSemanticsEntitiesMap
      ?definitionType
      ?typeName
     ;
  #--- Formal argument
    @lstring attributeName ;
    $identifier$ ? attributeName ;
    [!?tableAttributs insertKey ! attributeName !definitionType] ;
    listeTousAttributsSemantiques += !definitionType ! attributeName ;
    listeAttributsSemantiquesCourants += !definitionType ! attributeName ;
    outAttributeListModel += !typeName ;
    $;$ ;
  end repeat ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     W R A P P E R    D E C L A R A T I O N                                *
#                                                                           *
#---------------------------------------------------------------------------*

routine recursivelyEnumerateDirectories
  ??@string inAbsoluteSourcePath
  ??@wrapperExtensionMap inExtensionMap
  !@wrapperFileSortedList outWrapperFileSortedList
  !@wrapperDirectorySortedList outWrapperDirectorySortedList :
#--- Enumerates regular files
  @stringlist files := [inAbsoluteSourcePath regularFiles !false] ;
  outWrapperFileSortedList := [@wrapperFileSortedList emptySortedList] ;
  foreach files (@string kFile) :
    if [inExtensionMap hasKey ![kFile pathExtension]] then
      outWrapperFileSortedList += !kFile !inAbsoluteSourcePath . "/" . kFile ;
    end if ;
  end foreach ;
#--- Enumerates regular directories
  @stringlist directories := [inAbsoluteSourcePath directories !false] ;
  outWrapperDirectorySortedList := [@wrapperDirectorySortedList emptySortedList] ;
  foreach directories (@string kDirectory) :
    @wrapperFileSortedList internalWrapperFileSortedList ;
    @wrapperDirectorySortedList internalWrapperDirectorySortedList ;
    recursivelyEnumerateDirectories
      !inAbsoluteSourcePath . "/" . kDirectory
      !inExtensionMap
      ?internalWrapperFileSortedList
      ?internalWrapperDirectorySortedList
    ;
    outWrapperDirectorySortedList +=
      !kDirectory
      !internalWrapperFileSortedList
      !internalWrapperDirectorySortedList
    ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
:
  $filewrapper$ ;
  @lstring wrapperName ;
  $identifier$ ? wrapperName ;
  [!?ioFileWrappers insertKey ! wrapperName] ;
  $in$ ;
  @lstring sourcePath ;
  $literal_string$ ? sourcePath ;
  ${$ ;
  @wrapperExtensionMap extensionMap [emptyMap] ;
  repeat
    @lstring extension ;
    $literal_string$ ? extension ;
    [!?extensionMap insertKey !extension] ;
  while
    $,$ ;
  end repeat ;
  $}$ ;
#--- Build absolute path
  @string absoluteSourcePath ;
  if [sourcePath firstCharacterOrNul] == '/' then
    absoluteSourcePath := [sourcePath string] ;
  else
    absoluteSourcePath := [[@string stringWithSourceFilePath] stringByDeletingLastPathComponent] . "/" . [sourcePath string] ;
  end if ;
  if not [absoluteSourcePath directoryExists] then
    error sourcePath: "The '" . absoluteSourcePath . "' directory does not exist" ;
  else
  #--- Enumerate pathes
    @wrapperFileSortedList wrapperFileSortedList ;
     @wrapperDirectorySortedList wrapperDirectorySortedList ;
    recursivelyEnumerateDirectories !absoluteSourcePath !extensionMap ?wrapperFileSortedList ?wrapperDirectorySortedList ;
  #---- Enter wrapper in generated list
    @typeEntityToGenerate w := [@C_wrapperToImplement new
      !wrapperName
      ![sourcePath string]
      !extensionMap
      !wrapperFileSortedList
      !wrapperDirectorySortedList
    ] ;
    listeEntitesAengendrer += !w ;
  end if ;
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse unused ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers ioFileWrappers
:
  $filewrapper$ ;
  @lstring wrapperName ;
  $identifier$ ? wrapperName ;
  [!?ioFileWrappers insertKey ! wrapperName] ;
  $in$ ;
  $literal_string$ ? * ;
  ${$ ;
  repeat
    $literal_string$ ? * ;
  while
    $,$ ;
  end repeat ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     E X T E R N   T Y P E   D E C L A R A T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $extern$ ;
  <semantics_declaration_begining_by_extern>
    !?ioComponentSemanticsEntitiesMap
    !?listeEntitesAengendrer
    !inOptionsComponentsMapForUse
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
    !inTreewalkingComponentMap
  ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer tableRoutinesAimplementer
  ??@M_treewalkingComponents inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $extern$ ;
  <semantics_declaration_begining_by_extern> importSemantics
    !?ioModelMap
    !?ioExternActionMap
    !?ioComponentSemanticsEntitiesMap
    !?tableNomRoutinesDeclarees
    !?tableEnAvant
    !?tableRoutinesAimplementer
    !inTreewalkingComponentMap
  ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#     E X T E R N   T Y P E   D E C L A R A T I O N                         *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_begining_by_extern>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
#--- Parse extern type name
  @lstring externTypeName ;
  $type_name$ ? externTypeName ;
  ${$ ;
#--- Default behaviour : no operator, no method available
  @typeTableMethodes modifiersMap [emptyMap] ;
  @typeTableMethodes readersInInstructionMap [emptyMap] ;
  @bool acceptAddAssignOperatorCall := false ;
  @typeListeAttributsSemantiques addAssignOperatorCallTypeList [emptyList] ;
  @M_externTypeConstructorMap constructorsMap [emptyMap] ;
#--- Parse class operators and methods
  repeat
  while
    $constructor$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques constructorArgumentTypesList [emptyList] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !ioComponentSemanticsEntitiesMap
        ?type_semantique
        !?tableEnAvant
        ?galgasTypeName
      ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      constructorArgumentTypesList += !type_semantique !parameterName ;
    end repeat ;
    $;$ ;
    [!?constructorsMap insertKey !constructorName !constructorArgumentTypesList] ;
  while
    $method$ ;
  #--- Method name
    @lstring methodName ;
    $identifier$ ? methodName ;
  #--- Formal parameters
    @L_EXsignature listeDeTypes ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @L_signature signatureForGrammarComponent ; # Not used here
    <formal_arguments_list>
      !ioComponentSemanticsEntitiesMap
      ?listeDeTypes
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signatureForGrammarComponent
    ;
    $;$ ;
    [!?readersInInstructionMap insertKey !methodName !listeDeTypes] ;
  while
    $modifier$ ;
    select
    #--- Method name
      @lstring methodName ;
      $identifier$ ? methodName ;
    #--- Formal parameters
      @L_EXsignature listeDeTypes ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @typeVariablesMap tableArgumentsMethode [emptyMap] ;
      @L_signature signatureForGrammarComponent ; # Not used here
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?listeDeTypes
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signatureForGrammarComponent
      ;
      [!?modifiersMap insertKey !methodName !listeDeTypes] ;
    or
      $+=$ ;
      @location errorLocation := here ;
      repeat
      while
        $?$ ;
        @AC_galgasType type_semantique ;
        @lstring galgasTypeName ; # Not used here
        <formal_argument_type>
          !ioComponentSemanticsEntitiesMap
          ?type_semantique
          !?tableEnAvant
          ?galgasTypeName
        ;
        @lstring parameterName ;
        $identifier$ ? parameterName ;
        addAssignOperatorCallTypeList += !type_semantique !parameterName ;
      end repeat ;
      if acceptAddAssignOperatorCall then
        error errorLocation : "'+=' operator is already defined" ;
      else
        acceptAddAssignOperatorCall := true ;
      end if ;
    end select ;
    $;$ ;
  end repeat ;
#--- enter the new type into the list of entities to be generated
  @typeEntityToGenerate t := [@typeExternTypeToGenerate new
    !externTypeName
    !constructorsMap
    !modifiersMap
    !readersInInstructionMap
    !acceptAddAssignOperatorCall
    !addAssignOperatorCallTypeList
  ] ;
  listeEntitesAengendrer += !t ;
#--- Enter the new type in entities map
  @AC_galgasType c := [@typeGalgasExternType new
    !externTypeName
    !constructorsMap
    !modifiersMap
    !readersInInstructionMap
    !acceptAddAssignOperatorCall
    !addAssignOperatorCallTypeList
  ] ;
  @AC_semanticsEntity e := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !externTypeName !e] ;
  $}$ ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
#--- Parse extern type name
  @lstring externTypeName ;
  $type_name$ ? externTypeName ;
  ${$ ;
#--- Default behaviour : no operator, no method available
  @typeTableMethodes EXmodifiersMap [emptyMap] ;
  @typeTableMethodes readersInInstructionMap [emptyMap] ;
  @bool acceptAddAssignOperatorCall := false ;
  @typeListeAttributsSemantiques addAssignOperatorCallTypeList [emptyList] ;
  @M_externTypeConstructorMap EXconstructorsMap [emptyMap] ;
  @constructorMap constructorMap [emptyMap] ;
  @readerMap readerMap [emptyMap] ;
  @modifierMap modifierMap [emptyMap] ;
  @typeListModel addAssignFormalInputArgumentList [emptyList] ; # List is empty if += operator is not defined
#--- Parse class operators and methods
  repeat
  while
    $constructor$ ;
    @lstring constructorName ;
    $identifier$ ? constructorName ;
    @typeListeAttributsSemantiques constructorArgumentTypesList [emptyList] ;
    @typeListModel formalInputArgumentList [emptyList] ;
    repeat
    while
      $?$ ;
      @AC_galgasType type_semantique ;
      @lstring galgasTypeName ; # Not used here
      <formal_argument_type>
        !ioComponentSemanticsEntitiesMap
        ?type_semantique
        !?tableEnAvant
        ?galgasTypeName
      ;
      @lstring parameterName ;
      $identifier$ ? parameterName ;
      constructorArgumentTypesList += !type_semantique !parameterName ;
      formalInputArgumentList += !galgasTypeName ;
    end repeat ;
    $;$ ;
    [!?EXconstructorsMap insertKey !constructorName !constructorArgumentTypesList] ;
    [!?constructorMap insertKey !constructorName ! formalInputArgumentList] ;
  while
    $method$ ;
  #--- Reader name
    @lstring readerName ;
    $identifier$ ? readerName ;
  #--- Formal parameters
    @L_EXsignature listeDeTypes ;
    @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
    @typeVariablesMap tableArgumentsMethode [emptyMap] ;
    @L_signature signature ;
    <formal_arguments_list>
      !ioComponentSemanticsEntitiesMap
      ?listeDeTypes
      !?tableArgumentsMethode
      ?listeTypeEtNomsArguments
      !?tableEnAvant
      ?signature
    ;
    $;$ ;
    [!?readersInInstructionMap insertKey !readerName !listeDeTypes] ;
    [!?readerMap insertKey !readerName !signature] ;
  while
    $modifier$ ;
    select
    #--- Method name
      @lstring modifierName ;
      $identifier$ ? modifierName ;
    #--- Formal parameters
      @L_EXsignature listeDeTypes ;
      @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
      @typeVariablesMap tableArgumentsMethode [emptyMap] ;
      @L_signature signature ;
      <formal_arguments_list>
        !ioComponentSemanticsEntitiesMap
        ?listeDeTypes
        !?tableArgumentsMethode
        ?listeTypeEtNomsArguments
        !?tableEnAvant
        ?signature
      ;
      [!?EXmodifiersMap insertKey ! modifierName !listeDeTypes] ;
      [!?modifierMap insertKey !modifierName !signature] ;
    or
      $+=$ ;
      if [addAssignFormalInputArgumentList length] > 0 then
        error here : "'+=' operator is already defined" ;
      else
        acceptAddAssignOperatorCall := true ;
      end if ;
      repeat
      while
        $?$ ;
        @AC_galgasType type_semantique ;
        @lstring galgasTypeName ;
        <formal_argument_type>
          !ioComponentSemanticsEntitiesMap
          ?type_semantique
          !?tableEnAvant
          ?galgasTypeName
        ;
        @lstring parameterName ;
        $identifier$ ? parameterName ;
        addAssignOperatorCallTypeList += !type_semantique !parameterName ;
        addAssignFormalInputArgumentList += !galgasTypeName ;
      end repeat ;
    end select ;
    $;$ ;
  end repeat ;
#--- Enter the new type in entities map
  @AC_galgasType c := [@typeGalgasExternType new
    !externTypeName
    !EXconstructorsMap
    !EXmodifiersMap
    !readersInInstructionMap
    !acceptAddAssignOperatorCall
     !addAssignOperatorCallTypeList
  ] ;
  @AC_semanticsEntity e := [@typeEntiteType new !c] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !externTypeName !e] ;
  @TypeModel t := [@ExternTypeModel new !constructorMap !readerMap !modifierMap !addAssignFormalInputArgumentList] ;
  [!? ioModelMap insertKey !externTypeName !t] ;
  $}$ ;
end rule ;

#---------------------------------------------------------------------------*
#                            Type d'un argument                             *
#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $type_name$ ? outGalgasTypeName ;
  if [inComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [inComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    type_semantique := [(cast entite if >= @typeEntiteType else error outGalgasTypeName) aDefType] ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $list$ ;
  $type_name$ ? outGalgasTypeName ;
  if [inComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [inComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    type_semantique := [(cast entite if >= @typeEntiteType else error outGalgasTypeName) aDefType] ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    @typeGalgasUndefinedListType x := (cast type_semantique if >= @typeGalgasUndefinedListType else error outGalgasTypeName) ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $list$ ;
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $map$ ;
  $type_name$ ? outGalgasTypeName ;
  if [inComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [inComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    type_semantique := [(cast entite if >= @typeEntiteType else error outGalgasTypeName) aDefType] ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    @typeGalgasUndefinedMapType x := (cast type_semantique if >= @typeGalgasUndefinedMapType else error outGalgasTypeName) ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $map$ ;
  $type_name$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*

rule <formal_argument_type>
  ??@M_semanticsEntitiesForUse inComponentSemanticsEntitiesMap
  !@AC_galgasType type_semantique
  ?!@typeTableEnAvant tableEnAvant
  !@lstring outGalgasTypeName 
:
  $abstract$ ;
  $class$ ;
  $identifier$ ? outGalgasTypeName ;
  if [inComponentSemanticsEntitiesMap hasKey ![outGalgasTypeName string]] then
    @AC_semanticsEntity entite ;
    [inComponentSemanticsEntitiesMap searchKey !outGalgasTypeName ?entite] ;
    type_semantique := [(cast entite if >= @typeEntiteType else error outGalgasTypeName) aDefType] ;
  else # Declaration 'enavant' ?
    [tableEnAvant searchKey !outGalgasTypeName ?type_semantique] ;
    @typeGalgasUndefinedClassType x := (cast type_semantique if >= @typeGalgasUndefinedClassType else error outGalgasTypeName) ;
  end if ;
label importGrammarForSemantics
  !@lstring outGalgasTypeName 
:
  $abstract$ ;
  $class$ ;
  $identifier$ ? outGalgasTypeName ;
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#                   DECLARATION D'UNE extern routine EXTERNE               *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration_begining_by_extern>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents unused inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $routine$ ;
  @lstring nomAction ;
  $identifier$ ?nomAction ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signatureForGrammarComponent ; # Not used here
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  @AC_semanticsEntity entite := [@typeEntiteActionExterne new !listeDeTypes] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !nomAction !entite] ;
  @typeEntityToGenerate ea := [@typeActionExterneAengendrer new !nomAction !listeDeTypes] ;
  listeEntitesAengendrer += !ea ;
  $;$ ;    
label importSemantics
  ?!@ModelMap unused ioModelMap
  ?!@ActionMap ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
:
  $routine$ ;
  @lstring actionName ;
  $identifier$ ? actionName ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap tableArgumentsMethode [emptyMap] ;
  @typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments ;
  @L_signature signature ;
  <formal_arguments_list>
    !ioComponentSemanticsEntitiesMap
    ?listeDeTypes
    !?tableArgumentsMethode
    ?listeTypeEtNomsArguments
    !?tableEnAvant
    ?signature
  ;
  @AC_semanticsEntity entite := [@typeEntiteActionExterne new !listeDeTypes] ;
  [!?ioComponentSemanticsEntitiesMap insertKey ! actionName !entite] ;
  [!?ioExternActionMap insertKey !actionName !signature !true] ;
  $;$ ;    
end rule ;

#---------------------------------------------------------------------------*
#                                                                           *
#    E N U M     T Y P E                                                    *
#                                                                           *
#---------------------------------------------------------------------------*

rule <semantics_declaration>
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeEntitiesToGenerateList listeEntitesAengendrer
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $enum$ ;
#--- Enum type name
  @lstring enumTypeName ;
  $type_name$ ? enumTypeName ;
  ${$ ;
#--- Enum constants
  @enumConstantMap constantMap [emptyMap] ;
  repeat
    @bool hasConstructor ;
    select
      $constructor$ ;
      hasConstructor := true ;
    or
      hasConstructor := false ;
    end select ;
    repeat
      @lstring constantName ;
      $identifier$ ? constantName ;
      [!?constantMap insertKey !constantName !hasConstructor] ;
    while
      $,$ ;
    end repeat ;
    $;$ ;
  while
  end repeat ;
  $}$ ;
  ${$ ;
#--- Enum messages, action messages
  @typeEnumMessageMap enumMessageMap [emptyMap] ;
  @enumModifierMap modifierMap [emptyMap] ;
  @enumMethodMap methodMap [emptyMap] ;
  repeat
  while
    $modifier$ ;
    @lstring actionName ;
    $identifier$ ? actionName ;
    @L_EXsignature signature [emptyList] ;
    @typeVariablesMap localVariableMap [emptyMap] ;
    @typeListeTypesEtNomsArgMethode argumentList [emptyList] ;
    select
    or
      $??$ ;
      @lstring typeName ;
      $type_name$ ? typeName ;
      if [typeName string] != "location" then
        error typeName:"the type should be '@location'" ;
      end if ;
      @AC_galgasType type_semantique := [@typeGalgas_location new] ;
      @formalArgumentPassingMode argumentConstantIn [argumentConstantIn] ;
      select
        $unused$ ;
        @lstring nomArgument ;
        $identifier$ ? nomArgument ;
        @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
        argumentList += !type_semantique !argumentConstantIn !natureNom !true ;
        [!?localVariableMap insertUnusedConstInArgument !nomArgument !type_semantique !natureNom] ;
      or
        @lstring nomArgument ;
        $identifier$ ? nomArgument ;
        @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
        argumentList += !type_semantique !argumentConstantIn !natureNom !true ;
        [!?localVariableMap insertConstInArgument !nomArgument !type_semantique !natureNom] ;
      end select ;
      signature += !type_semantique !argumentConstantIn ;
    end select ;
    ${$ ;
    @enumUsedConstantMap definedSourceMap [emptyMap] ;
    @enumModifierDefinitionList enumActionDefinitionList [emptyList] ;
    repeat
      @lstring sourceName ;
      $identifier$ ? sourceName ;
      [constantMap searchKey !sourceName ?*] ;
      [!?definedSourceMap insertKey !sourceName] ;
      $->$ ;
      @lstring targetName ;
      $identifier$ ? targetName ;
      [constantMap searchKey !targetName ?*] ;
      @typeInstructionList instructionList [emptyList] ;
      select
        $;$ ;
      or
        <error_instruction>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?localVariableMap
          !?instructionList
        ;
      or
        <warning_instruction>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?localVariableMap
          !?instructionList
        ;
      end select ;
      enumActionDefinitionList += !sourceName !targetName !instructionList ;
    while
    end repeat ;
   #--- Check all enum values are used for source
    foreach constantMap (@lstring inConstant *) :
      if not [definedSourceMap hasKey ![inConstant string]] then
        error here: "The '" . [inConstant string] . "' is not handled" ;
      end if ;
    end foreach ;
  #--- Enter in action map
    [!?modifierMap insertKey !actionName !enumActionDefinitionList !signature !argumentList] ;
    $}$ ;
  while
    $method$ ;
    @lstring actionName ;
    $identifier$ ? actionName ;
    @L_EXsignature signature [emptyList] ;
    @typeVariablesMap localVariableMap [emptyMap] ;
    @typeListeTypesEtNomsArgMethode argumentList [emptyList] ;
    select
    or
      $??$ ;
      @lstring typeName ;
      $type_name$ ? typeName ;
      if [typeName string] != "location" then
        error typeName:"the type should be '@location'" ;
      end if ;
      @AC_galgasType type_semantique := [@typeGalgas_location new] ;
      @formalArgumentPassingMode argumentConstantIn [argumentConstantIn] ;
      select
        $unused$ ;
        @lstring nomArgument ;
        $identifier$ ? nomArgument ;
        @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
        argumentList += !type_semantique !argumentConstantIn !natureNom !true ;
        [!?localVariableMap insertUnusedConstInArgument !nomArgument !type_semantique !natureNom] ;
      or
        @lstring nomArgument ;
        $identifier$ ? nomArgument ;
        @typeCplusPlusName natureNom := [@typeAutomaticName new ![nomArgument location] ![nomArgument string]] ;
        argumentList += !type_semantique !argumentConstantIn !natureNom !true ;
        [!?localVariableMap insertConstInArgument !nomArgument !type_semantique !natureNom] ;
      end select ;
      signature += !type_semantique !argumentConstantIn ;
    end select ;
    ${$ ;
    @enumUsedConstantMap definedSourceMap [emptyMap] ;
    @enumMethodDefinitionList enumActionDefinitionList [emptyList] ;
    repeat
      @lstring sourceName ;
      $identifier$ ? sourceName ;
      [constantMap searchKey !sourceName ?*] ;
      [!?definedSourceMap insertKey !sourceName] ;
      @typeInstructionList instructionList [emptyList] ;
      select
        $;$ ;
      or
        <error_instruction>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?localVariableMap
          !?instructionList
        ;
      or
        <warning_instruction>
          !ioComponentSemanticsEntitiesMap
          !inOptionsComponentsMapForUse
          !?localVariableMap
          !?instructionList
        ;
      end select ;
      enumActionDefinitionList += !sourceName !instructionList ;
    while
    end repeat ;
   #--- Check all enum values are used for source
    foreach constantMap (@lstring inConstant *) :
      if not [definedSourceMap hasKey ![inConstant string]] then
        error here: "The '" . [inConstant string] . "' is not handled" ;
      end if ;
    end foreach ;
  #--- Enter in action map
    [!?methodMap insertKey !actionName !enumActionDefinitionList !signature !argumentList] ;
    $}$ ;
  while
    $reader$ ;
    @lstring messageName ;
    $identifier$ ? messageName ;
    ${$ ;
    @typeEnumCstMessageStringMap cstMessageStringMap [emptyMap] ;
    repeat
      @lstring cstName ;
      $identifier$ ? cstName ;
      $->$ ;
      @lstring cstString ;
      $literal_string$ ? cstString ;
      [!?cstMessageStringMap insertKey !cstName !cstString] ;
      $;$ ;
    while
    end repeat ;
    $}$ ;
  #--- Build message string list
    @L_lstringList messageStringList [emptyList] ;
    foreach constantMap (@lstring constantName *) :
      @lstring name := [@lstring new ![constantName string] !here] ;
      @lstring cstString ;
      [cstMessageStringMap searchKey !name ?cstString] ;
      messageStringList += !cstString ;
    end foreach ;
  #--- Enter message definition into message map
    [!?enumMessageMap insertKey !messageName !messageStringList] ;
  end repeat ;
#--- End type definition end
  $}$ ;
#---- Enter enum datas into the list of entities to generate
  @typeEntityToGenerate e := [@enumGalgasType new !enumTypeName !constantMap !enumMessageMap !modifierMap !methodMap] ;
  listeEntitesAengendrer += !e ;
#--- Enter enum type into semantic entities map
  @AC_galgasType t := [@typeGalgas_enum new !enumTypeName !constantMap !enumMessageMap !modifierMap !methodMap] ;
  @AC_semanticsEntity ee := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !enumTypeName !ee] ;
label importSemantics
  ?!@ModelMap ioModelMap
  ?!@ActionMap unused ioExternActionMap
  ?!@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ?!@typeTableNomRoutinesDeclarees unused tableNomRoutinesDeclarees
  ?!@typeTableEnAvant unused tableEnAvant
  ?!@typeTableRoutinesAimplementer unused tableRoutinesAimplementer
  ??@M_treewalkingComponents unused inTreewalkingComponentMap
  ?!@M_filewrappers unused ioFileWrappers
:
  $enum$ ;
#--- Enum type name
  @lstring enumTypeName ;
  $type_name$ ? enumTypeName ;
  ${$ ;
#--- Enum constants
  @enumConstantMap constantMap [emptyMap] ;
  repeat
    @bool hasConstructor ;
    select
      $constructor$ ;
      hasConstructor := true ;
    or
      hasConstructor := false ;
    end select ;
    repeat
      @lstring constantName ;
      $identifier$ ? constantName ;
      [!?constantMap insertKey !constantName !hasConstructor] ;
    while
      $,$ ;
    end repeat ;
    $;$ ;
  while
  end repeat ;
  $}$ ;
  ${$ ;
#--- readers, modifiers map
  @typeEnumMessageMap exEnumMessageMap [emptyMap] ;
  @enumModifierMap modifierMap [emptyMap] ;
  @enumMethodMap methodMap [emptyMap] ;
  @enumMessageMap enumMessageMap [emptyMap] ;
  repeat
  while
    $modifier$ ;
    @lstring actionName ;
    $identifier$ ? actionName ;
    @L_EXsignature signature [emptyList] ;
    @typeListeTypesEtNomsArgMethode argumentList [emptyList] ;
    select
    or
      signature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentConstantIn] ;
      $??$ ;
      @lstring typeName ;
      $type_name$ ? typeName ;
      select
        $unused$ ;
        $identifier$ ? * ;
      or
        $identifier$ ? * ;
      end select ;
    end select ;
    ${$ ;
    @enumUsedConstantMap definedSourceMap [emptyMap] ;
    @enumModifierDefinitionList enumActionDefinitionList [emptyList] ;
    repeat
      @lstring sourceName ;
      $identifier$ ? sourceName ;
      [constantMap searchKey !sourceName ?*] ;
      [!?definedSourceMap insertKey !sourceName] ;
      $->$ ;
      @lstring targetName ;
      $identifier$ ? targetName ;
      [constantMap searchKey !targetName ?*] ;
      select
        $;$ ;
      or
        <error_instruction> parse ;
      or
        <warning_instruction> parse ;
      end select ;
      enumActionDefinitionList += !sourceName !targetName ![@typeInstructionList emptyList] ;
    while
    end repeat ;
  #--- Enter in action map
    [!?modifierMap insertKey !actionName !enumActionDefinitionList !signature !argumentList] ;
    $}$ ;
  while
    $method$ ;
    @lstring actionName ;
    $identifier$ ? actionName ;
    @L_EXsignature signature [emptyList] ;
    @typeListeTypesEtNomsArgMethode argumentList [emptyList] ;
    select
    or
      signature += ![@typeGalgas_location new] ![@formalArgumentPassingMode argumentConstantIn] ;
      $??$ ;
      @lstring typeName ;
      $type_name$ ? typeName ;
      select
        $unused$ ;
        $identifier$ ? * ;
      or
        $identifier$ ? * ;
      end select ;
    end select ;
    ${$ ;
    @enumUsedConstantMap definedSourceMap [emptyMap] ;
    @enumMethodDefinitionList enumActionDefinitionList [emptyList] ;
    repeat
      @lstring sourceName ;
      $identifier$ ? sourceName ;
      [constantMap searchKey !sourceName ?*] ;
      [!?definedSourceMap insertKey !sourceName] ;
      select
        $;$ ;
      or
        <error_instruction> parse ;
      or
        <warning_instruction> parse ;
      end select ;
      enumActionDefinitionList += !sourceName ![@typeInstructionList emptyList] ;
    while
    end repeat ;
  #--- Enter in action map
    [!?methodMap insertKey !actionName !enumActionDefinitionList !signature !argumentList] ;
    $}$ ;
  while
    $reader$ ;
    @lstring messageName ;
    $identifier$ ? messageName ;
  #--- Enter message definition into message map
    [!?enumMessageMap insertKey !messageName] ;
    @L_lstringList messageStringList [emptyList] ;
    [!? exEnumMessageMap insertKey !messageName !messageStringList] ;
    ${$ ;
    repeat
      $identifier$ ? * ;
      $->$ ;
      $literal_string$ ? * ;
      $;$ ;
    while
    end repeat ;
    $}$ ;
  end repeat ;
  $}$ ;
#--- Enter enum type into semantic entities map
  @AC_galgasType t := [@typeGalgas_enum new !enumTypeName !constantMap !exEnumMessageMap !modifierMap !methodMap] ;
  @AC_semanticsEntity e := [@typeEntiteType new !t] ;
  [!?ioComponentSemanticsEntitiesMap insertKey !enumTypeName !e] ;
  @TypeModel type := [@EnumModel new !constantMap !enumMessageMap] ;
  [!?ioModelMap insertKey !enumTypeName !type] ;
end rule ;

#---------------------------------------------------------------------------*

end syntax ;
