#---------------------------------------------------------------------------*
#                                                                           *
#  Component for compiling a semantics component                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticsCompilation :
  import "allASTTypes.gSemantics" ;
  import "predefinedTypes.gSemantics" ;
  import "grammarCompilation.gSemantics" ;
  import "semanticsSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#           G E N E R A T I O N    F I L E W R A P P E R S                  *
#                                                                           *
#---------------------------------------------------------------------------*

filewrapper semanticFileGenerationTemplate in "../generation_templates/semantic_generation" {
}{
}{
  template semanticFileHeader "semantic-file.h.gTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST
  ;
  template semanticFileImplementation "semantic-file.cpp.gTemplate"
    ?@stringlist IMPORTED_COMPONENT_LIST
  ;
}
                            
#---------------------------------------------------------------------------*
#                                                                           *
#    C O M P I L E    S E M A N T I C S   C O M P O N E N T                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine parseSemanticComponent
  ??@lstring inSourceFile
  ?!@parsedComponentStruct ioParsedComponentStruct
  !@semanticsComponentAST outSemanticsComponentRoot
:
  @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  @lstring basenameKey [new !basename !here] ;
  if [[ioParsedComponentStruct mParsedSemanticsComponentMap] hasKey ! basename] then
    [[ioParsedComponentStruct mParsedSemanticsComponentMap] searchKey !basenameKey ?* ?outSemanticsComponentRoot] ;
  else
    grammar semanticsSLRgrammar in inSourceFile ?outSemanticsComponentRoot ;
    [!?ioParsedComponentStruct->mParsedSemanticsComponentMap insertKey !basenameKey !inSourceFile !outSemanticsComponentRoot] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

list @grammarComponentASTList {
  @galgas3GrammarComponentListAST.element mGrammarComponentAST ;
}

#---------------------------------------------------------------------------*

graph @semanticImportDependenceGraph (@stringlist) {
  insert insertNode error message "-- INTERNAL ERROR --" ;
}

#---------------------------------------------------------------------------*

routine recursivelyImportSemanticComponent
  ??@lstring inFilePath
  ?!@parsedComponentStruct ioParsedComponentStruct
  ?!@semanticImportDependenceGraph ioSemanticImportDependenceGraph
  ?!@lstringlist ioOptionComponentFileNameList
  ?!@grammarComponentASTList ioGrammarComponentASTList
  ?!@semanticDeclarationListAST ioSemanticDeclarationList
  ?!@stringset ioParsedFileSet
  ?!@stringlist ioHeaderIncludeList
  ?!@stringlist ioImplementationIncludeList
  ??@lstringlist inListOfFilesToParse
  ??@string inDirectory
:
  [!?ioSemanticImportDependenceGraph insertNode
    ![@lstring new ![inFilePath lastPathComponent] ![inFilePath location]]
    ![inFilePath lastPathComponent]
  ] ;
  foreach inListOfFilesToParse do
    const filePath := [@lstring new
      ![mValue absolutePathFromPath !inDirectory]
      ![mValue location]
    ] ;
    const @string extension := [mValue pathExtension] ;
    if not [ioParsedFileSet hasKey ![filePath string]] then
      ioParsedFileSet += ![filePath string] ;
      if extension == "gOption" then
        ioOptionComponentFileNameList += !filePath ;
        ioImplementationIncludeList += ![[filePath lastPathComponent] stringByDeletingPathExtension] ;
      elsif extension == "gGrammar" then
        @galgas3GrammarComponentListAST.element grammarComponentAST ;
        parseGrammarComponent
          !filePath
          !?ioParsedComponentStruct
          ?grammarComponentAST
        ;
        ioGrammarComponentASTList += !grammarComponentAST ;
        ioImplementationIncludeList += !grammarComponentAST->mGrammarComponentName->string ;
      elsif extension == "gSemantics" then
        [!?ioSemanticImportDependenceGraph addEdge
          ![@lstring new ![inFilePath lastPathComponent] ![inFilePath location]]
          ![@lstring new ![mValue lastPathComponent] ![mValue location]]
        ] ;
      #--- Parse semantic component
        @semanticsComponentAST semanticsComponentRoot ;
        parseSemanticComponent
          !filePath
          !?ioParsedComponentStruct
          ?semanticsComponentRoot
        ;
        ioHeaderIncludeList += ![[semanticsComponentRoot mSemanticsComponentName] string] ;
      #--- Add declaration to declaration list (only if global)
        foreach [semanticsComponentRoot mSemanticDeclarationList] do
          ioSemanticDeclarationList += !mSemanticDeclaration ;
        end foreach ;
      #--- Import semantic components named in this file
        recursivelyImportSemanticComponent
          !filePath
          !?ioParsedComponentStruct
          !?ioSemanticImportDependenceGraph
          !?ioOptionComponentFileNameList
          !?ioGrammarComponentASTList
          !?ioSemanticDeclarationList
          !?ioParsedFileSet
          !?ioHeaderIncludeList
          !?ioImplementationIncludeList
          ![semanticsComponentRoot mImportedComponentFileNameList]
          !inDirectory
        ;
      end if ;
    elsif extension == "gSemantics" then
        [!?ioSemanticImportDependenceGraph addEdge
          ![@lstring new ![inFilePath lastPathComponent] ![inFilePath location]]
          ![@lstring new ![mValue lastPathComponent] ![mValue location]]
        ] ;
    end if ;
  end foreach ;
end routine ;


#---------------------------------------------------------------------------*

routine recursivelyImportSemanticComponentAndCheckNoCircularityInImportSemantics
  ??@lstring inSourceFile
  ?!@parsedComponentStruct ioParsedComponentStruct
  ?!@lstringlist ioOptionComponentFileNameList
  ?!@grammarComponentASTList ioGrammarComponentASTList
  ?!@semanticDeclarationListAST ioSemanticDeclarationList
  ?!@stringset ioParsedFileSet
  ?!@stringlist ioHeaderIncludeList
  ?!@stringlist ioImplementationIncludeList
  ??@lstringlist inListOfFilesToParse
  ??@string inDirectory
:
  @semanticImportDependenceGraph semanticImportDependenceGraph [emptyGraph] ;
  recursivelyImportSemanticComponent
    !inSourceFile
    !?ioParsedComponentStruct
    !?semanticImportDependenceGraph
    !?ioOptionComponentFileNameList
    !?ioGrammarComponentASTList
    !?ioSemanticDeclarationList
    !?ioParsedFileSet
    !?ioHeaderIncludeList
    !?ioImplementationIncludeList
    !inListOfFilesToParse
    !inDirectory
  ;
#------ Check there is no import circularities
  @lstringlist circularityList;
  [semanticImportDependenceGraph topologicalSort ?* ?* ?* ?circularityList] ;
  if [circularityList length] > 0 then
    @string s := "theses components are involved in a circular import:" ;
    foreach circularityList do
      s .= "\n  - '" . mValue . "'" ;
    end foreach ;
    error here : s ;
    foreach circularityList do
      error mValue : "import was here";
    end foreach ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine buildLexiqueComponentMapForSemanticAnalysis
  ??@parsedComponentStruct inParsedComponentStruct
  !@lexiqueComponentMapForSemanticAnalysis outLexiqueComponentMapForSemanticAnalysis
:
  outLexiqueComponentMapForSemanticAnalysis := [@lexiqueComponentMapForSemanticAnalysis emptyMap] ;
  foreach inParsedComponentStruct->mParsedLexiqueComponentMap do
    buildTerminalMap !mLexiqueComponentAST ??@terminalMap terminalMap ;
    [!?outLexiqueComponentMapForSemanticAnalysis insertKey
      !lkey
      !terminalMap
      !mLexiqueComponentAST->mIndexingListAST
      !mLexiqueComponentAST->mIndexingDirectory
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine buildOptionComponentMapForSemanticAnalysis
  ??@lstringlist inOptionComponentFileNameList
  ?!@parsedComponentStruct ioParsedComponentStruct
  ?!@optionComponentMapForSemanticAnalysis ioOptionComponentMapForSemanticAnalysis
:
  foreach inOptionComponentFileNameList do
    @lstring optionComponentName ;
    @commandLineOptionMap boolOptionMap ;
    @commandLineOptionMap uintOptionMap ;
    @commandLineOptionMap stringOptionMap ;
    parseOptionComponent
      !mValue
      !?ioParsedComponentStruct
      ?optionComponentName
      ?boolOptionMap
      ?uintOptionMap
      ?stringOptionMap
    ;
    [!?ioOptionComponentMapForSemanticAnalysis insertKey
      !optionComponentName
      !false # Is not predefined
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ] ;
  end foreach ;
#--- Add predefined option component
  if not [ioOptionComponentMapForSemanticAnalysis hasKey !"galgas_builtin_options"] then
    @2stringlist optionNameList := [@application boolOptionNameList] ;
    @commandLineOptionMap boolOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?boolOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application boolOptionInvocationLetter !mValue0 !mValue1]
        ![@application boolOptionInvocationString !mValue0 !mValue1]
        ![@application boolOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #--- 
    optionNameList := [@application uintOptionNameList] ;
    @commandLineOptionMap uintOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?uintOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application uintOptionInvocationLetter !mValue0 !mValue1]
        ![@application uintOptionInvocationString !mValue0 !mValue1]
        ![@application uintOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #--- 
    optionNameList := [@application stringOptionNameList] ;
    @commandLineOptionMap stringOptionMap [emptyMap] ;
    foreach optionNameList do
      [!?stringOptionMap insertKey
        ![@lstring new !mValue1 !here]
        ![@application stringOptionInvocationLetter !mValue0 !mValue1]
        ![@application stringOptionInvocationString !mValue0 !mValue1]
        ![@application stringOptionCommentString !mValue0 !mValue1]
        !"" # Not used
      ] ;
    end foreach ;
  #---
    [!?ioOptionComponentMapForSemanticAnalysis insertKey
      ![@lstring new !"galgas_builtin_options" !here]
      !true # Is predefined
      !boolOptionMap
      !uintOptionMap
      !stringOptionMap
    ] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine buildGrammarComponentMapForSemanticAnalysis
  ??@grammarComponentASTList inGrammarComponentASTList
  ?!@semanticContext ioSemanticContext
:
#--- Perform semantic analysis of grammar components
  foreach inGrammarComponentASTList do
  #--- Analyze start symbol labels
    @grammarLabelMap grammarLabelMap [emptyMap] ;
    foreach [mGrammarComponentAST mStartSymbolLabelList] do
    #--- Analyze signature
      @formalParameterSignature formalArgumentList [emptyList] ;
      foreach mFormalArgumentList do
        formalArgumentList +=
          ![@unifiedTypeMapProxy searchKey !ioSemanticContext->mTypeMap !mFormalArgumentTypeName]
          !mFormalArgumentPassingMode
          !mFormalArgumentName->string
        ;
      end foreach ;
      [!?grammarLabelMap insertKey
        !mLabelName
        !formalArgumentList
      ] ;
    end foreach ;
  #--- Insert grammar in grammar map
    [!?ioSemanticContext->mGrammarMap insertGrammar
      !mGrammarComponentAST->mGrammarComponentName
      !grammarLabelMap
      ![[mGrammarComponentAST mHasIndexing] bool]
      !mGrammarComponentAST->mHasTranslateFeature
    ] ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine compileSemanticsComponentAST
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ??@semanticsComponentAST inSemanticsComponentRoot
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Check component name
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  const @lstring componentName := [inSemanticsComponentRoot mSemanticsComponentName] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--- Recursively parse all imported files
  @semanticDeclarationListAST semanticDeclarationList := [inSemanticsComponentRoot mSemanticDeclarationList] ;
  @stringset parsedFileSet [setWithString ![inSourceFile string]] ;
  @lstringlist optionComponentFileNameList [emptyList] ;
  @grammarComponentASTList grammarComponentASTList [emptyList] ;
  @stringlist headerIncludeList [emptyList] ;
  @stringlist implementationIncludeList [emptyList] ;
  @semanticImportDependenceGraph semanticImportDependenceGraph [emptyGraph] ;
  recursivelyImportSemanticComponent
    !inSourceFile
    !?ioParsedComponentStruct
    !?semanticImportDependenceGraph
    !?optionComponentFileNameList
    !?grammarComponentASTList
    !?semanticDeclarationList
    !?parsedFileSet
    !?headerIncludeList
    !?implementationIncludeList
    ![inSemanticsComponentRoot mImportedComponentFileNameList]
    ![inSourceFile stringByDeletingLastPathComponent]
  ;
#------ Check there is no import circularities
  @lstringlist circularityList;
  [semanticImportDependenceGraph topologicalSort ?* ?* ?* ?circularityList] ;
#------ Add predefined types to semantics declarations
  @semanticDeclarationListAST semanticDeclarationListWithPredefinedTypes := semanticDeclarationList ;
  appendPredefinedTypesASTs !?semanticDeclarationListWithPredefinedTypes ;
#------ Build semantic context
  buildSemanticContext
    ![inSourceFile string]
    !semanticDeclarationListWithPredefinedTypes
    ![inSemanticsComponentRoot mEndOfSourceFile]
    ?@semanticContext semanticContext
  ;
#------ Build option component map for analysis
  buildOptionComponentMapForSemanticAnalysis
    !optionComponentFileNameList
    !?ioParsedComponentStruct
    !?semanticContext->mOptionComponentMapForSemanticAnalysis
  ;
#--- Build lexique component map for semantic analysis
  buildLexiqueComponentMapForSemanticAnalysis
    !ioParsedComponentStruct
    ?@lexiqueComponentMapForSemanticAnalysis lexiqueMap
  ;
  semanticContext->mLexiqueComponentMapForSemanticAnalysis := lexiqueMap ;
#------ Perform semantic analysis of grammar components
  buildGrammarComponentMapForSemanticAnalysis
    !grammarComponentASTList
    !?semanticContext
  ;
#------ Semantic Analysis
  @semanticDeclarationSortedListForGeneration decoratedDeclarationListForGeneration ;
  performSemanticAnalysis
    ![inSemanticsComponentRoot mSemanticDeclarationList]
    !semanticContext
    ?decoratedDeclarationListForGeneration
  ;
#------ Generate Header File
  if [@uint errorCount] == 0 then
    @stringlist typeList [emptyList] ;
    var headerString := [filewrapper semanticFileGenerationTemplate.semanticFileHeader
      ![componentName string]
      !headerIncludeList
    ] ;
    foreach decoratedDeclarationListForGeneration do
      var unusedInclusionSet := [@stringset emptySet] ;
      [mDeclaration appendDeclaration1 !?unusedInclusionSet ??@string code] ;
      headerString .= code ;
    end foreach ;
    foreach decoratedDeclarationListForGeneration do
      var inclusionSet2 := [@stringset emptySet] ;
      [mDeclaration appendDeclaration2 !false !inOutputDirectory !?inclusionSet2 ??@string headerString2] ;
      headerString .= headerString2 ;
    end foreach ;
    [@string generateFileWithPattern
      !inOutputDirectory
      ![componentName string] . ".h"
      !"//"
      !"\n\n" # Defaut user zone1
      !headerString
      !"\n\n" # Defaut user zone2
      !"#endif\n"
    ] ;
  end if ;
#------ Generate Implementation File
  if [@uint errorCount] == 0 then
    implementationIncludeList += !componentName->string ;
    var implementationString := [filewrapper semanticFileGenerationTemplate.semanticFileImplementation
      !implementationIncludeList
    ] ;
    foreach decoratedDeclarationListForGeneration do
      var unusedInclusionSet := [@stringset emptySet] ;
      [mDeclaration appendSpecificImplementation !?unusedInclusionSet ??@string code] ;
      implementationString += code ;
#      implementationString .= [mDeclaration appendSpecificImplementation !false] ;
      implementationString .= [mDeclaration appendTypeGenericImplementation] ;
    end foreach ;
    [@string generateFileWithPattern
      !inOutputDirectory
      ![componentName string] . ".cpp"
      !"//"
      !"\n\n" # Defaut user zone1
      !implementationString
      !"\n\n" # Defaut user zone2
      !"\n"
    ] ;
  end if ;
end routine ;
#---------------------------------------------------------------------------*

routine compileSemanticsComponentFromSourceFile
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Parsing
  @semanticsComponentAST semanticsComponentRoot ;
  parseSemanticComponent
    !inSourceFile
    !?ioParsedComponentStruct
    ?semanticsComponentRoot
  ;
#---
  compileSemanticsComponentAST
    !inSourceFile
    !inOutputDirectory
    !semanticsComponentRoot
    !?ioParsedComponentStruct
  ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
