#---------------------------------------------------------------------------*
#                                                                           *
#  Component for compiling a semantics component                            *
#                                                                           *
#  Copyright (C) 2007, ..., 2010 Pierre Molinaro.                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

semantics semanticsCompilation :
  import "semanticsSemantics.gSemantics" ;
  import "allASTTypes.gSemantics" ;
  import "buildSemanticContext.gSemantics" ;

  import semantics allASTTypes in "allASTTypes.gSemantics" ;
  import semantics buildSemanticContext in "buildSemanticContext.gSemantics" ;
  import grammar semanticsSLRgrammar in "semanticsSLRgrammar.gGrammar" ;

#---------------------------------------------------------------------------*
#                                                                           *
#    C O M P I L E    S E M A N T I C S   C O M P O N E N T                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine parseSemanticComponent
  ??@lstring inSourceFile
  ?!@parsedComponentStruct ioParsedComponentStruct
  !@semanticsComponentAST outSemanticsComponentRoot
:
  @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  @lstring basenameKey [new !basename !here] ;
  if [[ioParsedComponentStruct mParsedSemanticsComponentMap] hasKey ! basename] then
    [[ioParsedComponentStruct mParsedSemanticsComponentMap] searchKey !basenameKey ?outSemanticsComponentRoot] ;
  else
    grammar semanticsSLRgrammar in inSourceFile ?outSemanticsComponentRoot ;
    [!?ioParsedComponentStruct->mParsedSemanticsComponentMap insertKey !basenameKey !outSemanticsComponentRoot] ;
  end if ;
end routine ;

#---------------------------------------------------------------------------*

routine recursivelyImportSemanticComponent
  ?!@parsedComponentStruct ioParsedComponentStruct
  ?!@semanticDeclarationListAST ioSemanticDeclarationList
  ?!@stringset ioParsedFileSet
  ??@lstringlist inListOfFilesToParse
  ??@string inDirectory
:
  foreach inListOfFilesToParse do
    if not [ioParsedFileSet hasKey ![mValue string]] then
      ioParsedFileSet += ![mValue string] ;
      @string extension := [[mValue string] pathExtension] ;
      if extension == "gSemantics" then
        @lstring filePath [new
          ![mValue absolutePathFromPath !inDirectory]
          ![mValue location]
        ] ;
        @semanticsComponentAST semanticsComponentRoot ;
        parseSemanticComponent
          !filePath
          !?ioParsedComponentStruct
          ?semanticsComponentRoot
        ;
        ioSemanticDeclarationList := ioSemanticDeclarationList . [[semanticsComponentRoot mSemanticDeclarations] mSemanticDeclarationList] ;
        recursivelyImportSemanticComponent
          !?ioParsedComponentStruct
          !?ioSemanticDeclarationList
          !?ioParsedFileSet
          ![semanticsComponentRoot mImportedComponentFileNameList]
          !inDirectory
        ;
      end if ;
    end if ;
  end foreach ;
end routine ;

#---------------------------------------------------------------------------*

routine compileSemanticsComponent
  ??@lstring inSourceFile
  ??@string inOutputDirectory
  ?!@parsedComponentStruct ioParsedComponentStruct
:
#--- Parse source file
  @semanticsComponentAST semanticsComponentRoot ;
  parseSemanticComponent
    !inSourceFile
    !?ioParsedComponentStruct
    ?semanticsComponentRoot
  ;
#--- Check component name
  const @string basename := [[inSourceFile lastPathComponent] stringByDeletingPathExtension] ;
  const @lstring componentName := [semanticsComponentRoot mSemanticsComponentName] ;
  if [componentName string] != basename then
    warning componentName: "GALGAS checks "
      "the component name ('" . [componentName string]
    . "') against the source file base name ('" . basename . "'): they should be identical"
    ;
  end if ; 
#--- Recursively parse all imported files
  @semanticDeclarationListAST semanticDeclarationList := [[semanticsComponentRoot mSemanticDeclarations] mSemanticDeclarationList] ;
  @stringset parsedFileSet [setWithString ![inSourceFile string]] ;
  recursivelyImportSemanticComponent
    !?ioParsedComponentStruct
    !?semanticDeclarationList
    !?parsedFileSet
    ![semanticsComponentRoot mImportedComponentFileNameList]
    ![inSourceFile stringByDeletingLastPathComponent]
  ;
##---- Build semantic context
#  @semanticContextEX semanticContextEX ;
#  buildSemanticContextEX !semanticDeclarationList ![semanticsComponentRoot mEndOfSourceFile] ?semanticContextEX ;
#  @semanticContext semanticContext ;
#  buildSemanticContext !semanticDeclarationList ![semanticsComponentRoot mEndOfSourceFile] ?semanticContext ;
##--- Check type declarations
#  if [@uint errorCount] == 0 then
#    foreach [semanticContextEX mTypeMap] do
#      @constructorMapEXX constructorMap := [mType constructorMap] ;
#      @readerMapEXX readerMap := [mType readerMap] ;
#      @modifierMapEXX modifierMap := [mType modifierMap] ;
#    end foreach ;
#  end if ;
##--- Perform semantic analysis of all declarations
#  foreach semanticDeclarationList do
#    [mSemanticDeclaration semanticAnalysis
#      !?semanticContextEX
#    ] ;
#  end foreach ;
##--- Perform semantic analysis of declarations of this component
#  @semanticDeclarationSortedListForGeneration declarationSortedListForGeneration [emptySortedList] ;
#  foreach semanticDeclarationList do
#    [mSemanticDeclaration decorateAbstractSyntaxTree
#      !semanticContextEX
#      !?declarationSortedListForGeneration
#    ] ;
#  end foreach ;
##--- Perform Code Generation
#  if [@uint errorCount] == 0 then
#    @stringlist predeclarationList [emptyList] ;
#    foreach declarationSortedListForGeneration do
#    
#    end foreach ;
#    @string headerString := [filewrapper typeGenerationTemplate.semanticFileHeader
#      ![componentName string]
#      !predeclarationList
#    ] ;
#    @string implementationString := [filewrapper typeGenerationTemplate.semanticFileImplementation
#      ![componentName string]
#    ] ;
#    foreach semanticDeclarationList do
#      [mSemanticDeclaration generateCode
#        !?semanticContextEX
#        !?headerString
#        !?implementationString
#      ] ;
#    end foreach ;
#    [@string generateFile
#      !inOutputDirectory
#      ![componentName string] . ".h"
#      !"//"
#      !"\n\n" # Defaut user zone1
#      !headerString
#      !"\n\n" # Defaut user zone2
#      !"#endif\n"
#    ] ;
#    [@string generateFile
#      !inOutputDirectory
#      ![componentName string] . ".cpp"
#      !"//"
#      !"\n\n" # Defaut user zone1
#      !implementationString
#      !"\n\n" # Defaut user zone2
#      !"\n"
#    ] ;
#  end if ;
end routine ;

#---------------------------------------------------------------------------*

end semantics ;
