#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS main program definition                                           *
#                                                                           *
#  Copyright (C) 2007, ..., 2014 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

program galgas_prgm :
  import "lexiqueSemantics.gSemantics" ;
  import "projectGlobalCheckings.gSemantics" ;
  import "projectCreation.gSemantics" ;
  import "lexiqueCompilation.gSemantics" ;
  import "guiCompilation.gSemantics" ;
  import "syntaxCompilation.gSemantics" ;
  import "predefinedTypes.gSemantics" ;
  import "programComponentCompilation.gSemantics" ;
  import "projectLL1grammar.gGrammar" ;
  import "targetGeneration.gSemantics" ;
  import "galgas3projectAST.gSemantics" ;
  import "galgas3ProjectGrammar.gGrammar" ;
  import "galgas3Grammar.gGrammar" ;
  import "galgas3SemanticDeclarationCompilation.gSemantics" ;
  import "galgas3TargetGeneration.gSemantics" ;

#---------------------------------------------------------------------------*

before {
#--- Generate project
  const creationProjectName := [option galgas_cli_options.create_project value] ;
  projectCreation !creationProjectName ;
}

before {
#--- Print predefined lexical action
  if [option galgas_cli_options.printPredefinedLexicalActions value] then
    printPredefinedLexicalActions ;
  end if ;
}

before {
#--- Generate predefined files
  generatePredefinedTypeFiles ![option galgas_cli_options.generatePredefinedTypes value] ;
}

before {
#--- Extract LIBPM
  if [option galgas_cli_options.extractLIBPMOption value] != "" then
    updateLIBPMatPath ![option galgas_cli_options.extractLIBPMOption value] ;
  end if ;  
}

#----------------------------------------------------------------------------*
#                                                                            *
#          Template                                                          *
#                                                                            *
#----------------------------------------------------------------------------*

when . "gTemplate"
message "a GALGAS Template source file"
indexing with projectLL1grammar
??@lstring inSourceFile {
  grammar templateGrammar in inSourceFile ?* ;
}

#---------------------------------------------------------------------------*

when . "gOption"
message "a GALGAS option source file"
indexing with optionLL1grammar
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
    ![@parsedGuiComponentMap emptyMap]
  ] ;
  compileOptionComponentFromSourceFile !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct ;
}

#---------------------------------------------------------------------------*

when . "gLexique"
message "a GALGAS lexique source file"
indexing with lexiqueLL1grammar
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
    ![@parsedGuiComponentMap emptyMap]
  ] ;
  compileLexiqueComponentFromSource !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct ;
}

#---------------------------------------------------------------------------*

when . "gSemantics"
message "a GALGAS semantics source file"
indexing with semanticsSLRgrammar
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
    ![@parsedGuiComponentMap emptyMap]
  ] ;
  compileSemanticsComponentFromSourceFile !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct;
}

#---------------------------------------------------------------------------*

when . "gSyntax"
message "a GALGAS syntax source file"
indexing with syntaxSLRgrammar
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
    ![@parsedGuiComponentMap emptyMap]
  ] ;
  compileSyntaxComponentFromSourceFile !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct;
}

#---------------------------------------------------------------------------*

when . "gGrammar"
message "a GALGAS grammar source file"
indexing with grammarLL1grammar
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
    ![@parsedGuiComponentMap emptyMap]
  ] ;
  compileGrammarComponentFromSourceFile
    !inSourceFile
    !outputDirectory [!inSourceFile]
    !?parsedComponentStruct;
}

#---------------------------------------------------------------------------*

when . "gGui"
message "a GALGAS GUI source file"
indexing with guiGrammar
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
    ![@parsedGuiComponentMap emptyMap]
  ] ;
  compileGuiComponentFromSourceFile !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct ;
}

#---------------------------------------------------------------------------*

when . "gProgram"
message "a GALGAS program source file"
indexing with programSLRgrammar
??@lstring inSourceFile {
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
    ![@parsedGuiComponentMap emptyMap]
  ] ;
  compileProgramComponentFromSourceFile !inSourceFile !outputDirectory [!inSourceFile] !?parsedComponentStruct;
}

#----------------------------------------------------------------------------*
#                                                                            *
#          Project                                                           *
#                                                                            *
#----------------------------------------------------------------------------*

when . "gProject"
message "a GALGAS project source file"
indexing with projectLL1grammar
??@lstring inProjectSourceFile {
  const @string outputDirectory := outputDirectory [!inProjectSourceFile] ;
#--- Parse metamodel component
  grammar projectLL1grammar in inProjectSourceFile ??@projectComponentAST projectComponentAST :> ??@string translatedProject ;
  if [option galgas_cli_options.convertToGalgas3 value] then
    const directory := [inProjectSourceFile stringByDeletingLastPathComponent] . "/../" ;
    const newProjectFile := directory . "+" . projectComponentAST->mTargetName . ".galgasProject" ;
    [translatedProject writeToFileWhenDifferentContents !newProjectFile ?*] ;
  end if ;
#--- Check project name
  if [[projectComponentAST mProjectName] string] != [[inProjectSourceFile lastPathComponent] stringByDeletingPathExtension] then
    error [projectComponentAST mProjectName] 
    :"the project name ('" . [projectComponentAST mProjectName] . "') should be the same as the source file base name ('"
    . [[inProjectSourceFile lastPathComponent] stringByDeletingPathExtension] . "')" ;
  end if ;
#--- Check target name
  const @string targetName := [[projectComponentAST mTargetName] string] ;
  if targetName == "" then
    error [projectComponentAST mTargetName]: "the target name should not be empty" ;
  end if ;
#--- Build qualified feature map
  @projectQualifiedFeatureMap projectQualifiedFeatureMap [emptyMap] ;
  foreach projectComponentAST->mQualifiedFeatureList do
    [!?projectQualifiedFeatureMap insertKey
      !mFeatureName
      !mFeatureValue
    ] ;
  end foreach ;
#--- Parse Component struct
  @parsedComponentStruct parsedComponentStruct [new
    ![@parsedSemanticsComponentMap emptyMap]
    ![@parsedLexiqueComponentMap emptyMap]
    ![@parsedSyntaxComponentMap emptyMap]
    ![@parsedOptionComponentMap emptyMap]
    ![@parsedGrammarComponentMap emptyMap]
    ![@parsedProgramComponentMap emptyMap]
    ![@parsedGuiComponentMap emptyMap]
  ] ;
#---------------------------------- Parse sources
  foreach [projectComponentAST mProjectSourceList] do
    const extension := [mFilePath pathExtension] ;
    const componentName := [@lstring new
      ![[mFilePath lastPathComponent] stringByDeletingPathExtension]
      ![mFilePath location]
    ] ;
    const fullFilePath := [@lstring new
      ![inProjectSourceFile stringByDeletingLastPathComponent] . "/" . [mFilePath string]
      ![mFilePath location]
    ] ;
    switch mSourceKind
    when externSourceFile :
    when guiSourceFile :
      if extension == "gGui" then
        if [option .verbose_output value] then
          message "*** Parse '" . [fullFilePath lastPathComponent] . "'\n" ;
        end if ;
        @guiComponentAST guiComponentRoot ;
        grammar guiGrammar in fullFilePath ?guiComponentRoot :> ??@string translatedGUI ;
        if [option galgas_cli_options.convertToGalgas3 value] then
          const projectName := [[fullFilePath lastPathComponent] stringByDeletingPathExtension] ;
          const directory := [fullFilePath stringByDeletingLastPathComponent] . "/../galgas-sources/" ;
          const newProjectFile := directory . projectName . ".galgas" ;
          [translatedGUI writeToFileWhenDifferentContents !newProjectFile ?*] ;
        end if ;
        [!?parsedComponentStruct->mParsedGuiComponentMap insertKey !componentName !fullFilePath !guiComponentRoot] ;
      else
        error mFilePath:"extension of a gui component should be '.gGui'." ;
      end if ;
    when lexiqueSourceFile :
      if extension == "gLexique" then
        if [option .verbose_output value] then
          message "*** Parse '" . [fullFilePath lastPathComponent] . "'\n" ;
        end if ;
        @galgas3LexiqueComponentListAST.element lexiqueComponentRoot ;
        grammar lexiqueLL1grammar in fullFilePath ?lexiqueComponentRoot :> ??@string translatedSource ;
        if [option galgas_cli_options.convertToGalgas3 value] then
          const projectName := [[fullFilePath lastPathComponent] stringByDeletingPathExtension] ;
          const directory := [fullFilePath stringByDeletingLastPathComponent] . "/../galgas-sources/" ;
          const newProjectFile := directory . projectName . ".galgas" ;
          [translatedSource writeToFileWhenDifferentContents !newProjectFile ?*] ;
        end if ;
        [!?parsedComponentStruct->mParsedLexiqueComponentMap insertKey !componentName !lexiqueComponentRoot] ;
      else
        error mFilePath:"extension of a lexique component should be '.gLexique'." ;
      end if ;
    when optionSourceFile :
      if extension == "gOption" then
        if [option .verbose_output value] then
          message "*** Parse '" . [fullFilePath lastPathComponent] . "'\n" ;
        end if ;
        @optionComponentAST optionComponentAST ;
        grammar optionLL1grammar in fullFilePath ?optionComponentAST :> ??@string translatedSource ;
        if [option galgas_cli_options.convertToGalgas3 value] then
          const projectName := [[fullFilePath lastPathComponent] stringByDeletingPathExtension] ;
          const directory := [fullFilePath stringByDeletingLastPathComponent] . "/../galgas-sources/" ;
          const newProjectFile := directory . projectName . ".galgas" ;
          [translatedSource writeToFileWhenDifferentContents !newProjectFile ?*] ;
        end if ;
      #--- Semantic Analysis of option component
        @commandLineOptionMap boolOptionMap ;
        @commandLineOptionMap UIntOptionMap ;
        @commandLineOptionMap stringOptionMap ;
        semanticAnalysisOfOptionComponent
          !optionComponentAST
          ?boolOptionMap
          ?UIntOptionMap
          ?stringOptionMap
        ;
        [!?parsedComponentStruct->mParsedOptionComponentMap insertKey
          !componentName
          !boolOptionMap
          !UIntOptionMap
          !stringOptionMap
        ] ;
      else
        error mFilePath:"extension of an option component should be '.gOption'." ;
      end if ;
    when semanticsSourceFile :
      if extension == "gSemantics" then
        if [option .verbose_output value] then
          message "*** Parse '" . [fullFilePath lastPathComponent] . "'\n" ;
        end if ;
        @semanticsComponentAST semanticsComponentRoot ;
        grammar semanticsSLRgrammar in fullFilePath ?semanticsComponentRoot :> ??@string translatedSource ;
        if [option galgas_cli_options.convertToGalgas3 value] then
          const projectName := [[fullFilePath lastPathComponent] stringByDeletingPathExtension] ;
          const directory := [fullFilePath stringByDeletingLastPathComponent] . "/../galgas-sources/" ;
          const newProjectFile := directory . projectName . ".galgas" ;
          [translatedSource writeToFileWhenDifferentContents !newProjectFile ?*] ;
        end if ;
        [!?parsedComponentStruct->mParsedSemanticsComponentMap insertKey !componentName !fullFilePath !semanticsComponentRoot] ;
      else
        error mFilePath:"extension of a semantics component should be '.gSemantics'." ;
      end if ;
    when syntaxSourceFile :
      if extension == "gSyntax" then
        if [option .verbose_output value] then
          message "*** Parse '" . [fullFilePath lastPathComponent] . "'\n" ;
        end if ;
        @galgas3SyntaxComponentListAST.element syntaxComponentRoot ;
        grammar syntaxSLRgrammar in fullFilePath ?syntaxComponentRoot :> ??@string translatedSource ;
        if [option galgas_cli_options.convertToGalgas3 value] then
          const projectName := [[fullFilePath lastPathComponent] stringByDeletingPathExtension] ;
          const directory := [fullFilePath stringByDeletingLastPathComponent] . "/../galgas-sources/" ;
          const newProjectFile := directory . projectName . ".galgas" ;
          [translatedSource writeToFileWhenDifferentContents !newProjectFile ?*] ;
        end if ;
        [!?parsedComponentStruct->mParsedSyntaxComponentMap insertKey !componentName !fullFilePath !syntaxComponentRoot] ;
      else
        error mFilePath:"extension of a syntax component should be '.gSyntax'." ;
      end if ;
    when grammarSourceFile :
      if extension == "gGrammar" then
        if [option .verbose_output value] then
          message "*** Parse '" . [fullFilePath lastPathComponent] . "'\n" ;
        end if ;
        @galgas3GrammarComponentListAST.element grammarComponentRoot ;
        grammar grammarLL1grammar in fullFilePath ?grammarComponentRoot :> ??@string translatedSource ;
        if [option galgas_cli_options.convertToGalgas3 value] then
          const projectName := [[fullFilePath lastPathComponent] stringByDeletingPathExtension] ;
          const directory := [fullFilePath stringByDeletingLastPathComponent] . "/../galgas-sources/" ;
          const newProjectFile := directory . projectName . ".galgas" ;
          [translatedSource writeToFileWhenDifferentContents !newProjectFile ?*] ;
        end if ;
        [!?parsedComponentStruct->mParsedGrammarComponentMap insertKey !componentName !fullFilePath !grammarComponentRoot] ;
      else
        error mFilePath:"extension of a grammar component should be '.gGrammar'." ;
      end if ;
    when programSourceFile :
      if extension == "gProgram" then
        if [option .verbose_output value] then
          message "*** Parse '" . [fullFilePath lastPathComponent] . "'\n" ;
        end if ;
        @programComponentAST programComponentAST ;
        grammar programSLRgrammar in fullFilePath ?programComponentAST :> ??@string translatedSource ;
        if [option galgas_cli_options.convertToGalgas3 value] then
          const projectName := [[fullFilePath lastPathComponent] stringByDeletingPathExtension] ;
          const directory := [fullFilePath stringByDeletingLastPathComponent] . "/../galgas-sources/" ;
          const newProjectFile := directory . projectName . ".galgas" ;
          [translatedSource writeToFileWhenDifferentContents !newProjectFile ?*] ;
        end if ;
        [!?parsedComponentStruct->mParsedProgramComponentMap insertKey !componentName !fullFilePath !programComponentAST] ;
      else
        error mFilePath:"extension of a program component should be '.gProgram'." ;
      end if ;
    end switch ;
  end foreach ;
#---------------------------------- Compile galgas sources
  @stringset handledExtensionSet [emptySet] ;
  if [@uint errorCount] == 0 then
  #--- Lexique components
    foreach parsedComponentStruct->mParsedLexiqueComponentMap do
      if [option .verbose_output value] then
        message "*** Compiling '" . lkey . ".gLexique'\n" ;
      end if ;
      compileLexiqueComponentFromAST
        !lkey->string
        !outputDirectory
        !mLexiqueComponentAST
      ;
    end foreach ;
  #--- GUI components
    foreach parsedComponentStruct->mParsedGuiComponentMap do
      if [option .verbose_output value] then
        message "*** Compiling '" . lkey . ".gGui'\n" ;
      end if ;
      compileGuiComponentFromAST
        !mSourceFullFilePath
        !outputDirectory
        !mGuiComponentAST
        !?parsedComponentStruct
      ;
    end foreach ;
  #--- Option components
    foreach parsedComponentStruct->mParsedOptionComponentMap do
      if [option .verbose_output value] then
        message "*** Compiling '" . lkey . ".gOption'\n" ;
      end if ;
      compileOptionComponentAST
        !outputDirectory
        !lkey
        !mBoolOptionMap
        !mUIntOptionMap
        !mStringOptionMap
      ;
    end foreach ;
  #--- Semantic components
    foreach parsedComponentStruct->mParsedSemanticsComponentMap do
      if [option .verbose_output value] then
        message "*** Compiling '" . lkey . ".gSemantics'\n" ;
      end if ;
      compileSemanticsComponentAST
        !mSourceFullFilePath
        !outputDirectory
        !mSemanticComponentRoot
        !?parsedComponentStruct
      ;
    end foreach ;
  #--- Syntax components
    foreach parsedComponentStruct->mParsedSyntaxComponentMap do
      if [option .verbose_output value] then
        message "*** Compiling '" . lkey . ".gSyntax'\n" ;
      end if ;
      compileSyntaxComponentFromAST
        !mSourceFullFilePath
        !outputDirectory
        !mSyntaxComponentRoot
        !?parsedComponentStruct
      ;
    end foreach ;
  #--- Grammar components
    foreach parsedComponentStruct->mParsedGrammarComponentMap do
      if [option .verbose_output value] then
        message "*** Compiling '" . lkey . ".gGrammar'\n" ;
      end if ;
      compileGrammarComponentFromAST
        !mSourceFullFilePath
        !outputDirectory
        !mGrammarComponentRoot
        !?parsedComponentStruct
      ;
    end foreach ;
  #--- Program components
    foreach parsedComponentStruct->mParsedProgramComponentMap do
      foreach mProgramComponentAST->mProgramRules do
        handledExtensionSet += !mSourceFileExtension->string ;
      end foreach ;
      if [option .verbose_output value] then
        message "*** Compiling '" . lkey . ".gProgram'\n" ;
      end if ;
      compileProgramComponentFromAST
        !mSourceFullFilePath
        !outputDirectory
        !mProgramComponentAST
        !?parsedComponentStruct
      ;
    end foreach ;
  end if ;
#---------------------------------- Perform global checkings
  if [@uint errorCount] == 0 then
    if [option .verbose_output value] then
      message "*** Perform global checkings\n" ;
    end if ;
    performProjectGlobalCheckings
      !parsedComponentStruct
      !inProjectSourceFile->string
      ![projectComponentAST mEndOfSourceFile]
    ;
  end if ;
#--- Update targets
  if 0 == [@uint errorCount] then
    updateTargets
      !inProjectSourceFile
      ![projectComponentAST->mMajorVersion->uint string] . "." . projectComponentAST->mMinorVersion->uint . "." . projectComponentAST->mRevisionVersion->uint
      ![projectComponentAST mProjectName]
      !targetName
      !projectQualifiedFeatureMap
      ![projectComponentAST mGenerationFeatureList]
      ![projectComponentAST mProjectSourceList]
      !handledExtensionSet
    ;
  end if ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#          galgasProject                                                     *
#                                                                            *
#----------------------------------------------------------------------------*

when . "galgasProject"
message "a GALGAS project source file"
indexing with galgas3ProjectGrammar
??@lstring inProjectSourceFile {
  message "*** Parsing project files\n" ;
  grammar galgas3ProjectGrammar in inProjectSourceFile
    ??@galgas3ProjectComponentAST projectComponentAST
  ;
  var declarationAST := [@galgas3DeclarationAST default] ; 
  foreach projectComponentAST->mProjectSourceList do
    if [mValue pathExtension] == "galgas" then
      const absoluteSourcePath := [mValue absolutePathFromPath ![inProjectSourceFile stringByDeletingLastPathComponent]] ;
      grammar galgas3Grammar in [@lstring new !absoluteSourcePath !mValue->location] !?declarationAST ;
    else
      error mValue: "only \".galgas\" extension is allowed here" ;
    end if ;
  end foreach ;
#---------------------------------- Hand coded source files
  var handCodedSourceAppFileList := [@stringlist emptyList] ;
  var handCodedSourceToolFileList := [@stringlist emptyList] ;
  var handCodedLinkToolFileList := [@stringlist emptyList] ;
  var handCodedSourceDirectorySet := [@stringset emptySet] ;
  for * in projectComponentAST->mQualifiedFeatureList do
    if mFeatureName->string == "tool-source" then
      handCodedSourceToolFileList += ![mFeatureValue lastPathComponent] ;
      const directory := [mFeatureValue stringByDeletingLastPathComponent] ;
      if directory != "" then
        handCodedSourceDirectorySet += !"../" + directory ;
      end if ;
    elsif mFeatureName->string == "app-source" then
      handCodedSourceAppFileList += ![mFeatureValue lastPathComponent] ;
      const directory := [mFeatureValue stringByDeletingLastPathComponent] ;
      if directory != "" then
        handCodedSourceDirectorySet += !"../" + directory ;
      end if ;
    elsif mFeatureName->string == "tool-link" then
      handCodedLinkToolFileList += !mFeatureValue->string ;
    end if ;
  end for ;
#---------------------------------- Display result
  var toolCppFileList := [@stringlist emptyList] ;
  var allProductFileSet := [@stringset emptySet] ;
  if [@uint errorCount] == 0 then
    message "  Semantic declarations: " . [declarationAST->mSemanticDeclarationList length] . "\n" ;
    message "  Lexique components: " . [declarationAST->mLexiqueComponentList length] . "\n" ;
    message "  Syntax components: " . [declarationAST->mSyntaxComponentList length] . "\n" ;
    message "  Grammar components: " . [declarationAST->mGrammarComponentList length] . "\n" ;
    message "  GUI components: " . [declarationAST->mGUIComponentList length] . "\n" ;
    message "  Option components: " . [declarationAST->mOptionComponentList length] . "\n" ;
    message "  Source rules: " . [declarationAST->mSourceRuleList length] . "\n" ;
    message "  Prologue procs: " . [declarationAST->mPrologueDeclarationList length] . "\n" ;
    message "  Epilogue procs: " . [declarationAST->mEpilogueDeclarationList length] . "\n" ;
  end if ;
#---------------------------------- Compile semantic declarations
  const productDirectory := [inProjectSourceFile stringByDeletingLastPathComponent] . "/build/output" ;
  var appProductFileList := [@stringlist emptyList] ;
  var semanticContext := [@semanticContext default] ;
  @semanticDeclarationSortedListForGeneration semanticDeclarationSortedListForGeneration ;
  if [@uint errorCount] == 0 then
    compileSemanticDeclarationsGalgas3
      !inProjectSourceFile->string
      !projectComponentAST->mEndOfSourceFile
      !declarationAST->mSemanticDeclarationList
      !declarationAST->mOptionComponentList
      !declarationAST->mLexiqueComponentList
      !declarationAST->mGrammarComponentList
      ?semanticContext
      ?semanticDeclarationSortedListForGeneration
    ;
  else
    semanticDeclarationSortedListForGeneration := [@semanticDeclarationSortedListForGeneration emptySortedList] ;
  end if ;
#---------------------------------- Compile option declarations
  if [@uint errorCount] == 0 then
    foreach semanticContext->mOptionComponentMapForSemanticAnalysis do
      if not mIsPredefined then
        compileOptionComponentGalgas3
          !productDirectory
          !lkey->string
          !mBoolOptionMap
          !mUIntOptionMap
          !mStringOptionMap
          !?toolCppFileList
          !?appProductFileList
          !?allProductFileSet
        ;
      end if ;
    end foreach ;
  end if ;
#---------------------------------- Compile lexique components
  if [@uint errorCount] == 0 then
    for scanner in declarationAST->mLexiqueComponentList do
      compileLexiqueComponentGalgas3
        !productDirectory
        !scanner
        !?toolCppFileList
        !?appProductFileList
        !?allProductFileSet
      ;
    end for ;
  end if ;
#---------------------------------- Compile syntax components
  var parsedSyntaxComponentMap := [@parsedSyntaxComponentMap emptyMap] ;
  var syntaxListForGeneration := [@syntaxListForGeneration emptyList] ;
  if [@uint errorCount] == 0 then
    for component in declarationAST->mSyntaxComponentList do
      compileSyntaxComponentGalgas3
        !component
        !semanticContext
        !?parsedSyntaxComponentMap
        !?syntaxListForGeneration
      ;
    end for ;
  end if ;
#---------------------------------- Compile grammar components
  if [@uint errorCount] == 0 then
    for component in declarationAST->mGrammarComponentList do
      compileGrammarComponentGalgas3
        !productDirectory
        !component
        !parsedSyntaxComponentMap
        !semanticContext
        !?toolCppFileList
        !?allProductFileSet
      ;
    end for ;
  end if ;
#---------------------------------- Compile program declarations
  if [@uint errorCount] == 0 then
    compileProgramComponentGalgas3
      !productDirectory
      !declarationAST->mPrologueDeclarationList
      !declarationAST->mSourceRuleList
      !declarationAST->mEpilogueDeclarationList
      !semanticContext
      !?toolCppFileList
      !?allProductFileSet
    ;
  end if ;
#---------------------------------- File generation
  if 0 == [@uint errorCount] then
    if [option .verbose_output value] then
      message "*** Generating files\n" ;
    end if ;
  end if ;
#---------------------------------- Generate syntax components
  if 0 == [@uint errorCount] then
    for s in syntaxListForGeneration do
      generateSyntaxComponentGalgas3
        !productDirectory
        !s
        !semanticContext
        !?toolCppFileList
        !?allProductFileSet
      ;
    end for ;
  end if ;
#---------------------------------- Generate semantic files
  generateSemanticDeclarationsGalgas3
    !productDirectory
    ![@generationKind oneFile]
    !semanticContext
    !semanticDeclarationSortedListForGeneration
    !?toolCppFileList
    !?allProductFileSet
  ;
#---------------------------------- Remove useless files
  var allActualFileSet := [@stringset emptySet] ;
  foreach [productDirectory regularFiles !false] do
    allActualFileSet += !mValue ;
  end foreach ;
  const uselessFileSet := allActualFileSet - allProductFileSet ;
  foreach uselessFileSet do
    [@string deleteFile !productDirectory . "/" . key] ;
  end foreach ;
#---------------------------------- Update targets
  if 0 == [@uint errorCount] then
    @stringset handledExtensionSet [emptySet] ;
    for * in declarationAST->mSourceRuleList do
      handledExtensionSet += !mSourceFileExtension->string ;
    end for ;
  #--- Build qualified feature map
    var ignoredFeatureSet := [@stringset emptySet] ;
    ignoredFeatureSet += !"tool-source" ;
    ignoredFeatureSet += !"tool-link" ;
    ignoredFeatureSet += !"app-source" ;
    @projectQualifiedFeatureMap projectQualifiedFeatureMap [emptyMap] ;
    foreach projectComponentAST->mQualifiedFeatureList do
      if not [ignoredFeatureSet hasKey !mFeatureName->string] then
        [!?projectQualifiedFeatureMap insertKey
          !mFeatureName
          !mFeatureValue
        ] ;
      end if ;
    end foreach ;
    updateGalgas3Targets
      !inProjectSourceFile
      !projectComponentAST->mTargetName->string
      !projectComponentAST->mEndOfSourceFile
      ![projectComponentAST->mMajorVersion->uint string] . "." . projectComponentAST->mMinorVersion->uint . "." . projectComponentAST->mRevisionVersion->uint
      !projectQualifiedFeatureMap
      !projectComponentAST->mGenerationFeatureList
      !toolCppFileList
      !appProductFileList
      !handCodedSourceToolFileList
      !handCodedSourceDirectorySet
      !handledExtensionSet
      !handCodedLinkToolFileList
    ;
  end if ;
}

#----------------------------------------------------------------------------*
#                                                                            *
#          galgas                                                            *
#                                                                            *
#----------------------------------------------------------------------------*

when . "galgas"
message "a GALGAS source file"
indexing with projectLL1grammar
??@lstring inSourceFile {
  var declaration := [@galgas3DeclarationAST default] ; 
  grammar galgas3Grammar in inSourceFile !?declaration ;
}

#---------------------------------------------------------------------------*

after {
}

#---------------------------------------------------------------------------*

end program ;

#---------------------------------------------------------------------------*
