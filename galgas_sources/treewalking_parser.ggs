#---------------------------------------------------------------------------*
#                                                                           *
#  GALGAS treewalking component parser definition                           *
#                                                                           *
#  Copyright (C) 2007 Pierre Molinaro.                                      *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax treewalking_parser :

import lexique galgas_scanner in "galgas_scanner.ggs" ;

import semantics semantics_semantics in "semantics_semantics.ggs" ;

#-------------------------------------------------------------------*

nonterminal <galgas_component>
  ?!@M_lexiqueComponents ioLexiqueMapForUse
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_optionComponents ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importLexique
  ?!@M_lexiqueComponents ioLexiqueMapForUse
label importSyntax
  ?!@M_syntaxComponents ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
label importSemantics
  ?!@M_semanticsComponents ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importGrammarForSemantics
  ?!@M_grammarComponents ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label importOptions
  ?!@M_optionComponents ioOptionsComponentsMap
;

nonterminal <parse_treewalking_document>
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
  ??@bool inGenerateTreewalkingCode
label parse
;

nonterminal <parse_semantics_component_for_importing>
  ??@lstring inFileName
  ?!@M_semanticsComponents ioSemanticsMapForUse
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
label parse
;

nonterminal <treewalking_routine>
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@stringset inMetamodelMultiReferencedEntities
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ?!@treewalkingRoutineToGenerateList ioTreewalkingRoutineToGenerateList
label firstLocalPhase
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@treewalkingRoutineHeaderMap ioTreewalkingRoutineHeaderMap
label parse
;

nonterminal <formal_arguments_list>
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  !@L_EXsignature listeDeTypes
  ?!@typeVariablesMap localVariableMap
  !@typeListeTypesEtNomsArgMethode listeTypeEtNomsArguments
  ?!@typeTableEnAvant tableEnAvant
  !@L_signature outSignature
label importGrammarForSemantics
  !@L_signature outSignature
label parse
;

nonterminal <semantic_instructions_list>
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ??@typeTableEnAvant inTableEnAvant
  ??@M_semanticsEntitiesForUse ioComponentSemanticsEntitiesMap
  ??@M_optionComponents inOptionsComponentsMapForUse
  ?!@typeVariablesMap ioVariablesMap
  ?!@typeInstructionList ioInstructionList
  ??@entityPropertyMap ioPropertyMap
  ?!@stringset ioConstraintPropertyDefinitionSet
label parse
;

#-------------------------------------------------------------------*
#                   treewalking component                           *
#-------------------------------------------------------------------*

rule <galgas_component>
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_optionComponents unused ioOptionsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_treewalking_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
    !true
  ;
label importLexique
  ?!@M_lexiqueComponents unused ioLexiqueMapForUse
:
  <parse_treewalking_document> parse ;
label importSyntax
  ?!@M_syntaxComponents unused ioSyntaxComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
:
  @M_constraintComponents constraintComponentMap [emptyMap] ;
  <parse_treewalking_document>
    !?ioMetamodelComponentMap
    !?constraintComponentMap
    !false
  ;
label importSemantics
  ?!@M_semanticsComponents unused ioSemanticsComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_treewalking_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
    !false
  ;
label importGrammarForSemantics
  ?!@M_grammarComponents unused ioGrammarComponentsMap
  ?!@M_metamodelsComponents ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
:
  <parse_treewalking_document>
    !?ioMetamodelComponentMap
    !?ioConstraintComponentMap
    !false
  ;
label importOptions
  ?!@M_optionComponents unused ioOptionsComponentsMap
:
  <parse_treewalking_document> parse ;
end rule ;


#-------------------------------------------------------------------*

rule <parse_treewalking_document>
  ?!@M_metamodelsComponents unused ioMetamodelComponentMap
  ?!@M_constraintComponents ioConstraintComponentMap
  ??@bool inGenerateTreewalkingCode
:
#--- Tree walking component header
  $treewalking$ ;
  @lstring treewalkingName ;
  $identifier$ ? treewalkingName ;
#--- Metamodel to walking trought
  $($ ;
  @lstring metamodelName ;
  $identifier$ ? metamodelName ;
  $)$ ;
  $:$ ;
  @stringset filesToImportInHeaderSet [setWithString ![metamodelName string]] ;
#--- Imported Metamodel
  @M_semanticsComponents semanticsComponentMap [emptyMap] ;
  @M_metamodelsComponents metamodelComponentMap [emptyMap] ;
  $import$ ;
  @lstring fileName ;
  $literal_string$ ? fileName ;
  $;$ ;  
  <parse_semantics_component_for_importing>
    !fileName
    !?semanticsComponentMap
    !?metamodelComponentMap
    !?ioConstraintComponentMap
  ;
  @lstring metamodelRootEntity ;
  @entityToImplementMap metamodelEntityMap ;
  @stringset metamodelMultiReferencedEntities ;
  if [metamodelComponentMap hasKey ![metamodelName string]] then
    [metamodelComponentMap searchKey
       !metamodelName
       ?metamodelRootEntity
       ?metamodelEntityMap
       ?metamodelMultiReferencedEntities
    ] ;
  else
    error fileName: "this file does not define the '" . [metamodelName string] . "' metamodel"
     -> metamodelRootEntity, metamodelEntityMap, metamodelMultiReferencedEntities ;
  end if ;
#--- Import semantics component(s)
  @M_optionComponents optionsComponentsMapForUse [emptyMap] ;
  @M_semanticsEntitiesForUse semanticsEntitiesMap ;
  enterBuiltinTypes ?semanticsEntitiesMap ;
  repeat
  while
    $import$ ;
    $semantics$ ;
    @lstring semanticsComponentName ;
    $identifier$ ? semanticsComponentName ;
    filesToImportInHeaderSet += ![semanticsComponentName string] ;
    $in$ ;    
    @lstring fileName ;
    $literal_string$ ? fileName ;
    $;$ ;  
    <parse_semantics_component_for_importing>
      !fileName
      !?semanticsComponentMap
      !?metamodelComponentMap
      !?ioConstraintComponentMap
    ;
    @M_semanticsEntitiesForUse importedSemanticsEntitiesMap ;
    [semanticsComponentMap searchKey !semanticsComponentName ?6* ?importedSemanticsEntitiesMap] ;
    foreach importedSemanticsEntitiesMap (@lstring kKey @AC_semanticsEntity kEntity) :
      if not [semanticsEntitiesMap hasKey ![kKey string]] then
        [!?semanticsEntitiesMap insertKey !kKey  !kEntity] ;
      end if ;
    end foreach ;
  end repeat ;
#---------------------- parse routine definitions
#--- FIRST PASS
  @treewalkingRoutineToGenerateList treewalkingRoutineToGenerateList [emptyList] ;
  @treewalkingRoutineHeaderMap treewalkingRoutineHeaderMap [emptyMap] ;
  @routineDispatcherSortedList routineDispatcherSortedList [emptySortedList] ;
  parse do
#--- FIRST PASS
    repeat
    while
      <treewalking_routine> firstLocalPhase
        !semanticsEntitiesMap
        !?treewalkingRoutineHeaderMap
      ;
    end repeat ;
  rewind
#--- SECOND PASS
    repeat
    while
      <treewalking_routine>
        !semanticsEntitiesMap
        !metamodelEntityMap
        !metamodelMultiReferencedEntities
        !optionsComponentsMapForUse
        !treewalkingRoutineHeaderMap
        !?treewalkingRoutineToGenerateList
      ;
    end repeat ;
  end parse ;
#--- Get Root routine signature
  @typeListeTypesEtNomsArgMethode rootRoutineSignature ;
  if [treewalkingRoutineHeaderMap hasKey ![metamodelRootEntity string]] then
    [treewalkingRoutineHeaderMap searchKey !metamodelRootEntity ?* ?rootRoutineSignature] ;
  else
    error here:"a routine should be defined for the '%" . [metamodelRootEntity string] . "' root class"
    -> rootRoutineSignature ;
  end if ;
#--- Generate code, and additional checkings ?
  if inGenerateTreewalkingCode then
  #--- check if a class defines a routine, a routine defined by a super class 
  #    should have the same signature
    foreach treewalkingRoutineHeaderMap (@lstring kKey @L_EXsignature kRoutineSignature *) :
      @luint entityID ;
      [metamodelEntityMap searchKeyGetID !kKey ?entityID ?8*] ;
      routineDispatcherSortedList += 
        ![[entityID uint] string]
        ![entityID uint]
        ![kKey string]
        ![kKey string]
        ;
      @lstring entityName := kKey ;
      loop [metamodelEntityMap count] : while [entityName string] != "" do
        @lstring superEntityName ;
        [metamodelEntityMap searchKey !entityName ?3* ?superEntityName ?4*] ;
        if [treewalkingRoutineHeaderMap hasKey ![superEntityName string]] then
          @L_EXsignature superRoutineSignature ;
          [treewalkingRoutineHeaderMap searchKey !superEntityName ?superRoutineSignature ?*] ;
          verifierCompatibiliteSignatures
            !kRoutineSignature
            !superRoutineSignature
            ![kKey location]
          ;
        end if ;
        entityName  := superEntityName ;
      end loop ;
    end foreach ;
  #--- If a class does not define a routine, use the super class 
  #    routine (if it exists)
    foreach metamodelEntityMap (@lstring kEntityName 3* @lstring kSuperEntityName 4*) :
      @bool hasRoutine := [treewalkingRoutineHeaderMap hasKey ![kEntityName string]] ;
      if not hasRoutine then
        @lstring superEntityName := kSuperEntityName ;
        loop [treewalkingRoutineHeaderMap count] : while (not hasRoutine) & ([superEntityName string] != "") do
          hasRoutine := [treewalkingRoutineHeaderMap hasKey ![superEntityName string]] ;
          if not hasRoutine then
            @lstring superSuperEntityName ;
            [metamodelEntityMap searchKey !superEntityName ?3* ?superSuperEntityName ?4*] ;
            superEntityName := superSuperEntityName ;
          end if ;
        end loop ;
        if hasRoutine then
          @luint entityID ;
          [metamodelEntityMap searchKeyGetID !kEntityName ?entityID ?8*] ;
          routineDispatcherSortedList += 
            ![[entityID uint] string]
            ![entityID uint]
            ![superEntityName string]
            ![kEntityName string]
          ;
        end if ;
      end if ;
    end foreach ;
  #--- Generate code
    action generate_treewalking
      !treewalkingName
      !filesToImportInHeaderSet
      !treewalkingRoutineToGenerateList
      !routineDispatcherSortedList
      !metamodelEntityMap
      !rootRoutineSignature
      !metamodelRootEntity
    ;
  end if ;
#--- End of treewalking component
  $end$ ;
  $treewalking$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

rule <treewalking_routine>
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ??@entityToImplementMap inMetamodelEntityMap
  ??@stringset unused inMetamodelMultiReferencedEntities
  ??@M_optionComponents inOptionsComponentsMapForUse
  ??@treewalkingRoutineHeaderMap inTreewalkingRoutineHeaderMap
  ?!@treewalkingRoutineToGenerateList ioTreewalkingRoutineToGenerateList
:
  $rule$ ;
  @lstring metamodelClassName ;
  $mda_type_name$ ? metamodelClassName ;
  @entityPropertyMap allMetamodelPropertyMap ;
  [inMetamodelEntityMap searchKey !metamodelClassName ?allMetamodelPropertyMap ?7*] ;
#---- Formal arguments -----------------------------------------
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap localVariableMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode formalArgumentList ;
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !inSemanticsEntitiesMap
    ?listeDeTypes
    !?localVariableMap
    ?formalArgumentList
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
#--- Add metamodel attributes as local constants
  foreach allMetamodelPropertyMap (@lstring kKey @metamodelProperty kProperty) :
    extract kProperty :
    when @metamodelAttributeProperty (@AC_galgasType kType) ->
      @typeCplusPlusName cppName := [@typeCurrentObjectName new !kKey] ;
      [!?localVariableMap insertUsedConstInArgument !kKey ! kType !cppName] ;
    else
    end extract ;
  end foreach ;
#--- Instruction list
  $:$ ;
  @typeInstructionList instructionList [emptyList] ;
  @stringset constraintPropertyDefinitionSet [emptySet] ;
  <semantic_instructions_list>
    !inTreewalkingRoutineHeaderMap
    !tableEnAvant
    !inSemanticsEntitiesMap
    !inOptionsComponentsMapForUse
    !?localVariableMap
    !?instructionList
    !allMetamodelPropertyMap
    !?constraintPropertyDefinitionSet
  ;
#---
  ioTreewalkingRoutineToGenerateList +=
    !metamodelClassName
    !formalArgumentList
    !instructionList
  ;
#--- End of rule
  $end$ ;
  $rule$ ;
  $;$ ;
label firstLocalPhase
  ??@M_semanticsEntitiesForUse inSemanticsEntitiesMap
  ?!@treewalkingRoutineHeaderMap ioTreewalkingRoutineHeaderMap
:
  $rule$ ;
  @lstring metamodelClassName ;
  $mda_type_name$ ? metamodelClassName ;
  @entityPropertyMap allMetamodelPropertyMap ;
#---- Formal arguments -----------------------------------------
  @typeTableEnAvant tableEnAvant [emptyMap] ;
  @L_EXsignature listeDeTypes ;
  @typeVariablesMap localVariableMap [emptyMap] ;
  @typeListeTypesEtNomsArgMethode formalArgumentList ;
  @L_signature signatureForGrammarComponent ;
  <formal_arguments_list>
    !inSemanticsEntitiesMap
    ?listeDeTypes
    !?localVariableMap
    ?formalArgumentList
    !?tableEnAvant
    ?signatureForGrammarComponent
  ;
  [!?ioTreewalkingRoutineHeaderMap insertKey !metamodelClassName !listeDeTypes !formalArgumentList] ;
#--- Instruction list
  $:$ ;
  <semantic_instructions_list> parse ;
#---
  $end$ ;
  $rule$ ;
  $;$ ;
end rule ;

#-------------------------------------------------------------------*

end syntax ;
