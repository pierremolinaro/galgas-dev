//--------------------------------------------------------------------------------------------------
//
//  Copyright (C) 2007, ..., 2023 Pierre Molinaro.
//
//  MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//--------------------------------------------------------------------------------------------------
//
//    C H E C K    M E T H O D    S I G N A T U R E
//
//--------------------------------------------------------------------------------------------------

proc checkMethodSignatures
  ?let @formalParameterListForGeneration inTestedSignature
  ?let @location inErrorLocation
  ?let @formalParameterSignature inReferenceSignature
  ?let @location inReferenceLocation
{
  if inTestedSignature.count != inReferenceSignature.count then
    error inErrorLocation:"this method declares " + inTestedSignature.count.string
    + " formal parameter(s), but overriden method declares " + inReferenceSignature.count.string
    error inReferenceLocation:"overriden method is declared here"
  else
    for (ref_mFormalSelector ref_mFormalArgumentType ref_mFormalArgumentPassingMode *) in inReferenceSignature, (mFormalSelector mFormalArgumentPassingMode mFormalArgumentType mFormalArgumentName *) in inTestedSignature do
      if ref_mFormalArgumentPassingMode != mFormalArgumentPassingMode then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter is declared as "
        + mFormalArgumentPassingMode.formalArgumentMessage + ", but overriden method declares it as "
        + ref_mFormalArgumentPassingMode.formalArgumentMessage
        error inReferenceLocation:"overriden method is declared here"
      end
      if mFormalSelector.string != ref_mFormalSelector.string then
        var @string s
        switch ref_mFormalArgumentPassingMode
        case argumentConstantIn, argumentVarIn :
          s = "?"
        case argumentInOut :
          s = "?!"
        case argumentOut :
          s = "!"
        end
        s += if ref_mFormalSelector.string != "" then ref_mFormalSelector.string + ":" else "" end
        error mFormalSelector : "the selector should be '" + s + "'" fixit { replace s }
      end
      if mFormalArgumentType.definition.typeName.string != ref_mFormalArgumentType.definition.typeName.string then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter has the '@"
        + mFormalArgumentType.definition.typeName.string + "' type, but overriden method declares with the '@"
        + ref_mFormalArgumentType.definition.typeName.string + "' type"
        error inReferenceLocation:"overriden method is declared here"
      end
    end
  end
}

//--------------------------------------------------------------------------------------------------
//
//    C H E C K    G E T T E R    S I G N A T U R E
//
//--------------------------------------------------------------------------------------------------

proc checkGetterSignatures
  ?let @formalInputParameterListForGeneration inTestedSignature
  ?let @unifiedTypeMapEntry inReturnType
  ?let @location inErrorLocation
  ?let @functionSignature inReferenceSignature
  ?let @unifiedTypeMapEntry inInheritedReturnType
  ?let @location inReferenceLocation {
  if inReturnType.definition.typeName.string != inInheritedReturnType.definition.typeName.string then
    error inErrorLocation : "the return type is '@"
    + inReturnType.definition.typeName.string + "', but overriden getter names '@"
    + inInheritedReturnType.definition.typeName.string + "' as return type"
    error inReferenceLocation:"overriden getter is declared here"
  end
  if inTestedSignature.count != inReferenceSignature.count then
    error inErrorLocation:"this getter declares " + inTestedSignature.count.string
    + " formal parameter(s), but overriden getter declares " + inReferenceSignature.count.string
    error inReferenceLocation:"overriden getter is declared here"
  else
    for (ref_mFormalSelector ref_mFormalArgumentType 2*) in inReferenceSignature, (mFormalSelector mFormalArgumentType * mFormalArgumentName *) in inTestedSignature do
      if mFormalSelector.string != ref_mFormalSelector.string then
        let @string s = "?" + if ref_mFormalSelector.string != "" then ref_mFormalSelector.string + ":" else "" end
        error mFormalSelector : "the selector should be '" + s + "'" fixit { replace s }
      end
      if mFormalArgumentType.definition.typeName.string != ref_mFormalArgumentType.definition.typeName.string then
        error mFormalArgumentName : "the '" + mFormalArgumentName + "' formal parameter has the '@"
        + mFormalArgumentType.definition.typeName.string + "' type, but overriden getter declares with the '@"
        + ref_mFormalArgumentType.definition.typeName.string + "' type"
        error inReferenceLocation:"overriden getter is declared here"
      end
    end
  end
}

//--------------------------------------------------------------------------------------------------

map @propertyIndexMap {
  public let @unifiedTypeMapEntry mPropertyTypeIndex
  insert insertKey error message "the '%K' attribute is already declared"
  search searchKey error message "the '%K' attribute is not declared"
}

//--------------------------------------------------------------------------------------------------
//         M A P
//--------------------------------------------------------------------------------------------------

proc buildLocalVariableMapAndSignature ?let @semanticContext unused inSemanticContext
                                       ?!@unifiedTypeMap ioTypeMap
                                       ?let @formalParameterListAST inRoutineSignatureAST
                                       ?!@localVarManager ioVariableMap
                                       !@formalParameterListForGeneration outRoutineSignature {
  outRoutineSignature = @formalParameterListForGeneration ()
  for formalArgument in inRoutineSignatureAST do
    let type = [ioTypeMap typeMapEntryForLKey !formalArgument.mFormalArgumentTypeName]
    let @string formalArgumentCppName
    switch formalArgument.mFormalArgumentPassingMode
    case argumentVarIn :
      formalArgumentCppName = "inArgument_"
         + formalArgument.mFormalArgumentName.string.identifierRepresentation
      if formalArgument.mIsUnused then
        [!?ioVariableMap insertInputFormalArgumentDeclaredAsUnused
          !formalArgument.mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      else
        [!?ioVariableMap insertInputFormalArgument
          !formalArgument.mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      end
    case argumentOut :
      formalArgumentCppName = "outArgument_"
        + formalArgument.mFormalArgumentName.string.identifierRepresentation
      [!?ioVariableMap insertOutputFormalArgument
        !formalArgument.mFormalArgumentName
        !type
        !formalArgumentCppName
        !formalArgumentCppName
      ]
    case argumentInOut :
      formalArgumentCppName = "ioArgument_"
         + formalArgument.mFormalArgumentName.string.identifierRepresentation
      if formalArgument.mIsUnused then
        [!?ioVariableMap insertInputOutputFormalArgumentDeclaredAsUnused
          !formalArgument.mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      else
        [!?ioVariableMap insertInputOutputFormalArgument
          !formalArgument.mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      end
    case argumentConstantIn :
      formalArgumentCppName = "constinArgument_"
        + formalArgument.mFormalArgumentName.string.identifierRepresentation
      if formalArgument.mIsUnused then
        [!?ioVariableMap insertConstantInputFormalArgumentDeclaredAsUnused
          !formalArgument.mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      else
        [!?ioVariableMap insertConstantInputFormalArgument
          !formalArgument.mFormalArgumentName
          !type
          !formalArgumentCppName
          !formalArgumentCppName
        ]
      end
    end
    outRoutineSignature += !formalArgument.mFormalSelector !formalArgument.mFormalArgumentPassingMode !type !formalArgument.mFormalArgumentName !formalArgumentCppName
  end
}

//--------------------------------------------------------------------------------------------------

proc analyzeRoutineBody ?let @lstring inUsefulnessCallerEntityName
                        ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                        ?let @analysisContext inAnalysisContext
                        ?!@unifiedTypeMap ioTypeMap
                        ?let @formalParameterListAST inRoutineSignatureAST
                        ?let @semanticInstructionListAST inInstructionList
                        ?let @location inEndOfMethodLocation
                        !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
                        !@formalParameterListForGeneration outRoutineSignature {
  var variableMap = @localVarManager {}
//--- Enter properties that should be explicitly initialized
  if let selfAvailable = inAnalysisContext.selfAvailability.getAvailable then
    for property in selfAvailable.type.definition.allTypedPropertyList do
      let initialized = if selfAvailable.selfMutability == .initializer
        then property.initialization != .none
        else true
      end
      [!?variableMap insertInitializerSelfProperty
        !property.name.string
        !inEndOfMethodLocation
        !property.typeEntry
        !"<< unused >>"
        !"self." + property.name
        !initialized: initialized
      ]
    end
  end
//--- Enter formal arguments
  buildLocalVariableMapAndSignature (
    !inAnalysisContext.semanticContext
    !?ioTypeMap
    !inRoutineSignatureAST
    !?variableMap
    ?outRoutineSignature
  )
//---  Analyze instruction list
  outSemanticInstructionListForGeneration = @semanticInstructionListForGeneration ()
  for (mInstruction) in inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ]
   end
//---
  [variableMap checkAutomatonStates !inEndOfMethodLocation]
}

//--------------------------------------------------------------------------------------------------

override method @externFunctionDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext unused inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @predefinedTypes unused inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
//--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  if self.usefullFunc then
    ioUsefulnessRootEntities += !nameForUsefulness
  end
//---
  var formalArgumentList = @formalInputParameterListForGeneration ()
  for (mFormalSelector mFormalArgumentTypeName mFormalArgumentName * mIsConstant) in self.mFormalArgumentList do
    formalArgumentList +=
      !mFormalSelector
      ![ioTypeMap typeMapEntryForLKey !mFormalArgumentTypeName]
      !mFormalArgumentName.string
      !mFormalArgumentName
      !mIsConstant
  end
  ioSemanticDeclarationListForGeneration +=
    !infoMessage: "extern func " + self.mFunctionName
    !@functionPrototypeDeclarationForGeneration {
      !generateHeader: true // Generate Cpp header file
      !implementationCppFileName: "func-" + self.mFunctionName.string.fileNameRepresentation
      !self.mFunctionName.string
      !formalArgumentList
      ![ioTypeMap typeMapEntryForLKey !self.mResultTypeName]
   }
}

//--------------------------------------------------------------------------------------------------

proc analyzeFunctionBody
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @formalInputParameterListAST inFunctionSignature
  ?let @semanticInstructionListAST inInstructionList
  ?let @lstring inReturnVariableName
  ?let @lstring inResultTypeName
  ?let @location inEndOfFunctionLocation
  !@formalInputParameterListForGeneration outSignatureForGeneration
  !@unifiedTypeMapEntry outReturnedType
  !@string outResultVariableCppName
  !@semanticInstructionListForGeneration outSemanticInstructionListForGeneration
{
  var variableMap = @localVarManager {}
//--- Enter formal parameters
  outSignatureForGeneration = @formalInputParameterListForGeneration ()
  for formalArg in inFunctionSignature do
    let parameterType = [ioTypeMap typeMapEntryForLKey !formalArg.mFormalArgumentTypeName]
    if formalArg.mIsConstant then
      let @string cppName = "constinArgument_" + formalArg.mFormalArgumentName.string.identifierRepresentation
      outSignatureForGeneration +=
        !formalArg.mFormalSelector
        !parameterType
        !cppName
        !formalArg.mFormalArgumentName
        !formalArg.mIsConstant
      if formalArg.mIsUnused then
        [!?variableMap insertConstantInputFormalArgumentDeclaredAsUnused !formalArg.mFormalArgumentName !parameterType !cppName !cppName]
      else
        [!?variableMap insertConstantInputFormalArgument !formalArg.mFormalArgumentName !parameterType !cppName !cppName]
      end
    else
      let @string cppName = "inArgument_" + formalArg.mFormalArgumentName.string.identifierRepresentation
      outSignatureForGeneration +=
        !formalArg.mFormalSelector
        !parameterType
        !cppName
        !formalArg.mFormalArgumentName
        !formalArg.mIsConstant
      if formalArg.mIsUnused then
        [!?variableMap insertInputFormalArgumentDeclaredAsUnused !formalArg.mFormalArgumentName !parameterType !cppName !cppName]
      else
        [!?variableMap insertInputFormalArgument !formalArg.mFormalArgumentName !parameterType !cppName !cppName]
      end
    end
  end
//--- Enter return variable
  outReturnedType = [ioTypeMap typeMapEntryForLKey !inResultTypeName]
  outResultVariableCppName = "result_" + inReturnVariableName.string.identifierRepresentation
  [!?variableMap insertOutputFormalArgument !inReturnVariableName !outReturnedType !outResultVariableCppName !outResultVariableCppName]
//--- Enter properties that should be explicitly initialized
  if let selfAvailable = inAnalysisContext.selfAvailability.getAvailable then
    for property in selfAvailable.type.definition.allTypedPropertyList do
      [!?variableMap insertInitializerSelfProperty
        !property.name.string
        !inEndOfFunctionLocation
        !property.typeEntry
        !"<< unused >>"
        !"self." + property.name
        !initialized: true
      ]
    end
  end
//---  Analyze instruction list
  outSemanticInstructionListForGeneration = @semanticInstructionListForGeneration ()
  for (mInstruction) in inInstructionList do
    [mInstruction analyzeSemanticInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !?outSemanticInstructionListForGeneration
      !?variableMap
    ]
   end
//---
  [variableMap checkAutomatonStates !inEndOfFunctionLocation]
}

//--------------------------------------------------------------------------------------------------

override method @functionDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
//--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  if self.usefullFunc then
    ioUsefulnessRootEntities += !nameForUsefulness
  end
//--- Analyse function body
  let analysisContext = @analysisContext {
    !inSemanticContext
    !inPredefinedTypes
    !selfObjectCppName: ""
    !selfAvailability: .none
    !selfObjectCppPrefixForAccessingProperty: ""
  }
  analyzeFunctionBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContext
    !?ioTypeMap
    !self.mFormalArgumentList
    !self.mFunctionInstructionList
    !self.mResultVariableName
    !self.mResultTypeName
    !self.mEndOfFunctionInstructionList
    ?let formalInputParameterList
    ?let returnType
    ?let resultVariableCppName
    ?let semanticInstructionListForGeneration
  )
//---
  ioSemanticDeclarationListForGeneration +=
    !infoMessage: "function " + self.mFunctionName
    !@functionImplementationForGeneration {
      !generateHeader: true // Generate Cpp header file
      !implementationCppFileName: "func-" + self.mFunctionName.string.fileNameRepresentation
      !self.mFunctionName.string
      !formalInputParameterList
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration}
}

//--------------------------------------------------------------------------------------------------

override method @onceFunctionDeclarationAST semanticAnalysis
  ?!@lstringlist ioUsefulnessRootEntities
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
//--- Useful entities graph
  let nameForUsefulness = functionNameForUsefulEntitiesGraph (!self.mFunctionName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
  if self.mIsUsefull then
    ioUsefulnessRootEntities += !nameForUsefulness
  end
//--- Analyse function body
  let analysisContext = @analysisContext {
    !inSemanticContext
    !inPredefinedTypes
    !selfObjectCppName: ""
    !selfAvailability: .none
    !selfObjectCppPrefixForAccessingProperty: ""
  }
  analyzeFunctionBody (
    !nameForUsefulness
    !?ioUsefulEntitiesGraph
    !analysisContext
    !?ioTypeMap
    !@formalInputParameterListAST ()
    !self.mFunctionInstructionList
    !self.mResultVariableName
    !self.mResultTypeName
    !self.mEndOfFunctionInstructionList
    ?*
    ?let returnType
    ?let resultVariableCppName
    ?let semanticInstructionListForGeneration
  )
//---
  ioSemanticDeclarationListForGeneration +=
    !infoMessage: "once function " + self.mFunctionName
    !@onceFunctionDeclarationForGeneration {
      !generateHeader: true // Generate Cpp header file
      !implementationCppFileName: "func-" + self.mFunctionName.string.fileNameRepresentation
      !self.mFunctionName.string
      !returnType
      !resultVariableCppName
      !semanticInstructionListForGeneration}
}

//--------------------------------------------------------------------------------------------------
//
//     F I L E W R A P P E R    A N A L Y S I S
//
//--------------------------------------------------------------------------------------------------

override method @filewrapperDeclarationAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
//--- Useful entities graph
  let filewrapperNameForUsefulness = filewrapperNameForUsefulEntitiesGraph (!self.mFilewrapperName)
  [!?ioUsefulEntitiesGraph addNode !filewrapperNameForUsefulness !filewrapperNameForUsefulness]
//--- Get filewrapper features
  [inSemanticContext.mFilewrapperMap searchKey
    !self.mFilewrapperName
    ?*
    ?*
    ?let @wrapperFileMap wrapperFileMap
    ?let @wrapperDirectoryMap wrapperDirectoryMap
    ?2*
  ]
//--- Build absolute path
  let @string absoluteSourcePath
  if self.mFilewrapperPath.string.firstCharacterOrNul == '/' then
    absoluteSourcePath = self.mFilewrapperPath.string
  else
    absoluteSourcePath = self.mSourceFileAbsolutePath.stringByDeletingLastPathComponent + "/" + self.mFilewrapperPath.string
  end
  if not absoluteSourcePath.directoryExists then
    error self.mFilewrapperPath: "The '" + absoluteSourcePath + "' directory does not exist"
  else
  //--- Analyze filewrapper templates
    var @filewrapperTemplateListForGeneration filewrapperTemplateListForGeneration = @()
    for filewrapperTemplate in self.mFilewrapperTemplateList do
      let filewrapperTemplateNameForUsefulness = filewrapperTemplateNameForUsefulEntitiesGraph (
        !self.mFilewrapperName
        !filewrapperTemplate.mFilewrapperTemplateName
      )
      [!?ioUsefulEntitiesGraph addNode !filewrapperTemplateNameForUsefulness !filewrapperTemplateNameForUsefulness]
      [!?ioUsefulEntitiesGraph addEdge !from: filewrapperTemplateNameForUsefulness !to: filewrapperNameForUsefulness]
      if filewrapperTemplate.mFilewrapperTemplatePath.string.firstCharacterOrNul == '/' then
        error filewrapperTemplate.mFilewrapperTemplatePath
         : "the path should not begin with a '/'; it is relative to filewrapper path '" + absoluteSourcePath + "'"
      end
      let absoluteTemplatePath = absoluteSourcePath + "/" + filewrapperTemplate.mFilewrapperTemplatePath
    //--- Parse template
      grammar templateGrammar (?let @templateInstructionListAST resultingInstructionList)
         in @lstring {!absoluteTemplatePath !filewrapperTemplate.mFilewrapperTemplatePath.location}
    //--- Build template variable map
      var @templateVariableMap templateVariableMap = @()
      var @formalInputParameterListForGeneration filewrapperTemplateFormalInputParameters = @()
      for (mFormalTemplateSelector mFormalArgumentTypeName mFormalArgumentName *) in filewrapperTemplate.mFilewrapperTemplateFormalInputParameters do
        let type = [ioTypeMap typeMapEntryForLKey !mFormalArgumentTypeName]
        let @string cppVarName = "in_" + mFormalArgumentName.string.identifierRepresentation
        [!?templateVariableMap insertKey !mFormalArgumentName !type !cppVarName]
        filewrapperTemplateFormalInputParameters += !mFormalTemplateSelector !type !cppVarName !mFormalArgumentName !true
      end
    //--- Analyze template
      var templateInstructionListForGeneration = @templateInstructionListForGeneration ()
      let templateAnalysisContext = @templateAnalysisContext {
        !inSemanticContext
        !inPredefinedTypes
        !templateVariableMap
      }
      templateInstructionListAnalysis (
        !filewrapperNameForUsefulness
        !?ioUsefulEntitiesGraph
        !templateAnalysisContext
        !?ioTypeMap
        !resultingInstructionList
        !?templateInstructionListForGeneration
      )
    //--- Enter in generation list
      filewrapperTemplateListForGeneration +=
        !filewrapperTemplate.mFilewrapperTemplateName.string
        !filewrapperTemplateFormalInputParameters
        !templateInstructionListForGeneration
    end
  //--- Enter filewrapper in generated list
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: "filewrapper " + self.mFilewrapperName
      !@filewrapperDeclarationForGeneration {
        !generateHeader: true // Generate Cpp header file
        !implementationCppFileName: "filewrapper-" + self.mFilewrapperName
        !self.mFilewrapperName.string
        !self.mFilewrapperPath.string
        !wrapperFileMap
        !wrapperDirectoryMap
        !filewrapperTemplateListForGeneration
     }
  end
}

//--------------------------------------------------------------------------------------------------

override method @galgas3SyntaxComponentAST semanticAnalysis
  ?!@lstringlist unused ioUsefulnessRootEntities
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @string unused inProductDirectory
  ?let @semanticContext inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @predefinedTypes inPredefinedTypes
  ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration
{
//--- Useful entities graph
  let nameForUsefulness = syntaxNameForUsefulEntitiesGraph (!self.mSyntaxComponentName)
  [!?ioUsefulEntitiesGraph addNode !nameForUsefulness !nameForUsefulness]
//-------------------------------------- Build terminal map
  [inSemanticContext.mLexiqueComponentMapForSemanticAnalysis searchKey
    !self.mLexiqueName
    ?*
    ?let @terminalMap terminalMap
    ?let @indexingListAST indexingListAST
//    ?let @lstring indexingDirectory
    ?4*
  ]
//-------------------------------------- Build "indexing" set
  var @stringset indexNameSet = @()
  for (mIndexName *) in indexingListAST do
    indexNameSet ++= mIndexName.string
  end
  let @bool hasIndexing = true // not [indexingDirectory isNowhere]
//--- Build semantic context from rule headers and non terminal declaration
  if @uint. errorCount == 0 then
    let lexiqueName = self.mLexiqueName.string
    semanticAnalysisOfSyntaxComponent (
      !nameForUsefulness
      !?ioUsefulEntitiesGraph
      !self.mNonterminalDeclarationList
      !self.mRuleList
      !self.mSyntaxComponentName.string
      !lexiqueName
      !inSemanticContext
      !?ioTypeMap
      !inPredefinedTypes
      !terminalMap
      !indexNameSet
      !hasIndexing
      !self.mHasTranslateFeature
      ?let @syntaxDeclarationForGeneration syntaxDeclarationForGeneration
    )
    ioSemanticDeclarationListForGeneration +=
      !infoMessage: ""
      !syntaxDeclarationForGeneration
//      !""
  end
}

//--------------------------------------------------------------------------------------------------

override method @galgas3GrammarComponentAST semanticAnalysis
                                ?!@lstringlist unused ioUsefulnessRootEntities
                                ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                ?let @string inProductDirectory
                                ?let @semanticContext inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
                                ?let @predefinedTypes unused inPredefinedTypes
                                ?!@semanticDeclarationListForGeneration ioSemanticDeclarationListForGeneration {
  if @application.verboseOutput then
    println (!"*** Analyzing '" + self.mGrammarComponentName + "' grammar")
  end
//--- Useful entities graph
  let grammarNameForUsefulness = grammarNameForUsefulEntitiesGraph (!self.mGrammarComponentName)
  [!?ioUsefulEntitiesGraph addNode !grammarNameForUsefulness !grammarNameForUsefulness]
//--------------------------------------------------------- Parse syntax components
  var @terminalSymbolsMapForGrammarAnalysis actuallyUsedTerminalSymbolMap = @()
  var @nonTerminalSymbolMapForGrammarAnalysis nonTerminalMapForGrammarAnalysis = @()
  var @lstring lexiqueComponentName =  "".nowhere // Empty string means unknown
  var @syntaxComponentListForGrammarAnalysis syntaxComponentListForGrammarAnalysis = @()
  var @nonTerminalToAddList nonTerminalToAddList = @()
  var @uint addedNonTerminalCount = 0
  for (syntaxComponentName) in self.mSyntaxComponents do
    let syntaxNameForUsefulness = syntaxNameForUsefulEntitiesGraph (!syntaxComponentName)
    [!?ioUsefulEntitiesGraph addEdge !from: grammarNameForUsefulness !to: syntaxNameForUsefulness]
    let @uint addedNonTerminalCountRef = addedNonTerminalCount
    [inSemanticContext.mSyntaxComponentMapForSemanticAnalysis searchKey
      !syntaxComponentName
      ?let @lstring lexiqueName
      ?let @nonterminalDeclarationListAST nonterminalDeclarationList
      ?let @syntaxRuleListAST ruleList
      ?let @bool hasTranslateFeature
    ]
    let lexiqueNameForUsefulness = lexiqueNameForUsefulEntitiesGraph (!lexiqueName)
    [!?ioUsefulEntitiesGraph addEdge !from: grammarNameForUsefulness !to: lexiqueNameForUsefulness]
  //--- Check translate feature
    if self.mHasTranslateFeature & not hasTranslateFeature then
      error syntaxComponentName : "as '" + self.mGrammarComponentName + "' grammar declares 'translate' feature, this syntax component should do so"
    elsif hasTranslateFeature & not self.mHasTranslateFeature then
      error self.mGrammarComponentName : "as '" + syntaxComponentName + "' syntax component declares 'translate' feature, this grammar should do so"
    end
  //--- Handle lexique component
    if lexiqueComponentName.string == "" then
      lexiqueComponentName = lexiqueName
    elsif lexiqueName.string != lexiqueComponentName.string then
      error syntaxComponentName : "this syntax component uses '"
        + lexiqueName + "' lexique component, but the first syntax component uses the '"
        + lexiqueComponentName + "' lexique component (they should be the same)"
    end
  //--- Handle non terminal declarations
    handleNonTerminalDeclarations (
      !?nonTerminalMapForGrammarAnalysis
      !nonterminalDeclarationList
    )
  //--- Enter non terminal definition from rule list
    handleNonTerminalDeclarationsFromRuleList (
      !?nonTerminalMapForGrammarAnalysis
      !ruleList
    )
  //--- Handle syntax rules
    buildRuleList (
      !nonTerminalMapForGrammarAnalysis
      !syntaxComponentName
      !ruleList
      !?actuallyUsedTerminalSymbolMap
      !?syntaxComponentListForGrammarAnalysis
      !?addedNonTerminalCount
    )
    var @uint i = 0
    loop (addedNonTerminalCount) while i < (addedNonTerminalCount - addedNonTerminalCountRef) do
      nonTerminalToAddList += !syntaxComponentName !i
      i += 1
    end
  end
//--------------------------------------------------------- Start symbol
//--- Search start symbol in non terminal map
  [nonTerminalMapForGrammarAnalysis searchKey
    !self.mStartSymbolName
    ?let @uint startSymbolIndex
    ?let @nonterminalSymbolLabelMapForGrammarAnalysis startSymbolAltMap
  ]
//--- Check signatures
  checkLabelMap (
    !self.mStartSymbolName.location
    !self.mStartSymbolLabelList
    ![nonTerminalMapForGrammarAnalysis locationForKey !self.mStartSymbolName.string]
    !startSymbolAltMap
  )
//--------------------------------------------------------- Unused Non Terminal Symbols
  var @unusedNonTerminalSymbolMapForGrammarAnalysis unusedNonTerminalSymbolsForGrammar = @()
  for (mValue) in self.mUnusedNonterminalList do
    [nonTerminalMapForGrammarAnalysis searchKey !mValue ?let @uint nonterminalIndex ?*]
    [!?unusedNonTerminalSymbolsForGrammar insertKey !mValue !nonterminalIndex]
  end
//--------------------------------------------------------- Non terminal symbols, sorted by index
  var @nonTerminalSymbolSortedListForGrammarAnalysis nonTerminalSymbolSortedListForGrammarAnalysis = @()
  for (lkey mNonTerminalIndex mNonterminalSymbolParametersMap) in nonTerminalMapForGrammarAnalysis do
    nonTerminalSymbolSortedListForGrammarAnalysis += !lkey !mNonTerminalIndex !mNonterminalSymbolParametersMap
  end
//--------------------------------------------------------- Print an tex file for grammar rule list
  if [option galgas_cli_options.emitSyntaxDiagrams value] then
    emitProductionRulesInTexFile (
      !inProductDirectory
      !self.mGrammarComponentName
      !nonTerminalMapForGrammarAnalysis
      !syntaxComponentListForGrammarAnalysis
      !self.mStartSymbolName
    )
  end
//--------------------------------------------------------- Emit class graph
  let dotDocumentFilePath = inProductDirectory + "/../graph-class/graph-class.dot"
  if [option galgas_cli_options.emitClassGraph value] then
    emitClassGraphFile (
      !dotDocumentFilePath
      !ioTypeMap
    )
  else
    [@string deleteFileIfExists !dotDocumentFilePath]
  end
  //--------------------------------------------------------- Header of implementation file
//  Loop throuht all rules for detecting input arguments: as the generated C++ code uses a copy constructor
// for these arguments, we need to include the corresponding type declaration.
  var @stringset implementationFileHeader = @()
  for nonTerminal in nonTerminalMapForGrammarAnalysis do
    for (* mFormalParametersList) in nonTerminal.mNonterminalSymbolParametersMap do
      for (mFormalArgumentPassingModeForGrammarAnalysis mGalgasTypeNameForGrammarAnalysis) in mFormalParametersList do
        switch mFormalArgumentPassingModeForGrammarAnalysis
        case argumentVarIn, argumentConstantIn :
          let t = [ioTypeMap typeMapEntryForLKey !mGalgasTypeNameForGrammarAnalysis]
          [t addHeaderFileName !?implementationFileHeader]
        case argumentInOut, argumentOut :
        end
      end
    end
  end
  if [option galgas_cli_options.generateOneHeader value] then
    implementationFileHeader = @()
  end
//--------------------------------------------------------- Analyze grammar
  let HTMLFilePath = inProductDirectory + "/../helpers/" + self.mGrammarComponentName + ".html"
  grammarAnalysisAndGeneration (
    !self.mGrammarComponentName
    !self.mGrammarClass
    !startSymbolIndex
    !lexiqueComponentName.string
    !actuallyUsedTerminalSymbolMap
    !syntaxComponentListForGrammarAnalysis
    !unusedNonTerminalSymbolsForGrammar
    !HTMLFilePath
    !nonTerminalSymbolSortedListForGrammarAnalysis
    !if self.mHasTranslateFeature then syntaxDirectedTranslationResultVarName () else "" end
    ?let @string grammarCppFile
    ?let @string grammarHTMLHelperContents
  )
//--------------------------------------------------------- Generate HTML grammer helper file
  if [option galgas_cli_options.outputHTMLgrammarFile value] then
    [HTMLFilePath.stringByDeletingLastPathComponent makeDirectory]
    [grammarHTMLHelperContents writeToFileWhenDifferentContents !HTMLFilePath ?*]
  else
    [@string deleteFileIfExists !HTMLFilePath]
  end
//---
  ioSemanticDeclarationListForGeneration +=
    !infoMessage: ""
    !@grammarForGeneration {
      !generateHeader:  true // has header
      !implementationCppFileName: "grammar-" + self.mGrammarComponentName.string.fileNameRepresentation
      !self.mGrammarComponentName.string
      !lexiqueComponentName.string
      !nonTerminalMapForGrammarAnalysis
      !nonTerminalToAddList
      !self.mSyntaxComponents
      !self.mStartSymbolName.string
      !self.mHasTranslateFeature
      !grammarCppFile
    }
}


//--------------------------------------------------------------------------------------------------
//
//    P R E D E F I N E D    T Y P E S
//
//--------------------------------------------------------------------------------------------------

func buildPredefinedTypes (?let @unifiedTypeMap inTypeMap) -> @predefinedTypes {
  result = @{
    ![inTypeMap typeMapEntryForLKey !@{!"location"   !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"bool"       !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"char"       !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"string"     !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"uint"       !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"sint"       !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"uint64"     !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"sint64"     !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"double"     !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"lbool"      !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"lchar"      !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"lstring"    !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"luint"      !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"lsint"      !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"luint64"    !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"lsint64"    !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"ldouble"    !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"stringlist" !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"lbigint"    !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"bigint"     !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"stringset"  !.here}]
    ![inTypeMap typeMapEntryForLKey !@{!"lstringlist"!.here}]
  }
}

//--------------------------------------------------------------------------------------------------
//
//    S Y N T A X    D E C L A R A T I O N S
//
//--------------------------------------------------------------------------------------------------

map @nonterminalLabelMap {
  public let @formalParameterListForGeneration mSignatureForGeneration
  public let @formalParameterSignature mSignature
  public let @location mEndOfArgumentLocation
  insert insertKey error message "the '%K' nonterminal label has been already declared in %L"
  search searchKey error message "the '%K' nonterminal label is not declared"
}

//--------------------------------------------------------------------------------------------------

map @nonterminalMap {
  public let @nonterminalLabelMap mLabelMap
  insert insertKey error message "the '%K' nonterminal has been already declared in %L"
  search searchKey error message "the '%K' nonterminal is not declared"
}

//--------------------------------------------------------------------------------------------------

list @ruleLabelImplementationList {
  public let @lstring mLabelName
  public let @formalParameterListForGeneration mSignatureForGeneration
  public let @formalParameterSignature mSignature
  public let @location mEndOfArgumentLocation
  public let @semanticInstructionListForGeneration mInstructionListForGeneration
}

//--------------------------------------------------------------------------------------------------

list @ruleDeclarationList {
  public let @string mNonterminalName
  public let @uint mRuleIndex
  public let @ruleLabelImplementationList mLabelImplementationList
}

//--------------------------------------------------------------------------------------------------
//
//           G E N E R A T I O N    F I L E W R A P P E R S
//
//--------------------------------------------------------------------------------------------------

filewrapper syntaxFileGenerationTemplate in "+generation-templates/syntax_generation" {
}{
}{
  template syntaxFileImplementationGalgas3 "syntax-file-galgas3.cpp.galgasTemplate"
    ?@stringset INCLUSION_SET

  template syntaxAnalyserClassDeclaration "syntax-analyser-class.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@string LEXIQUE_NAME
    ?@nonterminalMap NONTERMINAL_MAP
    ?@ruleDeclarationList RULE_DECLARATION_LIST
    ?@uintlist SELECT_METHOD_LIST
    ?@bool HAS_INDEXING
    ?@bool HAS_TRANSLATE_FEATURE
}

//--------------------------------------------------------------------------------------------------
//
//           B U I L D    N O N T E R M I N A L    M A P
//
//--------------------------------------------------------------------------------------------------

proc enterNonterminalNonTerminalInMapAndCheck
  ?let @lstring inNonTerminalName
  ?let @nonterminalLabelMap inNonterminalLabelMap
  ?!@nonterminalMap ioNonterminalDeclarationMap {
  if let entry = ioNonterminalDeclarationMap @[inNonTerminalName.string] then
    let @stringset firstDeclarationLabelSet = entry.mLabelMap.keySet
    let @stringset reDeclarationLabelSet = inNonterminalLabelMap.keySet
    let @stringset missingLabelSet = firstDeclarationLabelSet - reDeclarationLabelSet
    if missingLabelSet.count > 0 then
      var @string s = ""
      for (key) in missingLabelSet do
        s += "\n-  " + key
      end
      error inNonTerminalName
      : "the '" + inNonTerminalName + "' nonterminal is redeclared without the following label(s):" + s
    end
    let @stringset newLabelSet = reDeclarationLabelSet - firstDeclarationLabelSet
    if newLabelSet.count > 0 then
      var s = ""
      for (key) in newLabelSet do
        s += "\n-  " + key
      end
      error inNonTerminalName
      : "the '" + inNonTerminalName + "' nonterminal is redeclared with the new label(s):" + s
    end
    if (missingLabelSet.count == 0) & (newLabelSet.count == 0) then
      for aLabel in entry.mLabelMap, (* * new_mSignature new_mEndOfArgumentLocation) in inNonterminalLabelMap do
        var @formalParameterSignature newSignature = @()
        for (mFormalSelector mFormalArgumentType mFormalArgumentPassingMode mFormalArgumentName) in new_mSignature do
          newSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName
        end
        checkMethodSignatures (
          !aLabel.mSignatureForGeneration
          !aLabel.mEndOfArgumentLocation
          !newSignature
          !new_mEndOfArgumentLocation
        )
      end
    end
  else
    [!?ioNonterminalDeclarationMap insertKey !inNonTerminalName !inNonterminalLabelMap]
  end
}

//--------------------------------------------------------------------------------------------------

proc buildNonterminalDeclarationsMap
  ?let @nonterminalDeclarationListAST inNonterminalDeclarationList
  ?let @semanticContext unused inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  !@nonterminalMap outNonterminalDeclarationMap {
  outNonterminalDeclarationMap = @nonterminalMap ()
//--- Nonterminal declaration list
  for (mNonterminalName mLabels) in inNonterminalDeclarationList do
    var nonterminalLabelMap = @nonterminalLabelMap ()
    for (mLabelName mFormalArgumentList mEndOfArgumentLocation) in mLabels do
      var signatureForGeneration = @formalParameterListForGeneration ()
      var signature = @formalParameterSignature ()
      for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentTypeName mFormalArgumentName *) in mFormalArgumentList do
        let t = [ioTypeMap typeMapEntryForLKey !mFormalArgumentTypeName]
        signatureForGeneration += !mFormalSelector !mFormalArgumentPassingMode !t !mFormalArgumentName !mFormalArgumentName.string
        signature += !mFormalSelector !t !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation]
    end
    enterNonterminalNonTerminalInMapAndCheck (!mNonterminalName !nonterminalLabelMap !?outNonterminalDeclarationMap )
  end
}

//--------------------------------------------------------------------------------------------------
//
//    S Y N T A X    I N S T R U C T I O N    A N A L Y S I S
//
//--------------------------------------------------------------------------------------------------

abstract method @syntaxInstructionAST analyzeSyntaxInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @stringset inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
  ?!@uint ioSelectMethodCount

//--------------------------------------------------------------------------------------------------

override method @semanticInstructionAST analyzeSyntaxInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @bool unused inHasTranslateFeature
  ?let @terminalMap unused inTerminalMap
  ?let @string unused inLexiqueName
  ?let @nonterminalMap unused inNonterminalMap
  ?let @string unused inComponentName
  ?let @stringset unused inIndexNameSet
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
  ?!@uint unused ioSelectMethodCount
{
  [self analyzeSemanticInstruction
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inAnalysisContext
    !?ioTypeMap
    !?ioInstructionListForGeneration
    !?ioVariableMap
  ]
}

//--------------------------------------------------------------------------------------------------

abstract method @abstractInputParameter analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@localVarManager ioVariableMap

//--------------------------------------------------------------------------------------------------

override method @inputParameterAnonymousVariable analyzeInputParameter
  ?let @analysisContext unused inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?let @lexicalTypeEnum unused inRequiredLexicalType
  ?let @string unused inLexicalAttributeName
  ?!@terminalCheckAssignementList unused ioTerminalCheckAssignementList
  ?!@localVarManager unused ioVariableMap {
}

//--------------------------------------------------------------------------------------------------

override method @inputParameterVariable analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@localVarManager ioVariableMap {
  [!?ioVariableMap searchForWriteAccess !self.mActualParameterName ?let @unifiedTypeMapEntry type ?let @string cppName ?*]
  let @unifiedTypeMapEntry expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.predefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.predefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.predefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.predefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.predefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.predefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.predefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.predefinedTypes.mLBigIntType
  end
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + type.identifierRepresentation
    + ", bit an '@" + expectedType.identifierRepresentation + "' parameter is required here"
  end
  ioTerminalCheckAssignementList +=
    !"" // Do not declare variable
    !cppName
    !inLexicalAttributeName
}

//--------------------------------------------------------------------------------------------------

override method @inputParameterDeclaredVariable analyzeInputParameter
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap ioTypeMap
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@localVarManager ioVariableMap {
//--- Expected type
  let @unifiedTypeMapEntry expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.predefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.predefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.predefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.predefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.predefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.predefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.predefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.predefinedTypes.mLBigIntType
  end
//--- Type is named, or should be infered ?
  if self.mActualParameterTypeName.string != "" then
    let type = [ioTypeMap typeMapEntryForLKey !self.mActualParameterTypeName]
    if expectedType != type then
      error self.mActualParameterName
      : "the '" + self.mActualParameterName + "' formal argument has the '@" + type.definition.typeName.string
      + ", bit an '@" + expectedType.definition.typeName.string + "' parameter is required here"
    end
  end
//--- Create local variable
  let cppName = "var_" + self.mActualParameterName.string.identifierRepresentation + "_" + self.mActualParameterName.location.startLocationIndex
  [!?ioVariableMap insertInitializedLocalVariable
    !self.mActualParameterName
    !warnsIfNotMutated: true
    !expectedType
    !cppName
    !cppName
  ]
  ioTerminalCheckAssignementList +=
    !expectedType.definition.typeName.string
    !cppName
    !inLexicalAttributeName
}

//--------------------------------------------------------------------------------------------------

override method @inputParameterDeclaredConstant analyzeInputParameter
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @lexicalTypeEnum inRequiredLexicalType
  ?let @string inLexicalAttributeName
  ?!@terminalCheckAssignementList ioTerminalCheckAssignementList
  ?!@localVarManager ioVariableMap {
//--- Expected type
  let @unifiedTypeMapEntry expectedType
  switch inRequiredLexicalType
  case lexicalType_string : expectedType = inAnalysisContext.predefinedTypes.mLStringType
  case lexicalType_char : expectedType = inAnalysisContext.predefinedTypes.mLCharType
  case lexicalType_uint : expectedType = inAnalysisContext.predefinedTypes.mLUIntType
  case lexicalType_uint64 : expectedType = inAnalysisContext.predefinedTypes.mLUInt64Type
  case lexicalType_sint : expectedType = inAnalysisContext.predefinedTypes.mLSIntType
  case lexicalType_sint64 : expectedType = inAnalysisContext.predefinedTypes.mLSInt64Type
  case lexicalType_double : expectedType = inAnalysisContext.predefinedTypes.mLDoubleType
  case lexicalType_bigint : expectedType = inAnalysisContext.predefinedTypes.mLBigIntType
  end
//--- Type is named, or should be infered ?
  if self.mActualParameterTypeName.string != "" then
    let type = [ioTypeMap typeMapEntryForLKey !self.mActualParameterTypeName]
    if expectedType != type then
      error self.mActualParameterName
      : "the '" + self.mActualParameterName + "' formal argument has the '@" + type.definition.typeName.string
      + ", bit an '@" + expectedType.definition.typeName.string + "' parameter is required here"
    end
  end
//--- Create local constant
  let cppName = "var_" + self.mActualParameterName.string.identifierRepresentation + "_" + self.mActualParameterName.location.startLocationIndex
  [!?ioVariableMap insertInitializedLocalConstant !self.mActualParameterName !expectedType !cppName !cppName]
//---
  ioTerminalCheckAssignementList +=
    !expectedType.definition.typeName.string
    !cppName
    !inLexicalAttributeName
}

//--------------------------------------------------------------------------------------------------

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult analyzeSDT
  ?let @analysisContext inAnalysisContext
  ?!@unifiedTypeMap unused ioTypeMap
  ?let @bool inHasTranslateFeature
  ?!@localVarManager ioVariableMap

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationResultNone analyzeSDT
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @bool unused inHasTranslateFeature
  ?!@localVarManager unused ioVariableMap {
}

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationDropResult  analyzeSDT
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @bool inHasTranslateFeature
  ?!@localVarManager unused ioVariableMap {
  if not inHasTranslateFeature then
    error self.mLocation : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
}

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  analyzeSDT
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap unused ioTypeMap
  ?let @bool inHasTranslateFeature
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
  [!?ioVariableMap searchForWriteAccess !self.mActualParameterName ?let @unifiedTypeMapEntry type ?* ?*]
  let expectedType = inAnalysisContext.predefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + type.identifierRepresentation
    + ", bit an '@" + expectedType.identifierRepresentation + "' parameter is required here"
  end
}

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  analyzeSDT
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @bool inHasTranslateFeature
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the syntax component to be declared with 'translate' feature"
  end
  let cppName = "var_" + self.mActualParameterName.string.identifierRepresentation + "_" + self.mActualParameterName.location.startLocationIndex
  let type = [ioTypeMap typeMapEntryForLKey !self.mActualParameterTypeName]
  [!?ioVariableMap insertInitializedLocalVariable
    !self.mActualParameterName
    !warnsIfNotMutated: true
    !type
    !cppName
    !cppName
  ]
  let expectedType = inAnalysisContext.predefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + type.identifierRepresentation
    + ", bit an '@" + expectedType.identifierRepresentation + "' parameter is required here"
  end
}

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  analyzeSDT
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @bool inHasTranslateFeature
  ?!@localVarManager ioVariableMap {
  if not inHasTranslateFeature then
    error self.mActualParameterName : "the ':>' construct requires the grammar to be declared with 'translate' feature"
  end
  let cppName = "var_" + self.mActualParameterName.string.identifierRepresentation + "_" + self.mActualParameterName.location.startLocationIndex
  let type = [ioTypeMap typeMapEntryForLKey !self.mActualParameterTypeName]
  [!?ioVariableMap insertInitializedLocalConstant !self.mActualParameterName !type !cppName !cppName]
  let expectedType = inAnalysisContext.predefinedTypes.mStringType
  if expectedType != type then
    error self.mActualParameterName
    : "the '" + self.mActualParameterName + "' parameter has the '@" + type.identifierRepresentation
    + ", bit an '@" + expectedType.identifierRepresentation + "' parameter is required here"
  end
}

//--------------------------------------------------------------------------------------------------

abstract method @abstractGrammarInstructionSyntaxDirectedTranslationResult generateCode
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationResultNone generateCode
  ?let @bool inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  if inGenerateSyntaxDirectedTranslationString then
    ioGeneratedCode += syntaxDirectedTranslationResultVarName() + ".appendString (" + inAccessMethodName + ") ;\n"
    [!?ioUnusedVariableCppNameSet removeKey !syntaxDirectedTranslationResultVarName ()]
  end
}

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationDropResult  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string unused inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string unused ioGeneratedCode {
}

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationResultInVar  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + self.mActualParameterName.string.identifierRepresentation + "_" + self.mActualParameterName.location.startLocationIndex
  ioGeneratedCode += cppName + " = GGS_string (" + inAccessMethodName + ") ;\n"
}

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredVar  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + self.mActualParameterName.string.identifierRepresentation + "_" + self.mActualParameterName.location.startLocationIndex
  ioGeneratedCode += "GGS_string " + cppName + " (" + inAccessMethodName + ") ;\n"
}

//--------------------------------------------------------------------------------------------------

override method @grammarInstructionSyntaxDirectedTranslationResultInDeclaredConst  generateCode
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?let @string inAccessMethodName
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?!@string ioGeneratedCode {
  let cppName = "var_" + self.mActualParameterName.string.identifierRepresentation + "_" + self.mActualParameterName.location.startLocationIndex
  ioGeneratedCode += "const GGS_string " + cppName + " (" + inAccessMethodName + ") ;\n"
}

//--------------------------------------------------------------------------------------------------

proc analyzeSyntaxInstructionList
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @bool inHasTranslateFeature
  ?let @terminalMap inTerminalMap
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string  inComponentName
  ?let @syntaxInstructionList inSyntaxInstructionListAST
  ?let @location inEndOfBranchLocation
  ?let @stringset inIndexNameSet
  ?!@localVarManager ioVariableMap
  ?!@uint ioSelectMethodCount
  !@semanticInstructionListForGeneration outInstructionListForGeneration {
  outInstructionListForGeneration = @semanticInstructionListForGeneration ()
//--- Begin branch
  [!?ioVariableMap openBranch]
//--- Instruction list
  for (mInstruction) in inSyntaxInstructionListAST do
    [mInstruction analyzeSyntaxInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?ioVariableMap
      !?ioSelectMethodCount
    ]
  end
//--- Branch end
  [!?ioVariableMap closeBranch !inEndOfBranchLocation]
}

//--------------------------------------------------------------------------------------------------
//
//           B U I L D    C O N T E X T
//
//--------------------------------------------------------------------------------------------------

proc semanticAnalysisOfRuleLabel
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @formalParameterListAST inFormalArguments
  ?let @syntaxInstructionList inSyntaxInstructionList
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @terminalMap inTerminalMap
  ?let @bool inHasTranslateFeature
  ?let @string inLexiqueName
  ?let @nonterminalMap inNonterminalMap
  ?let @string inComponentName
  ?let @location inEndOfInstructionList
  ?let @stringset inIndexNameSet
  ?!@uint ioSelectMethodCount
  !@formalParameterListForGeneration outSignatureForGeneration
  !@formalParameterSignature outSignature
  !@semanticInstructionListForGeneration outInstructionListForGeneration
{
  var variableMap = @localVarManager {}
  buildLocalVariableMapAndSignature (
    !inAnalysisContext.semanticContext
    !?ioTypeMap
    !inFormalArguments
    !?variableMap
    ?outSignatureForGeneration
  )
//---
  outSignature = @formalParameterSignature ()
  for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentType mFormalArgumentName *) in outSignatureForGeneration do
    outSignature += !mFormalSelector !mFormalArgumentType !mFormalArgumentPassingMode !mFormalArgumentName.string
  end
//--- Semantic analysis of instruction list
  outInstructionListForGeneration = @semanticInstructionListForGeneration ()
//  var localVariableCppNameList = @stringlist ()
  for (mInstruction) in inSyntaxInstructionList do
    [mInstruction analyzeSyntaxInstruction
      !inUsefulnessCallerEntityName
      !?ioUsefulEntitiesGraph
      !inAnalysisContext
      !?ioTypeMap
      !inHasTranslateFeature
      !inTerminalMap
      !inLexiqueName
      !inNonterminalMap
      !inComponentName
      !inIndexNameSet
      !?outInstructionListForGeneration
      !?variableMap
      !?ioSelectMethodCount
    ]
  end
//---
  [variableMap checkAutomatonStates !inEndOfInstructionList]
}

//--------------------------------------------------------------------------------------------------
//
//           S E M A N T I C    A N A L Y S I S
//
//--------------------------------------------------------------------------------------------------

private proc semanticAnalysisOfSyntaxComponent
  ?let @lstring inSyntaxComponentUsefulnessName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @nonterminalDeclarationListAST inNonterminalDeclarationList
  ?let @syntaxRuleListAST inRuleList
  ?let @string inSyntaxComponentName
  ?let @string inLexiqueName
  ?let @semanticContext inSemanticContext
                                ?!@unifiedTypeMap ioTypeMap
  ?let @predefinedTypes inPredefinedTypes
  ?let @terminalMap inTerminalMap
  ?let @stringset inIndexNameSet
  ?let @bool inHasIndexing
  ?let @bool inHasTranslateFeature
  !@syntaxDeclarationForGeneration outSyntaxDeclarationForGeneration
{
//----------- Build nonterminal map
  buildNonterminalDeclarationsMap (
    !inNonterminalDeclarationList
    !inSemanticContext
    !?ioTypeMap
    ?var @nonterminalMap nonterminalMap
  )
//----------- Build nonterminal map from rule headers
  for (mNonterminalName mLabelList) in inRuleList do
    var @nonterminalLabelMap nonterminalLabelMap = @()
    for (mLabelName mFormalArguments mEndOfArgumentLocation * *) in mLabelList do
      var @formalParameterListForGeneration signatureForGeneration = @()
      var @formalParameterSignature signature = @()
      for (mFormalSelector mFormalArgumentPassingMode mFormalArgumentTypeName mFormalArgumentName *) in mFormalArguments do
        let type = [ioTypeMap typeMapEntryForLKey !mFormalArgumentTypeName]
        signatureForGeneration +=
          !mFormalSelector
          !mFormalArgumentPassingMode
          !type
          !mFormalArgumentName
          !"argument_" + mFormalArgumentName
        signature += !mFormalSelector !type !mFormalArgumentPassingMode !mFormalArgumentName.string
      end
      [!?nonterminalLabelMap insertKey !mLabelName !signatureForGeneration !signature !mEndOfArgumentLocation]
    end
      enterNonterminalNonTerminalInMapAndCheck (!mNonterminalName !nonterminalLabelMap !?nonterminalMap )
  end
//--- Analysis context
  let analysisContext = @analysisContext {
    !inSemanticContext
    !inPredefinedTypes
    !selfObjectCppName: ""
    !selfAvailability: .none
    !selfObjectCppPrefixForAccessingProperty: ""
  }
//--- Rule list
  var @uint selectMethodCount = 0
  var @ruleDeclarationList ruleDeclarationList = @()
  var @uint newRuleIndex = 0
  for (mNonterminalName mLabelList) in inRuleList do
  //---
    var @ruleLabelImplementationList ruleLabelImplementationList = @()
    var @uint localSelectMethodCount = selectMethodCount
    [nonterminalMap searchKey !mNonterminalName ?*]
    for (mLabelName mFormalArguments mEndOfArgumentLocation mSyntaxInstructionList mEndOfInstructionList) in mLabelList do
      localSelectMethodCount = selectMethodCount
      semanticAnalysisOfRuleLabel (
        !inSyntaxComponentUsefulnessName
        !?ioUsefulEntitiesGraph
        !mFormalArguments
        !mSyntaxInstructionList
        !analysisContext
        !?ioTypeMap
        !inTerminalMap
        !inHasTranslateFeature
        !inLexiqueName.identifierRepresentation
        !nonterminalMap
        !inSyntaxComponentName
        !mEndOfInstructionList
        !inIndexNameSet
        !?localSelectMethodCount
        ?let signatureForGeneration
        ?let signature
        ?let instructionListForGeneration
      )
      ruleLabelImplementationList +=
        !mLabelName
        !signatureForGeneration
        !signature
        !mEndOfArgumentLocation
        !instructionListForGeneration
    end
    selectMethodCount = localSelectMethodCount
    [nonterminalMap searchKey !mNonterminalName ?*]
    ruleDeclarationList +=
      !mNonterminalName.string
      !newRuleIndex
      !ruleLabelImplementationList
    newRuleIndex += 1
  end
//---
  outSyntaxDeclarationForGeneration = @syntaxDeclarationForGeneration {
    !inSyntaxComponentName
    !inLexiqueName
    !nonterminalMap
    !ruleDeclarationList
    !selectMethodCount
    !inHasIndexing
    !inHasTranslateFeature}
}

//--------------------------------------------------------------------------------------------------

private proc emitClassGraphFile ?let @string inDotDocumentFilePath
                                ?let @unifiedTypeMap inTypeMap {
  [inDotDocumentFilePath.stringByDeletingLastPathComponent makeDirectory]
  var document = "digraph G {\n"
  document += "  rankdir=LR ;\n"
  document += "  node [shape=record fontname=helvetica style=rounded] ;\n"
  for (* entry) in inTypeMap do
    switch entry.mDefinition
    case unsolved :
    case solved (@unifiedTypeDefinition definition) :
      if definition.typeKind.isClassType then
        switch definition.superType
        case null :
          document += "  \"@" + definition.typeName + "\" ;\n"
        case element (superType) :
          if let t = superType, let solvedType = t.mDefinition.getSolved then
            document += "  \"@" + definition.typeName + "\" ;\n"
            document += "  \"@" + definition.typeName + "\" -> \"@"
            document += solvedType.definition.typeName.string + "\" ;\n"
          end
        end
      end
    end
  end
  document += "}\n"
  [document writeToFileWhenDifferentContents !inDotDocumentFilePath ?*]
}

//--------------------------------------------------------------------------------------------------

