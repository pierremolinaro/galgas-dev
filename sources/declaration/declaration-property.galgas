//--------------------------------------------------------------------------------------------------
//
//  Copyright (C) 2014, ..., 2014 Pierre Molinaro.
//
//  MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//--------------------------------------------------------------------------------------------------

syntax extension galgas3DeclarationsSyntax {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //    PROPERTY IN COLLECTION
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rule <property_declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations
                                   ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    <acces_control> ?let accessControl
    let @propertyMutability mutability
    select
      $var$
      mutability = .mutableProperty
    or
      $let$
      [accessControl checkCompatibilityWithLet !.here]
      mutability = .constantProperty
    end
    <type_definition_ggs3> !?ioDeclarations ?let propertyTypeName
    $identifier$ ?let propertyName
    let @bool selectorAttribute
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
      selectorAttribute = false
    or
      $%initArgLabel$
      initialization = .none
      selectorAttribute = true
    or
      $=$
      <expression_ggs3> !?ioDeclarations ?let expression
      initialization = .some {!expression: expression}
      selectorAttribute = false
    end
    ioAttributeInCollectionList +=
      !mutability: mutability
      !propertyTypeName
      !propertyName
      !accessControl
      !hasSelector: selectorAttribute
      !initialization: initialization
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rule <property_declaration_ggs3> ?!@galgasDeclarationAST ioDeclarations
                                   ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    <acces_control> ?let accessControl
    $weak$
    select
      $var$
    or
      $let$
      error .here : "a weak property is mutable, and should be declared with 'var'"
    end
    <type_definition_ggs3> !?ioDeclarations ?let propertyTypeName
    $identifier$ ?let propertyName
    let @bool selectorAttribute
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
      selectorAttribute = false
    or
      $%initArgLabel$
      initialization = .none
      selectorAttribute = true
    or
      $=$
      <expression_ggs3> !?ioDeclarations ?let expression
      initialization = .some {!expression: expression}
      selectorAttribute = false
    end
    let propertyWeakTypeName = makeWeakTypeLName (!propertyTypeName)
//    if not [ioDeclarations.implicitTypeDeclarationSet hasKey !propertyWeakTypeName] then
//      ioDeclarations.implicitTypeDeclarationSet += !propertyWeakTypeName
//      
//    end
    ioAttributeInCollectionList +=
      !mutability: .weakProperty
      !propertyWeakTypeName
      !propertyName
      !accessControl
      !hasSelector: selectorAttribute
      !initialization: initialization
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

enum @propertyMutability {
  case constantProperty
  case mutableProperty
  case weakProperty
}

//--------------------------------------------------------------------------------------------------

enum @propertyInCollectionInitializationAST %equatable {
  case none
  case some (@semanticExpressionAST expression)
}

//--------------------------------------------------------------------------------------------------

syntax extension galgas4DeclarationsSyntax {

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  //    PROPERTY DECLARATION
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rule <property_declaration> ?!@galgasDeclarationAST ioDeclarations
                              ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    <acces_control> ?let accessControl
    let @propertyMutability mutability
    select
      $var$
      mutability = .mutableProperty
    or
      $let$
      [accessControl checkCompatibilityWithLet !.here]
      mutability = .constantProperty
    end
    <type_definition> !?ioDeclarations ?let propertyTypeName
    $identifier$ ?let propertyName
    var selectorAttribute = false
    repeat
    while
      $%initArgLabel$
      selectorAttribute = true
    end
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
    or
      $=$
      <expression> !?ioDeclarations ?let expression
      initialization = .some {!expression: expression}
    end
    ioAttributeInCollectionList +=
      !mutability: mutability
      !propertyTypeName
      !propertyName
      !accessControl
      !hasSelector: selectorAttribute
      !initialization: initialization
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  rule <property_declaration> ?!@galgasDeclarationAST ioDeclarations
                              ?!@propertyInCollectionListAST ioAttributeInCollectionList {
    <acces_control> ?let accessControl
    $weak$
    select
      $var$
    or
      $let$
      error .here : "a weak property is mutable, should be declared with 'var'"
    end
    <type_definition> !?ioDeclarations ?let propertyTypeName
    $identifier$ ?let propertyName
    var selectorAttribute = false
    repeat
    while
      $%initArgLabel$
      selectorAttribute = true
    end
    let @propertyInCollectionInitializationAST initialization
    select
      initialization = .none
    or
      $=$
      <expression> !?ioDeclarations ?let expression
      initialization = .some {!expression: expression}
    end
    let propertyWeakTypeName = makeWeakTypeLName (!propertyTypeName)
//    if not [ioDeclarations.implicitTypeDeclarationSet hasKey !propertyWeakTypeName] then
//      ioDeclarations.implicitTypeDeclarationSet += !propertyWeakTypeName
//      
//    end
    ioAttributeInCollectionList +=
      !mutability: .weakProperty
      !propertyWeakTypeName
      !propertyName
      !accessControl
      !hasSelector: selectorAttribute
      !initialization: initialization
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

list @propertyInCollectionListAST {
  public let @propertyMutability mutability %initArgLabel
  public let @lstring typeName
  public let @lstring name
  public let @AccessControlAST accessControl
  public let @bool hasSelector %initArgLabel
  public let @propertyInCollectionInitializationAST initialization %initArgLabel

  method buildPropertyInitializationCode ?let @lstring inTypeNameForUsefulness
                                          ?let @semanticContext inSemanticContext
                                          ?let @predefinedTypes inPredefinedTypes
                                          ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
                                          ?!@unifiedTypeMap ioTypeMap
                                          !@stringset outUnusedVariableCppNameSet
                                          !@string outInitializationCode {
    outInitializationCode = ""
    var inclusionSet = @stringset ()
    var @uint temporaryVariableIndex = 0
    outUnusedVariableCppNameSet = @stringset @[compilerCppName ()]
    for (* propertyTypeName propertyName 2* initExpression) in self do
     switch initExpression
      case none :
      case some (expressionAST) :
        var variableMap = @localVarManager {}
        let @analysisContext analysisContext = @{
          !inSemanticContext
          !inPredefinedTypes
          !selfObjectCppName: ""
          !selfAvailability: .none
          !selfObjectCppPrefixForAccessingProperty: ""
        }
        let propertyType = [ioTypeMap typeMapEntryForLKey !propertyTypeName]
        [expressionAST analyzeSemanticExpression
          !usefulnessCallerEntityName: inTypeNameForUsefulness
          !?ioUsefulEntitiesGraph
          !inferenceType: propertyType
          !analysisContext
          !?ioTypeMap
          !?variableMap
          ?var @semanticExpressionForGeneration expression
        ]
      //--- Check assignment type compatibility
        checkAssignmentTypeWithImplicitGetterCall (
          !propertyType
          !expression.mResultType
          !propertyName.location
          !?expression
        )
        [expression generateExpression
          !?outInitializationCode
          !?inclusionSet
          !?temporaryVariableIndex
          !?outUnusedVariableCppNameSet
          ?let sourceVar
        ]
        outInitializationCode += "  mProperty_" + [propertyName identifierRepresentation]
        outInitializationCode += " = " + sourceVar + " ;\n"
      end
    end
  }

}

//--------------------------------------------------------------------------------------------------
