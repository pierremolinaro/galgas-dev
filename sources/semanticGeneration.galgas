//--------------------------------------------------------------------------------------------------
//
//  Generate predefined types
//
//  Copyright (C) 2010, ..., 2021 Pierre Molinaro.
//
//  MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//--------------------------------------------------------------------------------------------------
//! Grammar
//--------------------------------------------------------------------------------------------------

final class @grammarForGeneration : @semanticDeclarationWithHeaderForGeneration {
  public let @string mGrammarName
  public let @string mLexiqueName
  public let @nonTerminalSymbolMapForGrammarAnalysis mNonTerminalMapForGrammarAnalysis
  public let @nonTerminalToAddList mNonTerminalToAddList
  public let @lstringlist mSyntaxComponents
  public let @string mStartSymbolName
  public let @bool mHasTranslateFeature
  public let @string mCppFileContents

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method appendDeclaration1 ?!@stringset ioInclusionSet
                                     !@string outHeader {
    for (s) in self.mSyntaxComponents do
      ioInclusionSet ++= "syntax-" + [s fileNameRepresentation]
    end
    outHeader = [filewrapper grammarGenerationTemplate.grammarZone3HeaderGalgas3
      !self.mLexiqueName.identifierRepresentation
      !self.mNonTerminalMapForGrammarAnalysis
      !self.mNonTerminalToAddList
      !self.mStartSymbolName
      !self.mHasTranslateFeature
      !self.mGrammarName
      !self.mSyntaxComponents
     ]
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method appendSpecificImplementation ?let @unifiedTypeMap inUnifiedTypeMap
                                                ?!@stringset ioInclusionSet
                                                !@string outImplementation {
    ioInclusionSet ++= "grammar-" + [self.mGrammarName fileNameRepresentation]
    for nonTerminal in self.mNonTerminalMapForGrammarAnalysis do
      for (* mFormalParametersList) in nonTerminal.mNonterminalSymbolParametersMap do
        for (mFormalArgumentPassingModeForGrammarAnalysis mGalgasTypeNameForGrammarAnalysis) in mFormalParametersList do
          switch mFormalArgumentPassingModeForGrammarAnalysis
          case argumentConstantIn, argumentVarIn :
            let t = [inUnifiedTypeMap typeMapEntryForLKey !mGalgasTypeNameForGrammarAnalysis]
            [t addHeaderFileName !?ioInclusionSet]
          case argumentInOut, argumentOut :
          end
        end
      end
    end
    outImplementation = self.mCppFileContents
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter getImplementationCppFileName -> @string {
    result = "grammar-" + [self.mGrammarName fileNameRepresentation]
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter hasCppHeaderFile -> @bool {
    result = false
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter headerKind -> @headerKind {
    result = @headerKind.oneHeader
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isPredefined -> @bool {
    result = false
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------

final class @syntaxDeclarationForGeneration : @semanticDeclarationForGeneration {
  public let @string mSyntaxComponentName
  public let @string mLexiqueName
  public let @nonterminalMap mNonterminalDeclarationMap
  public let @ruleDeclarationList mRuleDeclarationList
  public let @uint mSelectMethodCount
  public let @bool mHasIndexing
  public let @bool mHasTranslateFeature

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter getImplementationCppFileName -> @string {
    result = "syntax-" + [self.mSyntaxComponentName fileNameRepresentation]
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter hasCppHeaderFile -> @bool {
    result = false
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter headerKind -> @headerKind {
    result = .oneHeader
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter isPredefined -> @bool {
    result = false
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method appendDeclaration1 ?!@stringset ioInclusionSet
                                     !@string outHeader {
    ioInclusionSet ++= "lexique-" + [self.mLexiqueName fileNameRepresentation]
    var selectMethodList = @uintlist ()
    var @uint idx = 0
    loop (self.mSelectMethodCount + 1)
    while idx < self.mSelectMethodCount do
      selectMethodList += !idx
      idx += 1
    end
    outHeader = [filewrapper syntaxFileGenerationTemplate.syntaxAnalyserClassDeclaration
      !self.mSyntaxComponentName
      !self.mLexiqueName.identifierRepresentation
      !self.mNonterminalDeclarationMap
      !self.mRuleDeclarationList
      !selectMethodList
      !self.mHasIndexing
      !self.mHasTranslateFeature
    ]
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method appendSpecificImplementation ?let @unifiedTypeMap unused inTypeMap
                                              ?!@stringset ioInclusionSet
                                              !@string outImplementation {
    ioInclusionSet ++= "syntax-" + [self.mSyntaxComponentName fileNameRepresentation]
    outImplementation = [filewrapper syntaxFileGenerationTemplate.syntaxFileImplementationGalgas3
      !@()
    ]
  //---
    let lexiqueCppName = "Lexique_" + self.mLexiqueName.identifierRepresentation
    for (mNonterminalName mRuleIndex mLabelImplementationList) in self.mRuleDeclarationList do
    //--- Generate rule label implementation
      for (mLabelName mSignatureForGeneration * * mInstructionListForGeneration) in mLabelImplementationList do
        let @string ruleName = "cParser_" + self.mSyntaxComponentName.identifierRepresentation
          + "::rule_" + self.mSyntaxComponentName.identifierRepresentation + "_"
          + mNonterminalName.identifierRepresentation
          + "_i" + mRuleIndex.string + "_" + mLabelName.string.identifierRepresentation
        outImplementation += "//------------------------------------------------------------------------------------------------\n\n"
        generateProcedure (
          !static:false
          !ruleName
          !?ioInclusionSet
          !mSignatureForGeneration
          !mInstructionListForGeneration
          !false
          !lexiqueCppName
          !false // Do not generate location Argument
          !false // Do not generate 'resetTemplateString'
          !self.mHasTranslateFeature
          ?let @string code
        )
        outImplementation += code
      end
    //--- Generate "parse" label
      [mLabelImplementationList first ?* ?* ?* ?* ?let parseInstructionList]
      let @string parseRuleName = "cParser_" + self.mSyntaxComponentName.identifierRepresentation
      + "::rule_" + self.mSyntaxComponentName.identifierRepresentation + "_"
      + mNonterminalName.identifierRepresentation
      + "_i" + mRuleIndex.string + "_parse"
      outImplementation += "//------------------------------------------------------------------------------------------------\n\n"
      generateProcedure (
        !static:false
        !parseRuleName
        !?ioInclusionSet
        !@formalParameterListForGeneration ()
        !syntaxSignatureOfInstructionList (!"parse" !parseInstructionList)
        !false
        !lexiqueCppName
        !false // Do not generate location Argument
        !true // Generate 'resetTemplateString'
        !self.mHasTranslateFeature
        ?let @string parseCode
      )
      outImplementation += parseCode
    //--- Generate indexing code
      if self.mHasIndexing then
        [mLabelImplementationList first ?* ?* ?* ?* ?let instructionList]
        let @string ruleName = "cParser_" + self.mSyntaxComponentName.identifierRepresentation
        + "::rule_" + self.mSyntaxComponentName.identifierRepresentation + "_"
        + mNonterminalName.identifierRepresentation
        + "_i" + mRuleIndex.string + "_indexing"
        outImplementation += "//------------------------------------------------------------------------------------------------\n\n"
        generateProcedure (
          !static:false
          !ruleName
          !?ioInclusionSet
          !@formalParameterListForGeneration ()
          !syntaxSignatureOfInstructionList (!"indexing" !instructionList)
          !false
          !lexiqueCppName
          !false // Do not generate location Argument
          !false // Do not generate 'resetTemplateString'
          !false // Do not generate syntaxDirectedTranslationString argument
          ?let @string code
        )
        outImplementation += code
      end
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------
//
// P R O C E D U R E    I M P L E M E N T A T I O N
//
//--------------------------------------------------------------------------------------------------

proc generateProcedure
  ?static:let @bool inGenerateStatic
  ?let @string inProcedureMangledName
  ?!@stringset ioInclusionSet
  ?let @formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  ?let @bool inProcedureIsConst
  ?let @string inCompilerTypeName
  ?let @bool inGenerateLocationArgs
  ?let @bool inGenerateResetTemplateString
  ?let @bool inGenerateSyntaxDirectedTranslationString
  !@string outGeneratedCode
{
//--- Build unused variable set
  var @stringset unusedVariableCppNameSet = @()
  if inGenerateSyntaxDirectedTranslationString then
    unusedVariableCppNameSet ++= syntaxDirectedTranslationResultVarName ()
  end
  if not inGenerateResetTemplateString then
    unusedVariableCppNameSet ++= compilerCppName ()
  end
  for (* mFormalArgumentPassingMode * * mFormalArgumentCppName) in inFormalArgumentList do
    if mFormalArgumentPassingMode != @formalArgumentPassingModeAST. argumentOut then
      unusedVariableCppNameSet ++= mFormalArgumentCppName
    end
  end
//--- Generate body
  var @uint temporaryVariableIndex = 0
  var routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
//--- Generate inclusions
  for (* * mFormalArgumentType * *) in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
//--- Generate header
  outGeneratedCode = ""
  if inGenerateStatic then
    outGeneratedCode += "static "
  end
  outGeneratedCode += "void " + inProcedureMangledName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
//---
  for (* mFormalArgumentPassingMode mFormalArgumentType * mFormalArgumentCppName) in inFormalArgumentList do
    switch mFormalArgumentPassingMode
    case argumentConstantIn :
      outGeneratedCode += "const GGS_" + mFormalArgumentType.identifierRepresentation + " "
    case argumentInOut :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " & "
    case argumentOut :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " & "
    case argumentVarIn :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
//--- Syntax directed argument ?
  if inGenerateSyntaxDirectedTranslationString then
    if [unusedVariableCppNameSet hasKey !syntaxDirectedTranslationResultVarName ()] then
      outGeneratedCode += "String & /* " + syntaxDirectedTranslationResultVarName () + " */,\n"
    else
      outGeneratedCode += "String & " + syntaxDirectedTranslationResultVarName () + ",\n"
    end
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
//--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  if inGenerateLocationArgs then
    outGeneratedCode += "\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  end
  outGeneratedCode += ")"
  if inProcedureIsConst then
    outGeneratedCode += " const"
  end
  outGeneratedCode += " {\n"
//--- Release 'out' arguments
  for (* mFormalArgumentPassingMode * * mFormalArgumentCppName) in inFormalArgumentList do
    switch mFormalArgumentPassingMode
    case argumentOut :
      outGeneratedCode += "  " + mFormalArgumentCppName + ".drop () ; // Release 'out' argument\n"
    case argumentConstantIn, argumentVarIn, argumentInOut :
    end
  end
//--- Generate routine body
  outGeneratedCode += routineBody
//---
  if inGenerateResetTemplateString then
    outGeneratedCode += "  " + compilerCppName () + "->resetTemplateString () ;\n"
  end
//---
  outGeneratedCode += "}\n\n"
}

//--------------------------------------------------------------------------------------------------
//
// F U N C T I O N    I M P L E M E N A T I O N
//
//--------------------------------------------------------------------------------------------------

proc generateFunction ?let @string inFunctionCppRepresentationName
                      ?!@stringset ioInclusionSet
                      ?let @formalInputParameterListForGeneration inFormalArgumentList
                      ?let @semanticInstructionListForGeneration inInstructionList
                      ?let @string inCompilerTypeName
                      ?let @unifiedTypeMapEntry inResultType
                      ?let @string inResultVariableCppName
                      ?static: let @bool inIsStatic
                      ?const: let @bool inIsConst
                      !@string outGeneratedCode {
  outGeneratedCode = ""
  [inResultType addHeaderFileName !?ioInclusionSet]
//--- Build unused variable set
  var @stringset unusedVariableCppNameSet = @()
  unusedVariableCppNameSet ++= compilerCppName ()
//--- Release 'in' and 'const in' arguments at the end of the routine
  for (* mFormalArgumentType mFormalArgumentCppName * *) in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    unusedVariableCppNameSet ++= mFormalArgumentCppName
  end
//--- Generate body
  var @uint temporaryVariableIndex = 0
  var @string routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false // inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
//--- Generate header
  if inIsStatic then
    outGeneratedCode += "static "
  end
  outGeneratedCode += "GGS_" + inResultType.identifierRepresentation + " "
  outGeneratedCode += inFunctionCppRepresentationName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
//---
  for (* mFormalArgumentType mFormalArgumentCppName * mIsConstant) in inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode += "const GGS_" + mFormalArgumentType.identifierRepresentation + " &"
    else
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
//      outGeneratedCode += " /* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += " " + mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
//--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " *"
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
//    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += " " + compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS)"
  if inIsConst then
    outGeneratedCode += " const"
  end
  outGeneratedCode += " {\n"
//--- Declare returned variable
  outGeneratedCode += "  GGS_" + inResultType.identifierRepresentation
                   +  " " + inResultVariableCppName + " ; // Returned variable\n"
//--- Generate routine body
  outGeneratedCode += routineBody
//--- Generate return instruction
  outGeneratedCode += "//---\n"
  outGeneratedCode += "  return " + inResultVariableCppName + " ;\n"
//---
  outGeneratedCode += "}\n\n"
}

//--------------------------------------------------------------------------------------------------

proc generateExtensionGetter ?let @string inFunctionCppRepresentationName
                                ?!@stringset ioInclusionSet
                                ?let @formalInputParameterListForGeneration inFormalArgumentList
                                ?let @semanticInstructionListForGeneration inInstructionList
                                ?let @string inCompilerTypeName
                                ?let @unifiedTypeMapEntry inResultType
                                ?let @string inResultVariableCppName
                                !@string outGeneratedCode {
  outGeneratedCode = ""
  [inResultType addHeaderFileName !?ioInclusionSet]
//--- Build unused variable set
  var @stringset unusedVariableCppNameSet = @()
  unusedVariableCppNameSet ++= compilerCppName ()
//--- Release 'in' and 'const in' arguments at the end of the routine
  for (* mFormalArgumentType mFormalArgumentCppName * *) in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
    unusedVariableCppNameSet ++= mFormalArgumentCppName
  end
//--- Generate body
  var @uint temporaryVariableIndex = 0
  var @string routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false // inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
//--- Generate header
  outGeneratedCode += "GGS_" + inResultType.identifierRepresentation + " "
  outGeneratedCode += inFunctionCppRepresentationName + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
//---
  for (* mFormalArgumentType mFormalArgumentCppName * mIsConstant) in inFormalArgumentList do
    if mIsConstant then
      outGeneratedCode += "const GGS_" + mFormalArgumentType.identifierRepresentation
    else
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += " /* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += " " + mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
//--- Compiler argument
  outGeneratedCode += inCompilerTypeName + " *"
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += " " + compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS) const {\n"
//--- Declare returned variable
  outGeneratedCode += "  GGS_" + inResultType.identifierRepresentation
                   +  " " + inResultVariableCppName + " ; // Returned variable\n"
//--- Generate routine body
  outGeneratedCode += routineBody
//--- Generate return instruction
  outGeneratedCode += "//---\n"
  outGeneratedCode += "  return " + inResultVariableCppName + " ;\n"
//---
  outGeneratedCode += "}\n\n"
}

//--------------------------------------------------------------------------------------------------
//
// E X T E N S I O N    M O D I F I E R    I M P L E M E N T A T I O N
//
//--------------------------------------------------------------------------------------------------

proc generateExtensionSetter
  ?let @string inClassName
  ?let @string inBaseClassName
  ?let @string inMethodName
  ?!@stringset ioInclusionSet
  ?let @formalParameterListForGeneration inFormalArgumentList
  ?let @semanticInstructionListForGeneration inInstructionList
  !@string outGeneratedCode {
//--- Build unused variable set
  var @stringset unusedVariableCppNameSet = @()
  unusedVariableCppNameSet ++= compilerCppName ()
  unusedVariableCppNameSet ++= "object"
  for (* * * * mFormalArgumentCppName) in inFormalArgumentList do
    unusedVariableCppNameSet ++= mFormalArgumentCppName
  end
//--- Generate body
  var @uint temporaryVariableIndex = 0
  var routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false // inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
//--- Generate header
  outGeneratedCode = "static void extensionSetter_" + inClassName.identifierRepresentation + "_" + inMethodName.identifierRepresentation + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
  if inBaseClassName == "" then
    outGeneratedCode += "cPtr_" + inClassName.identifierRepresentation + " * "
  else
    outGeneratedCode += "cPtr_" + inBaseClassName.identifierRepresentation + " * "
  end
  let @bool currentObjectIsUnused = [unusedVariableCppNameSet hasKey !"object"]
  if currentObjectIsUnused then
    outGeneratedCode += "/* inObject */"
  else
    outGeneratedCode += "inObject"
  end
//---
  for (* mFormalArgumentPassingMode mFormalArgumentType * mFormalArgumentCppName) in inFormalArgumentList do
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
    switch mFormalArgumentPassingMode
    case argumentConstantIn :
      outGeneratedCode += "const GGS_" + mFormalArgumentType.identifierRepresentation + " "
    case argumentInOut :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " & "
    case argumentOut :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " & "
    case argumentVarIn :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
  end
//--- Compiler argument
  outGeneratedCode += ",\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "Compiler * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  outGeneratedCode += ") {\n"
//--- Generate routine body
  if not currentObjectIsUnused then
    if inBaseClassName == "" then
      outGeneratedCode += "  cPtr_" + inClassName.identifierRepresentation + " * object = inObject ;\n"
    else
      outGeneratedCode += "  cPtr_" + inClassName.identifierRepresentation + " * object = (cPtr_" + inClassName.identifierRepresentation + " *) inObject ;\n"
    end
    outGeneratedCode += "  macroValidSharedObject (object, cPtr_" + inClassName.identifierRepresentation + ") ;\n"
  end
  outGeneratedCode += routineBody
//---
  outGeneratedCode += "}"
}

//--------------------------------------------------------------------------------------------------
// E X T E N S I O N    M E T H O D    I M P L E M E N T A T I O N
//--------------------------------------------------------------------------------------------------

proc generateExtensionMethodNew ?let @unifiedTypeMapEntry inReceiverType
                                ?!@stringset ioInclusionSet
                                ?let @string inMethodName
                                ?let @formalParameterListForGeneration inFormalArgumentList
                                ?let @semanticInstructionListForGeneration inInstructionList
                                !@string outGeneratedCode {
  let className = inReceiverType.definition.typeName.string
//--- Build unused variable set
  var @stringset unusedVariableCppNameSet = @()
  unusedVariableCppNameSet ++= compilerCppName ()
  unusedVariableCppNameSet ++= "object"
  for (* * * * mFormalArgumentCppName) in inFormalArgumentList do
    unusedVariableCppNameSet ++= mFormalArgumentCppName
  end
//--- Generate body
  var @uint temporaryVariableIndex = 0
  var @string routineBody = ""
  [!?routineBody incIndentation !2]
  for (mInstruction) in inInstructionList do
    [mInstruction generateInstruction
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !false // inGenerateSyntaxDirectedTranslationString
      !?routineBody
    ]
  end
  [!?routineBody decIndentation !2]
//--- Generate inclusions
  var @unifiedTypeMapEntry baseType = inReceiverType
  var @bool searching = true
  loop (@uint. max) while searching do
    if not baseType.definition.superType.isNull then
      if [baseType.definition.superType.definition.instanceMethodMap hasKey !inMethodName] then
        baseType = baseType.definition.superType
      else
        searching = false
      end
    else
      searching = false
    end
  end
  ioInclusionSet ++= "method-" + [baseType.definition.typeName.string fileNameRepresentation] + "-" + [inMethodName fileNameRepresentation]
  [inReceiverType addHeaderFileName !?ioInclusionSet]
  for (* * mFormalArgumentType * *) in inFormalArgumentList do
    [mFormalArgumentType addHeaderFileName !?ioInclusionSet]
  end
//--- Generate header
  outGeneratedCode = "void cPtr_" + className.identifierRepresentation + "::method_" + inMethodName.identifierRepresentation + " ("
  let @uint colRef = [outGeneratedCode currentColumn]
//---
  for (* mFormalArgumentPassingMode mFormalArgumentType * mFormalArgumentCppName) in inFormalArgumentList do
    switch mFormalArgumentPassingMode
    case argumentConstantIn :
      outGeneratedCode += "const GGS_" + mFormalArgumentType.identifierRepresentation + " "
    case argumentInOut :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " & "
    case argumentOut :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " & "
    case argumentVarIn :
      outGeneratedCode += "GGS_" + mFormalArgumentType.identifierRepresentation + " "
    end
    if [unusedVariableCppNameSet hasKey !mFormalArgumentCppName] then
      outGeneratedCode += "/* " + mFormalArgumentCppName + " */"
    else
      outGeneratedCode += mFormalArgumentCppName
    end
    outGeneratedCode += ",\n"
    [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  end
//--- Compiler argument
  outGeneratedCode += "Compiler * "
  if [unusedVariableCppNameSet hasKey !compilerCppName ()] then
    outGeneratedCode += "/* " + compilerCppName () + " */"
  else
    outGeneratedCode += compilerCppName ()
  end
  outGeneratedCode += "\n"
  [!?outGeneratedCode appendSpacesUntilColumn !colRef]
  outGeneratedCode += "COMMA_UNUSED_LOCATION_ARGS"
  outGeneratedCode += ") {\n"
//--- Generate routine body
  outGeneratedCode += routineBody
//---
  outGeneratedCode += "}"
}

//--------------------------------------------------------------------------------------------------
//! Generation Filewrappers
//--------------------------------------------------------------------------------------------------

filewrapper typeGenerationTemplate in "+generation-templates/type_generation" {
  "txt"
}{
}{
  template unifiedClassBodyForType "unified-class-body-for-type.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@bool IS_CONCRETE // false if abstract class
    ?@initializerMap INITIALIZER_MAP
    ?@classFunctionMap CLASS_FUNC_MAP
    ?@getterMap GETTER_MAP
    ?@setterMap MODIFIER_MAP
    ?@instanceMethodMap INSTANCE_METHOD_MAP
    ?@classMethodMap CLASS_METHOD_MAP
    ?@subscriptMap READ_SUBSCRIPT_MAP
    ?@enumerationDescriptorList ENUMERATION_DESCRIPTOR_LIST // Empty List if cannot be enumerated
    ?@typeFeatures SUPPORTED_OPERATORS
    ?@functionSignature ADD_ASSIGN_ARGUMENT_LIST // Empty list if operator is not supported
    ?@unifiedTypeMapEntry ENUMERATED_OBJECT_TYPE
    ?@bool SUPPORT_COLLECTION_VALUE

  template unifiedClassBodyForPackage "unified-class-body-for-package.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@classFunctionMap CLASS_FUNC_MAP
    ?@classMethodMap CLASS_METHOD_MAP

  template genericTypeImplementation "generic-type.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMapEntry SUPER_TYPE_INDEX

//--------- Extern Type
  template externTypeHeader1 "GALGAS_extern_type.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER
    ?@string PRE_DECLARATION
    ?@string CODE

//--------- Graph
  template graphTypeHeader1 "GALGAS_graph.h1.galgasTemplate"
    ?@string TYPE_NAME
    ?@string TYPE_IDENTIFIER

  template graphTypeSpecificImplementation "GALGAS_graph.cpp.galgasTemplate"
    ?@unifiedTypeMapEntry TYPE
    ?@string TYPE_IDENTIFIER
    ?@unifiedTypeMapEntry ASSOCIATED_LIST_TYPE
    ?@graphInsertModifierList INSERT_MODIFIER_LIST
}

//--------------------------------------------------------------------------------------------------
//
//           G E N E R A T I O N    F I L E W R A P P E R S
//
//--------------------------------------------------------------------------------------------------

filewrapper semanticComponentGenerationTemplate in "+generation-templates/semantic_generation" {
}{
}{
//----------- initializer
  template initializerImplementation "initializer.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string INITIALIZER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string INITIALIZER_IMPLEMENTATION

//----------- Extension getter
  template abstractExtensionGetterDeclaration "abstract-extension-getter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapEntry RETURN_TYPE

  template abstractExtensionGetterImplementation "abstract-extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapEntry RETURN_TYPE

  template extensionGetterDeclaration "extension-getter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@unifiedTypeMapEntry RETURN_TYPE

  template extensionGetterImplementation "extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string GETTER_IMPLEMENTATION
    ?@unifiedTypeMapEntry RETURN_TYPE

  template overridingExtensionGetterImplementation "overriding-extension-getter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string GETTER_NAME
    ?@string GETTER_IMPLEMENTATION
    ?@unifiedTypeMapEntry RETURN_TYPE

//----------- Extension setter
  template abstractExtensionSetterDeclaration "abstract-extension-setter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template abstractExtensionSetterImplementation "abstract-extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionSetterDeclaration "extension-setter.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionsetterImplementation "extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string MODIFIER_IMPLEMENTATION

  template overridingExtensionSetterImplementation "overriding-extension-setter.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string MODIFIER_NAME
    ?@string MODIFIER_IMPLEMENTATION


//----------- Extension method
  template abstractExtensionMethodDeclaration "abstract-extension-method.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template abstractExtensionMethodImplementation "abstract-extension-method.cpp.galgasTemplate"
    ?@unifiedTypeMapEntry RECEIVER_TYPE
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionMethodDeclaration "extension-method.h.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionMethodImplementation "extension-method.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string METHOD_IMPLEMENTATION

  template overridingExtensionMethodImplementation "overriding-extension-method.cpp.galgasTemplate"
    ?@string CLASS_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION

  template filewrapperDeclaration "filewrapper-declaration.h.galgasTemplate"
    ?@stringlist FILE_INDEX_STRING_LIST
    ?@stringlist DIRECTORY_INDEX_STRING_LIST
    ?@stringlist TEXT_CONTENT_INDEX_STRING_LIST
    ?@stringlist BINARY_CONTENT_INDEX_STRING_LIST
    ?@string FILEWRAPPER_NAME

  template filewrapperImplementation "filewrapper-implementation.cpp.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string FILEWRAPPER_IMPLEMENTATION

//--- Extension getter implemented as function
  template extensionGetterAsFunctionDeclaration "extension-getter-as-function-declaration.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string GETTER_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template extensionGetterAsFunctionImplementation "extension-getter-as-function-implementation.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string GETTER_NAME
    ?@string FUNCTION_IMPLEMENTATION

//--- Extension method implemented as function
  template extensionMethodAsFunctionDeclaration "extension-method-as-function.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template extensionMethodAsFunctionImplementation "extension-method-as-function.cpp.galgasTemplate"
    ?@string TYPE_NAME
    ?@string METHOD_NAME
    ?@string METHOD_IMPLEMENTATION


//--- Extension setter implemented as function
  template extensionSetterAsFunctionDeclaration "extension-setter-as-function.h.galgasTemplate"
    ?@string TYPE_NAME
    ?@string MODIFIER_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

//--- Function
  template functionDeclaration "function-declaration.h.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template functionImplementation "function-implementation.cpp.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

//--- Routine
  template routineDeclaration "routine-declaration.h.galgasTemplate"
    ?@string ROUTINE_NAME
    ?@formalParameterListForGeneration FORMAL_ARGUMENT_LIST

  template routineImplementation "routine-implementation.cpp.galgasTemplate"
    ?@string ROUTINE_NAME
    ?@string ROUTINE_IMPLEMENTATION


  template onceFunctionImplementation "once-function-implementation.cpp.galgasTemplate"
    ?@string FUNCTION_NAME
    ?@string FUNCTION_IMPLEMENTATION
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@string RETURN_TYPE_IDENTIFIER

  template filewrapperTemplateDeclaration "filewrapper-template.h.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST

  template filewrapperTemplateImplementation "filewrapper-template.cpp.galgasTemplate"
    ?@string FILEWRAPPER_NAME
    ?@string TEMPLATE_NAME
    ?@formalInputParameterListForGeneration FORMAL_ARGUMENT_LIST
    ?@stringset UNUSED_VAR_SET
    ?@bool USES_COLUMN_MARKER
    ?@string GENERATED_INSTRUCTION_STRING
}

//--------------------------------------------------------------------------------------------------
//! func
//--------------------------------------------------------------------------------------------------

override getter @functionPrototypeDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

//--------------------------------------------------------------------------------------------------

override method @functionPrototypeDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !self.mFunctionName
    !self.mFormalArgumentList
    !self.mReturnType.identifierRepresentation
  ]
}

//--------------------------------------------------------------------------------------------------

override getter @onceFunctionDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

//--------------------------------------------------------------------------------------------------

override method @onceFunctionDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  outHeader = [filewrapper semanticComponentGenerationTemplate.functionDeclaration
    !self.mFunctionName
    !@formalInputParameterListForGeneration ()
    !self.mReturnType.identifierRepresentation
  ]
}

//--------------------------------------------------------------------------------------------------
//! Semantic Type
//--------------------------------------------------------------------------------------------------

override getter @semanticTypeForGeneration appendTypeGenericImplementation -> @string {
  let selfTypeDefinition = self.mSelfTypeEntry.definition
  if selfTypeDefinition.typeKind == .packageType then
    result = ""
  else
    result = [filewrapper typeGenerationTemplate.genericTypeImplementation
      !selfTypeDefinition.typeName.string
      !self.mSelfTypeEntry.identifierRepresentation
      !selfTypeDefinition.superType
    ]
  end
}

//--------------------------------------------------------------------------------------------------
//! Sub programs
//--------------------------------------------------------------------------------------------------

override method @functionImplementationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet ++= "func-" + [self.mFunctionName fileNameRepresentation]
  generateFunction (
    !"function_" + self.mFunctionName.identifierRepresentation
    !?ioInclusionSet
    !self.mFormalArgumentList
    !self.mFunctionInstructionList
    !"Compiler"
    !self.mReturnType
    !self.mResultVariableCppName
    !static: false // is not static
    !const: false
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.functionImplementation
    !self.mFunctionName
    !code
    !self.mFormalArgumentList
    !self.mReturnType.identifierRepresentation
  ]
}

//--------------------------------------------------------------------------------------------------

override method @onceFunctionDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation
{
  ioInclusionSet ++= "func-" + [self.mFunctionName fileNameRepresentation]
  generateFunction (
    !"onceFunction_" + self.mFunctionName.identifierRepresentation
    !?ioInclusionSet
    !@formalInputParameterListForGeneration ()
    !self.mFunctionInstructionList
    !"Compiler"
    !self.mReturnType
    !self.mResultVariableCppName
    !static: true // is static
    !const: false
    ?let @string code
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.onceFunctionImplementation
    !self.mFunctionName
    !code
    !@formalInputParameterListForGeneration ()
    !self.mReturnType.identifierRepresentation
  ]
}

//--------------------------------------------------------------------------------------------------
//    L E X I Q U E    D E C L A R A T I O N
//--------------------------------------------------------------------------------------------------

final class @lexiqueDeclarationForGeneration : @semanticDeclarationWithHeaderForGeneration {
  public let @string mLexiqueName
  public let @string mSuperLexiqueName
  public let @string mHeaderContents
  public let @string mCppContents
//  public let @string mObjcCocoaHeader
//  public let @string mObjcCocoaImplementation
//  public let @string mSwiftCocoaImplementation
  public let @string mSwiftUIImplementation

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override getter headerKind ->@headerKind {
    result = @headerKind.oneHeader
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method appendDeclaration1
    ?!@stringset ioInclusionSet
    !@string outHeader {
    outHeader = self.mHeaderContents
    if self.mSuperLexiqueName != "" then
      ioInclusionSet ++= "lexique-" + [self.mSuperLexiqueName fileNameRepresentation]
    end
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method appendSpecificImplementation
    ?let @unifiedTypeMap unused inTypeMap
    ?!@stringset ioInclusionSet
    !@string outHeader {
    ioInclusionSet ++= "lexique-" + [self.mLexiqueName fileNameRepresentation]
    outHeader = self.mCppContents
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  override method appendSpecificFiles
    ?let @string inProductDirectory
    ?!@stringset ioAllProductFileSet
    ?!swift: @stringlist ioSwiftAppProductFileList {
  //--- Generate cocoa header file
//    ioAllProductFileSet ++= "lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.h"
//    [@string generateFileWithPattern
//      !startPath:inProductDirectory
//      !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.h"
//      !lineComment:"//"
//      !header:"" // Header
//      !defaultUserZone1:"\n\n" // Defaut user zone1
//      !generatedZone2: self.mObjcCocoaHeader
//      !defaultUserZone2:"\n\n" // Defaut user zone2
//      !generatedZone3:"\n"
//      !makeExecutable:false
//    ]
  //--- Generate Objc Cocoa implementation file
//    ioAllProductFileSet ++= "lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
//    ioObjcAppProductFileList += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
//    [@string generateFileWithPattern
//      !startPath:inProductDirectory
//      !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.m"
//      !lineComment:"//"
//      !header:"" // Header
//      !defaultUserZone1:"\n\n" // Defaut user zone1
//      !generatedZone2:self.mObjcCocoaImplementation
//      !defaultUserZone2:"\n\n" // Defaut user zone2
//      !generatedZone3:"\n\n" // Zone 3
//      !makeExecutable:false
//    ]
  //--- Generate Swift Cocoa implementation file
//    ioAllProductFileSet ++= "lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.swift"
//    ioSwiftAppProductFileList += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.swift"
//    [@string generateFileWithPattern
//      !startPath:inProductDirectory
//      !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-cocoa.swift"
//      !lineComment:"//"
//      !header:"" // Header
//      !defaultUserZone1:"\n\n" // Defaut user zone1
//      !generatedZone2:self.mSwiftCocoaImplementation
//      !defaultUserZone2:"\n\n" // Defaut user zone2
//      !generatedZone3:"\n\n" // Zone 3
//      !makeExecutable:false
//    ]
  //--- Generate SwiftUI implementation file
    ioAllProductFileSet ++= "lexique-" + [self.mLexiqueName fileNameRepresentation] + "-swiftui.swift"
    ioSwiftAppProductFileList += !"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-swiftui.swift"
    [@string generateFileWithPattern
      !startPath:inProductDirectory
      !fileName:"lexique-" + [self.mLexiqueName fileNameRepresentation] + "-swiftui.swift"
      !lineComment:"//"
      !header:"" // Header
      !defaultUserZone1:"\n\n" // Defaut user zone1
      !generatedZone2:self.mSwiftUIImplementation
      !defaultUserZone2:"\n\n" // Defaut user zone2
      !generatedZone3:"\n\n" // Zone 3
      !makeExecutable:false
    ]
  }

  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

}

//--------------------------------------------------------------------------------------------------
//! Program
//--------------------------------------------------------------------------------------------------

override getter @programComponentForGeneration headerKind ->@headerKind {
  result = @headerKind.noHeader
}

//--------------------------------------------------------------------------------------------------

override method @programComponentForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet +=self. mInclusionSet
  outImplementation = self.mImplementationString
}

//--------------------------------------------------------------------------------------------------

//! Filewrapper

//--------------------------------------------------------------------------------------------------

override getter @filewrapperDeclarationForGeneration headerKind ->@headerKind {
  result = @headerKind.oneHeader
}

//--------------------------------------------------------------------------------------------------

proc recursivlyEnumerateRegularFile
  ?let @wrapperFileMap inFilewrapperFileMap
  ?let @wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@stringlist ioRegularFileIndexStringList
  ?!@stringlist ioDirectoryIndexStringList
  ?!@stringlist ioRegularTextContentIndexStringList
  ?!@stringlist ioRegularBinaryContentIndexStringList {
  ioDirectoryIndexStringList += !ioDirectoryIndexStringList.count.string
  for (* * mIsTextFile * mWrapperFileIndex) in inFilewrapperFileMap do
    ioRegularFileIndexStringList += !ioRegularFileIndexStringList.count.string
    if mIsTextFile then
      ioRegularTextContentIndexStringList += !mWrapperFileIndex.string
    else
      ioRegularBinaryContentIndexStringList += !mWrapperFileIndex.string
    end
  end
  for (* mRegularFileMap mDirectoryMap *) in inFilewrapperDirectoryMap do
    recursivlyEnumerateRegularFile (
      !mRegularFileMap
      !mDirectoryMap
      !?ioRegularFileIndexStringList
      !?ioDirectoryIndexStringList
      !?ioRegularTextContentIndexStringList
      !?ioRegularBinaryContentIndexStringList
    )
  end
}

//--------------------------------------------------------------------------------------------------

override method @filewrapperDeclarationForGeneration appendDeclaration1
  ?!@stringset unused ioInclusionSet
  !@string outHeader {
  var regularFileIndexStringList = @stringlist ()
  var regularBinaryContentIndexStringList = @stringlist ()
  var regularTextContentIndexStringList = @stringlist ()
  var directoryIndexStringList = @stringlist ()
  recursivlyEnumerateRegularFile (
    !self.mFilewrapperFileMap
    !self.mFilewrapperDirectoryMap
    !?regularFileIndexStringList
    !?directoryIndexStringList
    !?regularTextContentIndexStringList
    !?regularBinaryContentIndexStringList
  )
  outHeader = [filewrapper semanticComponentGenerationTemplate.filewrapperDeclaration
    !regularFileIndexStringList
    !directoryIndexStringList
    !regularTextContentIndexStringList
    !regularBinaryContentIndexStringList
    !self.mFilewrapperName
  ]
//--- template generation
  for (mFilewrapperTemplateName mFilewrapperTemplateFormalInputParameters *) in self.mFilewrapperTemplateListForGeneration do
    outHeader += [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateDeclaration
      !self.mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
    ]
  end
}

//--------------------------------------------------------------------------------------------------

proc generateWrapperContents
  ?let @string inFilewrapperName
  ?let @string inFilewrapperDirectory
  ?let @uint inFilewrapperDirectoryIndex
  ?let @wrapperFileMap inFilewrapperRegularFileMap
  ?let @wrapperDirectoryMap inFilewrapperDirectoryMap
  ?!@string ioImplementation {
//--- Generate regular files
  for (lkey mAbsoluteFilePath mIsTextFile * mWrapperFileIndex) in inFilewrapperRegularFileMap do
    if mIsTextFile then
      let contents = @string.stringWithContentsOfFile {!mAbsoluteFilePath}
      ioImplementation += "//--- File '" + inFilewrapperDirectory + "/" + lkey + "'\n\n"
      ioImplementation +=  "const char * gWrapperFileContent_"
      ioImplementation += mWrapperFileIndex.string
      ioImplementation += "_"
      ioImplementation += inFilewrapperName.identifierRepresentation
      ioImplementation += " = "
      if contents.count > 100 then
        var components = [contents componentsSeparatedByString !"\n"]
        [!?components popLast ?let lastLine]
        for (str) in components
        before
          ioImplementation += "\n  "
        do
          let s = str + "\n"
          ioImplementation += [s utf8RepresentationEscapingQuestionMark] + "\n  "
        end
        if lastLine.count > 0 then
          ioImplementation += [lastLine utf8RepresentationEscapingQuestionMark]
        end
      else
        ioImplementation += [contents utf8RepresentationEscapingQuestionMark]
      end
      ioImplementation += " ;\n\nconst cRegularFileWrapper gWrapperFile_"
      ioImplementation += mWrapperFileIndex.string
      ioImplementation += "_"
      ioImplementation += inFilewrapperName.identifierRepresentation
      ioImplementation += " (\n  "
      ioImplementation += [lkey utf8RepresentationEscapingQuestionMark]
      ioImplementation += ",\n  "
      ioImplementation += [[lkey pathExtension] utf8RepresentationEscapingQuestionMark]
      ioImplementation += ",\n  true, // Text file\n "
      ioImplementation += contents.count
      ioImplementation += ", // Text length\n  gWrapperFileContent_"
      ioImplementation += mWrapperFileIndex.string
      ioImplementation += "_"
      ioImplementation += inFilewrapperName.identifierRepresentation
      ioImplementation += "\n) ;\n\n"
    else
      let @data contents = @data. dataWithContentsOfFile {!mAbsoluteFilePath}
      ioImplementation += "//--- File '" + inFilewrapperDirectory + "/" + lkey + "'\n\n"
      +  "const uint8_t gWrapperFileContent_"
      + mWrapperFileIndex.string + "_"
      + inFilewrapperName.identifierRepresentation + " [" + contents.count + "] = {"
      + [contents cStringRepresentation] + "} ;\n\n"
      + "const cRegularFileWrapper gWrapperFile_" + mWrapperFileIndex.string+ "_"
      + inFilewrapperName.identifierRepresentation + " (\n"
      + "  " + [lkey utf8RepresentationEscapingQuestionMark] + ",\n"
      + "  " + [[lkey pathExtension] utf8RepresentationEscapingQuestionMark] + ",\n"
      + "  false, // binary file\n"
      + "  " + contents.count + ", // Length\n"
      + "  (const char *) gWrapperFileContent_" + mWrapperFileIndex.string + "_" + inFilewrapperName.identifierRepresentation +"\n"
      + ") ;\n\n"
    end
  end
//--- Generate sub-directories
  for (lkey mRegularFileMap mDirectoryMap mWrapperDirectoryIndex) in inFilewrapperDirectoryMap do
    generateWrapperContents (
      !inFilewrapperName
      !lkey.string
      !mWrapperDirectoryIndex
      !mRegularFileMap
      !mDirectoryMap
      !?ioImplementation
    )
  end
//--- Generate all Filewrapper list
  ioImplementation += "//--- All files of '" + inFilewrapperDirectory + "' directory\n\n"
  + "static const cRegularFileWrapper * gWrapperAllFiles_"
  + inFilewrapperName.identifierRepresentation + "_" + inFilewrapperDirectoryIndex.string
  + " [" + (inFilewrapperRegularFileMap.count + 1).string + "] = {\n"
  for (* * * * mWrapperFileIndex) in inFilewrapperRegularFileMap do
    ioImplementation += "  & gWrapperFile_" + mWrapperFileIndex.string + "_" + inFilewrapperName.identifierRepresentation + ",\n"
  end
  ioImplementation += "  nullptr\n"
  +"} ;\n\n"
//--- Generate all directory wrapper list
  ioImplementation += "//--- All sub-directories of '" + inFilewrapperDirectory + "' directory\n\n"
  + "static const cDirectoryWrapper * gWrapperAllDirectories_"
  + inFilewrapperName.identifierRepresentation + "_" + inFilewrapperDirectoryIndex.string
  + " [" + (inFilewrapperDirectoryMap.count + 1).string + "] = {\n"
  for (* * * mWrapperDirectoryIndex) in inFilewrapperDirectoryMap do
    ioImplementation += "  & gWrapperDirectory_" + mWrapperDirectoryIndex.string + "_" + inFilewrapperName.identifierRepresentation + ",\n"
  end
  ioImplementation += "  nullptr\n"
  + "} ;\n\n"
//--- Generate directory wrapper
  ioImplementation += "//--- Directory '" + inFilewrapperDirectory + "'\n\n"
  + "const cDirectoryWrapper gWrapperDirectory_" + inFilewrapperDirectoryIndex.string + "_"
  + inFilewrapperName.identifierRepresentation + " (\n"
  + "  " + [inFilewrapperDirectory utf8RepresentationEscapingQuestionMark] + ",\n"
  + "  " + inFilewrapperRegularFileMap.count.string + ",\n"
  + "  gWrapperAllFiles_" + inFilewrapperName.identifierRepresentation + "_" + inFilewrapperDirectoryIndex.string + ",\n"
  + "  " + inFilewrapperDirectoryMap.count.string + ",\n"
  + "  gWrapperAllDirectories_" + inFilewrapperName.identifierRepresentation + "_" + inFilewrapperDirectoryIndex.string + "\n"
  + ") ;\n\n"
}

//--------------------------------------------------------------------------------------------------

override method @filewrapperDeclarationForGeneration appendSpecificImplementation
  ?let @unifiedTypeMap unused inTypeMap
  ?!@stringset ioInclusionSet
  !@string outImplementation {
  ioInclusionSet ++= "filewrapper-" + self.mFilewrapperName
  var @string filewrapperImplementation = ""
  generateWrapperContents (
    !self.mFilewrapperName
    !""
    !0
    !self.mFilewrapperFileMap
    !self.mFilewrapperDirectoryMap
    !?filewrapperImplementation
  )
  outImplementation = [filewrapper semanticComponentGenerationTemplate.filewrapperImplementation
    !self.mFilewrapperName
    !filewrapperImplementation
  ]
//--- template generation
  for (mFilewrapperTemplateName mFilewrapperTemplateFormalInputParameters mTemplateInstructionListForGeneration) in self.mFilewrapperTemplateListForGeneration do
  //--- Build generated code for instruction list
    var @string generatedCodeForInstructionList = ""
    var @uint temporaryVariableIndex = 0
    var @stringset unusedVariableCppNameSet = @()
    unusedVariableCppNameSet ++= compilerCppName ()
    for (* * mFormalArgumentCppName * *) in mFilewrapperTemplateFormalInputParameters do
      unusedVariableCppNameSet ++= mFormalArgumentCppName
    end
    var @bool useColumnMarker = false
    templateCodeGenerationForListInstruction (
      !mTemplateInstructionListForGeneration
      !?generatedCodeForInstructionList
      !?ioInclusionSet
      !?temporaryVariableIndex
      !?unusedVariableCppNameSet
      !?useColumnMarker
    )
  //---
    outImplementation += [filewrapper semanticComponentGenerationTemplate.filewrapperTemplateImplementation
      !self.mFilewrapperName
      !mFilewrapperTemplateName
      !mFilewrapperTemplateFormalInputParameters
      !unusedVariableCppNameSet
      !useColumnMarker
      !generatedCodeForInstructionList
    ]
  end
}

//--------------------------------------------------------------------------------------------------
//    P R I M I T I V E    T Y P E
//--------------------------------------------------------------------------------------------------

final class @primitiveTypeForGeneration : @semanticTypeForGeneration {
  public let @string mPredefinedTypeName
  public let @string mCppDeclarationString
  public let @bool isPackage %initArgLabel

  //----------------------------------------------------------------------------------------------

  override method appendPrimitiveTypePreDeclaration ?!@string ioHeader {
    ioHeader += "class GGS_" + self.mPredefinedTypeName + " ;\n"
  }

  //----------------------------------------------------------------------------------------------

  override getter appendPrimitiveTypeDeclaration -> @string {
    result = self.mCppDeclarationString
    let selfTypeDefinition = self.mSelfTypeEntry.definition
    if self.isPackage then
      result += [filewrapper typeGenerationTemplate.unifiedClassBodyForPackage
        !selfTypeDefinition.typeName.string
        !self.mSelfTypeEntry.identifierRepresentation
        !selfTypeDefinition.classFunctionMap
        !selfTypeDefinition.classMethodMap
      ]
    else
      result += [filewrapper typeGenerationTemplate.unifiedClassBodyForType
        !selfTypeDefinition.typeName.string
        !self.mSelfTypeEntry.identifierRepresentation
        !selfTypeDefinition.isConcrete
        !selfTypeDefinition.initializerMap
        !selfTypeDefinition.classFunctionMap
        !selfTypeDefinition.getterMap
        !selfTypeDefinition.setterMap
        !selfTypeDefinition.instanceMethodMap
        !selfTypeDefinition.classMethodMap
        !selfTypeDefinition.readSubscriptMap
        !selfTypeDefinition.enumerationDescriptorList
        !selfTypeDefinition.features
        !selfTypeDefinition.addAssignOperatorArguments
        !selfTypeDefinition.typeForEnumeratedElement
        !selfTypeDefinition.supportCollectionValue
      ]
    end
  }

  //----------------------------------------------------------------------------------------------

}

//--------------------------------------------------------------------------------------------------
//! Generate Predefined types
//--------------------------------------------------------------------------------------------------

proc generatePredefinedTypeFiles
  ?let @string inDirectory
  ?let @semanticDeclarationListForGeneration inSemanticDeclarationListForGeneration
  ?!@stringlist ioToolHeaderFileList
  ?!@stringlist ioToolCppFileList
  ?!@stringset ioAllProductFileSet
{
//----------------------------------------------------------------- Generate header file
  var generatedCode = [filewrapper predefinedTypeGenerationTemplate.primitiveTypesHeaderPrologue]
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendPrimitiveTypePreDeclaration !?generatedCode]
    end
  end
  generatedCode += "\n"
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      generatedCode += [mDeclaration appendPrimitiveTypeDeclaration]
    end
  end
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendDeclaration1 !? %from @() ?let @string code]
      generatedCode += code
    end
  end
  generatedCode += [filewrapper predefinedTypeGenerationTemplate.predefinedTypeSeparation]
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      [mDeclaration appendDeclaration2 !inDirectory !? %from @() ?let @string headerString2]
      generatedCode += headerString2
    end
  end
  if @uint.errorCount == 0 then
    ioToolHeaderFileList += !"all-predefined-types.h"
    ioAllProductFileSet ++= "all-predefined-types.h"
    [@string generateFileWithPattern
      !startPath:inDirectory
      !fileName:"all-predefined-types.h"
      !lineComment:"//"
      !header:"" // Header
      !defaultUserZone1:"\n\n" // Defaut user zone1
      !generatedZone2:generatedCode
      !defaultUserZone2:"\n\n" // Defaut user zone2
      !generatedZone3:""
      !makeExecutable:false
    ]
  end
//----------------------------------------------------------------- Generate implementation file
  generatedCode = [filewrapper predefinedTypeGenerationTemplate.predefinedTypesImplementation]
  for (* mDeclaration) in inSemanticDeclarationListForGeneration do
    if [mDeclaration isPredefined] then
      generatedCode += [mDeclaration appendTypeGenericImplementation]
      [mDeclaration appendSpecificImplementation ! @() !? %from @() ?let @string code]
      generatedCode += code
    end
  end
  if @uint.errorCount == 0 then
    ioToolCppFileList += !"all-predefined-types.cpp"
    ioAllProductFileSet ++= "all-predefined-types.cpp"
    [@string generateFileWithPattern
      !startPath:inDirectory
      !fileName:"all-predefined-types.cpp"
      !lineComment:"//"
      !header:"" // Header
      !defaultUserZone1:"\n\n" // Defaut user zone1
      !generatedZone2:generatedCode
      !defaultUserZone2:"\n\n" // Defaut user zone2
      !generatedZone3:""
      !makeExecutable:false
    ]
  end
}

//--------------------------------------------------------------------------------------------------
//
//           G E N E R A T I O N    F I L E W R A P P E R S
//
//--------------------------------------------------------------------------------------------------

filewrapper semanticFileGenerationTemplate in "+generation-templates/semantic_generation" {
}{
}{
  template semanticFileHeader "semantic-file.h.galgasTemplate"
    ?@string COMPONENT_NAME
    ?@stringlist IMPORTED_COMPONENT_LIST

  template semanticFileImplementation "semantic-file.cpp.galgasTemplate"
    ?@stringlist IMPORTED_COMPONENT_LIST
}

//--------------------------------------------------------------------------------------------------
