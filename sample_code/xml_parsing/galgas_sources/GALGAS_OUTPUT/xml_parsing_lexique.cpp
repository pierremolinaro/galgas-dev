//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'xml_parsing_lexique.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 5th, 2009, at 20h12'29"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "xml_parsing_lexique.h"

#include "strings/unicode_character.h"
#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (HERE), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           Template Delimiters                             *
//                                                                           *
//---------------------------------------------------------------------------*

static const utf32 kTemplateDefinitionArray_0_startString [] = {
  UNICODE ('<'),
  UNICODE (0)
} ;

static const templateStruct kTemplateDefinitionArray [1] = {
  {kTemplateDefinitionArray_0_startString, 1, NULL, 0, false},
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Template Replacements                            *
//                                                                           *
//---------------------------------------------------------------------------*

static const utf32 kTemplateReplacementArray_0_startString [] = {
  UNICODE ('&'),
  UNICODE ('a'),
  UNICODE ('m'),
  UNICODE ('p'),
  UNICODE (';'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_0_endString [] = {
  UNICODE ('&'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_1_startString [] = {
  UNICODE ('&'),
  UNICODE ('l'),
  UNICODE ('t'),
  UNICODE (';'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_1_endString [] = {
  UNICODE ('<'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_2_startString [] = {
  UNICODE ('&'),
  UNICODE ('g'),
  UNICODE ('t'),
  UNICODE (';'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_2_endString [] = {
  UNICODE ('>'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_3_startString [] = {
  UNICODE ('&'),
  UNICODE ('q'),
  UNICODE ('u'),
  UNICODE ('o'),
  UNICODE ('t'),
  UNICODE (';'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_3_endString [] = {
  UNICODE ('\"'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_4_startString [] = {
  UNICODE ('&'),
  UNICODE ('a'),
  UNICODE ('p'),
  UNICODE ('o'),
  UNICODE ('s'),
  UNICODE (';'),
  UNICODE (0)
} ;

static const utf32 kTemplateReplacementArray_4_endString [] = {
  UNICODE ('\''),
  UNICODE (0)
} ;

static const templateStruct kTemplateReplacementArray [5] = {
  {kTemplateReplacementArray_0_startString, 5, kTemplateReplacementArray_0_endString, 1, true},
  {kTemplateReplacementArray_1_startString, 4, kTemplateReplacementArray_1_endString, 1, true},
  {kTemplateReplacementArray_2_startString, 4, kTemplateReplacementArray_2_endString, 1, true},
  {kTemplateReplacementArray_3_startString, 6, kTemplateReplacementArray_3_endString, 1, true},
  {kTemplateReplacementArray_4_startString, 6, kTemplateReplacementArray_4_endString, 1, true},
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Terminal Symbols as end of script in template mark             *
//                                                                           *
//---------------------------------------------------------------------------*

static const bool kEndOfScriptInTemplateArray [10] = {
  true, // $comment$
  false, // $<$
  false, // $<?$
  true, // $>$
  true, // $?>$
  true, // $/>$
  false, // $</$
  false, // $=$
  false, // $name$
  false, // $value$
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_xml_parsing_lexique::cTokenFor_xml_parsing_lexique (void) :
tokenString () {
}

//---------------------------------------------------------------------------*

xml_parsing_lexique::
xml_parsing_lexique (C_Compiler * inCallerCompiler,
                const C_String & inDependencyFileExtension,
                const C_String & inDependencyFilePath,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE),
_mMatchedTemplateDelimiterIndex (-1) {
}

//---------------------------------------------------------------------------*

xml_parsing_lexique::
xml_parsing_lexique (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE),
_mMatchedTemplateDelimiterIndex (-1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Message 0
static const utf32 gErrorMessage_0 [] = {
  UNICODE ('i'),
  UNICODE ('n'),
  UNICODE ('c'),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE ('r'),
  UNICODE ('e'),
  UNICODE ('c'),
  UNICODE ('t'),
  UNICODE (' '),
  UNICODE ('X'),
  UNICODE ('M'),
  UNICODE ('L'),
  UNICODE (' '),
  UNICODE ('c'),
  UNICODE ('o'),
  UNICODE ('m'),
  UNICODE ('m'),
  UNICODE ('e'),
  UNICODE ('n'),
  UNICODE ('t'),
  UNICODE (0)
} ;
//--- Message 1
static const utf32 gErrorMessage_1 [] = {
  UNICODE ('a'),
  UNICODE ('t'),
  UNICODE ('t'),
  UNICODE ('r'),
  UNICODE ('i'),
  UNICODE ('b'),
  UNICODE ('u'),
  UNICODE ('t'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('v'),
  UNICODE ('a'),
  UNICODE ('l'),
  UNICODE ('u'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('s'),
  UNICODE ('h'),
  UNICODE ('o'),
  UNICODE ('u'),
  UNICODE ('l'),
  UNICODE ('d'),
  UNICODE (' '),
  UNICODE ('b'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('e'),
  UNICODE ('n'),
  UNICODE ('c'),
  UNICODE ('l'),
  UNICODE ('o'),
  UNICODE ('s'),
  UNICODE ('e'),
  UNICODE ('d'),
  UNICODE (' '),
  UNICODE ('b'),
  UNICODE ('e'),
  UNICODE ('t'),
  UNICODE ('w'),
  UNICODE ('e'),
  UNICODE ('e'),
  UNICODE ('n'),
  UNICODE (' '),
  UNICODE ('a'),
  UNICODE ('p'),
  UNICODE ('o'),
  UNICODE ('s'),
  UNICODE ('t'),
  UNICODE ('r'),
  UNICODE ('o'),
  UNICODE ('p'),
  UNICODE ('h'),
  UNICODE ('e'),
  UNICODE ('s'),
  UNICODE (' '),
  UNICODE ('('),
  UNICODE ('\''),
  UNICODE (')'),
  UNICODE (' '),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE (' '),
  UNICODE ('q'),
  UNICODE ('u'),
  UNICODE ('o'),
  UNICODE ('t'),
  UNICODE ('a'),
  UNICODE ('t'),
  UNICODE ('i'),
  UNICODE ('o'),
  UNICODE ('n'),
  UNICODE (' '),
  UNICODE ('m'),
  UNICODE ('a'),
  UNICODE ('r'),
  UNICODE ('k'),
  UNICODE ('s'),
  UNICODE (' '),
  UNICODE ('('),
  UNICODE ('\"'),
  UNICODE (')'),
  UNICODE (0)
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Syntax error messages                            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Syntax error message for terminal '$comment$' :
static const utf32 gSyntaxErrorMessage_comment [] = {
  UNICODE ('a'),
  UNICODE (' '),
  UNICODE ('c'),
  UNICODE ('o'),
  UNICODE ('m'),
  UNICODE ('m'),
  UNICODE ('e'),
  UNICODE ('n'),
  UNICODE ('t'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$<$' :
static const utf32 gSyntaxErrorMessage__3C [] = {
  UNICODE ('t'),
  UNICODE ('h'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('\''),
  UNICODE ('<'),
  UNICODE ('\''),
  UNICODE (' '),
  UNICODE ('d'),
  UNICODE ('e'),
  UNICODE ('l'),
  UNICODE ('i'),
  UNICODE ('m'),
  UNICODE ('i'),
  UNICODE ('t'),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$<?$' :
static const utf32 gSyntaxErrorMessage__3C_3F [] = {
  UNICODE ('t'),
  UNICODE ('h'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('\''),
  UNICODE ('<'),
  UNICODE ('\?'),
  UNICODE ('\''),
  UNICODE (' '),
  UNICODE ('d'),
  UNICODE ('e'),
  UNICODE ('l'),
  UNICODE ('i'),
  UNICODE ('m'),
  UNICODE ('i'),
  UNICODE ('t'),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$>$' :
static const utf32 gSyntaxErrorMessage__3E [] = {
  UNICODE ('t'),
  UNICODE ('h'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('\''),
  UNICODE ('>'),
  UNICODE ('\''),
  UNICODE (' '),
  UNICODE ('d'),
  UNICODE ('e'),
  UNICODE ('l'),
  UNICODE ('i'),
  UNICODE ('m'),
  UNICODE ('i'),
  UNICODE ('t'),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$?>$' :
static const utf32 gSyntaxErrorMessage__3F_3E [] = {
  UNICODE ('t'),
  UNICODE ('h'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('\''),
  UNICODE ('\?'),
  UNICODE ('>'),
  UNICODE ('\''),
  UNICODE (' '),
  UNICODE ('d'),
  UNICODE ('e'),
  UNICODE ('l'),
  UNICODE ('i'),
  UNICODE ('m'),
  UNICODE ('i'),
  UNICODE ('t'),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$/>$' :
static const utf32 gSyntaxErrorMessage__2F_3E [] = {
  UNICODE ('t'),
  UNICODE ('h'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('\''),
  UNICODE ('/'),
  UNICODE ('>'),
  UNICODE ('\''),
  UNICODE (' '),
  UNICODE ('d'),
  UNICODE ('e'),
  UNICODE ('l'),
  UNICODE ('i'),
  UNICODE ('m'),
  UNICODE ('i'),
  UNICODE ('t'),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$</$' :
static const utf32 gSyntaxErrorMessage__3C_2F [] = {
  UNICODE ('t'),
  UNICODE ('h'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('\''),
  UNICODE ('<'),
  UNICODE ('/'),
  UNICODE ('\''),
  UNICODE (' '),
  UNICODE ('d'),
  UNICODE ('e'),
  UNICODE ('l'),
  UNICODE ('i'),
  UNICODE ('m'),
  UNICODE ('i'),
  UNICODE ('t'),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$=$' :
static const utf32 gSyntaxErrorMessage__3D [] = {
  UNICODE ('t'),
  UNICODE ('h'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('\''),
  UNICODE ('='),
  UNICODE ('\''),
  UNICODE (' '),
  UNICODE ('d'),
  UNICODE ('e'),
  UNICODE ('l'),
  UNICODE ('i'),
  UNICODE ('m'),
  UNICODE ('i'),
  UNICODE ('t'),
  UNICODE ('o'),
  UNICODE ('r'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$name$' :
static const utf32 gSyntaxErrorMessage_name [] = {
  UNICODE ('a'),
  UNICODE (' '),
  UNICODE ('n'),
  UNICODE ('a'),
  UNICODE ('m'),
  UNICODE ('e'),
  UNICODE (0)
} ;

//--- Syntax error message for terminal '$value$' :
static const utf32 gSyntaxErrorMessage_value [] = {
  UNICODE ('a'),
  UNICODE ('n'),
  UNICODE (' '),
  UNICODE ('a'),
  UNICODE ('t'),
  UNICODE ('t'),
  UNICODE ('r'),
  UNICODE ('i'),
  UNICODE ('b'),
  UNICODE ('u'),
  UNICODE ('t'),
  UNICODE ('e'),
  UNICODE (' '),
  UNICODE ('v'),
  UNICODE ('a'),
  UNICODE ('l'),
  UNICODE ('u'),
  UNICODE ('e'),
  UNICODE (0)
} ;

//--- Syntax error message for 'end of source' :
static const utf32 kEndOfSourceLexicalErrorMessage [] = {
  UNICODE ('e'),
  UNICODE ('n'),
  UNICODE ('d'),
  UNICODE (' '),
  UNICODE ('o'),
  UNICODE ('f'),
  UNICODE (' '),
  UNICODE ('s'),
  UNICODE ('o'),
  UNICODE ('u'),
  UNICODE ('r'),
  UNICODE ('c'),
  UNICODE ('e'),
  UNICODE (0)
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void xml_parsing_lexique::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const utf32 * syntaxErrorMessageArray [11] = {kEndOfSourceLexicalErrorMessage,
       gSyntaxErrorMessage_comment,
       gSyntaxErrorMessage__3C,
       gSyntaxErrorMessage__3C_3F,
       gSyntaxErrorMessage__3E,
       gSyntaxErrorMessage__3F_3E,
       gSyntaxErrorMessage__2F_3E,
       gSyntaxErrorMessage__3C_2F,
       gSyntaxErrorMessage__3D,
       gSyntaxErrorMessage_name,
       gSyntaxErrorMessage_value} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Key words table 'xmlDelimitorsList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

static const sint32 ktable_size_xmlDelimitorsList = 7 ;

static const utf32 kEntry_0_forTable_xmlDelimitorsList [] = {
  UNICODE ('<'),
  UNICODE (0)
}; 

static const utf32 kEntry_1_forTable_xmlDelimitorsList [] = {
  UNICODE ('='),
  UNICODE (0)
}; 

static const utf32 kEntry_2_forTable_xmlDelimitorsList [] = {
  UNICODE ('>'),
  UNICODE (0)
}; 

static const utf32 kEntry_3_forTable_xmlDelimitorsList [] = {
  UNICODE ('/'),
  UNICODE ('>'),
  UNICODE (0)
}; 

static const utf32 kEntry_4_forTable_xmlDelimitorsList [] = {
  UNICODE ('<'),
  UNICODE ('/'),
  UNICODE (0)
}; 

static const utf32 kEntry_5_forTable_xmlDelimitorsList [] = {
  UNICODE ('<'),
  UNICODE ('\?'),
  UNICODE (0)
}; 

static const utf32 kEntry_6_forTable_xmlDelimitorsList [] = {
  UNICODE ('\?'),
  UNICODE ('>'),
  UNICODE (0)
}; 

static const C_unicode_lexique_table_entry ktable_for_xmlDelimitorsList [ktable_size_xmlDelimitorsList] = {
  {kEntry_0_forTable_xmlDelimitorsList, 1, xml_parsing_lexique::xml_parsing_lexique_1__3C},
  {kEntry_1_forTable_xmlDelimitorsList, 1, xml_parsing_lexique::xml_parsing_lexique_1__3D},
  {kEntry_2_forTable_xmlDelimitorsList, 1, xml_parsing_lexique::xml_parsing_lexique_1__3E},
  {kEntry_3_forTable_xmlDelimitorsList, 2, xml_parsing_lexique::xml_parsing_lexique_1__2F_3E},
  {kEntry_4_forTable_xmlDelimitorsList, 2, xml_parsing_lexique::xml_parsing_lexique_1__3C_2F},
  {kEntry_5_forTable_xmlDelimitorsList, 2, xml_parsing_lexique::xml_parsing_lexique_1__3C_3F},
  {kEntry_6_forTable_xmlDelimitorsList, 2, xml_parsing_lexique::xml_parsing_lexique_1__3F_3E}
} ;

sint32 xml_parsing_lexique::search_into_xmlDelimitorsList (const C_String & inSearchedString) {
  return searchInList (inSearchedString, ktable_for_xmlDelimitorsList, ktable_size_xmlDelimitorsList) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String xml_parsing_lexique::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) inTokenPtr ;
  C_String s ;
  if (_p == NULL) {
    s << "$$" ;
  }else{
    switch (_p->_mTokenCode) {
    case  xml_parsing_lexique_1_:
      s << "$$" ;
      break ;
    case  xml_parsing_lexique_1_comment:
      s << "$"
        << "comment"
        << "$" ;
    s << " " ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    case  xml_parsing_lexique_1__3C:
      s << "$"
        << "<"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3C_3F:
      s << "$"
        << "<\?"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3E:
      s << "$"
        << ">"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3F_3E:
      s << "$"
        << "\?>"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__2F_3E:
      s << "$"
        << "/>"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3C_2F:
      s << "$"
        << "</"
        << "$" ;
      break;
    case  xml_parsing_lexique_1__3D:
      s << "$"
        << "="
        << "$" ;
      break;
    case  xml_parsing_lexique_1_name:
      s << "$"
        << "name"
        << "$" ;
    s << " " ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    case  xml_parsing_lexique_1_value:
      s << "$"
        << "value"
        << "$" ;
    s << " " ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            parseLexicalToken                              *
//                                                                           *
//---------------------------------------------------------------------------*

bool xml_parsing_lexique::
parseLexicalToken (void) {
  cTokenFor_xml_parsing_lexique _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while ((_token._mTokenCode < 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
    if ((_mMatchedTemplateDelimiterIndex >= 0)
     && (kTemplateDefinitionArray [_mMatchedTemplateDelimiterIndex].mEndStringLength > 0)
     && (UNICODE_VALUE (mCurrentChar) != '\0')) {
      const bool foundEndDelimitor = testForInputUTF32String (kTemplateDefinitionArray [_mMatchedTemplateDelimiterIndex].mEndString,
                                                              kTemplateDefinitionArray [_mMatchedTemplateDelimiterIndex].mEndStringLength,
                                                              true) ;
      if (foundEndDelimitor) {
        _mMatchedTemplateDelimiterIndex = -1 ;
      }
    }
    while ((_mMatchedTemplateDelimiterIndex < 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
      sint32 _replacementIndex = 0 ;
      while (_replacementIndex >= 0) {
       _replacementIndex = findTemplateDelimiterIndex (kTemplateReplacementArray, 5) ;
         if (_replacementIndex >= 0) {
           _token._mTemplateStringBeforeToken << kTemplateReplacementArray [_replacementIndex].mEndString ;
        }
      }
      _mMatchedTemplateDelimiterIndex = findTemplateDelimiterIndex (kTemplateDefinitionArray, 1) ;
      if (_mMatchedTemplateDelimiterIndex < 0) {
        _token._mTemplateStringBeforeToken.appendUnicodeCharacter (mCurrentChar COMMA_HERE) ;
        advance () ;
      }
    }
    if ((_mMatchedTemplateDelimiterIndex >= 0) && (UNICODE_VALUE (mCurrentChar) != '\0')) {
      _token.tokenString.clear () ;
      _mTokenFirstLocation = _mCurrentLocation ;
      try{
        if (testForInputString ("<!--", 4, true)) {
          do {
            if (testForInputString ("&amp;", 5, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('&')) ;
            }else if (testForInputString ("&lt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('<')) ;
            }else if (testForInputString ("&gt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('>')) ;
            }else if (testForInputString ("&quot;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\"')) ;
            }else if (testForInputString ("&apos;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\'')) ;
            }else if (testForInputCharRange (UNICODE (1), UNICODE (',')) ||
                testForInputCharRange (UNICODE ('.'), UNICODE (255))) {
              scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
            }else if (notTestForInputString ("-->", 3, gErrorMessage_0 COMMA_LINE_AND_SOURCE_FILE)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('-')) ;
            }else{
              loop_ = false ;
            }
          }while (loop_) ;
          loop_ = true ;
          _token._mTokenCode = xml_parsing_lexique_1_comment ;
          _enterToken (_token) ;
        }else if (testForInputString ("<\?", 2, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3C_3F ;
          _enterToken (_token) ;
        }else if (testForInputString ("\?>", 2, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3F_3E ;
          _enterToken (_token) ;
        }else if (testForInputString ("/>", 2, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__2F_3E ;
          _enterToken (_token) ;
        }else if (testForInputString ("</", 2, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3C_2F ;
          _enterToken (_token) ;
        }else if (testForInputString ("<", 1, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3C ;
          _enterToken (_token) ;
        }else if (testForInputString (">", 1, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3E ;
          _enterToken (_token) ;
        }else if (testForInputString ("=", 1, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3D ;
          _enterToken (_token) ;
        }else if (testForCharWithFunction (isUnicodeLetter)) {
          do {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
            if (testForCharWithFunction (isUnicodeLetter) ||
                testForInputCharRange (UNICODE ('0'), UNICODE ('9'))) {
            }else{
              loop_ = false ;
            }
          }while (loop_) ;
          loop_ = true ;
          _token._mTokenCode = xml_parsing_lexique_1_name ;
          _enterToken (_token) ;
        }else if (testForInputChar (UNICODE ('\"'))) {
          do {
            if (testForInputString ("&amp;", 5, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('&')) ;
            }else if (testForInputString ("&lt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('<')) ;
            }else if (testForInputString ("&gt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('>')) ;
            }else if (testForInputString ("&quot;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\"')) ;
            }else if (testForInputString ("&apos;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\'')) ;
            }else if (notTestForInputString ("\"", 1, gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
            }else{
              loop_ = false ;
            }
          }while (loop_) ;
          loop_ = true ;
          _token._mTokenCode = xml_parsing_lexique_1_value ;
          _enterToken (_token) ;
        }else if (testForInputChar (UNICODE ('\''))) {
          do {
            if (testForInputString ("&amp;", 5, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('&')) ;
            }else if (testForInputString ("&lt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('<')) ;
            }else if (testForInputString ("&gt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('>')) ;
            }else if (testForInputString ("&quot;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\"')) ;
            }else if (testForInputString ("&apos;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\'')) ;
            }else if (notTestForInputString ("'", 1, gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
            }else{
              loop_ = false ;
            }
          }while (loop_) ;
          loop_ = true ;
          _token._mTokenCode = xml_parsing_lexique_1_value ;
          _enterToken (_token) ;
        }else if (testForInputCharRange (UNICODE (1), UNICODE (' '))) {
        }else if (testForInputChar (UNICODE ('\0'))) { // End of source text ? 
          _token._mTokenCode = xml_parsing_lexique_1_ ; // Empty string code
        }else{ // Unknown input character
          unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
        }
      }catch (const C_lexicalErrorException &) {
        _token._mTokenCode = -1 ; // No token
        advance () ; // ... go throught unknown character
      }
    }
    if ((_token._mTokenCode > 0) && kEndOfScriptInTemplateArray [_token._mTokenCode - 1]) {
      _mMatchedTemplateDelimiterIndex = -1 ;
    }
  }
  if ((UNICODE_VALUE (mCurrentChar) == '\0') && (_token._mTemplateStringBeforeToken.length () > 0)) {
    _token._mTokenCode = 0 ;
    _enterToken (_token) ;
  }
  return _token._mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   parseLexicalTokenForLexicalColoring                     *
//                                                                           *
//---------------------------------------------------------------------------*

sint16 xml_parsing_lexique::
parseLexicalTokenForLexicalColoring (void) {
  cTokenFor_xml_parsing_lexique _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while (_token._mTokenCode < 0) {
    _token.tokenString.clear () ;
    _mTokenFirstLocation = _mCurrentLocation ;
    try{
      if (testForInputString ("<!--", 4, true)) {
        do {
          if (testForInputString ("&amp;", 5, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('&')) ;
          }else if (testForInputString ("&lt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('<')) ;
          }else if (testForInputString ("&gt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('>')) ;
          }else if (testForInputString ("&quot;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\"')) ;
          }else if (testForInputString ("&apos;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\'')) ;
          }else if (testForInputCharRange (UNICODE (1), UNICODE (',')) ||
              testForInputCharRange (UNICODE ('.'), UNICODE (255))) {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          }else if (notTestForInputString ("-->", 3, gErrorMessage_0 COMMA_LINE_AND_SOURCE_FILE)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('-')) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = xml_parsing_lexique_1_comment ;
      }else if (testForInputString ("<\?", 2, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3C_3F ;
      }else if (testForInputString ("\?>", 2, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3F_3E ;
      }else if (testForInputString ("/>", 2, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__2F_3E ;
      }else if (testForInputString ("</", 2, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3C_2F ;
      }else if (testForInputString ("<", 1, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3C ;
      }else if (testForInputString (">", 1, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3E ;
      }else if (testForInputString ("=", 1, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3D ;
      }else if (testForCharWithFunction (isUnicodeLetter)) {
        do {
          scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          if (testForCharWithFunction (isUnicodeLetter) ||
              testForInputCharRange (UNICODE ('0'), UNICODE ('9'))) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = xml_parsing_lexique_1_name ;
      }else if (testForInputChar (UNICODE ('\"'))) {
        do {
          if (testForInputString ("&amp;", 5, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('&')) ;
          }else if (testForInputString ("&lt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('<')) ;
          }else if (testForInputString ("&gt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('>')) ;
          }else if (testForInputString ("&quot;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\"')) ;
          }else if (testForInputString ("&apos;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\'')) ;
          }else if (notTestForInputString ("\"", 1, gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = xml_parsing_lexique_1_value ;
      }else if (testForInputChar (UNICODE ('\''))) {
        do {
          if (testForInputString ("&amp;", 5, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('&')) ;
          }else if (testForInputString ("&lt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('<')) ;
          }else if (testForInputString ("&gt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('>')) ;
          }else if (testForInputString ("&quot;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\"')) ;
          }else if (testForInputString ("&apos;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, UNICODE ('\'')) ;
          }else if (notTestForInputString ("'", 1, gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = xml_parsing_lexique_1_value ;
      }else if (testForInputCharRange (UNICODE (1), UNICODE (' '))) {
      }else if (testForInputChar (UNICODE ('\0'))) { // End of source text ? 
        _token._mTokenCode = xml_parsing_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      throw ;
    }
  }
  return _token._mTokenCode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 xml_parsing_lexique::getStylesCount (void) {
  return 6 ;
}

//---------------------------------------------------------------------------*

const char * xml_parsing_lexique::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [7] = {"Default style", "Delimiter:", "Name:", "Attribute value:", "Comment:", "Text:", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

const char * xml_parsing_lexique::getStyleIdentifier (const sint32 inIndex) {
  const char * kStylesArray [7] = {"", "delimitersStyle", "nameStyle", "attributeValue", "commentStyle", "textStyle", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 xml_parsing_lexique::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [11] = {0,
    4 /* xml_parsing_lexique_1_comment */,
    1 /* xml_parsing_lexique_1__3C */,
    1 /* xml_parsing_lexique_1__3C_3F */,
    1 /* xml_parsing_lexique_1__3E */,
    1 /* xml_parsing_lexique_1__3F_3E */,
    1 /* xml_parsing_lexique_1__2F_3E */,
    1 /* xml_parsing_lexique_1__3C_2F */,
    1 /* xml_parsing_lexique_1__3D */,
    2 /* xml_parsing_lexique_1_name */,
    3 /* xml_parsing_lexique_1_value */
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*

void xml_parsing_lexique::_enterToken (const cTokenFor_xml_parsing_lexique & inToken) {
  cTokenFor_xml_parsing_lexique * _p = NULL ;
  macroMyNew (_p, cTokenFor_xml_parsing_lexique ()) ;
  _p->_mTokenCode = inToken._mTokenCode ;
  _p->_mFirstLocation = _mTokenFirstLocation ;
  _p->_mLastLocation  = _mTokenLastLocation ;
  _p->_mTemplateStringBeforeToken  = inToken._mTemplateStringBeforeToken ;
  _p->tokenString = inToken.tokenString ;
  _enterTokenFromPointer (_p) ;
}

//---------------------------------------------------------------------------*

void xml_parsing_lexique::
_assignFromAttribute_tokenString (GGS_lstring & outValue) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->tokenString) ;
}

//---------------------------------------------------------------------------*

C_String xml_parsing_lexique::
_attributeValue_tokenString (void) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) mCurrentTokenPtr ;
  return _p->tokenString ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

