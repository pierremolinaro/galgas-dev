//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'xml_parsing_lexique.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                       may 2nd, 2009, at 10h23'57"                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "xml_parsing_lexique.h"

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                           Template Delimiters                             *
//                                                                           *
//---------------------------------------------------------------------------*

static const templateStruct kTemplateDefinitionArray [1] = {
  {"<", 1, "", 0, false},
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Template Replacements                            *
//                                                                           *
//---------------------------------------------------------------------------*

static const templateStruct kTemplateReplacementArray [0] = {
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//            Terminal Symbols as end of script in template mark             *
//                                                                           *
//---------------------------------------------------------------------------*

static const bool kEndOfScriptInTemplateArray [11] = {
  false, // End of source
  true, // $comment$
  false, // $<$
  false, // $<?$
  true, // $>$
  true, // $?>$
  true, // $/>$
  false, // $</$
  false, // $=$
  false, // $name$
  false, // $value$
} ;

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_xml_parsing_lexique::cTokenFor_xml_parsing_lexique (void) :
tokenString () {
}

//---------------------------------------------------------------------------*

xml_parsing_lexique::
xml_parsing_lexique (C_Compiler * inCallerCompiler,
                const C_String & inDependencyFileExtension,
                const C_String & inDependencyFilePath,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE),
_mMatchedTemplateDelimiterIndex (-1) {
}

//---------------------------------------------------------------------------*

xml_parsing_lexique::
xml_parsing_lexique (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE),
_mMatchedTemplateDelimiterIndex (-1) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                        Lexical error message list                         *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Message 0
static const char * gErrorMessage_0 = "incorrect XML comment" ;
//--- Message 1
static const char * gErrorMessage_1 = "attribute value should be enclosed between apostrophes (') or quotation marks (\")" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                          Syntax error messages                            *
//                                                                           *
//---------------------------------------------------------------------------*

//--- Syntax error message for terminal '$comment$' :
static const char * gSyntaxErrorMessage_comment = "a comment" ;

//--- Syntax error message for terminal '$<$' :
static const char * gSyntaxErrorMessage__3C = "the '<' delimitor" ;

//--- Syntax error message for terminal '$<?$' :
static const char * gSyntaxErrorMessage__3C_3F = "the '<\?' delimitor" ;

//--- Syntax error message for terminal '$>$' :
static const char * gSyntaxErrorMessage__3E = "the '>' delimitor" ;

//--- Syntax error message for terminal '$?>$' :
static const char * gSyntaxErrorMessage__3F_3E = "the '\?>' delimitor" ;

//--- Syntax error message for terminal '$/>$' :
static const char * gSyntaxErrorMessage__2F_3E = "the '/>' delimitor" ;

//--- Syntax error message for terminal '$</$' :
static const char * gSyntaxErrorMessage__3C_2F = "the '</' delimitor" ;

//--- Syntax error message for terminal '$=$' :
static const char * gSyntaxErrorMessage__3D = "the '=' delimitor" ;

//--- Syntax error message for terminal '$name$' :
static const char * gSyntaxErrorMessage_name = "a name" ;

//--- Syntax error message for terminal '$value$' :
static const char * gSyntaxErrorMessage_value = "an attribute value" ;

//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void xml_parsing_lexique::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const char * syntaxErrorMessageArray [11] = {"end of source",
       gSyntaxErrorMessage_comment,
       gSyntaxErrorMessage__3C,
       gSyntaxErrorMessage__3C_3F,
       gSyntaxErrorMessage__3E,
       gSyntaxErrorMessage__3F_3E,
       gSyntaxErrorMessage__2F_3E,
       gSyntaxErrorMessage__3C_2F,
       gSyntaxErrorMessage__3D,
       gSyntaxErrorMessage_name,
       gSyntaxErrorMessage_value} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   Key words table 'xmlDelimitorsList'                     *
//                                                                           *
//---------------------------------------------------------------------------*

const sint16 xml_parsing_lexique::xml_parsing_lexique_table_size_xmlDelimitorsList = 7 ;

const C_lexique_table_entry xml_parsing_lexique::xml_parsing_lexique_table_for_xmlDelimitorsList [7] = {
  C_lexique_table_entry ("<", 1, xml_parsing_lexique_1__3C),
  C_lexique_table_entry ("=", 1, xml_parsing_lexique_1__3D),
  C_lexique_table_entry (">", 1, xml_parsing_lexique_1__3E),
  C_lexique_table_entry ("/>", 2, xml_parsing_lexique_1__2F_3E),
  C_lexique_table_entry ("</", 2, xml_parsing_lexique_1__3C_2F),
  C_lexique_table_entry ("<\?", 2, xml_parsing_lexique_1__3C_3F),
  C_lexique_table_entry ("\?>", 2, xml_parsing_lexique_1__3F_3E)
} ;

sint16 xml_parsing_lexique::search_into_xmlDelimitorsList (const C_String & inSearchedString) {
  return searchInList (inSearchedString, xml_parsing_lexique_table_for_xmlDelimitorsList, xml_parsing_lexique_table_size_xmlDelimitorsList) ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String xml_parsing_lexique::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) inTokenPtr ;
  C_String s ;
  if (_p == NULL) {
    s << "$$" ;
  }else{
    switch (_p->_mTokenCode) {
    case  xml_parsing_lexique_1_:
      s << "$$" ;
      break ;
    case  xml_parsing_lexique_1_comment:
      s << '$'
        << "comment"
        << '$' ;
    s << ' ' ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    case  xml_parsing_lexique_1__3C:
      s << '$'
        << "<"
        << '$' ;
      break;
    case  xml_parsing_lexique_1__3C_3F:
      s << '$'
        << "<\?"
        << '$' ;
      break;
    case  xml_parsing_lexique_1__3E:
      s << '$'
        << ">"
        << '$' ;
      break;
    case  xml_parsing_lexique_1__3F_3E:
      s << '$'
        << "\?>"
        << '$' ;
      break;
    case  xml_parsing_lexique_1__2F_3E:
      s << '$'
        << "/>"
        << '$' ;
      break;
    case  xml_parsing_lexique_1__3C_2F:
      s << '$'
        << "</"
        << '$' ;
      break;
    case  xml_parsing_lexique_1__3D:
      s << '$'
        << "="
        << '$' ;
      break;
    case  xml_parsing_lexique_1_name:
      s << '$'
        << "name"
        << '$' ;
    s << ' ' ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    case  xml_parsing_lexique_1_value:
      s << '$'
        << "value"
        << '$' ;
    s << ' ' ;
    s.appendCLiteralStringConstant (_p->tokenString) ;
      break;
    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            parseLexicalToken                              *
//                                                                           *
//---------------------------------------------------------------------------*

bool xml_parsing_lexique::
parseLexicalToken (void) {
  cTokenFor_xml_parsing_lexique _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while ((_token._mTokenCode < 0) && (mCurrentChar != '\0')) {
    if ((_mMatchedTemplateDelimiterIndex >= 0)
     && (kTemplateDefinitionArray [_mMatchedTemplateDelimiterIndex].mEndStringLength > 0)
     && (mCurrentChar != '\0')) {
      const bool foundEndDelimitor = testForInputString (kTemplateDefinitionArray [_mMatchedTemplateDelimiterIndex].mEndString,
                                                         kTemplateDefinitionArray [_mMatchedTemplateDelimiterIndex].mEndStringLength,
                                                         true) ;
      if (foundEndDelimitor) {
        _mMatchedTemplateDelimiterIndex = -1 ;
      }
    }
    while ((_mMatchedTemplateDelimiterIndex < 0) && (mCurrentChar != '\0')) {
      sint32 _replacementIndex = 0 ;
      while (_replacementIndex >= 0) {
       _replacementIndex = findTemplateDelimiterIndex (kTemplateReplacementArray, 0) ;
         if (_replacementIndex >= 0) {
           _token._mTemplateStringBeforeToken << kTemplateReplacementArray [_replacementIndex].mEndString ;
        }
      }
      _mMatchedTemplateDelimiterIndex = findTemplateDelimiterIndex (kTemplateDefinitionArray, 1) ;
      if (_mMatchedTemplateDelimiterIndex < 0) {
        _token._mTemplateStringBeforeToken << mCurrentChar ;
        advance () ;
      }
    }
    if ((_mMatchedTemplateDelimiterIndex >= 0) && (mCurrentChar != '\0')) {
      _token.tokenString.clear () ;
      _mTokenFirstLocation = _mCurrentLocation ;
      try{
        if (testForInputString ("<!--", 4, true)) {
          do {
            if (testForInputString ("&amp;", 5, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '&') ;
            }else if (testForInputString ("&lt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '<') ;
            }else if (testForInputString ("&gt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '>') ;
            }else if (testForInputString ("&quot;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\"') ;
            }else if (testForInputString ("&apos;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\'') ;
            }else if (testForInputChar ('\x1', ',') ||
                testForInputChar ('.', '\xFF')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
            }else if (testForInputString ("-->", 3, true)) {
              loop_ = false ;
            }else if (testForInputChar ('-')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '-') ;
            }else if (testForInputChar ('\0')) {
              lexicalError (gErrorMessage_0 COMMA_LINE_AND_SOURCE_FILE) ;
            }else{
              loop_ = false ;
            }
          }while (loop_) ;
          loop_ = true ;
          _token._mTokenCode = xml_parsing_lexique_1_comment ;
          _enterToken (_token) ;
        }else if (testForInputString ("<\?", 2, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3C_3F ;
          _enterToken (_token) ;
        }else if (testForInputString ("\?>", 2, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3F_3E ;
          _enterToken (_token) ;
        }else if (testForInputString ("/>", 2, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__2F_3E ;
          _enterToken (_token) ;
        }else if (testForInputString ("</", 2, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3C_2F ;
          _enterToken (_token) ;
        }else if (testForInputString ("<", 1, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3C ;
          _enterToken (_token) ;
        }else if (testForInputString (">", 1, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3E ;
          _enterToken (_token) ;
        }else if (testForInputString ("=", 1, true)) {
          _token._mTokenCode = xml_parsing_lexique_1__3D ;
          _enterToken (_token) ;
        }else if (testForInputChar ('a', 'z') ||
            testForInputChar ('A', 'Z')) {
          do {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
            if (testForInputChar ('a', 'z') ||
                testForInputChar ('A', 'Z') ||
                testForInputChar ('_') ||
                testForInputChar ('0', '9')) {
            }else{
              loop_ = false ;
            }
          }while (loop_) ;
          loop_ = true ;
          _token._mTokenCode = xml_parsing_lexique_1_name ;
          _enterToken (_token) ;
        }else if (testForInputChar ('\"')) {
          do {
            if (testForInputString ("&amp;", 5, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '&') ;
            }else if (testForInputString ("&lt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '<') ;
            }else if (testForInputString ("&gt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '>') ;
            }else if (testForInputString ("&quot;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\"') ;
            }else if (testForInputString ("&apos;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\'') ;
            }else if (testForInputChar (' ') ||
                testForInputChar ('!') ||
                testForInputChar ('#', '\xFF')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
            }else{
              loop_ = false ;
            }
          }while (loop_) ;
          loop_ = true ;
          if (testForInputChar ('\"')) {
            _token._mTokenCode = xml_parsing_lexique_1_value ;
            _enterToken (_token) ;
          }else{
            lexicalError (gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE) ;
          }
        }else if (testForInputChar ('\'')) {
          do {
            if (testForInputString ("&amp;", 5, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '&') ;
            }else if (testForInputString ("&lt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '<') ;
            }else if (testForInputString ("&gt;", 4, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '>') ;
            }else if (testForInputString ("&quot;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\"') ;
            }else if (testForInputString ("&apos;", 6, true)) {
              scanner_action_enterCharacterIntoString (_token.tokenString, '\'') ;
            }else if (testForInputChar (' ', '&') ||
                testForInputChar ('(', '\xFF')) {
              scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
            }else{
              loop_ = false ;
            }
          }while (loop_) ;
          loop_ = true ;
          if (testForInputChar ('\'')) {
            _token._mTokenCode = xml_parsing_lexique_1_value ;
            _enterToken (_token) ;
          }else{
            lexicalError (gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE) ;
          }
        }else if (testForInputChar ('\x1', ' ')) {
        }else if (testForInputChar ('\0')) { // End of source text ? 
          _token._mTokenCode = xml_parsing_lexique_1_ ; // Empty string code
        }else{ // Unknown input character
          unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
        }
      }catch (const C_lexicalErrorException &) {
        _token._mTokenCode = -1 ; // No token
        advance () ; // ... go throught unknown character
      }
    }
    if (kEndOfScriptInTemplateArray [_token._mTokenCode]) {
      _mMatchedTemplateDelimiterIndex = -1 ;
    }
  }
  if ((mCurrentChar == '\0') && (_token._mTemplateStringBeforeToken.length () > 0)) {
    _token._mTokenCode = 0 ;
    _enterToken (_token) ;
  }
  return _token._mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   parseLexicalTokenForLexicalColoring                     *
//                                                                           *
//---------------------------------------------------------------------------*

sint16 xml_parsing_lexique::
parseLexicalTokenForLexicalColoring (void) {
  cTokenFor_xml_parsing_lexique _token ;
  bool loop_ = true ;
  _token._mTokenCode = -1 ;
  while (_token._mTokenCode < 0) {
    _token.tokenString.clear () ;
    _mTokenFirstLocation = _mCurrentLocation ;
    try{
      if (testForInputString ("<!--", 4, true)) {
        do {
          if (testForInputString ("&amp;", 5, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '&') ;
          }else if (testForInputString ("&lt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '<') ;
          }else if (testForInputString ("&gt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '>') ;
          }else if (testForInputString ("&quot;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '\"') ;
          }else if (testForInputString ("&apos;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '\'') ;
          }else if (testForInputChar ('\x1', ',') ||
              testForInputChar ('.', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          }else if (testForInputString ("-->", 3, true)) {
            loop_ = false ;
          }else if (testForInputChar ('-')) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '-') ;
          }else if (testForInputChar ('\0')) {
            lexicalError (gErrorMessage_0 COMMA_LINE_AND_SOURCE_FILE) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = xml_parsing_lexique_1_comment ;
      }else if (testForInputString ("<\?", 2, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3C_3F ;
      }else if (testForInputString ("\?>", 2, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3F_3E ;
      }else if (testForInputString ("/>", 2, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__2F_3E ;
      }else if (testForInputString ("</", 2, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3C_2F ;
      }else if (testForInputString ("<", 1, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3C ;
      }else if (testForInputString (">", 1, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3E ;
      }else if (testForInputString ("=", 1, true)) {
        _token._mTokenCode = xml_parsing_lexique_1__3D ;
      }else if (testForInputChar ('a', 'z') ||
          testForInputChar ('A', 'Z')) {
        do {
          scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          if (testForInputChar ('a', 'z') ||
              testForInputChar ('A', 'Z') ||
              testForInputChar ('_') ||
              testForInputChar ('0', '9')) {
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        _token._mTokenCode = xml_parsing_lexique_1_name ;
      }else if (testForInputChar ('\"')) {
        do {
          if (testForInputString ("&amp;", 5, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '&') ;
          }else if (testForInputString ("&lt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '<') ;
          }else if (testForInputString ("&gt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '>') ;
          }else if (testForInputString ("&quot;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '\"') ;
          }else if (testForInputString ("&apos;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '\'') ;
          }else if (testForInputChar (' ') ||
              testForInputChar ('!') ||
              testForInputChar ('#', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\"')) {
          _token._mTokenCode = xml_parsing_lexique_1_value ;
        }else{
          lexicalError (gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputChar ('\'')) {
        do {
          if (testForInputString ("&amp;", 5, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '&') ;
          }else if (testForInputString ("&lt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '<') ;
          }else if (testForInputString ("&gt;", 4, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '>') ;
          }else if (testForInputString ("&quot;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '\"') ;
          }else if (testForInputString ("&apos;", 6, true)) {
            scanner_action_enterCharacterIntoString (_token.tokenString, '\'') ;
          }else if (testForInputChar (' ', '&') ||
              testForInputChar ('(', '\xFF')) {
            scanner_action_enterCharacterIntoString (_token.tokenString, previousChar ()) ;
          }else{
            loop_ = false ;
          }
        }while (loop_) ;
        loop_ = true ;
        if (testForInputChar ('\'')) {
          _token._mTokenCode = xml_parsing_lexique_1_value ;
        }else{
          lexicalError (gErrorMessage_1 COMMA_LINE_AND_SOURCE_FILE) ;
        }
      }else if (testForInputChar ('\x1', ' ')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = xml_parsing_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      throw ;
    }
  }
  return _token._mTokenCode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 xml_parsing_lexique::getStylesCount (void) {
  return 6 ;
}

//---------------------------------------------------------------------------*

const char * xml_parsing_lexique::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [7] = {"Default style", "Delimiter:", "Name:", "Attribute value:", "Comment:", "Text:", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

const char * xml_parsing_lexique::getStyleIdentifier (const sint32 inIndex) {
  const char * kStylesArray [7] = {"", "delimitersStyle", "nameStyle", "attributeValue", "commentStyle", "textStyle", NULL} ;
  return (inIndex < 6) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 xml_parsing_lexique::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [11] = {0,
    4 /* xml_parsing_lexique_1_comment */,
    1 /* xml_parsing_lexique_1__3C */,
    1 /* xml_parsing_lexique_1__3C_3F */,
    1 /* xml_parsing_lexique_1__3E */,
    1 /* xml_parsing_lexique_1__3F_3E */,
    1 /* xml_parsing_lexique_1__2F_3E */,
    1 /* xml_parsing_lexique_1__3C_2F */,
    1 /* xml_parsing_lexique_1__3D */,
    2 /* xml_parsing_lexique_1_name */,
    3 /* xml_parsing_lexique_1_value */
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*

void xml_parsing_lexique::_enterToken (const cTokenFor_xml_parsing_lexique & inToken) {
  cTokenFor_xml_parsing_lexique * _p = NULL ;
  macroMyNew (_p, cTokenFor_xml_parsing_lexique ()) ;
  _p->_mTokenCode = inToken._mTokenCode ;
  _p->_mFirstLocation = _mTokenFirstLocation ;
  _p->_mLastLocation  = _mTokenLastLocation ;
  _p->_mTemplateStringBeforeToken  = inToken._mTemplateStringBeforeToken ;
  _p->tokenString = inToken.tokenString ;
  _enterTokenFromPointer (_p) ;
}

//---------------------------------------------------------------------------*

void xml_parsing_lexique::
_assignFromAttribute_tokenString (GGS_lstring & outValue) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) mCurrentTokenPtr ;
  outValue = GGS_lstring (* this, _p->tokenString) ;
}

//---------------------------------------------------------------------------*

C_String xml_parsing_lexique::
_attributeValue_tokenString (void) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) mCurrentTokenPtr ;
  return _p->tokenString ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

