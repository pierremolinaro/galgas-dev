//---------------------------------------------------------------------------*
//                                                                           *
//                      File 'xml_parsing_lexique.cpp'                       *
//                 Generated by version GALGAS_BETA_VERSION                  *
//                      april 26th, 2009, at 11h4'52"                        *
//                                                                           *
//---------------------------------------------------------------------------*

//--- START OF USER ZONE 1


//--- END OF USER ZONE 1

//---------------------------------------------------------------------------*

#include "version_libpm.h"
#if LIBPM_VERSION != THE_LIBPM_VERSION
  #error "This file has been compiled with a version of GALGAS different than the version of libpm"
#endif

//---------------------------------------------------------------------------*

#include <ctype.h>
#include <string.h>

#include "utilities/MF_MemoryControl.h"
#include "xml_parsing_lexique.h"

#ifndef DO_NOT_GENERATE_CHECKINGS
  #define LINE_AND_SOURCE_FILE sourceText ()->sourceFileName ().cString (), lineNumber ()
  #define COMMA_LINE_AND_SOURCE_FILE , LINE_AND_SOURCE_FILE
#else
  #define LINE_AND_SOURCE_FILE
  #define COMMA_LINE_AND_SOURCE_FILE
#endif

//---------------------------------------------------------------------------*
//                                                                           *
//                               Constructors                                *
//                                                                           *
//---------------------------------------------------------------------------*

cTokenFor_xml_parsing_lexique::cTokenFor_xml_parsing_lexique (void) {
}

//---------------------------------------------------------------------------*

xml_parsing_lexique::
xml_parsing_lexique (C_Compiler * inCallerCompiler,
                const C_String & inDependencyFileExtension,
                const C_String & inDependencyFilePath,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceFileName
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inDependencyFileExtension, inDependencyFilePath, inParametersPtr, inSourceFileName COMMA_THERE) {
}

//---------------------------------------------------------------------------*

xml_parsing_lexique::
xml_parsing_lexique (C_Compiler * inCallerCompiler,
                C_galgas_io * inParametersPtr,
                const C_String & inSourceString,
                const C_String & inStringForError
                COMMA_LOCATION_ARGS) :
C_Lexique (inCallerCompiler, inParametersPtr, inSourceString, inStringForError COMMA_THERE) {
}

//---------------------------------------------------------------------------*
//                                                                           *
//                appendTerminalMessageToSyntaxErrorMessage                  *
//                                                                           *
//---------------------------------------------------------------------------*

void xml_parsing_lexique::
appendTerminalMessageToSyntaxErrorMessage (const sint16 inTerminalIndex,
                                           C_String & outSyntaxErrorMessage) {
  static const char * syntaxErrorMessageArray [1] = {"end of source"} ;
  outSyntaxErrorMessage << syntaxErrorMessageArray [inTerminalIndex] ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                          getCurrentTokenString                            *
//                                                                           *
//---------------------------------------------------------------------------*

C_String xml_parsing_lexique::
getCurrentTokenString (const cToken * inTokenPtr) const {
  cTokenFor_xml_parsing_lexique * _p = (cTokenFor_xml_parsing_lexique *) inTokenPtr ;
  C_String s ;
  if (_p == NULL) {
    s << "$$" ;
  }else{
    switch (_p->_mTokenCode) {
    case  xml_parsing_lexique_1_:
      s << "$$" ;
      break ;
    default:
      break ;
    }
  }
  return s ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            parseLexicalToken                              *
//                                                                           *
//---------------------------------------------------------------------------*

bool xml_parsing_lexique::
parseLexicalToken (void) {
  cTokenFor_xml_parsing_lexique _token ;
  _token._mTokenCode = -1 ;
  while ((_token._mTokenCode < 0) && (mCurrentChar != '\0')) {
    _mTokenFirstLocation = _mCurrentLocation ;
    try{
      if (testForInputChar ('\x1', '\xFF')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = xml_parsing_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
    }
  }
  if ((mCurrentChar == '\0') && (_token._mTemplateStringBeforeToken.length () > 0)) {
    _token._mTokenCode = 0 ;
    _enterToken (_token) ;
  }
  return _token._mTokenCode > 0 ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                   parseLexicalTokenForLexicalColoring                     *
//                                                                           *
//---------------------------------------------------------------------------*

sint16 xml_parsing_lexique::
parseLexicalTokenForLexicalColoring (void) {
  cTokenFor_xml_parsing_lexique _token ;
  _token._mTokenCode = -1 ;
  while (_token._mTokenCode < 0) {
    _mTokenFirstLocation = _mCurrentLocation ;
    try{
      if (testForInputChar ('\x1', '\xFF')) {
      }else if (testForInputChar ('\0')) { // End of source text ? 
        _token._mTokenCode = xml_parsing_lexique_1_ ; // Empty string code
      }else{ // Unknown input character
        unknownCharacterLexicalError (LINE_AND_SOURCE_FILE) ;
      }
    }catch (const C_lexicalErrorException &) {
      _token._mTokenCode = -1 ; // No token
      advance () ; // ... go throught unknown character
      throw ;
    }
  }
  return _token._mTokenCode ;
}

//---------------------------------------------------------------------------*
//                                                                           *
//                            Styles definition                              *
//                                                                           *
//---------------------------------------------------------------------------*

sint32 xml_parsing_lexique::getStylesCount (void) {
  return 1 ;
}

//---------------------------------------------------------------------------*

const char * xml_parsing_lexique::getStyleName (const sint32 inIndex) {
  const char * kStylesArray [2] = {"Default style", NULL} ;
  return (inIndex < 1) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

const char * xml_parsing_lexique::getStyleIdentifier (const sint32 inIndex) {
  const char * kStylesArray [2] = {"", NULL} ;
  return (inIndex < 1) ? kStylesArray [inIndex] : NULL ;
} ;

//---------------------------------------------------------------------------*

uint8 xml_parsing_lexique::
terminalStyleIndex (const sint32 inTerminal) {
  static const uint8 kTerminalSymbolStyles [1] = {0
  } ;
  return kTerminalSymbolStyles [inTerminal] ;
}

//---------------------------------------------------------------------------*

void xml_parsing_lexique::_enterToken (const cTokenFor_xml_parsing_lexique & inToken) {
  cTokenFor_xml_parsing_lexique * _p = NULL ;
  macroMyNew (_p, cTokenFor_xml_parsing_lexique ()) ;
  _p->_mTokenCode = inToken._mTokenCode ;
  _p->_mFirstLocation = _mTokenFirstLocation ;
  _p->_mLastLocation  = _mTokenLastLocation ;
  _p->_mTemplateStringBeforeToken  = inToken._mTemplateStringBeforeToken ;
  _enterTokenFromPointer (_p) ;
}

//---------------------------------------------------------------------------*

//--- START OF USER ZONE 2


//--- END OF USER ZONE 2

//---------------------------------------------------------------------------*

