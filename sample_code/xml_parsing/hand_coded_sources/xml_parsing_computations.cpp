//---------------------------------------------------------------------------*
//                                                                           *
//                             xml_parsing Project                           *
//                   Generated by GALGAS Project Creation                    *
//                      march 29th, 2008, at 21h55'21"                       *
//                                                                           *
//---------------------------------------------------------------------------*

#include "xml_parsing_semantics.h"
#include "utilities/MF_MemoryControl.h"
#include "tiny_xml/tinyxml.h"

//---------------------------------------------------------------------------*

const uint32 kXMLPrintOnParsing = 1 << 0 ;
const uint32 kXMLIncludeComment = 1 << 1 ;

//---------------------------------------------------------------------------*

static void handleNode (C_Compiler & inCompiler,
                        AC_sourceText * inSourceText,
                        const TiXmlNode * inNode,
                        GGS_xmlNodeList & ioNodeList,
                        const sint32 inIndendation,
                        const uint32 inFlags) {
  const bool print = (inFlags & kXMLPrintOnParsing) != 0 ;
  if (print) {
    for (sint32 i=0 ; i<inIndendation ; i++) {
      printf ( " ") ;
    }
  }

  GGS_xmlNodeList nodeList = GGS_xmlNodeList::constructor_emptyList () ;
  GGS_xmlAttributeMap attributeMap = GGS_xmlAttributeMap::constructor_emptyMap (inCompiler COMMA_HERE) ;
  GGS_lstring name ;
  GGS_xmlNodeType type ;

  switch (inNode->Type ()) {
  case TiXmlNode::ELEMENT:
    { type = GGS_xmlNodeType::constructor_element (inCompiler COMMA_HERE) ;
      name = GGS_lstring (inSourceText, inNode->mLocation.row, inNode->mLocation.col, inNode->Value ()) ;
      if (print) {
        printf ("ELEMENT '%s' %u:%u {", inNode->Value (), inNode->mLocation.row, inNode->mLocation.col) ;
      }
      const TiXmlElement * element = inNode->ToElement () ;
      const TiXmlAttribute * attribute = element->FirstAttribute() ;
      while (NULL != attribute) {
        const GGS_lstring key (inSourceText, attribute->mNameLocation.row, attribute->mNameLocation.col, attribute->Name ()) ;
        const GGS_lstring value (inSourceText, attribute->mValueLocation.row, attribute->mValueLocation.col, attribute->Value ()) ;
        attributeMap.modifier_insertKey (inCompiler, key, value COMMA_HERE) ;
        if (print) {
          printf ("'%s' %u:%u ->'%s' %u:%u",
                  attribute->Name (), attribute->mNameLocation.row, attribute->mNameLocation.col,
                  attribute->Value (), attribute->mValueLocation.row, attribute->mValueLocation.col) ;
        }
        attribute = attribute->Next () ;
        if (print && (NULL != attribute)) {
          printf (", ") ;
        }
      }
      if (print) {
        printf ("}\n") ;  
      }
      const TiXmlNode * child = element->FirstChild ()  ;
      while (NULL != child) {
        handleNode (inCompiler, inSourceText, child, nodeList, inIndendation + 1, inFlags) ;
        child = child->NextSibling () ;
      }
    } break ;
  case TiXmlNode::DOCUMENT :
    if (print) {
      printf ("DOCUMENT (discarded)\n") ;
    }
    break ;
  case TiXmlNode::DECLARATION:
    if (print) {
      const TiXmlDeclaration * declaration = inNode->ToDeclaration () ;
      printf ("DECLARATION version '%s', encoding '%s', standalone '%s'\n",
              declaration->Version (),
              declaration->Encoding (),
              declaration->Standalone ()) ;
    }
    break ;
  case TiXmlNode::COMMENT :
    if ((inFlags & kXMLIncludeComment) != 0) {
      type = GGS_xmlNodeType::constructor_comment (inCompiler COMMA_HERE) ;
      name = GGS_lstring (inSourceText, inNode->mLocation.row, inNode->mLocation.col, inNode->Value ()) ;
    }
    if (print) {
      printf ("COMMENT '%s' %u:%u%s\n",
              inNode->Value (), inNode->mLocation.row, inNode->mLocation.col,
              ((inFlags & kXMLIncludeComment) != 0) ? "" : " (discarded)") ;
    }
    break ;
  case TiXmlNode::TEXT:
    type = GGS_xmlNodeType::constructor_text (inCompiler COMMA_HERE) ;
    name = GGS_lstring (inSourceText, inNode->mLocation.row, inNode->mLocation.col, inNode->Value ()) ;
    if (print) {
      printf ("TEXT '%s' %u:%u\n", inNode->Value (), inNode->mLocation.row, inNode->mLocation.col) ;
    }
    break ;
  default: 
    if (print) {
      printf ("UNKNOWN NODE (discarded)\n") ;
    }
    break ;
  }
  if (type._isBuilt ()) {
    GGS_xmlNode node = GGS_xmlNode::constructor_new (inCompiler,
                                                     type,
                                                     name,
                                                     attributeMap,
                                                     nodeList
                                                     COMMA_HERE) ;
    ioNodeList._addAssign_operation (node) ;
  }
}

//---------------------------------------------------------------------------*

void routine_temporaryParseXML (C_Compiler & inCompiler,
                                const GGS_lstring inSourceFileName,
                                GGS_xmlNodeList & outRootNodeList
                                COMMA_UNUSED_LOCATION_ARGS) {
  const uint32 flags = 0 ;
  const bool print = (flags & kXMLPrintOnParsing) != 0 ;
  const C_String sourceFileContents = C_String::stringWithContentOfFile (inSourceFileName) ;
  AC_sourceText * sourceText = NULL ;
  macroMyNew (sourceText, C_sourceTextInString (sourceFileContents, inSourceFileName, false COMMA_HERE)) ;
  outRootNodeList._drop () ;
  if (inSourceFileName._isBuilt ()) {
    TiXmlDocument doc (inSourceFileName.cString ()) ;
    const bool ok = doc.LoadFile () ;
    if (ok) {
      outRootNodeList = GGS_xmlNodeList::constructor_emptyList () ;
      const TiXmlNode * node = doc.FirstChild () ;
      while (NULL != node) {
        handleNode (inCompiler, sourceText, node, outRootNodeList, 0, flags) ;
        node = node->NextSibling () ;
      }
      if (print) {
        printf ("***********\n") ;
      }
    }else{
      printf ("XML error %d\n", doc.ErrorId ()) ;
    }
  }
  macroDetachPointer (sourceText, AC_sourceText) ;
}

//---------------------------------------------------------------------------*

