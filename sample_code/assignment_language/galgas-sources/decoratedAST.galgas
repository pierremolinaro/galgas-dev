

abstract refclass @expressionForGeneration {
}

refclass @varInExpressionForGeneration : @expressionForGeneration {
  public var @string mVarCppName
}

refclass @cstInExpressionForGeneration : @expressionForGeneration {
  public var @uint mConstantValue
}

enum @diadicOperation {
 case addition  case multiplication
}

refclass @diadicForGeneration : @expressionForGeneration {
  public var @expressionForGeneration mLeftExpression
  public var @diadicOperation mOperation
  public var @expressionForGeneration mRightExpression
}

abstract refclass @instructionForGeneration {
}

list @instructionListForGeneration {
  public var @instructionForGeneration mInstruction
}

refclass @assignmentForGeneration : @instructionForGeneration {
  public var @string mTargetVarCppName
  public var @expressionForGeneration mSourceExpression
}

refclass @varDeclarationForGeneration : @instructionForGeneration {
  public var @string mVarCppName
}

refclass @printVariableForGeneration : @instructionForGeneration {
  public var @string mSourceName
  public var @string mVarCppName
}

#---------------------------------------------------------------------------*

shared map @variableMap {
  public var @string mCppName

#--- Variable states
  state declaredState warning "the '%K' variable is unused" {
    readAccess      -> declaredState error "this variable has no value, it cannot be read"
    writeAccess     -> assignedState
  }

  state assignedState warning "the '%K' variable value has not been read" {
    readAccess      -> assignedAndReadState
    writeAccess     -> assignedState warning "the previous value has not been read"
  }

  state assignedAndReadState {
    readAccess      -> assignedAndReadState
    writeAccess     -> assignedState
  }

  insert declareVariable state declaredState error message "redefinition of '%K' variable"

  search searchForReadAccess do readAccess error message "the '%K' variable is not declared"
  search searchForWriteAccess do writeAccess error message "the '%K' variable is not declared"

}

#---------------------------------------------------------------------------*

abstract method @instructionAST semanticAnalysis
  ?!@variableMap ioVariableMap
  ?!@instructionListForGeneration ioInstructionListForGeneration

#---------------------------------------------------------------------------*

override method @varDeclarationAST semanticAnalysis
  ?!@variableMap ioVariableMap
  ?!@instructionListForGeneration ioInstructionListForGeneration {
  let @string cppName = "var_" + [self.mVarName identifierRepresentation] + "_" + [self.mVarName.location locationIndex]
  [!?ioVariableMap declareVariable !self.mVarName !cppName]
  ioInstructionListForGeneration += !@varDeclarationForGeneration.new { !cppName}
}

#---------------------------------------------------------------------------*

override method @printVariableAST semanticAnalysis
  ?!@variableMap ioVariableMap
  ?!@instructionListForGeneration ioInstructionListForGeneration {
  [!?ioVariableMap searchForReadAccess !self.mVarName ?let cppName]
  ioInstructionListForGeneration += !@printVariableForGeneration.new { !self.mVarName.string !cppName}
}

#---------------------------------------------------------------------------*

override method @assignmentAST semanticAnalysis
  ?!@variableMap ioVariableMap
  ?!@instructionListForGeneration ioInstructionListForGeneration {
#--- Expression
  [self.mSourceExpression expSemanticAnalysis !?ioVariableMap ?let expression]
#--- Target variable
  [!?ioVariableMap searchForWriteAccess !self.mTargetVarName ?let cppName]
#---
  ioInstructionListForGeneration += !@assignmentForGeneration.new { !cppName !expression}
}

#---------------------------------------------------------------------------*

abstract method @expressionAST expSemanticAnalysis
  ?!@variableMap ioVariableMap
  !@expressionForGeneration outExpression

#---------------------------------------------------------------------------*

override method @varInExpressionAST expSemanticAnalysis
  ?!@variableMap ioVariableMap
  !@expressionForGeneration outExpression {
  [!?ioVariableMap searchForReadAccess !self.mVarName ?let cppName]
  outExpression = @varInExpressionForGeneration.new { !cppName}
}

#---------------------------------------------------------------------------*

override method @cstInExpressionAST expSemanticAnalysis
  ?!@variableMap unused ioVariableMap
  !@expressionForGeneration outExpression {
  outExpression = @cstInExpressionForGeneration.new { !self.mConstant.uint}
}

#---------------------------------------------------------------------------*

override method @additionAST expSemanticAnalysis
  ?!@variableMap ioVariableMap
  !@expressionForGeneration outExpression {
#--- Left expression
  [self.mLeftExpression expSemanticAnalysis !?ioVariableMap ?let leftExpression]
#--- Right expression
  [self.mRightExpression expSemanticAnalysis !?ioVariableMap ?let rightExpression]
#---
  outExpression = @diadicForGeneration.new {
    !leftExpression
    !@diadicOperation. addition
    !rightExpression}
}

#---------------------------------------------------------------------------*

override method @multiplicationAST expSemanticAnalysis
  ?!@variableMap ioVariableMap
  !@expressionForGeneration outExpression {
#--- Left expression
  [self.mLeftExpression expSemanticAnalysis !?ioVariableMap ?let leftExpression]
#--- Right expression
  [self.mRightExpression expSemanticAnalysis !?ioVariableMap ?let rightExpression]
#---
  outExpression = @diadicForGeneration.new {
    !leftExpression
    !@diadicOperation. multiplication
    !rightExpression}
}

#---------------------------------------------------------------------------*

