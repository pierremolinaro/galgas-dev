syntax SLR_expression_syntax :
import lexique SLR_expression_lexique in "SLR_expression_lexique.gLexique" ;
import option SLR_expression_options in "SLR_expression_options.gOption" ;
import semantics SLR_expression_semantics in "SLR_expression_semantics.ggs" ;

nonterminal <StartSymbol> ;

nonterminal <Expression>
  !@cExpression outExpressionTree
  !@uint outValue
;
nonterminal <Terme>
  !@cExpression outExpressionTree
  !@uint outValue
;

nonterminal <Facteur>
  !@cExpression outExpressionTree
  !@uint outValue
;

nonterminal <Constant>
  !@cExpression outExpressionTree
  !@uint outValue
;

rule <StartSymbol>:
  @cExpression expressionTree;
  @uint value ;
  <Expression> ?expressionTree ?value ;
  log value ;
end rule;
  
rule <Constant>
  !@cExpression outExpressionTree
  !@uint outValue
:
  @luint cst ;
  $number$ ? cst;
  outExpressionTree := [@cConst new !cst] ;
  outValue := [cst uint] ;
end rule;

rule <Expression>
  !@cExpression outExpressionTree
  !@uint outValue
:
  select
    <Terme> ?outExpressionTree ?outValue ;
  or 
    <Expression> ?outExpressionTree ?outValue ;
    $+$ ;
    @cExpression rightOperand ;
    @uint v ;
    <Terme> ?rightOperand ?v ;
    outExpressionTree := [@cAdd new ! outExpressionTree !rightOperand] ;
    outValue := outValue + v ;
  end select ;
end rule;

rule <Terme>
  !@cExpression outExpressionTree
  !@uint outValue
:
  select
    <Facteur> ?outExpressionTree ?outValue ;
  or 
    <Terme> ?outExpressionTree ?outValue ;
    $*$ ;
    @cExpression rightOperand ;
    @uint v ;
    <Facteur> ?rightOperand ?v ;
    outExpressionTree := [@cAdd new ! outExpressionTree !rightOperand] ;
    outValue := outValue * v ;
  end select ;
end rule;

rule <Facteur>
  !@cExpression outExpressionTree
  !@uint outValue
:
  select
    $($ ;
    <Expression> ?outExpressionTree ?outValue ;
    $)$ ;
  or
    <Constant> ?outExpressionTree ?outValue ;
  end select ;
end rule ;

end syntax ;
