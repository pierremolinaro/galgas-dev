syntax LL1_expression_syntax ("LL1_expression_lexique.gLexique") feature translate :

import "LL1_expression_options.gOption" ;
import "LL1_expression_semantics.gSemantics" ;

rule <StartSymbol>:
  <Expression> ??@cExpression expressionTree ??@uint value ;
  log expressionTree, value ;
end rule;
  
rule <Constant>
  !@cExpression outExpressionTree
  !@uint outValue
:
  $number$ ??@luint cst ;
  send " " ;
  outExpressionTree := [@cConst new !cst] ;
  outValue := [cst uint] ;
end rule;
  
rule <Expression>
  !@cExpression outExpressionTree
  !@uint outValue
:
  <Terme> ?outExpressionTree ?outValue ;
  repeat
  while 
    $+$ :> ?@string sep ?@string token ;
    send sep ;
    <Terme> ??@cExpression rightOperand ??@uint v ;
    send token ;
    outExpressionTree := [@cAdd new ! outExpressionTree !rightOperand] ;
    outValue := outValue + v ;
  end repeat ;
end rule;
  
rule <Terme>
  !@cExpression outExpressionTree
  !@uint outValue
:
  <Facteur> ?outExpressionTree ?outValue ;
  repeat
  while 
    $*$ :> ?@string sep ?@string token ;
    send sep ;
    <Facteur> ??@cExpression rightOperand ??@uint v ;
    send token ;
    outExpressionTree := [@cMult new ! outExpressionTree !rightOperand] ;
    outValue := outValue * v ;
  end repeat ;
end rule;

rule <Facteur>
  !@cExpression outExpressionTree
  !@uint outValue
:
  select
    $($ :> ?* ?* ;
    <Expression> ?outExpressionTree ?outValue ;
    $)$ :> ?* ?* ;
  or
    <Constant> ?outExpressionTree ?outValue ;
  end select ;
end rule ;

end syntax ;
