#---------------------------------------------------------------------------*
#                                                                           *
#  GOIL template expression parser definition                               *
#                                                                           *
#  Copyright (C) 2009, ..., 2009 Pierre Molinaro.                           *
#                                                                           *
#  e-mail : molinaro@irccyn.ec-nantes.fr                                    *
#                                                                           *
#  This program is free software; you can redistribute it and/or modify it  *
#  under the terms of the GNU General Public License as published by the    *
#  Free Software Foundation.                                                *
#                                                                           *
#  This program is distributed in the hope it will be useful, but WITHOUT   *
#  ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or    *
#  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for *
#   more details.                                                           *
#                                                                           *
#---------------------------------------------------------------------------*

syntax template_expression_parser ("template_scanner.gLexique"):

import "template_invocation.gSemantics";
import "template_semantics.gSemantics";
import "systemConfig.gSemantics";

#------------------------------------------------------------------------------*
#                                                                              *
#          Rules prototypes                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

nonterminal <expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <relation_term>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <relation_factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <simple_expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <term>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
;

nonterminal <variable>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@TvarPath path
;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    &    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchAndOperatorForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType;
  when unsignedType :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " & " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           : outResultType;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    |    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchOrOperatorForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType;
  when unsignedType :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " | " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           : outResultType;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   M A T C H    ^    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine matchXorOperatorForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType :: boolType :
    outResultType := inLeftExpressionType;
  when unsignedType :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "operand type error : (" . [inLeftExpressionType messageGoilTemplateType] .
           " | " . [inRightExpressionType messageGoilTemplateType] . ") is not valid" 
           : outResultType;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    N O T    O P E R A T O R                                   *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkNotOperatorForTemplate
  ??@Ttype inOperandType
  !@Ttype outResultType
:
  if inOperandType != [@Ttype boolType] then
    error here : "the 'not' operator is not defined for an "
    . [inOperandType messageGoilTemplateType] . " type";
  end if;
  outResultType := inOperandType;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ~    O P E R A T O R                                       *
#                                                                           *
#---------------------------------------------------------------------------*

routine checkBitComplementOperatorForTemplate
  ??@Ttype inOperandType
  !@Ttype outResultType
:
  outResultType := inOperandType;
  if inOperandType != [@Ttype unsignedType] then
    error here : "the ~ operator is not defined for an "
    . [inOperandType messageGoilTemplateType] . " type";
  end if;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    C O M P A R I S O N S                          *
#                                                                           *
#---------------------------------------------------------------------------*

routine comparison_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType     :: boolType :
  when unsignedType :: unsignedType :
  when stringType   :: stringType :
  when enumType     :: enumType :
  else
    error here : "comparison between " . [inLeftExpressionType messageGoilTemplateType] .
           " and " . [inRightExpressionType messageGoilTemplateType] . " is not valid" ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    ==    !=    <    <=    >    >=   C O M P A R I S O N S     *
#                                                                           *
#---------------------------------------------------------------------------*

routine magnitude_comparison_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
:
  match inLeftExpressionType :: inRightExpressionType :
  when boolType      :: boolType :
  when unsignedType      :: unsignedType :
  when stringType    :: stringType :
  else
    error here : "comparison between " . [inLeftExpressionType messageGoilTemplateType] .
           " and " . [inRightExpressionType messageGoilTemplateType] . " is not valid" ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S H I F T    O P E R A T O R                               *
#                                                                           *
#---------------------------------------------------------------------------*

routine left_shift_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType    :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "shift between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*

routine right_shift_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType    :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "shift between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    A D D I T I O N    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine addition_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "addition between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    C O N C A T E N A T I O N    O P E R A T O R               *
#                                                                           *
#---------------------------------------------------------------------------*

routine concatenation_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when stringType        :: stringType :
    outResultType := inLeftExpressionType;
  else
    error here : "addition between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    S U B S T R A C T I O N    O P E R A T O R                 *
#                                                                           *
#---------------------------------------------------------------------------*

routine substraction_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "substraction between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M U L T I P L Y    O P E R A T O R                         *
#                                                                           *
#---------------------------------------------------------------------------*

routine multiply_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "multiplication between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    D I V I D E    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine divide_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "division between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#---------------------------------------------------------------------------*
#                                                                           *
#   C H E C K    M O D U L O    O P E R A T O R                             *
#                                                                           *
#---------------------------------------------------------------------------*

routine modulo_types_checkForTemplate
  ??@Ttype inLeftExpressionType
  ??@Ttype inRightExpressionType
  !@Ttype outResultType
:
  match inLeftExpressionType :: inRightExpressionType :
  when unsignedType      :: unsignedType :
    outResultType := inLeftExpressionType;
  else
    error here : "modulo between " . [inLeftExpressionType messageGoilTemplateType]
      ." and " . [inRightExpressionType messageGoilTemplateType] . " is not valid"
      : outResultType
   ;
  end match;
end routine;

#------------------------------------------------------------------------------*
#                                                                              *
#  A R G U M E N T    L I S T    S I G N A T U R E                             *
#                                                                              *
#------------------------------------------------------------------------------*

function argumentListSignature
  ??@TexpressionList inParameterTypeList
  -> @string outResult
:
  outResult := " this method call has ";
  outResult .= [[inParameterTypeList length] string] . " argument";
  outResult .= if [inParameterTypeList length] > 0 then "s" else "" end;
  foreach inParameterTypeList
  before outResult .= ": ";
  do outResult .= [mType messageGoilTemplateType];
  between outResult .= ", ";
  end foreach;
end function;

#------------------------------------------------------------------------------*
#                                                                              *
#  C H E C K    I N V O C A T I O N    H A S   N O    A R G U M E N T          *
#                                                                              *
#------------------------------------------------------------------------------*

routine checkInvocationHasNoArgument
  ??@Ttype inType
  ??@lstring inMethodName
  ??@TexpressionList inParameterTypeList
:
  if [inParameterTypeList length] > 0 then
    error inMethodName:"calling '" . inMethodName . "' on a "
    . [inType messageGoilTemplateType] . " type requires no argument; "
    . argumentListSignature [!inParameterTypeList];
  end if;
end routine;

#------------------------------------------------------------------------------*
#                                                                              *
#  M E T H O D    I N V O C A T I O N                                          *
#                                                                              *
#------------------------------------------------------------------------------*

routine templateMethodInvocation
  ??@Ttype inType
  ??@Tvalue inValue
  ??@lstring inMethodName
  ??@TexpressionList inParameterTypeList
  !@Ttype outResultType
  !@Tvalue outResultValue
:
  switch inType
  when boolType :
    if [inMethodName string] == "trueOrFalse" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [
        ! if [inValue mUnsigned64Value] > 0L then "true" else "false" end
      ];
    elsif [inMethodName string] == "yesOrNo" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [
        ! if [inValue mUnsigned64Value] > 0L then "yes" else "no" end
      ];
    elsif [inMethodName string] == "unsigned" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype unsignedType];
      outResultValue := inValue;
    else
      error inMethodName: "this template method is not defined" : outResultValue, outResultType;
    end if;
  when unsignedType :
    if [inMethodName string] == "string" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mUnsigned64Value] string]];
    elsif [inMethodName string] == "hexString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mUnsigned64Value] hexString]];
    else
      error inMethodName: "this template method is not defined" : outResultValue, outResultType;
    end if;
  when stringType :
    if [inMethodName string] == "HTMLRepresentation" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] HTMLRepresentation]];
    elsif [inMethodName string] == "identifierRepresentation" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] identifierRepresentation]];
    elsif [inMethodName string] == "lowercaseString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] lowercaseString]];
    elsif [inMethodName string] == "length" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype unsignedType];
      outResultValue := valueWithUnsigned [![[[inValue mStringValue] length] uint64]];
    elsif [inMethodName string] == "stringByCapitalizingFirstCharacter" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] stringByCapitalizingFirstCharacter]];
    elsif [inMethodName string] == "uppercaseString" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype stringType];
      outResultValue := valueWithString [![[inValue mStringValue] uppercaseString]];
    else
      error inMethodName: "this template method is not defined" : outResultValue, outResultType;
    end if;
  when listType :
    if [inMethodName string] == "length" then
      checkInvocationHasNoArgument !inType !inMethodName !inParameterTypeList;
      outResultType := [@Ttype unsignedType];
      outResultValue := valueWithUnsigned [![[[inValue mMapListValue] length] uint64]];
    else
      error inMethodName: "this template method is not defined" : outResultValue, outResultType;
    end if;
  when enumType, structType, mapType:
    error inMethodName: "this template method is not defined" : outResultValue, outResultType;
  when unconstructedType:
    error here: "internal error, unconstructed type found": outResultValue, outResultType;
  end switch;
end routine;

#------------------------------------------------------------------------------*
#                                                                              *
#   E X P R E S S I O N                                                        *
#                                                                              *
#------------------------------------------------------------------------------*

rule <expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <relation_term>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  repeat
  while
    $|$;
    @Tvalue leftOperand := outValue;
    @Tvalue rightOperand;
    @Ttype firstOperandType := outResultType;
    @Ttype secondOperandType;
    <relation_term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
   ;
    outValue->mUnsigned64Value := [leftOperand mUnsigned64Value] | [rightOperand mUnsigned64Value];
    matchOrOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
    ;
  while
    $^$;
    @Tvalue leftOperand := outValue;
    @Tvalue rightOperand;
    @Ttype firstOperandType := outResultType;
    @Ttype secondOperandType;
    <relation_term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
   ;
    outValue->mUnsigned64Value := [leftOperand mUnsigned64Value] ^ [rightOperand mUnsigned64Value];
    matchXorOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
    ;
  end repeat;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    T E R M                                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_term>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <relation_factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  repeat
  while
    $&$;
    @Tvalue leftOperand := outValue;
    @Tvalue rightOperand;
    @Ttype firstOperandType := outResultType;
    @Ttype secondOperandType;
    <relation_factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightOperand
      ?secondOperandType
   ;
    outValue->mUnsigned64Value := [leftOperand mUnsigned64Value] & [rightOperand mUnsigned64Value];
    matchAndOperatorForTemplate
      !firstOperandType
      !secondOperandType
      ?outResultType
   ;
  end repeat;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   R E L A T I O N    F A C T O R                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <relation_factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <simple_expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  select
  or
    $==$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType;
    comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] == [rightExpression mUnsigned64Value];
    when unsignedType :
      result := [leftExpression mUnsigned64Value] == [rightExpression mUnsigned64Value];
    when stringType :
      result := [leftExpression mStringValue] == [rightExpression mStringValue];
    when enumType :
      result := [leftExpression mStringValue] == [rightExpression mStringValue];
    when listType, structType, mapType:
      error here: "lists, structs and maps may not be compared" : result;
    when unconstructedType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue->mUnsigned64Value := if result then 1L else 0L end;
  or
    $!=$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] != [rightExpression mUnsigned64Value];
    when unsignedType :
      result := [leftExpression mUnsigned64Value] != [rightExpression mUnsigned64Value];
    when stringType :
      result := [leftExpression mStringValue] != [rightExpression mStringValue];
    when enumType :
      result := [leftExpression mStringValue] != [rightExpression mStringValue];
    when listType, structType, mapType:
      error here: "lists, structs and maps may not be compared": result;
    when unconstructedType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue->mUnsigned64Value := if result then 1L else 0L end;
  or
    $<=$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] <= [rightExpression mUnsigned64Value];
    when unsignedType :
      result := [leftExpression mUnsigned64Value] <= [rightExpression mUnsigned64Value];
    when stringType, enumType, listType, structType, mapType :
      result := false;
    when unconstructedType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue->mUnsigned64Value := if result then 1L else 0L end;
  or
    $>=$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] >= [rightExpression mUnsigned64Value];
    when unsignedType :
      result := [leftExpression mUnsigned64Value] >= [rightExpression mUnsigned64Value];
    when stringType, enumType, listType, structType, mapType :
      result := false;
    when unconstructedType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue->mUnsigned64Value := if result then 1L else 0L end;
  or
    $>$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] > [rightExpression mUnsigned64Value];
    when unsignedType :
      result := [leftExpression mUnsigned64Value] > [rightExpression mUnsigned64Value];
    when stringType, enumType, listType, structType, mapType :
      result := false;
    when unconstructedType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue->mUnsigned64Value := if result then 1L else 0L end;
  or
    $<$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <simple_expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    magnitude_comparison_types_checkForTemplate !leftType !rightType;
    @bool result;
    switch leftType
    when boolType :
      result := [leftExpression mUnsigned64Value] < [rightExpression mUnsigned64Value];
    when unsignedType :
      result := [leftExpression mUnsigned64Value] < [rightExpression mUnsigned64Value];
    when stringType, enumType, listType, structType, mapType :
      result := false;
    when unconstructedType:
      error here: "internal error, unconstructed type found" : result;
    end switch;
    outResultType := [@Ttype boolType];
    outValue->mUnsigned64Value := if result then 1L else 0L end;
  end select;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   S I M P L E    E X P R E S S I O N                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <simple_expression>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <term>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  repeat
  while 
    $<<$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    left_shift_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue->mUnsigned64Value := [leftExpression mUnsigned64Value] << [[rightExpression mUnsigned64Value] uint];
  while 
    $>>$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    right_shift_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue->mUnsigned64Value := [leftExpression mUnsigned64Value] >> [[rightExpression mUnsigned64Value] uint];
  while 
    $+$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    addition_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue->mUnsigned64Value := [leftExpression mUnsigned64Value] + [rightExpression mUnsigned64Value];
  while 
    $.$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
    ;
    concatenation_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue->mStringValue := [leftExpression mStringValue] . [rightExpression mStringValue];
  while 
    $-$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <term>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    addition_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue->mUnsigned64Value := [leftExpression mUnsigned64Value] - [rightExpression mUnsigned64Value];
  end repeat;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   T E R M                                                                    *
#                                                                              *
#------------------------------------------------------------------------------*

rule <term>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  repeat
  while 
    $*$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    multiply_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue->mUnsigned64Value := [leftExpression mUnsigned64Value] * [rightExpression mUnsigned64Value];
  while 
    $/$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    divide_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue->mUnsigned64Value := [leftExpression mUnsigned64Value] / [rightExpression mUnsigned64Value];
  while 
    $mod$;
    @Tvalue leftExpression := outValue;
    @Ttype leftType := outResultType;
    @Tvalue rightExpression;
    @Ttype rightType;
    <factor>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?rightExpression
      ?rightType
   ;
    modulo_types_checkForTemplate !leftType !rightType ?outResultType;
    outValue->mUnsigned64Value := [leftExpression mUnsigned64Value] mod [rightExpression mUnsigned64Value];
  end repeat;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ( EXPRESSION )                                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $($;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?outValue
    ?outResultType
 ;
  $)$;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    not FACTOR                                             *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $not$;
  @Tvalue expression;
  @Ttype operandType;
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?expression
    ?operandType
 ;
  outValue := valueWithUnsigned[!1L - [expression mUnsigned64Value]];
  checkNotOperatorForTemplate !operandType ?outResultType;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    ~ FACTOR                                               *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $~$;
  @Tvalue value;
  @Ttype operandType;
  <factor>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?value
    ?operandType
 ;
  outValue := valueWithUnsigned[!~ [value mUnsigned64Value]];
  checkBitComplementOperatorForTemplate !operandType ?outResultType;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    true                                                   *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $yes$;
  outValue := valueWithUnsigned[!1L];
  outResultType := [@Ttype boolType];
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    false                                                  *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $no$;
  outValue := valueWithUnsigned[!0L];
  outResultType := [@Ttype boolType];
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a 64-bit unsigned literal integer value                *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  @luint64 literalInt;
  $unsigned_literal_integer64$ ?literalInt;
  outValue := valueWithUnsigned[![literalInt uint64]];
  outResultType := [@Ttype unsignedType];
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#   F A C T O R    :    a literal string value                                 *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $string$ ?@lstring literalString;
  outValue := valueWithString[![literalString string]];
  outResultType := [@Ttype stringType];
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   template method call :   [expression method !... ]                         *
#                                                                              *
#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $[$;

  @Tvalue expressionValue;
  @Ttype expressionType;
  <expression>
    !inPrefix
    !inPath
    !inTemplateDirectory
    !inVariableMap
    ?expressionValue
    ?expressionType
 ;

  $identifier$ ? @lstring templateMethodName;

  @TexpressionList expressionList [emptyList];
  select
  or
    $:$;
    repeat
      @Tvalue expression;
      @Ttype resultType;
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !inVariableMap
        ?expression
        ?resultType
     ;
      expressionList += !expression !resultType;
    while
      $,$;
    end repeat;
  end select;

  $]$;

  templateMethodInvocation
    !expressionType
    !expressionValue
    !templateMethodName
    !expressionList
    ?outResultType
    ?outValue
 ;
end rule;

#------------------------------------------------------------------------------*
#                                                                              *
#                         F A C T O R                                          *
#   function call        :   function_name (..., ...)                          *
#   variable             :   variable_name                                     *
#                                                                              *
#------------------------------------------------------------------------------*

routine typeError
  ??@lstring inFunctionName
  ??@type inActualType
  ??@string inExpectedTypeName
  ??@uint inParameterIndex
:
  @string m := "the function requires the parameter " . [inParameterIndex string]
  . " to be " . inExpectedTypeName . "; its type is "
 ;
  if inActualType == `@bool then
    m .= "boolean";
  elsif inActualType == `@uint64 then
    m .= "unsigned";
  elsif inActualType == `@string then
    m .= "string";
  else
    m .= "a not allowed type";
  end if;
  error inFunctionName : m;
end routine;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  @TvarPath path;
  <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path;
  select
    searchField !path !inVariableMap ?outResultType ?outValue ?*;
  or
    @lstring functionOrVariableName;
    [path first ?functionOrVariableName ?*];
  #--- Search for function name
    @function f;
    if not [@function isFunctionDefined ![functionOrVariableName string]] then
      error functionOrVariableName : "there is no '" . functionOrVariableName . "' function defined in GOIL template language" : f;
    else
      f := [@function functionWithName ![functionOrVariableName string]];
    end if;
  #--- Parse actual arguments
    @TexpressionList actualArgumentList [emptyList];
    $($;
    repeat
      @Tvalue expression;
      @Ttype resultType;
      <expression>
        !inPrefix
        !inPath
        !inTemplateDirectory
        !inVariableMap
        ?expression
        ?resultType
     ;
      actualArgumentList += !expression !resultType;
    while
      $,$;
    end repeat;
    $)$;
  #--- Check arguments
    @objectlist actualArgumentObjectList [emptyList];
    const @typelist formalParameterList := [f formalParameterTypeList];
    if [formalParameterList length] != [actualArgumentList length] then
      error functionOrVariableName: "this function is invoked with "
      . [[actualArgumentList length] string]
      . " parameter" . if [actualArgumentList length] > 1 then "s" else "" end
      . ", but requires " 
      . [[formalParameterList length] string]
      . " parameter" . if [formalParameterList length] > 1 then "s" else "" end
      : outValue, outResultType;
    else
      @uint idx := 1;
      foreach formalParameterList prefixedby formal_, actualArgumentList prefixedby actual_ do
        switch actual_mType
        when boolType :
          if formal_mValue != `@bool then
            typeError !functionOrVariableName !formal_mValue !"boolean" !idx;
          end if;
          actualArgumentObjectList += ![if [actual_mValue mUnsigned64Value] == 0L then false else true end object];
        when unsignedType :
          if formal_mValue != `@uint64 then
            typeError !functionOrVariableName !formal_mValue !"unsigned" !idx;
          end if;
          actualArgumentObjectList += ![[actual_mValue mUnsigned64Value] object];
        when stringType :
          if formal_mValue != `@string then
            typeError !functionOrVariableName !formal_mValue !"string" !idx;
          end if;
        when enumType :
          if formal_mValue != `@string then
            typeError !functionOrVariableName !formal_mValue !"enum" !idx;
          end if;
          actualArgumentObjectList += ![[actual_mValue mStringValue] object];
        when listType, structType, mapType :
          typeError !functionOrVariableName !formal_mValue !"string" !idx;
        when unconstructedType:
          error here: "internal error, unconstructed type found";
        end switch;
        idx ++;     
      end foreach;
      outResultType := [@Ttype unsignedType];
      outValue := valueWithUnsigned[!0L];
      if [@uint errorCount] == 0 then
        const @object result := [f invoke !actualArgumentObjectList ![functionOrVariableName location]];
        if [result objectDynamicType] == `@uint64 then
          outResultType := [@Ttype unsignedType];
          outValue->mUnsigned64Value := (cast result if == @uint64 else error functionOrVariableName);
        elsif [result objectDynamicType] == `@bool then
          outResultType := [@Ttype boolType];
          outValue->mUnsigned64Value := [(cast result if == @bool else error functionOrVariableName) uint64];
        elsif [result objectDynamicType] == `@string then
          outResultType := [@Ttype stringType];
          outValue->mStringValue := (cast result if == @string else error functionOrVariableName);
        else
          error functionOrVariableName : "this function does not return an unsigned, boolean or string value";
        end if;
      end if;
    end if;
  end select;
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  @TvarPath path;
  $exists$; <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path;

  @Ttype variableType;
  @Tvalue variableValue;
  @bool varExists;

  searchFieldIfExists !path !inVariableMap ?variableType ?variableValue ?varExists;

  select
    $default$;
    @Tvalue expression;
    @Ttype resultType;
    $($;
    <expression>
      !inPrefix
      !inPath
      !inTemplateDirectory
      !inVariableMap
      ?expression
      ?resultType
    ;
    $)$;
    if varExists then
      outResultType := variableType;
      outValue := variableValue;
    else
      outResultType := resultType;
      outValue := expression;
    end if;
  or
    outResultType := [@Ttype boolType];
    if varExists then
      outValue := valueWithUnsigned[!1L];
    else
      outValue := valueWithUnsigned[!0L];
    end if;
  end select;
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string  inPath
  ??@string  inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  @TvarPath variableName;
  $typeof$; <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?variableName;
  @Ttype variableType;
  @Tvalue variableValue;
  searchField !variableName !inVariableMap ?variableType ?variableValue ?*;
  outResultType := [@Ttype enumType];
  outValue := valueWithString[![variableType messageGoilTemplateType]];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  select
    $true$;
    outValue := valueWithUnsigned[!1L];
  or
    $false$;
    outValue := valueWithUnsigned[!0L];
  end select;
  outResultType := [@Ttype boolType];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $@$; $identifier$ ?@lstring enumValue;
  outValue := valueWithString[![enumValue string]];
  outResultType := [@Ttype enumType];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $emptylist$;
  outValue := [@Tvalue new !0L !"" ![@TfieldMapList emptyList] ![@TfieldMap emptyMap]];
  outResultType := [@Ttype listType];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string unused inPrefix
  ??@string unused inPath
  ??@string unused inTemplateDirectory
  ??@TfieldMap unused inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $emptymap$;
  outValue := [@Tvalue new !0L !"" ![@TfieldMapList emptyList] ![@TfieldMap emptyMap]];
  outResultType := [@Ttype mapType];
end rule;

#------------------------------------------------------------------------------*

rule <factor>
  ??@string inPrefix
  ??@string inPath
  ??@string inTemplateDirectory
  ??@TfieldMap inVariableMap
  !@Tvalue outValue
  !@Ttype outResultType
:
  $mapof$;
  @TvarPath path;
  <variable> !inPrefix !inPath !inTemplateDirectory !inVariableMap ?path;
  $by$;
  $identifier$ ?@lstring key;
  
  @Ttype variableType;
  @Tvalue variableValue;
  @location where;
  searchField !path !inVariableMap ?variableType ?variableValue ?where;
  if variableType != [@Ttype listType] then
    error where: "list expected": outValue, outResultType;
  else
    # get the elements of the list to build a map, each key being
    # one of the field of the elements of the list
    @TfieldMap resultMap [emptyMap];
    foreach [variableValue mMapListValue] do
      if [mMap hasKey ![key string]] then
        # the specified key is found, get it and check it is a string
        @Ttype keyType;
        @Tvalue keyValue;
        [mMap searchKey !key ?keyType ?keyValue];
        if keyType == [@Ttype stringType] then
          @lstring keyVal := [@lstring new ![keyValue mStringValue] ![mMap locationForKey ![key string]]];
          [!?resultMap insertKey !keyVal ![@Ttype structType] !valueWithMap[!mMap]];
        else
          error [mMap locationForKey ![key string]]: "the list element specified key is not a string";
        end if;
      else
        error here: "the list element has not the specified key";
      end if;
    end foreach;
    outResultType := [@Ttype mapType];
    outValue := valueWithMap[!resultMap];
  end if;
end rule;

##------------------------------------------------------------------------------*
#
#rule <factor>
#  ??@string inPrefix
#  ??@string inPath
#  ??@string inTemplateDirectory
#  ??@TfieldMap inVariableMap
#  !@Tvalue outValue
#  !@Ttype outResultType
#:
#  @string resultString := "";
#  $templateresult$;
#  select
#    $if$; $exists$;
#    @bool found;
#    $identifier$ ? @lstring templateName;
#    goilTemplateInvocation
#      !templateName
#      !inPrefix
#      !inPath
#      !inTemplateDirectory
#      !false
#      !inVariableMap
#      !?resultString
#      ?*
#    ;
#  or
#    $identifier$ ? @lstring templateName;
#    goilTemplateInvocation
#      !templateName
#      !inPrefix
#      !inPath
#      !inTemplateDirectory
#      !true
#      !inVariableMap
#      !?resultString
#      ?*
#    ;
#  end select;
#  outValue := [@Tvalue new !0L !resultString ![@TfieldMapList emptyList]];
#  outResultType := [@Ttype stringType];
#end rule;

end syntax;
