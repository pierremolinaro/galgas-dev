//---------------------------------------------------------------------------*//                                                                           *//                       File 'grammar_semantics.cpp'                        *//               Generated by version 0.14.0 (LL(1) grammar)                 *//                     january 13th, 2005, at 17h52'36"                      *//                                                                           *// This program is free software; you can redistribute it and/or modify it   *// under the terms of the GNU General Public License as published by the     *// Free Software Foundation.                                                 *//                                                                           *// This program is distributed in the hope it will be useful, but WITHOUT    *// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *// more details.                                                             *//                                                                           *//---------------------------------------------------------------------------*//--- START OF USER ZONE 1//--- END OF USER ZONE 1#include "files/C_text_file_write.h"#include "grammar_semantics.h"//--- START OF USER ZONE 2//--- END OF USER ZONE 2//---------------------------------------------------------------------------*//                                                                           *//             Class element of list 'typeListeAttributsAxiome'              *//                                                                           *//---------------------------------------------------------------------------*GGS_typeListeAttributsAxiome::element_type::element_type (const GGS_lstring & argument_0) {  mNextItem = (element_type *) NULL ;  aAttributAxiome = argument_0 ;}//---------------------------------------------------------------------------*//                                                                           *//                  class list 'typeListeAttributsAxiome'                    *//                                                                           *//---------------------------------------------------------------------------*GGS_typeListeAttributsAxiome::GGS_typeListeAttributsAxiome (void) { // Default Constructor  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mCountReference = (sint32 *) NULL ;}//---------------------------------------------------------------------------*GGS_typeListeAttributsAxiome::~GGS_typeListeAttributsAxiome (void) {  emptyList () ;}//---------------------------------------------------------------------------*GGS_typeListeAttributsAxiome::GGS_typeListeAttributsAxiome (const GGS_typeListeAttributsAxiome & source) { // Copy constructor  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mCountReference = (sint32 *) NULL ;  *this = source ;}//---------------------------------------------------------------------------*void GGS_typeListeAttributsAxiome::operator = (const GGS_typeListeAttributsAxiome & source) { // Assignment operator  if (this != & source) {    emptyList () ;    mFirstItem = source.mFirstItem ;    mLastItem = source.mLastItem ;    mCurrentItemPtr = (element_type *) NULL ;    mCurrentItemIndex = 0 ;    mListLength = source.mListLength ;    mCountReference = source.mCountReference ;    if (mCountReference != NULL) {      macroValidPointer (mCountReference) ;      (*mCountReference) ++ ;    }  }}//---------------------------------------------------------------------------*void GGS_typeListeAttributsAxiome::emptyList (void) {  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mLastItem = (element_type *) NULL ;  if (mCountReference != NULL) {    macroValidPointer (mCountReference) ;    if ((*mCountReference) == 1) {      macroMyDelete (mCountReference, sint32) ;      while (mFirstItem != NULL) {        macroValidPointer (mFirstItem) ;        mLastItem = mFirstItem->mNextItem ;        macroMyDelete (mFirstItem, element_type) ;        mFirstItem = mLastItem ;      }    }else{      mFirstItem = (element_type *) NULL ;      (*mCountReference) -- ;      mCountReference = (sint32 *) NULL ;    }  }}//---------------------------------------------------------------------------*void GGS_typeListeAttributsAxiome::internalAppendItem (const GGS_lstring & argument_0) {  element_type * nouvelElement = (element_type *) NULL ;  macroMyNew (nouvelElement, element_type (argument_0)) ;  if (nouvelElement != NULL) {    macroValidPointer (nouvelElement) ;    if (mLastItem == NULL) {      mFirstItem = nouvelElement ;    }else{      macroValidPointer (mLastItem) ;      mLastItem->mNextItem = nouvelElement ;    }    mLastItem = nouvelElement ;    nouvelElement = (element_type *) NULL ;    mListLength ++ ;  }}//---------------------------------------------------------------------------*void GGS_typeListeAttributsAxiome::addAssign_operation (const GGS_lstring & argument_0) {  if (isBuilt ()                 && argument_0.isBuilt ()) {    insulateList () ;    internalAppendItem (argument_0) ;  }}//---------------------------------------------------------------------------*void GGS_typeListeAttributsAxiome::insulateList (void) {  if (mCountReference != NULL) {    macroValidPointer (mCountReference) ;    if ((*mCountReference) > 1) {      element_type * p = mFirstItem ;      mFirstItem = (element_type *)  NULL ;      mLastItem = (element_type *)  NULL ;      mListLength = 0 ;      mCurrentItemPtr = (element_type *) NULL ;      mCurrentItemIndex = 0 ;      while (p != NULL) {        macroValidPointer (p) ;        internalAppendItem (p->aAttributAxiome) ;        p = p->mNextItem ;      }      (*mCountReference) -- ;      mCountReference = (sint32 *) NULL ;      macroMyNew (mCountReference, sint32 (1)) ;    }  }}//---------------------------------------------------------------------------*GGS_typeListeAttributsAxiome  GGS_typeListeAttributsAxiome::constructor_empty (void) {  GGS_typeListeAttributsAxiome result ;  macroMyNew (result.mCountReference, sint32 (1)) ;  return result ;}//---------------------------------------------------------------------------*void GGS_typeListeAttributsAxiome::drop_operation (void) {  emptyList () ;}//---------------------------------------------------------------------------*//                                                                           *//                 Class element of list 'typeListeChaines'                  *//                                                                           *//---------------------------------------------------------------------------*GGS_typeListeChaines::element_type::element_type (const GGS_lstring & argument_0) {  mNextItem = (element_type *) NULL ;  attributChaine = argument_0 ;}//---------------------------------------------------------------------------*//                                                                           *//                      class list 'typeListeChaines'                        *//                                                                           *//---------------------------------------------------------------------------*GGS_typeListeChaines::GGS_typeListeChaines (void) { // Default Constructor  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mCountReference = (sint32 *) NULL ;}//---------------------------------------------------------------------------*GGS_typeListeChaines::~GGS_typeListeChaines (void) {  emptyList () ;}//---------------------------------------------------------------------------*GGS_typeListeChaines::GGS_typeListeChaines (const GGS_typeListeChaines & source) { // Copy constructor  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mCountReference = (sint32 *) NULL ;  *this = source ;}//---------------------------------------------------------------------------*void GGS_typeListeChaines::operator = (const GGS_typeListeChaines & source) { // Assignment operator  if (this != & source) {    emptyList () ;    mFirstItem = source.mFirstItem ;    mLastItem = source.mLastItem ;    mCurrentItemPtr = (element_type *) NULL ;    mCurrentItemIndex = 0 ;    mListLength = source.mListLength ;    mCountReference = source.mCountReference ;    if (mCountReference != NULL) {      macroValidPointer (mCountReference) ;      (*mCountReference) ++ ;    }  }}//---------------------------------------------------------------------------*void GGS_typeListeChaines::emptyList (void) {  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mLastItem = (element_type *) NULL ;  if (mCountReference != NULL) {    macroValidPointer (mCountReference) ;    if ((*mCountReference) == 1) {      macroMyDelete (mCountReference, sint32) ;      while (mFirstItem != NULL) {        macroValidPointer (mFirstItem) ;        mLastItem = mFirstItem->mNextItem ;        macroMyDelete (mFirstItem, element_type) ;        mFirstItem = mLastItem ;      }    }else{      mFirstItem = (element_type *) NULL ;      (*mCountReference) -- ;      mCountReference = (sint32 *) NULL ;    }  }}//---------------------------------------------------------------------------*void GGS_typeListeChaines::internalAppendItem (const GGS_lstring & argument_0) {  element_type * nouvelElement = (element_type *) NULL ;  macroMyNew (nouvelElement, element_type (argument_0)) ;  if (nouvelElement != NULL) {    macroValidPointer (nouvelElement) ;    if (mLastItem == NULL) {      mFirstItem = nouvelElement ;    }else{      macroValidPointer (mLastItem) ;      mLastItem->mNextItem = nouvelElement ;    }    mLastItem = nouvelElement ;    nouvelElement = (element_type *) NULL ;    mListLength ++ ;  }}//---------------------------------------------------------------------------*void GGS_typeListeChaines::addAssign_operation (const GGS_lstring & argument_0) {  if (isBuilt ()                 && argument_0.isBuilt ()) {    insulateList () ;    internalAppendItem (argument_0) ;  }}//---------------------------------------------------------------------------*void GGS_typeListeChaines::insulateList (void) {  if (mCountReference != NULL) {    macroValidPointer (mCountReference) ;    if ((*mCountReference) > 1) {      element_type * p = mFirstItem ;      mFirstItem = (element_type *)  NULL ;      mLastItem = (element_type *)  NULL ;      mListLength = 0 ;      mCurrentItemPtr = (element_type *) NULL ;      mCurrentItemIndex = 0 ;      while (p != NULL) {        macroValidPointer (p) ;        internalAppendItem (p->attributChaine) ;        p = p->mNextItem ;      }      (*mCountReference) -- ;      mCountReference = (sint32 *) NULL ;      macroMyNew (mCountReference, sint32 (1)) ;    }  }}//---------------------------------------------------------------------------*GGS_typeListeChaines  GGS_typeListeChaines::constructor_empty (void) {  GGS_typeListeChaines result ;  macroMyNew (result.mCountReference, sint32 (1)) ;  return result ;}//---------------------------------------------------------------------------*void GGS_typeListeChaines::drop_operation (void) {  emptyList () ;}//---------------------------------------------------------------------------*//                                                                           *//               abstract class 'cPtr_typeAbstraitInclusionM'                *//                                                                           *//---------------------------------------------------------------------------*//---------------------------------------------------------------------------*//                                                                           *//                GALGAS class 'GGS_typeAbstraitInclusionM'                  *//                                                                           *//---------------------------------------------------------------------------*GGS_typeAbstraitInclusionM::GGS_typeAbstraitInclusionM (void) {  mPointer = (cPtr_typeAbstraitInclusionM *) NULL ;}//---------------------------------------------------------------------------*GGS_typeAbstraitInclusionM::GGS_typeAbstraitInclusionM (const GGS_typeAbstraitInclusionM & inOperand) {  mPointer = (cPtr_typeAbstraitInclusionM *) NULL ;  macroAttachPointer (mPointer, inOperand.mPointer) ;}//---------------------------------------------------------------------------*GGS_typeAbstraitInclusionM::~GGS_typeAbstraitInclusionM (void) {  macroDetachPointer (mPointer, cPtr_typeAbstraitInclusionM) ;}//---------------------------------------------------------------------------*void GGS_typeAbstraitInclusionM::operator = (const GGS_typeAbstraitInclusionM & inOperand) {  macroAttachPointer (mPointer, inOperand.mPointer) ;}//---------------------------------------------------------------------------*bool GGS_typeAbstraitInclusionM::isBuilt (void) const {  bool result = false ;  if (mPointer != NULL) {    macroValidPointer (mPointer) ;    result = mPointer->isBuilt () ;  }  return result ;}//---------------------------------------------------------------------------*void GGS_typeAbstraitInclusionM::operator = (cPtr_typeAbstraitInclusionM * inSource) {  macroAttachPointer (mPointer, inSource) ;}//---------------------------------------------------------------------------*GGS_typeAbstraitInclusionM::GGS_typeAbstraitInclusionM (cPtr_typeAbstraitInclusionM * inSource) {  mPointer = (cPtr_typeAbstraitInclusionM *) NULL ;  macroAttachPointer (mPointer, inSource) ;}//---------------------------------------------------------------------------*cPtr_typeAbstraitInclusionM * GGS_typeAbstraitInclusionM::operator () (void) const {  macroValidPointer (mPointer) ;  return mPointer ;}//---------------------------------------------------------------------------*void GGS_typeAbstraitInclusionM::drop_operation (void) {  macroDetachPointer (mPointer, cPtr_typeAbstraitInclusionM) ;}//---------------------------------------------------------------------------*//                                                                           *//                        class 'typePasInclusionM'                          *//                                                                           *//---------------------------------------------------------------------------*//---------------------------------------------------------------------------*bool cPtr_typePasInclusionM::isBuilt (void) const {  return true ;}//---------------------------------------------------------------------------*//                                                                           *//                   GALGAS class 'GGS_typePasInclusionM'                    *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_typePasInclusionM * GGS_typePasInclusionM::    constructor_new () {    cPtr_typePasInclusionM * ptr_ = (cPtr_typePasInclusionM *) NULL ;    macroMyNew (ptr_, cPtr_typePasInclusionM ()) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*//                                                                           *//                          class 'typeInclusionM'                           *//                                                                           *//---------------------------------------------------------------------------*cPtr_typeInclusionM::cPtr_typeInclusionM (const GGS_lstring & argument_0,                                const GGS_typeListeChaines & argument_1):attributNomFichier (argument_0),aListeInclure (argument_1) {}//---------------------------------------------------------------------------*bool cPtr_typeInclusionM::isBuilt (void) const {  return attributNomFichier.isBuilt () &&       aListeInclure.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//                    GALGAS class 'GGS_typeInclusionM'                      *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_typeInclusionM * GGS_typeInclusionM::    constructor_new (const GGS_lstring & argument_0,                                const GGS_typeListeChaines & argument_1) {    cPtr_typeInclusionM * ptr_ = (cPtr_typeInclusionM *) NULL ;    macroMyNew (ptr_, cPtr_typeInclusionM (argument_0,                                argument_1)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*