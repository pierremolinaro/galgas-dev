//---------------------------------------------------------------------------*//                                                                           *//                       File 'parser_semantics.cpp'                         *//               Generated by version 0.14.0 (LL(1) grammar)                 *//                     january 13th, 2005, at 17h52'40"                      *//                                                                           *// This program is free software; you can redistribute it and/or modify it   *// under the terms of the GNU General Public License as published by the     *// Free Software Foundation.                                                 *//                                                                           *// This program is distributed in the hope it will be useful, but WITHOUT    *// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *// more details.                                                             *//                                                                           *//---------------------------------------------------------------------------*//--- START OF USER ZONE 1//--- END OF USER ZONE 1#include "files/C_text_file_write.h"#include "parser_semantics.h"//--- START OF USER ZONE 2//--- END OF USER ZONE 2//---------------------------------------------------------------------------*//                                                                           *//               abstract class 'cPtr_typeParserInstruction'                 *//                                                                           *//---------------------------------------------------------------------------*//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_typeParserInstruction'                  *//                                                                           *//---------------------------------------------------------------------------*GGS_typeParserInstruction::GGS_typeParserInstruction (void) {  mPointer = (cPtr_typeParserInstruction *) NULL ;}//---------------------------------------------------------------------------*GGS_typeParserInstruction::GGS_typeParserInstruction (const GGS_typeParserInstruction & inOperand) {  mPointer = (cPtr_typeParserInstruction *) NULL ;  macroAttachPointer (mPointer, inOperand.mPointer) ;}//---------------------------------------------------------------------------*GGS_typeParserInstruction::~GGS_typeParserInstruction (void) {  macroDetachPointer (mPointer, cPtr_typeParserInstruction) ;}//---------------------------------------------------------------------------*void GGS_typeParserInstruction::operator = (const GGS_typeParserInstruction & inOperand) {  macroAttachPointer (mPointer, inOperand.mPointer) ;}//---------------------------------------------------------------------------*bool GGS_typeParserInstruction::isBuilt (void) const {  bool result = false ;  if (mPointer != NULL) {    macroValidPointer (mPointer) ;    result = mPointer->isBuilt () ;  }  return result ;}//---------------------------------------------------------------------------*void GGS_typeParserInstruction::operator = (cPtr_typeParserInstruction * inSource) {  macroAttachPointer (mPointer, inSource) ;}//---------------------------------------------------------------------------*GGS_typeParserInstruction::GGS_typeParserInstruction (cPtr_typeParserInstruction * inSource) {  mPointer = (cPtr_typeParserInstruction *) NULL ;  macroAttachPointer (mPointer, inSource) ;}//---------------------------------------------------------------------------*cPtr_typeParserInstruction * GGS_typeParserInstruction::operator () (void) const {  macroValidPointer (mPointer) ;  return mPointer ;}//---------------------------------------------------------------------------*void GGS_typeParserInstruction::drop_operation (void) {  macroDetachPointer (mPointer, cPtr_typeParserInstruction) ;}//---------------------------------------------------------------------------*//                                                                           *//                 class 'typeInstructionAppelNonTerminal'                   *//                                                                           *//---------------------------------------------------------------------------*cPtr_typeInstructionAppelNonTerminal::cPtr_typeInstructionAppelNonTerminal (const GGS_lstring & argument_0,                                const GGS_typeExpressionList & argument_1,                                const GGS_lstring & argument_2):mNonterminalName (argument_0),mParametersExpressionList (argument_1),mAltName (argument_2) {}//---------------------------------------------------------------------------*bool cPtr_typeInstructionAppelNonTerminal::isBuilt (void) const {  return mNonterminalName.isBuilt () &&       mParametersExpressionList.isBuilt () &&       mAltName.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//            GALGAS class 'GGS_typeInstructionAppelNonTerminal'             *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_typeInstructionAppelNonTerminal * GGS_typeInstructionAppelNonTerminal::    constructor_new (const GGS_lstring & argument_0,                                const GGS_typeExpressionList & argument_1,                                const GGS_lstring & argument_2) {    cPtr_typeInstructionAppelNonTerminal * ptr_ = (cPtr_typeInstructionAppelNonTerminal *) NULL ;    macroMyNew (ptr_, cPtr_typeInstructionAppelNonTerminal (argument_0,                                argument_1,                                argument_2)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*//                                                                           *//                  class 'typeInstructionVerifSyntaxique'                   *//                                                                           *//---------------------------------------------------------------------------*cPtr_typeInstructionVerifSyntaxique::cPtr_typeInstructionVerifSyntaxique (const GGS_lstring & argument_0,                                const GGS_L_assignedVariables & argument_1):aNomTerminal (argument_0),aListeTypeEffectifs (argument_1) {}//---------------------------------------------------------------------------*bool cPtr_typeInstructionVerifSyntaxique::isBuilt (void) const {  return aNomTerminal.isBuilt () &&       aListeTypeEffectifs.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//            GALGAS class 'GGS_typeInstructionVerifSyntaxique'              *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_typeInstructionVerifSyntaxique * GGS_typeInstructionVerifSyntaxique::    constructor_new (const GGS_lstring & argument_0,                                const GGS_L_assignedVariables & argument_1) {    cPtr_typeInstructionVerifSyntaxique * ptr_ = (cPtr_typeInstructionVerifSyntaxique *) NULL ;    macroMyNew (ptr_, cPtr_typeInstructionVerifSyntaxique (argument_0,                                argument_1)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*//                                                                           *//          Class element of list 'typeListeBranchesInstructions'            *//                                                                           *//---------------------------------------------------------------------------*GGS_typeListeBranchesInstructions::element_type::element_type (const GGS_typeInstructionsList & argument_0) {  mNextItem = (element_type *) NULL ;  mInstructionsList = argument_0 ;}//---------------------------------------------------------------------------*//                                                                           *//                class list 'typeListeBranchesInstructions'                 *//                                                                           *//---------------------------------------------------------------------------*GGS_typeListeBranchesInstructions::GGS_typeListeBranchesInstructions (void) { // Default Constructor  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mCountReference = (sint32 *) NULL ;}//---------------------------------------------------------------------------*GGS_typeListeBranchesInstructions::~GGS_typeListeBranchesInstructions (void) {  emptyList () ;}//---------------------------------------------------------------------------*GGS_typeListeBranchesInstructions::GGS_typeListeBranchesInstructions (const GGS_typeListeBranchesInstructions & source) { // Copy constructor  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mCountReference = (sint32 *) NULL ;  *this = source ;}//---------------------------------------------------------------------------*void GGS_typeListeBranchesInstructions::operator = (const GGS_typeListeBranchesInstructions & source) { // Assignment operator  if (this != & source) {    emptyList () ;    mFirstItem = source.mFirstItem ;    mLastItem = source.mLastItem ;    mCurrentItemPtr = (element_type *) NULL ;    mCurrentItemIndex = 0 ;    mListLength = source.mListLength ;    mCountReference = source.mCountReference ;    if (mCountReference != NULL) {      macroValidPointer (mCountReference) ;      (*mCountReference) ++ ;    }  }}//---------------------------------------------------------------------------*void GGS_typeListeBranchesInstructions::emptyList (void) {  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mLastItem = (element_type *) NULL ;  if (mCountReference != NULL) {    macroValidPointer (mCountReference) ;    if ((*mCountReference) == 1) {      macroMyDelete (mCountReference, sint32) ;      while (mFirstItem != NULL) {        macroValidPointer (mFirstItem) ;        mLastItem = mFirstItem->mNextItem ;        macroMyDelete (mFirstItem, element_type) ;        mFirstItem = mLastItem ;      }    }else{      mFirstItem = (element_type *) NULL ;      (*mCountReference) -- ;      mCountReference = (sint32 *) NULL ;    }  }}//---------------------------------------------------------------------------*void GGS_typeListeBranchesInstructions::internalAppendItem (const GGS_typeInstructionsList & argument_0) {  element_type * nouvelElement = (element_type *) NULL ;  macroMyNew (nouvelElement, element_type (argument_0)) ;  if (nouvelElement != NULL) {    macroValidPointer (nouvelElement) ;    if (mLastItem == NULL) {      mFirstItem = nouvelElement ;    }else{      macroValidPointer (mLastItem) ;      mLastItem->mNextItem = nouvelElement ;    }    mLastItem = nouvelElement ;    nouvelElement = (element_type *) NULL ;    mListLength ++ ;  }}//---------------------------------------------------------------------------*void GGS_typeListeBranchesInstructions::addAssign_operation (const GGS_typeInstructionsList & argument_0) {  if (isBuilt ()                 && argument_0.isBuilt ()) {    insulateList () ;    internalAppendItem (argument_0) ;  }}//---------------------------------------------------------------------------*void GGS_typeListeBranchesInstructions::insulateList (void) {  if (mCountReference != NULL) {    macroValidPointer (mCountReference) ;    if ((*mCountReference) > 1) {      element_type * p = mFirstItem ;      mFirstItem = (element_type *)  NULL ;      mLastItem = (element_type *)  NULL ;      mListLength = 0 ;      mCurrentItemPtr = (element_type *) NULL ;      mCurrentItemIndex = 0 ;      while (p != NULL) {        macroValidPointer (p) ;        internalAppendItem (p->mInstructionsList) ;        p = p->mNextItem ;      }      (*mCountReference) -- ;      mCountReference = (sint32 *) NULL ;      macroMyNew (mCountReference, sint32 (1)) ;    }  }}//---------------------------------------------------------------------------*GGS_typeListeBranchesInstructions  GGS_typeListeBranchesInstructions::constructor_empty (void) {  GGS_typeListeBranchesInstructions result ;  macroMyNew (result.mCountReference, sint32 (1)) ;  return result ;}//---------------------------------------------------------------------------*void GGS_typeListeBranchesInstructions::drop_operation (void) {  emptyList () ;}//---------------------------------------------------------------------------*//                                                                           *//                       class 'C_select_instruction'                        *//                                                                           *//---------------------------------------------------------------------------*cPtr_C_select_instruction::cPtr_C_select_instruction (const GGS_typeListeBranchesInstructions & argument_0,                                const GGS_location & argument_1):mIFbranchesList (argument_0),aPositionDebut (argument_1) {}//---------------------------------------------------------------------------*bool cPtr_C_select_instruction::isBuilt (void) const {  return mIFbranchesList.isBuilt () &&       aPositionDebut.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_C_select_instruction'                   *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_C_select_instruction * GGS_C_select_instruction::    constructor_new (const GGS_typeListeBranchesInstructions & argument_0,                                const GGS_location & argument_1) {    cPtr_C_select_instruction * ptr_ = (cPtr_C_select_instruction *) NULL ;    macroMyNew (ptr_, cPtr_C_select_instruction (argument_0,                                argument_1)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*//                                                                           *//                       class 'C_repeat_instruction'                        *//                                                                           *//---------------------------------------------------------------------------*cPtr_C_repeat_instruction::cPtr_C_repeat_instruction (const GGS_typeListeBranchesInstructions & argument_0,                                const GGS_location & argument_1):aListesBranchesRepeter (argument_0),aPositionDebut (argument_1) {}//---------------------------------------------------------------------------*bool cPtr_C_repeat_instruction::isBuilt (void) const {  return aListesBranchesRepeter.isBuilt () &&       aPositionDebut.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_C_repeat_instruction'                   *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_C_repeat_instruction * GGS_C_repeat_instruction::    constructor_new (const GGS_typeListeBranchesInstructions & argument_0,                                const GGS_location & argument_1) {    cPtr_C_repeat_instruction * ptr_ = (cPtr_C_repeat_instruction *) NULL ;    macroMyNew (ptr_, cPtr_C_repeat_instruction (argument_0,                                argument_1)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*//                                                                           *//          Class element of list 'L_parse_rewind_signature_list'            *//                                                                           *//---------------------------------------------------------------------------*GGS_L_parse_rewind_signature_list::element_type::element_type (const GGS_L_ruleSyntaxSignature & argument_0,                                const GGS_location & argument_1) {  mNextItem = (element_type *) NULL ;  mSignature = argument_0 ;  mErrorLocation = argument_1 ;}//---------------------------------------------------------------------------*//                                                                           *//                class list 'L_parse_rewind_signature_list'                 *//                                                                           *//---------------------------------------------------------------------------*GGS_L_parse_rewind_signature_list::GGS_L_parse_rewind_signature_list (void) { // Default Constructor  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mCountReference = (sint32 *) NULL ;}//---------------------------------------------------------------------------*GGS_L_parse_rewind_signature_list::~GGS_L_parse_rewind_signature_list (void) {  emptyList () ;}//---------------------------------------------------------------------------*GGS_L_parse_rewind_signature_list::GGS_L_parse_rewind_signature_list (const GGS_L_parse_rewind_signature_list & source) { // Copy constructor  mFirstItem = (element_type *) NULL ;  mLastItem = (element_type *) NULL ;  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mCountReference = (sint32 *) NULL ;  *this = source ;}//---------------------------------------------------------------------------*void GGS_L_parse_rewind_signature_list::operator = (const GGS_L_parse_rewind_signature_list & source) { // Assignment operator  if (this != & source) {    emptyList () ;    mFirstItem = source.mFirstItem ;    mLastItem = source.mLastItem ;    mCurrentItemPtr = (element_type *) NULL ;    mCurrentItemIndex = 0 ;    mListLength = source.mListLength ;    mCountReference = source.mCountReference ;    if (mCountReference != NULL) {      macroValidPointer (mCountReference) ;      (*mCountReference) ++ ;    }  }}//---------------------------------------------------------------------------*void GGS_L_parse_rewind_signature_list::emptyList (void) {  mCurrentItemPtr = (element_type *) NULL ;  mCurrentItemIndex = 0 ;  mListLength = 0 ;  mLastItem = (element_type *) NULL ;  if (mCountReference != NULL) {    macroValidPointer (mCountReference) ;    if ((*mCountReference) == 1) {      macroMyDelete (mCountReference, sint32) ;      while (mFirstItem != NULL) {        macroValidPointer (mFirstItem) ;        mLastItem = mFirstItem->mNextItem ;        macroMyDelete (mFirstItem, element_type) ;        mFirstItem = mLastItem ;      }    }else{      mFirstItem = (element_type *) NULL ;      (*mCountReference) -- ;      mCountReference = (sint32 *) NULL ;    }  }}//---------------------------------------------------------------------------*void GGS_L_parse_rewind_signature_list::internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0,                                const GGS_location & argument_1) {  element_type * nouvelElement = (element_type *) NULL ;  macroMyNew (nouvelElement, element_type (argument_0,                                argument_1)) ;  if (nouvelElement != NULL) {    macroValidPointer (nouvelElement) ;    if (mLastItem == NULL) {      mFirstItem = nouvelElement ;    }else{      macroValidPointer (mLastItem) ;      mLastItem->mNextItem = nouvelElement ;    }    mLastItem = nouvelElement ;    nouvelElement = (element_type *) NULL ;    mListLength ++ ;  }}//---------------------------------------------------------------------------*void GGS_L_parse_rewind_signature_list::addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0,                                const GGS_location & argument_1) {  if (isBuilt ()                 && argument_0.isBuilt ()                 && argument_1.isBuilt ()) {    insulateList () ;    internalAppendItem (argument_0,                                argument_1) ;  }}//---------------------------------------------------------------------------*void GGS_L_parse_rewind_signature_list::insulateList (void) {  if (mCountReference != NULL) {    macroValidPointer (mCountReference) ;    if ((*mCountReference) > 1) {      element_type * p = mFirstItem ;      mFirstItem = (element_type *)  NULL ;      mLastItem = (element_type *)  NULL ;      mListLength = 0 ;      mCurrentItemPtr = (element_type *) NULL ;      mCurrentItemIndex = 0 ;      while (p != NULL) {        macroValidPointer (p) ;        internalAppendItem (p->mSignature,                                p->mErrorLocation) ;        p = p->mNextItem ;      }      (*mCountReference) -- ;      mCountReference = (sint32 *) NULL ;      macroMyNew (mCountReference, sint32 (1)) ;    }  }}//---------------------------------------------------------------------------*GGS_L_parse_rewind_signature_list  GGS_L_parse_rewind_signature_list::constructor_empty (void) {  GGS_L_parse_rewind_signature_list result ;  macroMyNew (result.mCountReference, sint32 (1)) ;  return result ;}//---------------------------------------------------------------------------*void GGS_L_parse_rewind_signature_list::drop_operation (void) {  emptyList () ;}//---------------------------------------------------------------------------*//                                                                           *//                    class 'C_parse_rewind_instruction'                     *//                                                                           *//---------------------------------------------------------------------------*cPtr_C_parse_rewind_instruction::cPtr_C_parse_rewind_instruction (const GGS_location & argument_0,                                const GGS_typeListeBranchesInstructions & argument_1):mInstructionLocation (argument_0),mBranchList (argument_1) {}//---------------------------------------------------------------------------*bool cPtr_C_parse_rewind_instruction::isBuilt (void) const {  return mInstructionLocation.isBuilt () &&       mBranchList.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//              GALGAS class 'GGS_C_parse_rewind_instruction'                *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_C_parse_rewind_instruction * GGS_C_parse_rewind_instruction::    constructor_new (const GGS_location & argument_0,                                const GGS_typeListeBranchesInstructions & argument_1) {    cPtr_C_parse_rewind_instruction * ptr_ = (cPtr_C_parse_rewind_instruction *) NULL ;    macroMyNew (ptr_, cPtr_C_parse_rewind_instruction (argument_0,                                argument_1)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*//                                                                           *//                  class 'C_parse_when_else_instruction'                    *//                                                                           *//---------------------------------------------------------------------------*cPtr_C_parse_when_else_instruction::cPtr_C_parse_when_else_instruction (const GGS_L_expression_instructionsList_list & argument_0,                                const GGS_typeInstructionsList & argument_1):mIFbranchesList (argument_0),mElseInstructionsList (argument_1) {}//---------------------------------------------------------------------------*bool cPtr_C_parse_when_else_instruction::isBuilt (void) const {  return mIFbranchesList.isBuilt () &&       mElseInstructionsList.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//             GALGAS class 'GGS_C_parse_when_else_instruction'              *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_C_parse_when_else_instruction * GGS_C_parse_when_else_instruction::    constructor_new (const GGS_L_expression_instructionsList_list & argument_0,                                const GGS_typeInstructionsList & argument_1) {    cPtr_C_parse_when_else_instruction * ptr_ = (cPtr_C_parse_when_else_instruction *) NULL ;    macroMyNew (ptr_, cPtr_C_parse_when_else_instruction (argument_0,                                argument_1)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*//                                                                           *//                    class 'typeNonterminalToGenerate'                      *//                                                                           *//---------------------------------------------------------------------------*cPtr_typeNonterminalToGenerate::cPtr_typeNonterminalToGenerate (const GGS_lstring & argument_0,                                const GGS_M_nonterminalSymbolAlts & argument_1):aNomNonTerminal (argument_0),mNonterminalSymbolParametersMap (argument_1) {}//---------------------------------------------------------------------------*bool cPtr_typeNonterminalToGenerate::isBuilt (void) const {  return aNomNonTerminal.isBuilt () &&       mNonterminalSymbolParametersMap.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//               GALGAS class 'GGS_typeNonterminalToGenerate'                *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_typeNonterminalToGenerate * GGS_typeNonterminalToGenerate::    constructor_new (const GGS_lstring & argument_0,                                const GGS_M_nonterminalSymbolAlts & argument_1) {    cPtr_typeNonterminalToGenerate * ptr_ = (cPtr_typeNonterminalToGenerate *) NULL ;    macroMyNew (ptr_, cPtr_typeNonterminalToGenerate (argument_0,                                argument_1)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*//                                                                           *//                    class map 'typeAltProductionsMap'                      *//                                                                           *//---------------------------------------------------------------------------*GGS_typeAltProductionsMap::element_type::element_type (const GGS_lstring & inKey,              const sint32 inIndex,              const e_typeAltProductionsMap & inInfo) :AC_galgas_map_element (inIndex),mKey (inKey),mInfo (inInfo) {}//---------------------------------------------------------------------------*AC_galgas_map_element * GGS_typeAltProductionsMap::new_element (void * inKey, void * inInfo) {  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;  M_assert (reinterpret_cast <e_typeAltProductionsMap *> (inInfo) != NULL, "Dynamic cast error", 0, 0) ;  AC_galgas_map_element * p = NULL ;  GGS_lstring * key = (GGS_lstring *) inKey ;  e_typeAltProductionsMap * info = (e_typeAltProductionsMap *) inInfo ;  macroMyNew (p, element_type (* key, getCount (), * info)) ;  return p ;}//---------------------------------------------------------------------------*sint32 GGS_typeAltProductionsMap::element_type::compareKeys (void * inKey) const {  M_assert (reinterpret_cast <GGS_lstring *> (inKey) != NULL, "Dynamic cast error", 0, 0) ;  GGS_lstring * key = (GGS_lstring *) inKey ;  return mKey.compare_key_for_map (* key) ;}//---------------------------------------------------------------------------*GGS_typeAltProductionsMap GGS_typeAltProductionsMap::constructor_empty (void) {  GGS_typeAltProductionsMap result ;  macroMyNew (result.mReferenceCountPtr, sint32 (1)) ;  return result ;}//---------------------------------------------------------------------------*GGS_bool GGS_typeAltProductionsMap::reader_hasKey (const GGS_lstring & inKey) const {  return GGS_bool (isBuilt (), internal_has_key ((void *) & inKey)) ;}//---------------------------------------------------------------------------*void GGS_typeAltProductionsMap::internalInsertForDuplication (AC_galgas_map_element * inPtr) {  M_assert (reinterpret_cast <element_type *> (inPtr) != NULL, "Dynamic cast error", 0, 0) ;  element_type * p = (element_type *) inPtr ;  bool extension = false ; // Unused here  sint32 index = -1 ; // Unused here  internalInsert ((void * ) & p->mKey, (void *) & p->mInfo, mRoot, extension, index) ;}//---------------------------------------------------------------------------*void GGS_typeAltProductionsMap::insertElement (C_lexique & inLexique,               const char * inErrorMessagesArray [],               const GGS_lstring & inKey,               const GGS_typeListeTypesEtNomsArgMethode &  inParameter0,               const GGS_typeInstructionsList &  inParameter1,               const GGS_L_ruleSyntaxSignature &  inParameter2,               const GGS_location &  inParameter3,               GGS_luint * outIndex) {  sint32 index = - 1 ;  if (isBuilt () && inKey.isBuilt ()                 && inParameter0.isBuilt ()                 && inParameter1.isBuilt ()                 && inParameter2.isBuilt ()                 && inParameter3.isBuilt ()) {     insulateMap () ;    e_typeAltProductionsMap info  ;    info.aListeDeTypesEffectifs = inParameter0 ;    info.mAllInstructionsList = inParameter1 ;    info.mSyntaxSignature = inParameter2 ;    info.mEndOfInstructionListLocation = inParameter3 ;    bool extension = false ; // Unused here    internalInsert ((void * ) & inKey, (void *) & info, mRoot, extension, index) ;    if (index < 0) {      C_string keyString ;      keyString << inKey ;      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;     }  }  if (outIndex != NULL) {    * outIndex = GGS_luint (GGS_uint (isBuilt () && (index >= 0), (uint32) index), inKey) ;  }}//---------------------------------------------------------------------------*void GGS_typeAltProductionsMap::searchElement (C_lexique & inLexique,               const char * inErrorMessagesArray [],               const GGS_lstring & inKey,               GGS_typeListeTypesEtNomsArgMethode   * outParameter0,               GGS_typeInstructionsList   * outParameter1,               GGS_L_ruleSyntaxSignature   * outParameter2,               GGS_location   * outParameter3,               GGS_luint * outIndex) {  element_type * node = NULL  ;  if (isBuilt () && inKey.isBuilt ()) {    AC_galgas_map_element * p = internal_search ((void *) & inKey) ;    M_assert ((p == NULL) || (reinterpret_cast <element_type *> (p) != NULL), "Dynamic cast error", 0, 0) ;    node = (element_type *) p ;    if (node == NULL) {      C_string keyString ;      keyString << inKey ;      buildMapSemanticErrorMessage (inLexique, inKey, inErrorMessagesArray, keyString) ;    }  }  if (node == NULL) {    if (outParameter0 != NULL) {      outParameter0->drop_operation () ;    }    if (outParameter1 != NULL) {      outParameter1->drop_operation () ;    }    if (outParameter2 != NULL) {      outParameter2->drop_operation () ;    }    if (outParameter3 != NULL) {      outParameter3->drop_operation () ;    }    if (outIndex != NULL) {      outIndex->drop_operation () ;     }  }else{    if (outParameter0 != NULL) {      * outParameter0 = node->mInfo.aListeDeTypesEffectifs ;    }    if (outParameter1 != NULL) {      * outParameter1 = node->mInfo.mAllInstructionsList ;    }    if (outParameter2 != NULL) {      * outParameter2 = node->mInfo.mSyntaxSignature ;    }    if (outParameter3 != NULL) {      * outParameter3 = node->mInfo.mEndOfInstructionListLocation ;    }    if (outIndex != NULL) {      * outIndex = GGS_luint (GGS_uint (true, (uint32) node->mIndex), inKey) ;    }  }}//---------------------------------------------------------------------------*void searchKey_typeAltProductionsMap (C_lexique & inLexique,                                GGS_typeAltProductionsMap & ioMap,                                const GGS_lstring & inKey,                                GGS_typeListeTypesEtNomsArgMethode   * outParameter0,                                GGS_typeInstructionsList   * outParameter1,                                GGS_L_ruleSyntaxSignature   * outParameter2,                                GGS_location   * outParameter3,                                GGS_luint * outIndex) {  const char * kErrorMessage [] = {"the '",                                   "",                                   "' label is not declared",                                   NULL} ;  ioMap.searchElement (inLexique,                       kErrorMessage,                       inKey,                       outParameter0,                       outParameter1,                       outParameter2,                       outParameter3,                       outIndex) ;}//---------------------------------------------------------------------------*void insertKey_typeAltProductionsMap (C_lexique & lexique_var_,                                GGS_typeAltProductionsMap & ioMap,                                const GGS_lstring & inKey,                                const GGS_typeListeTypesEtNomsArgMethode & inParameter0,                                const GGS_typeInstructionsList & inParameter1,                                const GGS_L_ruleSyntaxSignature & inParameter2,                                const GGS_location & inParameter3,                                GGS_luint * outIndex) {  const char * kErrorMessage [] = {"the '",                                   "",                                   "' label has been already declared",                                   NULL} ;  ioMap.insertElement (lexique_var_,                       kErrorMessage,                       inKey,                       inParameter0,                       inParameter1,                       inParameter2,                       inParameter3,                       outIndex) ;}//---------------------------------------------------------------------------*//                                                                           *//                     class 'typeProductionAengendrer'                      *//                                                                           *//---------------------------------------------------------------------------*cPtr_typeProductionAengendrer::cPtr_typeProductionAengendrer (const GGS_lstring & argument_0,                                const GGS_typeAltProductionsMap & argument_1,                                const GGS_string& argument_2,                                const GGS_bool& argument_3):aNomProduction (argument_0),mAltProductionMap (argument_1),mProductionTagName (argument_2),mHasParseLabel (argument_3) {}//---------------------------------------------------------------------------*bool cPtr_typeProductionAengendrer::isBuilt (void) const {  return aNomProduction.isBuilt () &&       mAltProductionMap.isBuilt () &&       mProductionTagName.isBuilt () &&       mHasParseLabel.isBuilt () ;}//---------------------------------------------------------------------------*//                                                                           *//               GALGAS class 'GGS_typeProductionAengendrer'                 *//                                                                           *//---------------------------------------------------------------------------*#ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE  cPtr_typeProductionAengendrer * GGS_typeProductionAengendrer::    constructor_new (const GGS_lstring & argument_0,                                const GGS_typeAltProductionsMap & argument_1,                                const GGS_string& argument_2,                                const GGS_bool& argument_3) {    cPtr_typeProductionAengendrer * ptr_ = (cPtr_typeProductionAengendrer *) NULL ;    macroMyNew (ptr_, cPtr_typeProductionAengendrer (argument_0,                                argument_1,                                argument_2,                                argument_3)) ;    return ptr_ ;  }#endif//---------------------------------------------------------------------------*