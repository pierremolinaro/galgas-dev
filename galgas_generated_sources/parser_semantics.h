//---------------------------------------------------------------------------*//                                                                           *//                        File 'parser_semantics.h'                          *//               Generated by version 0.14.0 (LL(1) grammar)                 *//                     january 13th, 2005, at 17h52'40"                      *//                                                                           *// This program is free software; you can redistribute it and/or modify it   *// under the terms of the GNU General Public License as published by the     *// Free Software Foundation.                                                 *//                                                                           *// This program is distributed in the hope it will be useful, but WITHOUT    *// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *// more details.                                                             *//                                                                           *//---------------------------------------------------------------------------*//--- START OF USER ZONE 1//--- END OF USER ZONE 1#ifndef parser_semantics_DEFINED#define parser_semantics_DEFINED#include <string.h>// Include predefined semantics types definition *#include "memory/C_reference_count.h"#include "galgas/AC_galgas_io.h"#include "galgas/GGS_location.h"#include "galgas/GGS_lbool.h"#include "galgas/GGS_lchar.h"#include "galgas/GGS_lstring.h"#include "galgas/GGS_ldfloat.h"#include "galgas/GGS_luint.h"#include "galgas/GGS_lsint.h"#include "galgas/AC_galgas_map.h"// Include scanner definition *#include "galgas/C_lexique.h"// Include imported semantics *#include "semantics_semantics.h"//--- START OF USER ZONE 2//--- END OF USER ZONE 2class cPtr_typeParserInstruction ;//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_typeParserInstruction'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeParserInstruction {  protected : cPtr_typeParserInstruction * mPointer ;  public : GGS_typeParserInstruction (void) ;  public : GGS_typeParserInstruction (const GGS_typeParserInstruction &) ;  public : virtual ~GGS_typeParserInstruction (void) ;  public : void operator = (const GGS_typeParserInstruction &) ;  public : bool isBuilt (void) const ;  public : inline bool isEqualTo (const GGS_typeParserInstruction & operand_) const {    return mPointer == operand_.mPointer ;  }  public : void operator = (cPtr_typeParserInstruction * inSource) ;  public : GGS_typeParserInstruction (cPtr_typeParserInstruction * inSource) ;  public : inline cPtr_typeParserInstruction * getPtr (void) const {    return mPointer ;  }  public : void drop_operation (void) ;  public : cPtr_typeParserInstruction * operator () (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                class list 'typeListeBranchesInstructions'                 *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeBranchesInstructions {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_typeInstructionsList  mInstructionsList ;    public : element_type (const GGS_typeInstructionsList & ) ;    public : inline element_type * getNextItem (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeBranchesInstructions ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 getCount (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeBranchesInstructions (void) ; // Default Constructor  public : GGS_typeListeBranchesInstructions (const GGS_typeListeBranchesInstructions &) ; // Copy constructor  public : void operator = (const GGS_typeListeBranchesInstructions &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeBranchesInstructions (void) ;//--- Constructor 'new'  public : static GGS_typeListeBranchesInstructions constructor_empty (void) ;//--- Get first item  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_typeInstructionsList & argument_0) ;  protected : void internalAppendItem (const GGS_typeInstructionsList & argument_0) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;//---------------------------------------------------------------------------*//                                                                           *//                class list 'L_parse_rewind_signature_list'                 *//                                                                           *//---------------------------------------------------------------------------*class GGS_L_parse_rewind_signature_list {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_L_ruleSyntaxSignature  mSignature ;    public : GGS_location  mErrorLocation ;    public : element_type (const GGS_L_ruleSyntaxSignature & ,                                const GGS_location & ) ;    public : inline element_type * getNextItem (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_L_parse_rewind_signature_list ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 getCount (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_L_parse_rewind_signature_list (void) ; // Default Constructor  public : GGS_L_parse_rewind_signature_list (const GGS_L_parse_rewind_signature_list &) ; // Copy constructor  public : void operator = (const GGS_L_parse_rewind_signature_list &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_L_parse_rewind_signature_list (void) ;//--- Constructor 'new'  public : static GGS_L_parse_rewind_signature_list constructor_empty (void) ;//--- Get first item  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_L_ruleSyntaxSignature & argument_0,                                const GGS_location & argument_1) ;  protected : void internalAppendItem (const GGS_L_ruleSyntaxSignature & argument_0,                                const GGS_location & argument_1) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;//---------------------------------------------------------------------------*//                                                                           *//               DECLARATIONS FOR MAP 'typeAltProductionsMap'                *//                                                                           *//---------------------------------------------------------------------------*class e_typeAltProductionsMap {  public : GGS_typeListeTypesEtNomsArgMethode  aListeDeTypesEffectifs ;  public : GGS_typeInstructionsList  mAllInstructionsList ;  public : GGS_L_ruleSyntaxSignature  mSyntaxSignature ;  public : GGS_location  mEndOfInstructionListLocation ;} ;//---------------------------------------------------------------------------*class GGS_typeAltProductionsMap : public AC_galgas_map {//--- Internal class for an element  public : class element_type : public AC_galgas_map_element {  //--- Constructor    public : element_type (const GGS_lstring & inKey,                           const sint32 inIndex,                           const e_typeAltProductionsMap & inInfo) ;  //--- Method for key compare    public : virtual sint32 compareKeys (void * inKey) const ;  //--- Get pointers    public : inline element_type * getNextItem (void) const { return (element_type *) mNextItem ; }    public : inline element_type * getInfPtr (void) const { return (element_type *) mInfPtr ; }    public : inline element_type * getSupPtr (void) const { return (element_type *) mSupPtr ; }  //--- Data members    public : const GGS_lstring mKey ;    public : e_typeAltProductionsMap mInfo ;  } ;//--- Get pointers  public : inline element_type * getRoot (void) const { return (element_type *) mRoot ; }  public : inline element_type * getFirstItem (void) const { return (element_type *) mFirstItem ; }  public : inline element_type * getLastItem (void) const { return (element_type *) mLastItem ; }//--- Create a new element  protected : virtual AC_galgas_map_element * new_element (void * inKey, void * inInfo) ;//--- 'empty' constructor  public : static GGS_typeAltProductionsMap constructor_empty (void) ;//--- 'hasKey' reader  public : GGS_bool reader_hasKey (const GGS_lstring & inKey) const ;//--- Method used for duplicate a map  protected : virtual void internalInsertForDuplication (AC_galgas_map_element * inPtr) ;//--- Insert an element  public : void insertElement (C_lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               const GGS_typeListeTypesEtNomsArgMethode & inParameter0,                               const GGS_typeInstructionsList & inParameter1,                               const GGS_L_ruleSyntaxSignature & inParameter2,                               const GGS_location & inParameter3,                               GGS_luint * outIndex) ;//--- Search for an element  public : void searchElement (C_lexique & inLexique,                               const char * inErrorMessagesArray [],                               const GGS_lstring & inKey,                               GGS_typeListeTypesEtNomsArgMethode * outParameter0,                               GGS_typeInstructionsList * outParameter1,                               GGS_L_ruleSyntaxSignature * outParameter2,                               GGS_location * outParameter3,                               GGS_luint * outIndex) ;} ;//---------------------------------------------------------------------------*void searchKey_typeAltProductionsMap (C_lexique & inLexique,                                GGS_typeAltProductionsMap & ioMap,                                const GGS_lstring & inKey,                                GGS_typeListeTypesEtNomsArgMethode   * outParameter0,                                GGS_typeInstructionsList   * outParameter1,                                GGS_L_ruleSyntaxSignature   * outParameter2,                                GGS_location   * outParameter3,                                GGS_luint * outIndex) ;//---------------------------------------------------------------------------*void insertKey_typeAltProductionsMap (C_lexique & inLexique,                                GGS_typeAltProductionsMap & ioMap,                                const GGS_lstring & inKey,                                const GGS_typeListeTypesEtNomsArgMethode &  inParameter0,                                const GGS_typeInstructionsList &  inParameter1,                                const GGS_L_ruleSyntaxSignature &  inParameter2,                                const GGS_location &  inParameter3,                                GGS_luint * outIndex) ;#include "include_typeParserInstruction.h"//---------------------------------------------------------------------------*//                                                                           *//                 class 'typeInstructionAppelNonTerminal'                   *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInstructionAppelNonTerminal#define macroInheritFrom_typeInstructionAppelNonTerminalclass cPtr_typeInstructionAppelNonTerminal : public cPtr_typeParserInstruction {  private : typedef cPtr_typeParserInstruction inherited ;  macroInheritFrom_typeInstruction  macroInheritFrom_typeParserInstruction  macro_typeInstructionAppelNonTerminal  public : cPtr_typeInstructionAppelNonTerminal (const GGS_lstring & ,                                const GGS_typeExpressionList & ,                                const GGS_lstring & ) ;  public : GGS_lstring  mNonterminalName ;  public : GGS_typeExpressionList  mParametersExpressionList ;  public : GGS_lstring  mAltName ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//            GALGAS class 'GGS_typeInstructionAppelNonTerminal'             *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionAppelNonTerminal {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInstructionAppelNonTerminal * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeExpressionList & argument_1,                                const GGS_lstring & argument_2) ;  #else    public : inline static cPtr_typeInstructionAppelNonTerminal * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeExpressionList & argument_1,                                const GGS_lstring & argument_2) {      return new cPtr_typeInstructionAppelNonTerminal(argument_0,                                argument_1,                                argument_2) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                  class 'typeInstructionVerifSyntaxique'                   *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInstructionVerifSyntaxique#define macroInheritFrom_typeInstructionVerifSyntaxiqueclass cPtr_typeInstructionVerifSyntaxique : public cPtr_typeParserInstruction {  private : typedef cPtr_typeParserInstruction inherited ;  macroInheritFrom_typeInstruction  macroInheritFrom_typeParserInstruction  macro_typeInstructionVerifSyntaxique  public : cPtr_typeInstructionVerifSyntaxique (const GGS_lstring & ,                                const GGS_L_assignedVariables & ) ;  public : GGS_lstring  aNomTerminal ;  public : GGS_L_assignedVariables  aListeTypeEffectifs ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//            GALGAS class 'GGS_typeInstructionVerifSyntaxique'              *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInstructionVerifSyntaxique {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInstructionVerifSyntaxique * constructor_new (const GGS_lstring & argument_0,                                const GGS_L_assignedVariables & argument_1) ;  #else    public : inline static cPtr_typeInstructionVerifSyntaxique * constructor_new (const GGS_lstring & argument_0,                                const GGS_L_assignedVariables & argument_1) {      return new cPtr_typeInstructionVerifSyntaxique(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                       class 'C_select_instruction'                        *//                                                                           *//---------------------------------------------------------------------------*#define macro_C_select_instruction#define macroInheritFrom_C_select_instructionclass cPtr_C_select_instruction : public cPtr_typeParserInstruction {  private : typedef cPtr_typeParserInstruction inherited ;  macroInheritFrom_typeInstruction  macroInheritFrom_typeParserInstruction  macro_C_select_instruction  public : cPtr_C_select_instruction (const GGS_typeListeBranchesInstructions & ,                                const GGS_location & ) ;  public : GGS_typeListeBranchesInstructions  mIFbranchesList ;  public : GGS_location  aPositionDebut ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_C_select_instruction'                   *//                                                                           *//---------------------------------------------------------------------------*class GGS_C_select_instruction {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_C_select_instruction * constructor_new (const GGS_typeListeBranchesInstructions & argument_0,                                const GGS_location & argument_1) ;  #else    public : inline static cPtr_C_select_instruction * constructor_new (const GGS_typeListeBranchesInstructions & argument_0,                                const GGS_location & argument_1) {      return new cPtr_C_select_instruction(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                       class 'C_repeat_instruction'                        *//                                                                           *//---------------------------------------------------------------------------*#define macro_C_repeat_instruction#define macroInheritFrom_C_repeat_instructionclass cPtr_C_repeat_instruction : public cPtr_typeParserInstruction {  private : typedef cPtr_typeParserInstruction inherited ;  macroInheritFrom_typeInstruction  macroInheritFrom_typeParserInstruction  macro_C_repeat_instruction  public : cPtr_C_repeat_instruction (const GGS_typeListeBranchesInstructions & ,                                const GGS_location & ) ;  public : GGS_typeListeBranchesInstructions  aListesBranchesRepeter ;  public : GGS_location  aPositionDebut ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                 GALGAS class 'GGS_C_repeat_instruction'                   *//                                                                           *//---------------------------------------------------------------------------*class GGS_C_repeat_instruction {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_C_repeat_instruction * constructor_new (const GGS_typeListeBranchesInstructions & argument_0,                                const GGS_location & argument_1) ;  #else    public : inline static cPtr_C_repeat_instruction * constructor_new (const GGS_typeListeBranchesInstructions & argument_0,                                const GGS_location & argument_1) {      return new cPtr_C_repeat_instruction(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                    class 'C_parse_rewind_instruction'                     *//                                                                           *//---------------------------------------------------------------------------*#define macro_C_parse_rewind_instruction#define macroInheritFrom_C_parse_rewind_instructionclass cPtr_C_parse_rewind_instruction : public cPtr_typeParserInstruction {  private : typedef cPtr_typeParserInstruction inherited ;  macroInheritFrom_typeInstruction  macroInheritFrom_typeParserInstruction  macro_C_parse_rewind_instruction  public : cPtr_C_parse_rewind_instruction (const GGS_location & ,                                const GGS_typeListeBranchesInstructions & ) ;  public : GGS_location  mInstructionLocation ;  public : GGS_typeListeBranchesInstructions  mBranchList ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//              GALGAS class 'GGS_C_parse_rewind_instruction'                *//                                                                           *//---------------------------------------------------------------------------*class GGS_C_parse_rewind_instruction {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_C_parse_rewind_instruction * constructor_new (const GGS_location & argument_0,                                const GGS_typeListeBranchesInstructions & argument_1) ;  #else    public : inline static cPtr_C_parse_rewind_instruction * constructor_new (const GGS_location & argument_0,                                const GGS_typeListeBranchesInstructions & argument_1) {      return new cPtr_C_parse_rewind_instruction(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                  class 'C_parse_when_else_instruction'                    *//                                                                           *//---------------------------------------------------------------------------*#define macro_C_parse_when_else_instruction#define macroInheritFrom_C_parse_when_else_instructionclass cPtr_C_parse_when_else_instruction : public cPtr_typeParserInstruction {  private : typedef cPtr_typeParserInstruction inherited ;  macroInheritFrom_typeInstruction  macroInheritFrom_typeParserInstruction  macro_C_parse_when_else_instruction  public : cPtr_C_parse_when_else_instruction (const GGS_L_expression_instructionsList_list & ,                                const GGS_typeInstructionsList & ) ;  public : GGS_L_expression_instructionsList_list  mIFbranchesList ;  public : GGS_typeInstructionsList  mElseInstructionsList ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//             GALGAS class 'GGS_C_parse_when_else_instruction'              *//                                                                           *//---------------------------------------------------------------------------*class GGS_C_parse_when_else_instruction {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_C_parse_when_else_instruction * constructor_new (const GGS_L_expression_instructionsList_list & argument_0,                                const GGS_typeInstructionsList & argument_1) ;  #else    public : inline static cPtr_C_parse_when_else_instruction * constructor_new (const GGS_L_expression_instructionsList_list & argument_0,                                const GGS_typeInstructionsList & argument_1) {      return new cPtr_C_parse_when_else_instruction(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                    class 'typeNonterminalToGenerate'                      *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeNonterminalToGenerate#define macroInheritFrom_typeNonterminalToGenerateclass cPtr_typeNonterminalToGenerate : public cPtr_typeEntityToGenerate {  private : typedef cPtr_typeEntityToGenerate inherited ;  macroInheritFrom_typeEntityToGenerate  macro_typeNonterminalToGenerate  public : cPtr_typeNonterminalToGenerate (const GGS_lstring & ,                                const GGS_M_nonterminalSymbolAlts & ) ;  public : GGS_lstring  aNomNonTerminal ;  public : GGS_M_nonterminalSymbolAlts  mNonterminalSymbolParametersMap ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//               GALGAS class 'GGS_typeNonterminalToGenerate'                *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeNonterminalToGenerate {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeNonterminalToGenerate * constructor_new (const GGS_lstring & argument_0,                                const GGS_M_nonterminalSymbolAlts & argument_1) ;  #else    public : inline static cPtr_typeNonterminalToGenerate * constructor_new (const GGS_lstring & argument_0,                                const GGS_M_nonterminalSymbolAlts & argument_1) {      return new cPtr_typeNonterminalToGenerate(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                     class 'typeProductionAengendrer'                      *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeProductionAengendrer#define macroInheritFrom_typeProductionAengendrerclass cPtr_typeProductionAengendrer : public cPtr_typeEntityToGenerate {  private : typedef cPtr_typeEntityToGenerate inherited ;  macroInheritFrom_typeEntityToGenerate  macro_typeProductionAengendrer  public : cPtr_typeProductionAengendrer (const GGS_lstring & ,                                const GGS_typeAltProductionsMap & ,                                const GGS_string& ,                                const GGS_bool& ) ;  public : GGS_lstring  aNomProduction ;  public : GGS_typeAltProductionsMap  mAltProductionMap ;  public : GGS_string mProductionTagName ;  public : GGS_bool mHasParseLabel ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//               GALGAS class 'GGS_typeProductionAengendrer'                 *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeProductionAengendrer {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeProductionAengendrer * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeAltProductionsMap & argument_1,                                const GGS_string& argument_2,                                const GGS_bool& argument_3) ;  #else    public : inline static cPtr_typeProductionAengendrer * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeAltProductionsMap & argument_1,                                const GGS_string& argument_2,                                const GGS_bool& argument_3) {      return new cPtr_typeProductionAengendrer(argument_0,                                argument_1,                                argument_2,                                argument_3) ;    }  #endif} ;//---------------------------------------------------------------------------*#endif