//---------------------------------------------------------------------------*//                                                                           *//                        File 'grammar_semantics.h'                         *//               Generated by version 0.14.0 (LL(1) grammar)                 *//                     january 13th, 2005, at 17h52'36"                      *//                                                                           *// This program is free software; you can redistribute it and/or modify it   *// under the terms of the GNU General Public License as published by the     *// Free Software Foundation.                                                 *//                                                                           *// This program is distributed in the hope it will be useful, but WITHOUT    *// ANY WARRANTY; without even the implied warranty of MERCHANDIBILITY or     *// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *// more details.                                                             *//                                                                           *//---------------------------------------------------------------------------*//--- START OF USER ZONE 1//--- END OF USER ZONE 1#ifndef grammar_semantics_DEFINED#define grammar_semantics_DEFINED#include <string.h>// Include predefined semantics types definition *#include "memory/C_reference_count.h"#include "galgas/AC_galgas_io.h"#include "galgas/GGS_location.h"#include "galgas/GGS_lbool.h"#include "galgas/GGS_lchar.h"#include "galgas/GGS_lstring.h"#include "galgas/GGS_ldfloat.h"#include "galgas/GGS_luint.h"#include "galgas/GGS_lsint.h"#include "galgas/AC_galgas_map.h"// Include scanner definition *#include "galgas/C_lexique.h"// Include imported semantics *#include "common_semantics.h"//--- START OF USER ZONE 2//--- END OF USER ZONE 2//---------------------------------------------------------------------------*//                                                                           *//                  class list 'typeListeAttributsAxiome'                    *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeAttributsAxiome {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_lstring  aAttributAxiome ;    public : element_type (const GGS_lstring & ) ;    public : inline element_type * getNextItem (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeAttributsAxiome ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 getCount (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeAttributsAxiome (void) ; // Default Constructor  public : GGS_typeListeAttributsAxiome (const GGS_typeListeAttributsAxiome &) ; // Copy constructor  public : void operator = (const GGS_typeListeAttributsAxiome &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeAttributsAxiome (void) ;//--- Constructor 'new'  public : static GGS_typeListeAttributsAxiome constructor_empty (void) ;//--- Get first item  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_lstring & argument_0) ;  protected : void internalAppendItem (const GGS_lstring & argument_0) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;//---------------------------------------------------------------------------*//                                                                           *//                      class list 'typeListeChaines'                        *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeListeChaines {  public : class element_type {    private : element_type * mNextItem ;    public : GGS_lstring  attributChaine ;    public : element_type (const GGS_lstring & ) ;    public : inline element_type * getNextItem (void) const { return mNextItem ; }    private : element_type (const element_type &) ;    private : void operator = (const element_type &) ;    public : ~element_type (void) {}    friend class GGS_typeListeChaines ;  } ;  private : element_type * mFirstItem ;  private : element_type * mLastItem ;  private : element_type * mCurrentItemPtr ;  private : sint32 mCurrentItemIndex ;  private : sint32 mListLength ;  public : inline sint32 getCount (void) const {    return mListLength ;  }  private : sint32 * mCountReference ;  public : GGS_typeListeChaines (void) ; // Default Constructor  public : GGS_typeListeChaines (const GGS_typeListeChaines &) ; // Copy constructor  public : void operator = (const GGS_typeListeChaines &) ; // Assignment operator//--- Virtual destructor  public : virtual ~GGS_typeListeChaines (void) ;//--- Constructor 'new'  public : static GGS_typeListeChaines constructor_empty (void) ;//--- Get first item  public : inline element_type * getFirstItem (void) const { return mFirstItem ; }  public : void addAssign_operation (const GGS_lstring & argument_0) ;  protected : void internalAppendItem (const GGS_lstring & argument_0) ;  public : void insulateList (void) ;  public : void emptyList (void) ;  public : inline bool isBuilt (void) const {    return mCountReference != NULL ;  }  public : void drop_operation (void) ;  public : inline GGS_uint reader_length (void)  const {    return GGS_uint (mCountReference != NULL, (uint32) mListLength) ;  }} ;class cPtr_typeAbstraitInclusionM ;//---------------------------------------------------------------------------*//                                                                           *//                GALGAS class 'GGS_typeAbstraitInclusionM'                  *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeAbstraitInclusionM {  protected : cPtr_typeAbstraitInclusionM * mPointer ;  public : GGS_typeAbstraitInclusionM (void) ;  public : GGS_typeAbstraitInclusionM (const GGS_typeAbstraitInclusionM &) ;  public : virtual ~GGS_typeAbstraitInclusionM (void) ;  public : void operator = (const GGS_typeAbstraitInclusionM &) ;  public : bool isBuilt (void) const ;  public : inline bool isEqualTo (const GGS_typeAbstraitInclusionM & operand_) const {    return mPointer == operand_.mPointer ;  }  public : void operator = (cPtr_typeAbstraitInclusionM * inSource) ;  public : GGS_typeAbstraitInclusionM (cPtr_typeAbstraitInclusionM * inSource) ;  public : inline cPtr_typeAbstraitInclusionM * getPtr (void) const {    return mPointer ;  }  public : void drop_operation (void) ;  public : cPtr_typeAbstraitInclusionM * operator () (void) const ;} ;#include "include_typeAbstraitInclusionM.h"//---------------------------------------------------------------------------*//                                                                           *//                        class 'typePasInclusionM'                          *//                                                                           *//---------------------------------------------------------------------------*#define macro_typePasInclusionM#define macroInheritFrom_typePasInclusionMclass cPtr_typePasInclusionM : public cPtr_typeAbstraitInclusionM {  private : typedef cPtr_typeAbstraitInclusionM inherited ;  macroInheritFrom_typeAbstraitInclusionM  macro_typePasInclusionM  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                   GALGAS class 'GGS_typePasInclusionM'                    *//                                                                           *//---------------------------------------------------------------------------*class GGS_typePasInclusionM {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typePasInclusionM * constructor_new () ;  #else    public : inline static cPtr_typePasInclusionM * constructor_new () {      return new cPtr_typePasInclusionM() ;    }  #endif} ;//---------------------------------------------------------------------------*//                                                                           *//                          class 'typeInclusionM'                           *//                                                                           *//---------------------------------------------------------------------------*#define macro_typeInclusionM#define macroInheritFrom_typeInclusionMclass cPtr_typeInclusionM : public cPtr_typeAbstraitInclusionM {  private : typedef cPtr_typeAbstraitInclusionM inherited ;  macroInheritFrom_typeAbstraitInclusionM  macro_typeInclusionM  public : cPtr_typeInclusionM (const GGS_lstring & ,                                const GGS_typeListeChaines & ) ;  public : GGS_lstring  attributNomFichier ;  public : GGS_typeListeChaines  aListeInclure ;  public : virtual bool isBuilt (void) const ;} ;//---------------------------------------------------------------------------*//                                                                           *//                    GALGAS class 'GGS_typeInclusionM'                      *//                                                                           *//---------------------------------------------------------------------------*class GGS_typeInclusionM {  #ifndef DO_NOT_GENERATE_MEMORY_CHECK_CODE    public : static cPtr_typeInclusionM * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeListeChaines & argument_1) ;  #else    public : inline static cPtr_typeInclusionM * constructor_new (const GGS_lstring & argument_0,                                const GGS_typeListeChaines & argument_1) {      return new cPtr_typeInclusionM(argument_0,                                argument_1) ;    }  #endif} ;//---------------------------------------------------------------------------*#endif