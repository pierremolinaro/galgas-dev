#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @plusEqualElementsInstructionAST : @semanticInstructionAST {
  private let @bool mPrefixedBySelf
  private let @lstring mReceiverName
  private let @lstringlist mStructAttributeList
  private let @actualOutputExpressionList mExpressions
}

#······················································································································

refclass @plusEqualExpressionInstructionAST : @semanticInstructionAST {
  private let @bool mPrefixedBySelf
  private let @lstring mReceiverName
  private let @lstringlist mStructAttributeList
  private let @semanticExpressionAST mExpression
}

#······················································································································

refclass @minusEqualExpressionInstructionAST : @semanticInstructionAST {
  private let @bool mPrefixedBySelf
  private let @lstring mReceiverName
  private let @lstringlist mStructAttributeList
  private let @semanticExpressionAST mExpression
}

#······················································································································

refclass @mulEqualExpressionInstructionAST : @semanticInstructionAST {
  private let @bool mPrefixedBySelf
  private let @lstring mReceiverName
  private let @lstringlist mStructAttributeList
  private let @semanticExpressionAST mExpression
}

#······················································································································

refclass @divEqualExpressionInstructionAST : @semanticInstructionAST {
  private let @bool mPrefixedBySelf
  private let @lstring mReceiverName
  private let @lstringlist mStructAttributeList
  private let @semanticExpressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    <semantic_instruction_beginning_with_identifier> !prefixedBySelf: false ?outInstruction
  }
  #·····················································································································

  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $self$
    $.$
    <semantic_instruction_beginning_with_identifier> !prefixedBySelf: true ?outInstruction
  }

  #·····················································································································

  rule <semantic_instruction_beginning_with_identifier>
        ?prefixedBySelf: let @bool inHasSelfPrefix
        !@semanticInstructionAST outInstruction {
    $identifier$ ?let @lstring receiverName
    let instructionLocation = @location.here
    var @lstringlist mStructAttributeList = {}
    repeat
    while
      $.$
      $identifier$ ?let attributeName
      mStructAttributeList += !attributeName
    end
    select
      $-=$
      <expression_ggs3> ?let @semanticExpressionAST expression
      outInstruction = @minusEqualExpressionInstructionAST.new {
        !instructionLocation
        !inHasSelfPrefix
        !receiverName
        !mStructAttributeList
        !expression
      }
    or
      $+=$
      select
        <non_empty_output_expression_list_ggs3> ?let @actualOutputExpressionList expressionList
        outInstruction = @plusEqualElementsInstructionAST.new {
          !instructionLocation
          !inHasSelfPrefix
          !receiverName
          !mStructAttributeList
          !expressionList
        }
      or
        <expression_ggs3> ?let @semanticExpressionAST expression
        outInstruction = @plusEqualExpressionInstructionAST.new {
          !instructionLocation
          !inHasSelfPrefix
          !receiverName
          !mStructAttributeList
          !expression
        }
      end
    or
      $*=$
      <expression_ggs3> ?let @semanticExpressionAST expression
      outInstruction = @mulEqualExpressionInstructionAST.new {
        !instructionLocation
        !inHasSelfPrefix
        !receiverName
        !mStructAttributeList
        !expression
      }
    or
      $/=$
      <expression_ggs3> ?let @semanticExpressionAST expression
      outInstruction = @divEqualExpressionInstructionAST.new {
        !instructionLocation
        !inHasSelfPrefix
        !receiverName
        !mStructAttributeList
        !expression
      }
    end
  }  

  #·····················································································································

  rule <non_empty_output_expression_list_ggs3> !@actualOutputExpressionList outExpressionList {
    outExpressionList = {}
    repeat
      $!$ ?let selector
      <expression_ggs3> ?let @semanticExpressionAST expression
      outExpressionList += !selector !expression !@location.here
    while
    end
  }

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations
                              ?!@stringset unused ioUserImplicitDeclaredTypeSet
                              !@semanticInstructionAST outInstruction {
    <semantic_instruction_beginning_with_identifier> !prefixedBySelf: false ?outInstruction
  }
  #·····················································································································

  rule <semantic_instruction> ?!@galgasDeclarationAST unused ioDeclarations
                              ?!@stringset unused ioUserImplicitDeclaredTypeSet
                              !@semanticInstructionAST outInstruction {
    $self$
    $.$
    <semantic_instruction_beginning_with_identifier> !prefixedBySelf: true ?outInstruction
  }

  #·····················································································································

  rule <semantic_instruction_beginning_with_identifier>
        ?prefixedBySelf: let @bool inHasSelfPrefix
        !@semanticInstructionAST outInstruction {
    $identifier$ ?let @lstring receiverName
    let instructionLocation = @location.here
    var @lstringlist propertyList = {}
    repeat
    while
      $.$
      $identifier$ ?let attributeName
      propertyList += !attributeName
    end
  #---
    select
      $-=$
      <expression> ?let @semanticExpressionAST expression
      outInstruction = @minusEqualExpressionInstructionAST.new {
        !instructionLocation
        !inHasSelfPrefix
        !receiverName
        !propertyList
        !expression
      }
    or
      $+=$
#      select
#        <non_empty_output_expression_list> ?let @actualOutputExpressionList expressionList
#        warning .here : "obsolete"
#        outInstruction = @plusEqualElementsInstructionAST.new {
#          !instructionLocation
#          !inHasSelfPrefix
#          !receiverName
#          !propertyList
#          !expressionList
#        }
#      or
        <expression> ?let @semanticExpressionAST expression
        outInstruction = @plusEqualExpressionInstructionAST.new {
          !instructionLocation
          !inHasSelfPrefix
          !receiverName
          !propertyList
          !expression
        }
#      end
    or
      $*=$
      <expression> ?let @semanticExpressionAST expression
      outInstruction = @mulEqualExpressionInstructionAST.new {
        !instructionLocation
        !inHasSelfPrefix
        !receiverName
        !propertyList
        !expression
      }
    or
      $/=$
      <expression> ?let @semanticExpressionAST expression
      outInstruction = @divEqualExpressionInstructionAST.new {
        !instructionLocation
        !inHasSelfPrefix
        !receiverName
        !propertyList
        !expression
      }
    or
      <actual_parameter_list_within_parenthesis> ?let @actualParameterListAST actualParameterList
      if inHasSelfPrefix then
        if [propertyList length] == 0 then
          outInstruction = @methodCallInstructionAST.new {
            !instructionLocation
            !@selfInExpressionAST.new {!instructionLocation}
            !receiverName # Method name
            !actualParameterList
          }
        else
          [!?propertyList popLast ?let methodName]
          var @semanticExpressionAST receiverExpression = @selfInExpressionAST.new {!@location.here}
          receiverExpression = @structPropertyAccessExpressionAST.new {!receiverName.location !receiverExpression !receiverName}
          for (propertyName) in propertyList do
            receiverExpression = @structPropertyAccessExpressionAST.new {!propertyName.location !receiverExpression !propertyName}
          end
          outInstruction = @methodCallInstructionAST.new {
            !instructionLocation
            !receiverExpression
            !methodName
            !actualParameterList
          }
        end
      elsif [propertyList length] == 0 then
        outInstruction = @procCallInstructionAST.new {
          !receiverName.location
          !receiverName # Proc name
          !actualParameterList
        }
      else
        [!?propertyList popLast ?let methodName]
        var @semanticExpressionAST receiverExpression = @varInExpressionAST.new {!receiverName}
        for (propertyName) in propertyList do
          receiverExpression = @structPropertyAccessExpressionAST.new {!propertyName.location !receiverExpression !propertyName}
        end
        outInstruction = @methodCallInstructionAST.new {
          !instructionLocation
          !receiverExpression
          !methodName
          !actualParameterList
        }
      end
    end
  }  

  #·····················································································································

#  rule <non_empty_output_expression_list> !@actualOutputExpressionList outExpressionList {
#    outExpressionList = {}
#    repeat
#      $!$ ?let selector
#      <expression> ?let @semanticExpressionAST expression
#      outExpressionList += !selector !expression !@location.here
#    while
#    end
#  }

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @plusEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @minusEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @mulEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @divEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#·····················································································································*

override method @plusEqualElementsInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [self.mExpressions enterInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @plusEqualExpressionInstructionAST analyzeSemanticInstruction # += exp
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable, or self.property
  var @unifiedTypeMapEntry targetType
  let @string targetVariableCppName
  let @string nameForCheckingFormalParameterUsing
  if self.mPrefixedBySelf then
    if let [inAnalysisContext.selfType available ?type: let selfType ?1* ?mutableproperties: let mutableProperties] then
      if not mutableProperties then
        error self.mInstructionLocation : "property not mutable in this context"
      end
      let propertyMap = [selfType definition].mPropertyMap
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?targetType]
      nameForCheckingFormalParameterUsing = inAnalysisContext.mSelfObjectCppName
      targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
        + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
      if isConstant then
        error self.mReceiverName : "a constant property cannot be modified"
      end
      if not mutableProperties then
        error self.mReceiverName : "the property is not mutable in this context"
      end
    else
      error self.mInstructionLocation : "'self' not available in this context"
      : targetType, targetVariableCppName, nameForCheckingFormalParameterUsing
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mReceiverName
      ?targetType
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  end
  for (value) in self.mStructAttributeList do
    let propertyMap = [targetType definition].mPropertyMap
    [propertyMap searchKey !value ?let accessControl ?let isConstant ?targetType]
    [accessControl checkSetAccess !inAnalysisContext.selfType !value.location]
#    if not isPublic then
#      error mValue : " inaccessible property (due to its 'private' qualifier)"
#    end
    if isConstant then
      error value : "a constant property cannot be modified"
    end
  end
#--- Check target variable type support '+= exp' operator
  if not [[targetType definition].mHandledOperatorFlags plusEqualOperatorWithExpression] then
    error self.mInstructionLocation
    :"the target object has the '@" + [targetType definition].mTypeName.string + "' type, but this type does not support the '+=' operator"
  end
#--- Analyze source expression
  [self.mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType:  targetType
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType !expression.mResultType !self.mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
    !self.mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mStructAttributeList
    !expression
    !"plusAssign_operation"
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @minusEqualExpressionInstructionAST analyzeSemanticInstruction # -= exp
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable, or self.property
  var @unifiedTypeMapEntry targetType
  let @string targetVariableCppName
  let @string nameForCheckingFormalParameterUsing
  if self.mPrefixedBySelf then
    if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: let mutableProperties] then
      if not selfIsMutable then
        error self.mInstructionLocation : "'self' not mutable in this context"
      end
      let propertyMap = [selfType definition].mPropertyMap
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?targetType]
      nameForCheckingFormalParameterUsing = inAnalysisContext.mSelfObjectCppName
      targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
        + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
      if isConstant then
        error self.mReceiverName : "a constant property cannot be modified"
      end
      if not mutableProperties then
        error self.mReceiverName : "the property is not mutable in this context"
      end
    else
      error self.mInstructionLocation : "'self' not available in this context"
      : targetType, targetVariableCppName, nameForCheckingFormalParameterUsing
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mReceiverName
      ?targetType
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  end
  for (value) in self.mStructAttributeList do
    let propertyMap = [targetType definition].mPropertyMap
    [propertyMap searchKey !value ?let accessControl ?let isConstant ?targetType]
    [accessControl checkSetAccess !inAnalysisContext.selfType !value.location]
#    if not isPublic then
#      error mValue : " inaccessible property (due to its 'private' qualifier)"
#    end
    if isConstant then
      error value : "a constant property cannot be modified"
    end
  end
#--- Check target variable type support '-= exp' operator
  if not [[targetType definition].mHandledOperatorFlags minusEqualOperatorWithExpression] then
    error self.mInstructionLocation
    :"the target object has the '@" + [targetType definition].mTypeName.string + "' type, but this type does not support the '-=' operator"
  end
#--- Analyze source expression
  [self.mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType:  targetType
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType !expression.mResultType !self.mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
    !self.mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mStructAttributeList
    !expression
    !"minusAssign_operation"
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @mulEqualExpressionInstructionAST analyzeSemanticInstruction # *= exp
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable, or self.property
  var @unifiedTypeMapEntry targetType
  let @string targetVariableCppName
  let @string nameForCheckingFormalParameterUsing
  if self.mPrefixedBySelf then
    if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: let mutableProperties] then
      if not selfIsMutable then
        error self.mInstructionLocation : "'self' not mutable in this context"
      end
      let propertyMap = [selfType definition].mPropertyMap
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?targetType]
      nameForCheckingFormalParameterUsing = inAnalysisContext.mSelfObjectCppName
      targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
        + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
      if isConstant then
        error self.mReceiverName : "a constant property cannot be modified"
      end
      if not mutableProperties then
        error self.mReceiverName : "the property is not mutable in this context"
      end
    else
      error self.mInstructionLocation : "'self' not available in this context"
      : targetType, targetVariableCppName, nameForCheckingFormalParameterUsing
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mReceiverName
      ?targetType
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  end
#--- Check target variable
  for (value) in self.mStructAttributeList do
    let propertyMap = [targetType definition].mPropertyMap
    [propertyMap searchKey !value ?let accessControl ?let isConstant ?targetType]
    [accessControl checkSetAccess !inAnalysisContext.selfType !value.location]
#    if not isPublic then
#      error mValue : " inaccessible property (due to its 'private' qualifier)"
#    end
    if isConstant then
      error value : "a constant property cannot be modified"
    end
  end
#--- Check target variable type support '*= exp' operator
  if [[targetType definition].mHandledOperatorFlags mulEqualOperatorWithExpression] then
    error self.mInstructionLocation
    :"the target object has the '@" + [targetType definition].mTypeName.string + "' type, but this type does not support the '*=' operator"
  end
#--- Analyze source expression
  [self.mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType:  targetType
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType !expression.mResultType !self.mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
    !self.mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mStructAttributeList
    !expression
    !"mulAssign_operation"
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @divEqualExpressionInstructionAST analyzeSemanticInstruction # /= exp
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable, or self.property
  var @unifiedTypeMapEntry targetType
  let @string targetVariableCppName
  let @string nameForCheckingFormalParameterUsing
  if self.mPrefixedBySelf then
    if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: let selfIsMutable ?mutableproperties: let mutableProperties] then
      if not selfIsMutable then
        error self.mInstructionLocation : "'self' not mutable in this context"
      end
      let propertyMap = [selfType definition].mPropertyMap
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?targetType]
      nameForCheckingFormalParameterUsing = inAnalysisContext.mSelfObjectCppName
      targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
        + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
      if isConstant then
        error self.mReceiverName : "a constant property cannot be modified"
      end
      if not mutableProperties then
        error self.mReceiverName : "the property is not mutable in this context"
      end
    else
      error self.mInstructionLocation : "'self' not available in this context"
      : targetType, targetVariableCppName, nameForCheckingFormalParameterUsing
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mReceiverName
      ?targetType
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  end
#--- Check target variable
  for (value) in self.mStructAttributeList do
    let propertyMap = [targetType definition].mPropertyMap
    [propertyMap searchKey !value ?let accessControl ?let isConstant ?targetType]
    [accessControl checkSetAccess !inAnalysisContext.selfType !value.location]
#    if not isPublic then
#      error mValue : " inaccessible property (due to its 'private' qualifier)"
#    end
    if isConstant then
      error self.mReceiverName : "a constant property cannot be modified"
    end
  end
#--- Check target variable type support '/= exp' operator
  if [[targetType definition].mHandledOperatorFlags divEqualOperatorWithExpression] then
    error self.mInstructionLocation
    :"the target object has the '@" + [targetType definition].mTypeName.string + "' type, but this type does not support the '/=' operator"
  end
#--- Analyze source expression
  [self.mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !inferenceType:  targetType
    !inAnalysisContext
    !?ioTypeMap
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType !expression.mResultType !self.mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
    !self.mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !self.mStructAttributeList
    !expression
    !"divAssign_operation"
  }
}

#·····················································································································*

override method @plusEqualElementsInstructionAST analyzeSemanticInstruction
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable, or self.property
  var @unifiedTypeMapEntry targetType
  let @string targetVariableCppName
  let @string nameForCheckingFormalParameterUsing
  if self.mPrefixedBySelf then
    if let [inAnalysisContext.selfType available ?type: let selfType ?mutable: * ?mutableproperties: let mutableProperties] then
      if not mutableProperties then
        error self.mInstructionLocation : "'self' not mutable in this context"
      end
      let propertyMap = [selfType definition].mPropertyMap
      [propertyMap searchKey !self.mReceiverName ?* ?let isConstant ?targetType]
      nameForCheckingFormalParameterUsing = inAnalysisContext.mSelfObjectCppName
      targetVariableCppName = inAnalysisContext.mSelfObjectCppPrefixForAccessingProperty
        + "mProperty_"+ [self.mReceiverName.string identifierRepresentation]
      if isConstant then
        error self.mReceiverName : "a constant property cannot be modified"
      end
      if not mutableProperties then
        error self.mReceiverName : "the property cannot be mutated in this context"
      end
    else
      error self.mInstructionLocation : "'self' not available in this context"
      : targetType, targetVariableCppName, nameForCheckingFormalParameterUsing
    end
  else
    [!?ioVariableMap searchForReadWriteAccess
      !self.mReceiverName
      ?targetType
      ?targetVariableCppName
      ?nameForCheckingFormalParameterUsing
    ]
  end
#--- Check target variable
  for (value) in self.mStructAttributeList do
    let propertyMap = [targetType definition].mPropertyMap
#    let previousTargetType = targetType
    [propertyMap searchKey !value ?let accessControl ?let isConstant ?targetType]
    [accessControl checkSetAccess !inAnalysisContext.selfType !value]
#    if not isPublic  then
#      switch inAnalysisContext.selfType
#      case none :
#        error value : " inaccessible property (due to its 'private' qualifier)"
#      case available (selfType 2*) :
#        if previousTargetType != selfType then
#          error value : " inaccessible property (due to its 'private' qualifier)"
#        end
#      end
#    end
    if isConstant then
      error value : "a constant property cannot be modified"
    end
  end
#--- Check target variable type support '+=' operator
  let addAssignOperatorArguments= [targetType definition].mAddAssignOperatorArguments # Empty list if += operator is not supported
  if [addAssignOperatorArguments count] == 0 then
    error self.mInstructionLocation
    :"the target object has the '@" + [targetType definition].mTypeName.string + "' type, but this type does not support the '+=' operator"
#--- Analyze source expressions
  elsif [self.mExpressions count] != [addAssignOperatorArguments count] then
    error self.mInstructionLocation
    : "calling the '+=' operator on an '@" + [targetType definition].mTypeName.string + "' object requires "
    + [[addAssignOperatorArguments count] string] + " parameter(s), while this invocation has "
    + [[self.mExpressions count] string] + " parameter(s)"
  else
    var @semanticExpressionListForGeneration effectiveParameterList = {}
    for (mActualSelector mExpression mEndOfExpressionLocation) in self.mExpressions, (mFormalSelector mFormalArgumentType *) in addAssignOperatorArguments do
      [mExpression analyzeSemanticExpression
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !inferenceType: mFormalArgumentType
        !inAnalysisContext
        !?ioTypeMap
        !?ioVariableMap
        ?@semanticExpressionForGeneration expression
      ]
      if mFormalSelector.string != mActualSelector.string then
        let @string s = "!" + if mFormalSelector.string != "" then mFormalSelector.string + ":" else "" end
        error mActualSelector : "the selector should be '" + s + "'" fixit { %replaceBy s }
#        error mActualSelector
#          : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType !expression.mResultType !mEndOfExpressionLocation !?expression)
      effectiveParameterList += !expression
    end
  #--- Generate instruction
    ioInstructionListForGeneration += !@plusEqualnstructionForGeneration.new {
      !targetVariableCppName
      !targetType
      !nameForCheckingFormalParameterUsing
      !self.mInstructionLocation
      !self.mStructAttributeList
      !effectiveParameterList}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @plusEqualnstructionForGeneration : @semanticInstructionForGeneration {
  private let @string mReceiverCppName
  private let @unifiedTypeMapEntry mTargetType
  private let @string mNameForCheckingFormalParameterUsing
  private let @location mInstructionLocation
  private let @lstringlist mStructAttributeList
  private let @semanticExpressionListForGeneration mExpressionList
}

#·····················································································································*

override method @plusEqualnstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Parameters
  [self.mTargetType addHeaderFileName !?ioInclusionSet]
  var parameterList = @stringlist {}
  for (mExpression) in self.mExpressionList do
    [mExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string parameter
    ]
    parameterList += !parameter  
  end
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !self.mNameForCheckingFormalParameterUsing]
  ioGeneratedCode += self.mReceiverCppName
  for (mValue) in self.mStructAttributeList do
    ioGeneratedCode += ".mProperty_" + [mValue.string identifierRepresentation]
  end
#--- Call add assign (+=) operator
  ioGeneratedCode += ".addAssign_operation ("
  [!?ioUnusedVariableCppNameSet removeKey !self.mReceiverCppName]
  for (mValue) in parameterList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if [[self.mTargetType definition].mHandledOperatorFlags plusEqualOperatorWithFieldListNeedsCompilerArg] then
    ioGeneratedCode  += ", " + compilerCppName ()
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  end
  ioGeneratedCode += " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
}

#·····················································································································*

refclass @opEqualInstructionForGeneration : @semanticInstructionForGeneration {
  private let @location mInstructionLocation
  private let @unifiedTypeMapEntry mTargetType
  private let @string mTargetVariableCppName
  private let @string mNameForCheckingFormalParameterUsing
  private let @lstringlist mStructAttributeList
  private let @semanticExpressionForGeneration mSourceExpression
  private let @string mGeneratedMethod
}

#·····················································································································*

override method @opEqualInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
  [self.mTargetType addHeaderFileName !?ioInclusionSet]
  [self.mSourceExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string sourceVar
  ]
  [!?ioUnusedVariableCppNameSet removeKey !self.mNameForCheckingFormalParameterUsing]
  ioGeneratedCode += self.mTargetVariableCppName
  for (mValue) in self.mStructAttributeList do
    ioGeneratedCode += ".mProperty_" + mValue
  end
  ioGeneratedCode += "." + self.mGeneratedMethod + "(" + sourceVar
  ioGeneratedCode += ", " + compilerCppName ()
  ioGeneratedCode += " " + [self.mInstructionLocation commaSourceFile] + ") ;\n"
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  [!?ioUnusedVariableCppNameSet removeKey !self.mTargetVariableCppName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
