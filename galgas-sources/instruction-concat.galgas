#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @plusEqualElementsInstructionAST : @semanticInstructionAST {
  @lstring mReceiverName
  @lstringlist mStructAttributeList
  @actualOutputExpressionList mExpressions
}

#······················································································································*

class @plusEqualExpressionInstructionAST : @semanticInstructionAST {
  @lstring mReceiverName
  @lstringlist mStructAttributeList
  @semanticExpressionAST mExpression
}

#······················································································································*

class @minusEqualExpressionInstructionAST : @semanticInstructionAST {
  @lstring mReceiverName
  @lstringlist mStructAttributeList
  @semanticExpressionAST mExpression
}

#······················································································································*

class @mulEqualExpressionInstructionAST : @semanticInstructionAST {
  @lstring mReceiverName
  @lstringlist mStructAttributeList
  @semanticExpressionAST mExpression
}

#······················································································································*

class @divEqualExpressionInstructionAST : @semanticInstructionAST {
  @lstring mReceiverName
  @lstringlist mStructAttributeList
  @semanticExpressionAST mExpression
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3InstructionsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $identifier$ ?let @lstring mReceiverName
    let instructionLocation = @location.here
    @lstringlist mStructAttributeList = {}
    repeat
    while
      $.$
      $identifier$ ?let attributeName
      mStructAttributeList += !attributeName
    end
    select
      $-=$
      <expression> ?let @semanticExpressionAST expression
      outInstruction = @minusEqualExpressionInstructionAST.new {
        !instructionLocation
        !mReceiverName
        !mStructAttributeList
        !expression
      }
    or
      $+=$
      select
        <non_empty_output_expression_list> ?let @actualOutputExpressionList expressionList
        outInstruction = @plusEqualElementsInstructionAST.new {
          !instructionLocation
          !mReceiverName
          !mStructAttributeList
          !expressionList
        }
      or
        <expression> ?let @semanticExpressionAST expression
        outInstruction = @plusEqualExpressionInstructionAST.new {
          !instructionLocation
          !mReceiverName
          !mStructAttributeList
          !expression
        }
      end
    or
      $*=$
      <expression> ?let @semanticExpressionAST expression
      outInstruction = @mulEqualExpressionInstructionAST.new {
        !instructionLocation
        !mReceiverName
        !mStructAttributeList
        !expression
      }
    or
      $/=$
      <expression> ?let @semanticExpressionAST expression
      outInstruction = @divEqualExpressionInstructionAST.new {
        !instructionLocation
        !mReceiverName
        !mStructAttributeList
        !expression
      }
    end
  }  

  #·····················································································································

  rule <non_empty_output_expression_list> !@actualOutputExpressionList outExpressionList {
    outExpressionList = {}
    repeat
      $!$ ?let selector
      <expression> ?let @semanticExpressionAST expression
      outExpressionList += !selector !expression !@location.here
    while
    end
  }

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! CONTEXT
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @plusEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @minusEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @mulEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @divEqualExpressionInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [mExpression enterExpressionInSemanticContext !?ioTypeMap]
}

#·····················································································································*

override method @plusEqualElementsInstructionAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [mExpressions enterInSemanticContext !?ioTypeMap]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @plusEqualExpressionInstructionAST analyzeSemanticInstruction # += exp
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Check target variable
  [!?ioVariableMap searchForReadWriteAccess
    !mReceiverName 
    ?@unifiedTypeMap-proxy targetType
    ?@string targetVariableCppName
    ?@string nameForCheckingFormalParameterUsing
  ]
  for () in mStructAttributeList do
    let attributeMap = [targetType mAttributeMap]
    [attributeMap searchKey
      !mValue
      ?targetType
    ]
  end
#--- Check target variable type support '+= exp' operator
  if not [[targetType mHandledOperatorFlags] plusEqualOperatorWithExpression] then
    error mInstructionLocation
    :"the target object has the '@" + [targetType key] + "' type, but this type does not support the '+=' operator"
  end
#--- Analyze source expression
  [mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType ![expression mResultType] !mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
    !mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !mStructAttributeList
    !expression
    !"plusAssign_operation"
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @minusEqualExpressionInstructionAST analyzeSemanticInstruction # -= exp
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Check target variable
  [!?ioVariableMap searchForReadWriteAccess
    !mReceiverName 
    ?@unifiedTypeMap-proxy targetType
    ?@string targetVariableCppName
    ?@string nameForCheckingFormalParameterUsing
  ]
  for () in mStructAttributeList do
    let attributeMap = [targetType mAttributeMap]
    [attributeMap searchKey
      !mValue
      ?targetType
    ]
  end
#--- Check target variable type support '-= exp' operator
  if not [[targetType mHandledOperatorFlags] minusEqualOperatorWithExpression] then
    error mInstructionLocation
    :"the target object has the '@" + [targetType key] + "' type, but this type does not support the '-=' operator"
  end
#--- Analyze source expression
  [mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType ![expression mResultType] !mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
    !mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !mStructAttributeList
    !expression
    !"minusAssign_operation"
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @mulEqualExpressionInstructionAST analyzeSemanticInstruction # *= exp
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Check target variable
  [!?ioVariableMap searchForReadWriteAccess
    !mReceiverName 
    ?@unifiedTypeMap-proxy targetType
    ?@string targetVariableCppName
    ?@string nameForCheckingFormalParameterUsing
  ]
  for () in mStructAttributeList do
    let attributeMap = [targetType mAttributeMap]
    [attributeMap searchKey
      !mValue
      ?targetType
    ]
  end
#--- Check target variable type support '*= exp' operator
  if [[targetType mHandledOperatorFlags] mulEqualOperatorWithExpression] then
    error mInstructionLocation
    :"the target object has the '@" + [targetType key] + "' type, but this type does not support the '*=' operator"
  end
#--- Analyze source expression
  [mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType ![expression mResultType] !mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
    !mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !mStructAttributeList
    !expression
    !"mulAssign_operation"
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @divEqualExpressionInstructionAST analyzeSemanticInstruction # /= exp
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap
{
#--- Check target variable
  [!?ioVariableMap searchForReadWriteAccess
    !mReceiverName 
    ?@unifiedTypeMap-proxy targetType
    ?@string targetVariableCppName
    ?@string nameForCheckingFormalParameterUsing
  ]
  for () in mStructAttributeList do
    let attributeMap = [targetType mAttributeMap]
    [attributeMap searchKey
      !mValue
      ?targetType
    ]
  end
#--- Check target variable type support '/= exp' operator
  if [[targetType mHandledOperatorFlags] divEqualOperatorWithExpression] then
    error mInstructionLocation
    :"the target object has the '@" + [targetType key] + "' type, but this type does not support the '/=' operator"
  end
#--- Analyze source expression
  [mExpression analyzeSemanticExpression
    !inUsefulnessCallerEntityName
    !?ioUsefulEntitiesGraph
    !targetType
    !inAnalysisContext
    !?ioVariableMap
    ?@semanticExpressionForGeneration expression
  ]
#--- Check assignment type compatibility
  checkAssignmentTypeWithImplicitGetterCall (!targetType ![expression mResultType] !mInstructionLocation !?expression)
#--- Generate instruction
  ioInstructionListForGeneration += !@opEqualInstructionForGeneration.new {
    !mInstructionLocation
    !targetType
    !targetVariableCppName
    !nameForCheckingFormalParameterUsing
    !mStructAttributeList
    !expression
    !"divAssign_operation"
  }
}

#·····················································································································*

override method @plusEqualElementsInstructionAST analyzeSemanticInstruction # += !… !…
  ?let @lstring inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@variableMap ioVariableMap {
#--- Check target variable
  [!?ioVariableMap searchForReadWriteAccess
    !mReceiverName
    ?var targetType
    ?let targetVariableCppName
    ?let nameForCheckingFormalParameterUsing
  ]
  for () in mStructAttributeList do
    let attributeMap = [targetType mAttributeMap]
    [attributeMap searchKey
      !mValue
#      ??@bool isPrivate
      ?targetType
    ]
#    if isPrivate && ([mValue file] != [[attributeMap locationForKey !mValue->string] file]) then
#      error mValue : "this field is private" ;
#    end if ;
  end
#--- Check target variable type support '+=' operator
  let addAssignOperatorArguments= [targetType mAddAssignOperatorArguments] # Empty list if += operator is not supported
  if [addAssignOperatorArguments length] == 0 then
    error mInstructionLocation
    :"the target object has the '@" + [targetType key] + "' type, but this type does not support the '+=' operator"
#--- Analyze source expressions
  elsif [mExpressions length] != [addAssignOperatorArguments length] then
    error mInstructionLocation
    : "calling the '+=' operator on an '@" + [targetType key] + "' object requires "
    + [[addAssignOperatorArguments length] string] + " parameter(s), while this invocation has "
    + [[mExpressions length] string] + " parameter(s)"
  else
    @semanticExpressionListForGeneration effectiveParameterList = {}
    for () in mExpressions, () in addAssignOperatorArguments do
      [mExpression analyzeSemanticExpression
        !inUsefulnessCallerEntityName
        !?ioUsefulEntitiesGraph
        !mFormalArgumentType
        !inAnalysisContext
        !?ioVariableMap
        ?@semanticExpressionForGeneration expression
      ]
      if mFormalSelector.string != mActualSelector.string then
        error mActualSelector
          : "the selector should be '!" + mFormalSelector + if mFormalSelector.string != "" then ":" else "" end + "'"
      end
      checkAssignmentTypeWithImplicitGetterCall (!mFormalArgumentType ![expression mResultType] !mEndOfExpressionLocation !?expression)
      effectiveParameterList += !expression
    end
  #--- Generate instruction
    ioInstructionListForGeneration += !@plusEqualnstructionForGeneration.new {
      !targetVariableCppName
      !targetType
      !nameForCheckingFormalParameterUsing
      !mInstructionLocation
      !mStructAttributeList
      !effectiveParameterList}
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#! GENERATION
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @plusEqualnstructionForGeneration : @semanticInstructionForGeneration {
  @string mReceiverCppName
  @unifiedTypeMap-proxy mTargetType
  @string mNameForCheckingFormalParameterUsing
  @location mInstructionLocation
  @lstringlist mStructAttributeList
  @semanticExpressionListForGeneration mExpressionList
}

#·····················································································································*

override method @plusEqualnstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
#--- Parameters
  [mTargetType addHeaderFileName !?ioInclusionSet]
  var parameterList =@stringlist {}
  for () in mExpressionList do
    [mExpression generateExpression
      !?ioGeneratedCode
      !?ioInclusionSet
      !?ioTemporaryVariableIndex
      !?ioUnusedVariableCppNameSet
      ?let @string parameter
    ]
    parameterList += !parameter  
  end
#--- Receiver
  [!?ioUnusedVariableCppNameSet removeKey !mNameForCheckingFormalParameterUsing]
  ioGeneratedCode += mReceiverCppName
  for () in mStructAttributeList do
    ioGeneratedCode += ".mProperty_" + [[mValue string] identifierRepresentation]
  end
#--- Call add assign (+=) operator
  ioGeneratedCode += ".addAssign_operation ("
  [!?ioUnusedVariableCppNameSet removeKey !mReceiverCppName]
  for () in parameterList
    do ioGeneratedCode += mValue
    between ioGeneratedCode += ", "
  end
  if [[mTargetType mHandledOperatorFlags] plusEqualOperatorWithFieldListNeedsCompilerArg] then
    ioGeneratedCode  += ", " + compilerCppName ()
    [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  end
  ioGeneratedCode += " " + [mInstructionLocation commaSourceFile] + ") ;\n"
}

#·····················································································································*

class @opEqualInstructionForGeneration : @semanticInstructionForGeneration {
  @location mInstructionLocation
  @unifiedTypeMap-proxy mTargetType
  @string mTargetVariableCppName
  @string mNameForCheckingFormalParameterUsing
  @lstringlist mStructAttributeList
  @semanticExpressionForGeneration mSourceExpression
  @string mGeneratedMethod
}

#·····················································································································*

override method @opEqualInstructionForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint ioTemporaryVariableIndex
  ?!@stringset ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode {
  [mTargetType addHeaderFileName !?ioInclusionSet]
  [mSourceExpression generateExpression
    !?ioGeneratedCode
    !?ioInclusionSet
    !?ioTemporaryVariableIndex
    !?ioUnusedVariableCppNameSet
    ?let @string sourceVar
  ]
  [!?ioUnusedVariableCppNameSet removeKey !mNameForCheckingFormalParameterUsing]
  ioGeneratedCode += mTargetVariableCppName
  for () in mStructAttributeList do
    ioGeneratedCode += ".mProperty_" + mValue
  end
  ioGeneratedCode += "." + mGeneratedMethod + "(" + sourceVar
  ioGeneratedCode += ", " + compilerCppName ()
  ioGeneratedCode += " " + [mInstructionLocation commaSourceFile] + ") ;\n"
  [!?ioUnusedVariableCppNameSet removeKey !compilerCppName ()]
  [!?ioUnusedVariableCppNameSet removeKey !mTargetVariableCppName]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
