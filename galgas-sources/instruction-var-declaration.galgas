#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @localVariableDeclarationAST : @semanticInstructionAST {
  private let @lstring mTypeName
  private let @lstring mVariableName
  private let @bool mIsUndefinedConstant
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $var$
    $@type$ ?let typeName
    $identifier$ ?let variableName
    outInstruction = @localVariableDeclarationAST.new {!typeName.location !typeName !variableName !false}
  }

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $@type$ ?let typeName
    $identifier$ ?let variableName
    outInstruction = @localVariableDeclarationAST.new {!typeName.location !typeName !variableName !false}
    if [option galgas_cli_options.errorOldStyleLocalVarDeclaration value] then
      error typeName : "old style local variable declaration (due to '--error-old-style-local-var-declaration' option)"
      fixit { replace "var @" + typeName }
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $var$
    $@type$ ?let typeName
    $identifier$ ?let variableName
    outInstruction = @localVariableDeclarationAST.new {!typeName.location !typeName !variableName !false}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC CONTEXT                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @localVariableDeclarationAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [@unifiedTypeMap-entry makeEntry !?ioTypeMap !self.mTypeName ?*]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @localVariableDeclarationAST analyzeSemanticInstruction
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext inAnalysisContext
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable
  let targetType = @unifiedTypeMap-entry.searchKey {!inAnalysisContext.mSemanticContext.mTypeMap !self.mTypeName}
  let targetVariableCppName = "var_" + [self.mVariableName identifierRepresentation] + "_" + [self.mVariableName.location locationIndex]
  if self.mIsUndefinedConstant then
    [!?ioVariableMap insertUndefinedLocalConstant !self.mVariableName !targetType !targetVariableCppName !targetVariableCppName]
  else
    [!?ioVariableMap insertDeclaredLocalVariable
      !self.mVariableName
      !targetType
      !targetVariableCppName
      !targetVariableCppName
    ]
  end
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !targetType
    !targetVariableCppName
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @localVariableDeclarationForGeneration : @semanticInstructionForGeneration {
  private let @unifiedTypeMap-entry mVariableType
  private let @string mCppVariableName
}

#·······················································································································

override method @localVariableDeclarationForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  [self.mVariableType addHeaderFileName !?ioInclusionSet]
  ioGeneratedCode += "GALGAS_" + [self.mVariableType identifierRepresentation] + " " + self.mCppVariableName + " ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

