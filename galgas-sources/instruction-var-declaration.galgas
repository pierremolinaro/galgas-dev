#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   AST                                     
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @localVariableDeclarationAST : @semanticInstructionAST {
  private let @lstring mTypeName
  private let @lstring mVariableName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SYNTAX                                  
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas3DeclarationsSyntax {

  #·····················································································································

  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $var$
    $@type$ ?let typeName
    $identifier$ ?let variableName
    outInstruction = @localVariableDeclarationAST.new {!typeName.location !typeName !variableName}
  }

  #·····················································································································

  rule <semantic_instruction_ggs3> !@semanticInstructionAST outInstruction {
    $@type$ ?let typeName
    $identifier$ ?let variableName
    outInstruction = @localVariableDeclarationAST.new {!typeName.location !typeName !variableName}
    if [option galgas_cli_options.errorOldStyleLocalVarDeclaration value] then
      error typeName : "old style local variable declaration (due to '--error-old-style-local-var-declaration' option)"
      fixit { replace "var @" + typeName }
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension galgas4DeclarationsSyntax {

  #·····················································································································

  rule <semantic_instruction> !@semanticInstructionAST outInstruction {
    $var$
    $@type$ ?let typeName
    $identifier$ ?let variableName
    outInstruction = @localVariableDeclarationAST.new {!typeName.location !typeName !variableName}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC CONTEXT                        
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @localVariableDeclarationAST enterInstructionInSemanticContext ?!@unifiedTypeMap ioTypeMap {
  [!?ioTypeMap makeEntry !self.mTypeName ?*]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTIC ANALYSIS                       
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @localVariableDeclarationAST analyzeSemanticInstruction
  ?let @lstring unused inUsefulnessCallerEntityName
  ?!@usefulEntitiesGraph unused ioUsefulEntitiesGraph
  ?let @analysisContext unused inAnalysisContext
                                ?!@unifiedTypeMap ioTypeMap
  ?!@semanticInstructionListForGeneration ioInstructionListForGeneration
  ?!@localVarManager ioVariableMap
{
#--- Check target variable
  let targetType = [ioTypeMap searchKey !self.mTypeName]
  let targetVariableCppName = "var_" + [self.mVariableName identifierRepresentation] + "_" + [self.mVariableName.location startLocationIndex]
  [!?ioVariableMap insertDeclaredLocalVariable
    !self.mVariableName
    !targetType
    !targetVariableCppName
    !targetVariableCppName
  ]
#--- Generate instruction
  ioInstructionListForGeneration += !@localVariableDeclarationForGeneration.new {
    !targetType
    !targetVariableCppName
  }
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   CODE GENERATION                         
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

refclass @localVariableDeclarationForGeneration : @semanticInstructionForGeneration {
  private let @unifiedTypeMapEntry mVariableType
  private let @string mCppVariableName
}

#·······················································································································

override method @localVariableDeclarationForGeneration generateInstruction
  ?!@stringset ioInclusionSet
  ?!@uint unused ioTemporaryVariableIndex
  ?!@stringset unused ioUnusedVariableCppNameSet
  ?let @bool unused inGenerateSyntaxDirectedTranslationString
  ?!@string ioGeneratedCode
{
  [self.mVariableType addHeaderFileName !?ioInclusionSet]
  ioGeneratedCode += "GALGAS_" + [self.mVariableType identifierRepresentation] + " " + self.mCppVariableName + " ;\n"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

